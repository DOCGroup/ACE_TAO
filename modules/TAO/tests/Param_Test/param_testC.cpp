// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v1.7.5
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 *       http://doc.ece.uci.edu/
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// .\be\be_codegen.cpp:381


#include "param_testC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Enum_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/AnyTypeCode/Recursive_Type_TypeCode.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/AnyTypeCode/Any_Array_Impl_T.h"
#include "tao/AnyTypeCode/Any_Basic_Impl_T.h"
#include "tao/Vector_CDR_T.h"
#include "tao/AnyTypeCode/Vector_AnyOp_T.h"
#include "tao/Basic_Arguments.h"
#include "tao/BD_String_Argument_T.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/Fixed_Array_Argument_T.h"
#include "tao/Fixed_Size_Argument_T.h"
#include "tao/Object_Argument_T.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Var_Array_Argument_T.h"
#include "tao/Var_Size_Argument_T.h"
#include "tao/Vector_Argument_T.h"
#include "tao/AnyTypeCode/Any_Arg_Traits.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "param_testC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// .\be\be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_CORBA_LONGSEQ__ARG_TRAITS_)
#define _CORBA_LONGSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<CORBA::Long> >
    : public
        Vector_Arg_Traits_T<
            std::vector<CORBA::Long>,
            TAO::Any_Insert_Policy_Stream<std::vector<CORBA::Long> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_CORBA_SHORTSEQ__ARG_TRAITS_)
#define _CORBA_SHORTSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<CORBA::Short> >
    : public
        Vector_Arg_Traits_T<
            std::vector<CORBA::Short>,
            TAO::Any_Insert_Policy_Stream<std::vector<CORBA::Short> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_CORBA_STRINGSEQ__ARG_TRAITS_)
#define _CORBA_STRINGSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<char *> >
    : public
        Vector_Arg_Traits_T<
            std::vector<char *>,
            TAO::Any_Insert_Policy_Stream<std::vector<char *> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_CORBA_WSTRINGSEQ__ARG_TRAITS_)
#define _CORBA_WSTRINGSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<CORBA::WChar *> >
    : public
        Vector_Arg_Traits_T<
            std::vector<CORBA::WChar *>,
            TAO::Any_Insert_Policy_Stream<std::vector<CORBA::WChar *> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_CORBA_ANYSEQ__ARG_TRAITS_)
#define _CORBA_ANYSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<CORBA::Any> >
    : public
        Vector_Arg_Traits_T<
            std::vector<CORBA::Any>,
            TAO::Any_Insert_Policy_Stream<std::vector<CORBA::Any> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:141

#if !defined (_COFFEE__ARG_TRAITS_)
#define _COFFEE__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<Coffee>
    : public
        Object_Arg_Traits_T<
            Coffee_ptr,
            Coffee_var,
            Coffee_out,
            TAO::Objref_Traits<Coffee>,
            TAO::Any_Insert_Policy_Stream <Coffee_ptr>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:884

#if !defined (_COFFEE_DESC__ARG_TRAITS_)
#define _COFFEE_DESC__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Coffee::Desc>
    : public
        Var_Size_Arg_Traits_T<
            Coffee::Desc,
            TAO::Any_Insert_Policy_Stream <Coffee::Desc>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_SHORT_STRING128__ARG_TRAITS_)
#define _SHORT_STRING128__ARG_TRAITS_
  
  struct short_string_128 {};
  
  template<>
  class Arg_Traits<short_string_128>
    : public
        BD_String_Arg_Traits_T<
            CORBA::String_var,
            128,
            TAO::Any_Insert_Policy_Stream <
                ACE_OutputCDR::from_string
              >
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_SHORT_WSTRING128__ARG_TRAITS_)
#define _SHORT_WSTRING128__ARG_TRAITS_
  
  struct short_wstring_128 {};
  
  template<>
  class Arg_Traits<short_wstring_128>
    : public
        BD_String_Arg_Traits_T<
            CORBA::WString_var,
            128,
            TAO::Any_Insert_Policy_Stream <
                ACE_OutputCDR::from_wstring
              >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:884

#if !defined (_PARAM_TEST_FIXED_STRUCT__ARG_TRAITS_)
#define _PARAM_TEST_FIXED_STRUCT__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Fixed_Struct>
    : public
        Fixed_Size_Arg_Traits_T<
            Param_Test::Fixed_Struct,
            TAO::Any_Insert_Policy_Stream <Param_Test::Fixed_Struct>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_PATHSPEC__ARG_TRAITS_)
#define _PARAM_TEST_PATHSPEC__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<Param_Test::Step> >
    : public
        Vector_Arg_Traits_T<
            std::vector<Param_Test::Step>,
            TAO::Any_Insert_Policy_Stream<std::vector<Param_Test::Step> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_BOUNDED_SHORT_SEQ__ARG_TRAITS_)
#define _PARAM_TEST_BOUNDED_SHORT_SEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Bounded_Short_Seq>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Bounded_Short_Seq,
            TAO::Any_Insert_Policy_Stream<Param_Test::Bounded_Short_Seq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_BOUNDED_LONG_SEQ__ARG_TRAITS_)
#define _PARAM_TEST_BOUNDED_LONG_SEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Bounded_Long_Seq>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Bounded_Long_Seq,
            TAO::Any_Insert_Policy_Stream<Param_Test::Bounded_Long_Seq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_BOUNDED_STRSEQ__ARG_TRAITS_)
#define _PARAM_TEST_BOUNDED_STRSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Bounded_StrSeq>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Bounded_StrSeq,
            TAO::Any_Insert_Policy_Stream<Param_Test::Bounded_StrSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_BOUNDED_WSTRSEQ__ARG_TRAITS_)
#define _PARAM_TEST_BOUNDED_WSTRSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Bounded_WStrSeq>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Bounded_WStrSeq,
            TAO::Any_Insert_Policy_Stream<Param_Test::Bounded_WStrSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_STRUCTSEQ__ARG_TRAITS_)
#define _PARAM_TEST_STRUCTSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<Param_Test::Fixed_Struct> >
    : public
        Vector_Arg_Traits_T<
            std::vector<Param_Test::Fixed_Struct>,
            TAO::Any_Insert_Policy_Stream<std::vector<Param_Test::Fixed_Struct> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_BOUNDED_STRUCTSEQ__ARG_TRAITS_)
#define _PARAM_TEST_BOUNDED_STRUCTSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Bounded_StructSeq>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Bounded_StructSeq,
            TAO::Any_Insert_Policy_Stream<Param_Test::Bounded_StructSeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_COFFEE_MIX__ARG_TRAITS_)
#define _PARAM_TEST_COFFEE_MIX__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<Coffee> >
    : public
        Vector_Arg_Traits_T<
            std::vector<Coffee>,
            TAO::Any_Insert_Policy_Stream<std::vector<Coffee> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_BOUNDED_COFFEE_MIX__ARG_TRAITS_)
#define _PARAM_TEST_BOUNDED_COFFEE_MIX__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Bounded_Coffee_Mix>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Bounded_Coffee_Mix,
            TAO::Any_Insert_Policy_Stream<Param_Test::Bounded_Coffee_Mix>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:884

#if !defined (_PARAM_TEST_VAR_STRUCT__ARG_TRAITS_)
#define _PARAM_TEST_VAR_STRUCT__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Var_Struct>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Var_Struct,
            TAO::Any_Insert_Policy_Stream <Param_Test::Var_Struct>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:884

#if !defined (_PARAM_TEST_NESTED_STRUCT__ARG_TRAITS_)
#define _PARAM_TEST_NESTED_STRUCT__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Nested_Struct>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Nested_Struct,
            TAO::Any_Insert_Policy_Stream <Param_Test::Nested_Struct>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:884

#if !defined (_PARAM_TEST_OBJREF_STRUCT__ARG_TRAITS_)
#define _PARAM_TEST_OBJREF_STRUCT__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Objref_Struct>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Objref_Struct,
            TAO::Any_Insert_Policy_Stream <Param_Test::Objref_Struct>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_PARAM_TEST_FIXED_ARRAY__ARG_TRAITS_)
#define _PARAM_TEST_FIXED_ARRAY__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Fixed_Array_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            Param_Test::Fixed_Array_var,
            Param_Test::Fixed_Array_forany,
            TAO::Any_Insert_Policy_Stream <Param_Test::Fixed_Array_forany>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_PARAM_TEST_VAR_ARRAY__ARG_TRAITS_)
#define _PARAM_TEST_VAR_ARRAY__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Var_Array_tag>
    : public
        Var_Array_Arg_Traits_T<
            Param_Test::Var_Array_out,
            Param_Test::Var_Array_forany,
            TAO::Any_Insert_Policy_Stream <Param_Test::Var_Array_forany>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_ARRAYSEQ__ARG_TRAITS_)
#define _PARAM_TEST_ARRAYSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<std::vector<Param_Test::Fixed_Array> >
    : public
        Vector_Arg_Traits_T<
            std::vector<Param_Test::Fixed_Array>,
            TAO::Any_Insert_Policy_Stream<std::vector<Param_Test::Fixed_Array> >
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:621

#if !defined (_PARAM_TEST_BOUNDED_ARRAYSEQ__ARG_TRAITS_)
#define _PARAM_TEST_BOUNDED_ARRAYSEQ__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Bounded_ArraySeq>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Bounded_ArraySeq,
            TAO::Any_Insert_Policy_Stream<Param_Test::Bounded_ArraySeq>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:992

#if !defined (_PARAM_TEST_BIG_UNION__ARG_TRAITS_)
#define _PARAM_TEST_BIG_UNION__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Big_Union>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Big_Union,
            TAO::Any_Insert_Policy_Stream <Param_Test::Big_Union>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:992

#if !defined (_PARAM_TEST_SMALL_UNION__ARG_TRAITS_)
#define _PARAM_TEST_SMALL_UNION__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Small_Union>
    : public
        Fixed_Size_Arg_Traits_T<
            Param_Test::Small_Union,
            TAO::Any_Insert_Policy_Stream <Param_Test::Small_Union>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:884

#if !defined (_PARAM_TEST_RECURSIVE_STRUCT__ARG_TRAITS_)
#define _PARAM_TEST_RECURSIVE_STRUCT__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Recursive_Struct>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Recursive_Struct,
            TAO::Any_Insert_Policy_Stream <Param_Test::Recursive_Struct>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // .\be\be_visitor_arg_traits.cpp:992

#if !defined (_PARAM_TEST_RECURSIVE_UNION__ARG_TRAITS_)
#define _PARAM_TEST_RECURSIVE_UNION__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Recursive_Union>
    : public
        Var_Size_Arg_Traits_T<
            Param_Test::Recursive_Union,
            TAO::Any_Insert_Policy_Stream <Param_Test::Recursive_Union>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_PARAM_TEST_MULTDIM_ARRAY__ARG_TRAITS_)
#define _PARAM_TEST_MULTDIM_ARRAY__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Param_Test::Multdim_Array_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            Param_Test::Multdim_Array_var,
            Param_Test::Multdim_Array_forany,
            TAO::Any_Insert_Policy_Stream <Param_Test::Multdim_Array_forany>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:60

// Traits specializations for Coffee.

Coffee_ptr
TAO::Objref_Traits<Coffee>::duplicate (
    Coffee_ptr p)
{
  return Coffee::_duplicate (p);
}

void
TAO::Objref_Traits<Coffee>::release (
    Coffee_ptr p)
{
  ::CORBA::release (p);
}

Coffee_ptr
TAO::Objref_Traits<Coffee>::nil (void)
{
  return Coffee::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Coffee>::marshal (
    const Coffee_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*_TAO_Coffee_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj
  ) = 0;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Coffee_Desc[] =
      {
        { "name", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Coffee_Desc (
  ::CORBA::tk_struct,
  "IDL:Coffee/Desc:1.0",
  "Desc",
  _tao_fields_Coffee_Desc,
  1);

::CORBA::TypeCode_ptr const Coffee::_tc_Desc =
  &_tao_tc_Coffee_Desc;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Coffee::Desc::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Desc *_tao_tmp_pointer =
    static_cast<Desc *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Coffee::Desc *
Coffee::description (void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Coffee_Proxy_Broker_ == 0)
    {
      Coffee_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Coffee::Desc>::ret_val _tao_retval;
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_description",
      16,
      this->the_TAO_Coffee_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

void
Coffee::description (
  const Coffee::Desc & description)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Coffee_Proxy_Broker_ == 0)
    {
      Coffee_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Coffee::Desc>::in_arg_val _tao_description (description);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_description
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_description",
      16,
      this->the_TAO_Coffee_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
}

Coffee::Coffee (void)
 : the_TAO_Coffee_Proxy_Broker_ (0)
{
  this->Coffee_setup_collocation ();
}

void
Coffee::Coffee_setup_collocation ()
{
  if (::_TAO_Coffee_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Coffee_Proxy_Broker_ =
        ::_TAO_Coffee_Proxy_Broker_Factory_function_pointer (this);
    }
}

Coffee::~Coffee (void)
{}

void 
Coffee::_tao_any_destructor (void *_tao_void_pointer)
{
  Coffee *_tao_tmp_pointer =
    static_cast<Coffee *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Coffee_ptr
Coffee::_narrow (
    ::CORBA::Object_ptr _tao_objref
  )
{
  return
    TAO::Narrow_Utils<Coffee>::narrow (
        _tao_objref,
        "IDL:Coffee:1.0",
        _TAO_Coffee_Proxy_Broker_Factory_function_pointer
      );
}

Coffee_ptr
Coffee::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref
  )
{
  return
    TAO::Narrow_Utils<Coffee>::unchecked_narrow (
        _tao_objref,
        "IDL:Coffee:1.0",
        _TAO_Coffee_Proxy_Broker_Factory_function_pointer
      );
}

Coffee_ptr
Coffee::_duplicate (Coffee_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
Coffee::_tao_release (Coffee_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Coffee::_is_a (const char *value)
{
  if (
      !ACE_OS::strcmp (
          value,
          "IDL:Coffee:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Coffee::_interface_repository_id (void) const
{
  return "IDL:Coffee:1.0";
}

::CORBA::Boolean
Coffee::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:76

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Coffee (
    ::CORBA::tk_objref,
    "IDL:Coffee:1.0",
    "Coffee");
  
::CORBA::TypeCode_ptr const _tc_Coffee =
  &_tao_tc_Coffee;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_interface/interface_cs.cpp:60

// Traits specializations for Param_Test.

Param_Test_ptr
TAO::Objref_Traits<Param_Test>::duplicate (
    Param_Test_ptr p)
{
  return Param_Test::_duplicate (p);
}

void
TAO::Objref_Traits<Param_Test>::release (
    Param_Test_ptr p)
{
  ::CORBA::release (p);
}

Param_Test_ptr
TAO::Objref_Traits<Param_Test>::nil (void)
{
  return Param_Test::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Param_Test>::marshal (
    const Param_Test_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*_TAO_Param_Test_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj
  ) = 0;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::CORBA::Short
Param_Test::test_short (
  CORBA::Short s1,
  CORBA::Short & s2,
  CORBA::Short_out s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Short>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Short>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< ::CORBA::Short>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< ::CORBA::Short>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_short",
      10,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::CORBA::ULongLong
Param_Test::test_ulonglong (
  CORBA::ULongLong s1,
  CORBA::ULongLong & s2,
  CORBA::ULongLong_out s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULongLong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULongLong>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< ::CORBA::ULongLong>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< ::CORBA::ULongLong>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_ulonglong",
      14,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::string
Param_Test::test_unbounded_string (
  const std::string s1,
  std::string & s2,
  std::string & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::string>::ret_val _tao_retval;
  TAO::Arg_Traits< std::string>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::string>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::string>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_unbounded_string",
      21,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:611


#ifndef _TAO_TYPECODE_CORBA_STRING_128_GUARD
#define _TAO_TYPECODE_CORBA_STRING_128_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::String<TAO::Null_RefCount_Policy>
        CORBA_STRING_128 (
          ::CORBA::tk_string,
          128U);
        
      ::CORBA::TypeCode_ptr const tc_CORBA_STRING_128 =
        &CORBA_STRING_128;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CORBA_STRING_128_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_short_string (
    ::CORBA::tk_alias,
    "IDL:Param_Test/short_string:1.0",
    "short_string",
    &TAO::TypeCode::tc_CORBA_STRING_128);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_short_string =
  &_tao_tc_Param_Test_short_string;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

char *
Param_Test::test_bounded_string (
  const char * s1,
  char *& s2,
  ::CORBA::String_out s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::TAO::short_string_128>::ret_val _tao_retval;
  TAO::Arg_Traits< ::TAO::short_string_128>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< ::TAO::short_string_128>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< ::TAO::short_string_128>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_string",
      19,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::CORBA::WChar *
Param_Test::test_unbounded_wstring (
  const ::CORBA::WChar * ws1,
  ::CORBA::WChar *& ws2,
  ::CORBA::WString_out ws3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::WChar *>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::WChar *>::in_arg_val _tao_ws1 (ws1);
  TAO::Arg_Traits< ::CORBA::WChar *>::inout_arg_val _tao_ws2 (ws2);
  TAO::Arg_Traits< ::CORBA::WChar *>::out_arg_val _tao_ws3 (ws3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ws1,
      &_tao_ws2,
      &_tao_ws3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_unbounded_wstring",
      22,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:611


#ifndef _TAO_TYPECODE_CORBA_WSTRING_128_GUARD
#define _TAO_TYPECODE_CORBA_WSTRING_128_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::String<TAO::Null_RefCount_Policy>
        CORBA_WSTRING_128 (
          ::CORBA::tk_wstring,
          128U);
        
      ::CORBA::TypeCode_ptr const tc_CORBA_WSTRING_128 =
        &CORBA_WSTRING_128;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_CORBA_WSTRING_128_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_short_wstring (
    ::CORBA::tk_alias,
    "IDL:Param_Test/short_wstring:1.0",
    "short_wstring",
    &TAO::TypeCode::tc_CORBA_WSTRING_128);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_short_wstring =
  &_tao_tc_Param_Test_short_wstring;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::CORBA::WChar *
Param_Test::test_bounded_wstring (
  const ::CORBA::WChar * ws1,
  ::CORBA::WChar *& ws2,
  ::CORBA::WString_out ws3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::TAO::short_wstring_128>::ret_val _tao_retval;
  TAO::Arg_Traits< ::TAO::short_wstring_128>::in_arg_val _tao_ws1 (ws1);
  TAO::Arg_Traits< ::TAO::short_wstring_128>::inout_arg_val _tao_ws2 (ws2);
  TAO::Arg_Traits< ::TAO::short_wstring_128>::out_arg_val _tao_ws3 (ws3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ws1,
      &_tao_ws2,
      &_tao_ws3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_wstring",
      20,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_Fixed_Struct[] =
      {
        { "l", &CORBA::_tc_long },
        { "c", &CORBA::_tc_char },
        { "s", &CORBA::_tc_short },
        { "o", &CORBA::_tc_octet },
        { "f", &CORBA::_tc_float },
        { "b", &CORBA::_tc_boolean },
        { "d", &CORBA::_tc_double }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_Fixed_Struct (
  ::CORBA::tk_struct,
  "IDL:Param_Test/Fixed_Struct:1.0",
  "Fixed_Struct",
  _tao_fields_Param_Test_Fixed_Struct,
  7);

::CORBA::TypeCode_ptr const Param_Test::_tc_Fixed_Struct =
  &_tao_tc_Param_Test_Fixed_Struct;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::Fixed_Struct::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Fixed_Struct *_tao_tmp_pointer =
    static_cast<Fixed_Struct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Fixed_Struct
Param_Test::test_fixed_struct (
  const Param_Test::Fixed_Struct & s1,
  Param_Test::Fixed_Struct & s2,
  Param_Test::Fixed_Struct_out s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Fixed_Struct>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Fixed_Struct>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< ::Param_Test::Fixed_Struct>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< ::Param_Test::Fixed_Struct>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_fixed_struct",
      17,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_NameComponent[] =
      {
        { "id", &CORBA::_tc_string },
        { "kind", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_NameComponent (
  ::CORBA::tk_struct,
  "IDL:Param_Test/NameComponent:1.0",
  "NameComponent",
  _tao_fields_Param_Test_NameComponent,
  2);

::CORBA::TypeCode_ptr const Param_Test::_tc_NameComponent =
  &_tao_tc_Param_Test_NameComponent;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::NameComponent::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  NameComponent *_tao_tmp_pointer =
    static_cast<NameComponent *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_Step[] =
      {
        { "name", &Param_Test::_tc_NameComponent },
        { "process", &CORBA::_tc_boolean }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_Step (
  ::CORBA::tk_struct,
  "IDL:Param_Test/Step:1.0",
  "Step",
  _tao_fields_Param_Test_Step,
  2);

::CORBA::TypeCode_ptr const Param_Test::_tc_Step =
  &_tao_tc_Param_Test_Step;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::Step::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Step *_tao_tmp_pointer =
    static_cast<Step *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_PATHSPEC_CS_)
#define _PARAM_TEST_PATHSPEC_CS_

Param_Test::PathSpec::PathSpec (void)
{}

Param_Test::PathSpec::PathSpec (
      ::CORBA::ULong max)
  : std::vector<Step> (max)
{}

Param_Test::PathSpec::PathSpec (
      const PathSpec &seq)
  : std::vector<Step> (seq)
{}

Param_Test::PathSpec::~PathSpec (void)
{}

::CORBA::ULong
Param_Test::PathSpec::length (void) const
{
  return this->size ();
}

void
Param_Test::PathSpec::length (::CORBA::ULong length)
{
  this->reserve (length);
}

void Param_Test::PathSpec::_tao_any_destructor (
  void * _tao_void_pointer)
{
  PathSpec * _tao_tmp_pointer =
    static_cast<PathSpec *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_PathSpec_GUARD
#define _TAO_TYPECODE_Param_Test_PathSpec_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_PathSpec_0 (
          ::CORBA::tk_sequence,
          &Param_Test::_tc_Step,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_PathSpec_0 =
        &Param_Test_PathSpec_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_PathSpec_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_PathSpec (
    ::CORBA::tk_alias,
    "IDL:Param_Test/PathSpec:1.0",
    "PathSpec",
    &TAO::TypeCode::tc_Param_Test_PathSpec_0);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_PathSpec =
  &_tao_tc_Param_Test_PathSpec;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<Param_Test::Step>
Param_Test::test_unbounded_struct_sequence (
  const std::vector<Param_Test::Step> & s1,
  std::vector<Param_Test::Step> & s2,
  std::vector<Param_Test::Step> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<Param_Test::Step>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<Param_Test::Step>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<Param_Test::Step>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<Param_Test::Step>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_unbounded_struct_sequence",
      30,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<CORBA::Short>
Param_Test::test_short_sequence (
  const std::vector<CORBA::Short> & s1,
  std::vector<CORBA::Short> & s2,
  std::vector<CORBA::Short> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<CORBA::Short>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<CORBA::Short>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<CORBA::Short>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<CORBA::Short>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_short_sequence",
      19,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_BOUNDED_SHORT_SEQ_CS_)
#define _PARAM_TEST_BOUNDED_SHORT_SEQ_CS_

Param_Test::Bounded_Short_Seq::Bounded_Short_Seq (void)
{}

Param_Test::Bounded_Short_Seq::Bounded_Short_Seq (
    ::CORBA::ULong length,
    ::CORBA::Short * buffer,
    ::CORBA::Boolean release
  )
  : TAO::bounded_value_sequence<
        ::CORBA::Short,
        32
      >
    (length, buffer, release)
{}

Param_Test::Bounded_Short_Seq::Bounded_Short_Seq (
      const Bounded_Short_Seq &seq)
  : TAO::bounded_value_sequence<
        ::CORBA::Short,
        32
      > (seq)
{}

Param_Test::Bounded_Short_Seq::~Bounded_Short_Seq (void)
{}

void Param_Test::Bounded_Short_Seq::_tao_any_destructor (
  void * _tao_void_pointer)
{
  Bounded_Short_Seq * _tao_tmp_pointer =
    static_cast<Bounded_Short_Seq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Bounded_Short_Seq_GUARD
#define _TAO_TYPECODE_Param_Test_Bounded_Short_Seq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Bounded_Short_Seq_32 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_short,
          32U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Bounded_Short_Seq_32 =
        &Param_Test_Bounded_Short_Seq_32;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Bounded_Short_Seq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Bounded_Short_Seq (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Bounded_Short_Seq:1.0",
    "Bounded_Short_Seq",
    &TAO::TypeCode::tc_Param_Test_Bounded_Short_Seq_32);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Bounded_Short_Seq =
  &_tao_tc_Param_Test_Bounded_Short_Seq;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<CORBA::Short>
Param_Test::test_bounded_short_sequence (
  const std::vector<CORBA::Short> & s1,
  std::vector<CORBA::Short> & s2,
  std::vector<CORBA::Short> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<CORBA::Short>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<CORBA::Short>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<CORBA::Short>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<CORBA::Short>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_short_sequence",
      27,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<CORBA::Long>
Param_Test::test_long_sequence (
  const std::vector<CORBA::Long> & s1,
  std::vector<CORBA::Long> & s2,
  std::vector<CORBA::Long> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<CORBA::Long>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<CORBA::Long>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<CORBA::Long>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<CORBA::Long>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_long_sequence",
      18,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_BOUNDED_LONG_SEQ_CS_)
#define _PARAM_TEST_BOUNDED_LONG_SEQ_CS_

Param_Test::Bounded_Long_Seq::Bounded_Long_Seq (void)
{}

Param_Test::Bounded_Long_Seq::Bounded_Long_Seq (
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : TAO::bounded_value_sequence<
        ::CORBA::Long,
        32
      >
    (length, buffer, release)
{}

Param_Test::Bounded_Long_Seq::Bounded_Long_Seq (
      const Bounded_Long_Seq &seq)
  : TAO::bounded_value_sequence<
        ::CORBA::Long,
        32
      > (seq)
{}

Param_Test::Bounded_Long_Seq::~Bounded_Long_Seq (void)
{}

void Param_Test::Bounded_Long_Seq::_tao_any_destructor (
  void * _tao_void_pointer)
{
  Bounded_Long_Seq * _tao_tmp_pointer =
    static_cast<Bounded_Long_Seq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Bounded_Long_Seq_GUARD
#define _TAO_TYPECODE_Param_Test_Bounded_Long_Seq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Bounded_Long_Seq_32 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_long,
          32U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Bounded_Long_Seq_32 =
        &Param_Test_Bounded_Long_Seq_32;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Bounded_Long_Seq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Bounded_Long_Seq (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Bounded_Long_Seq:1.0",
    "Bounded_Long_Seq",
    &TAO::TypeCode::tc_Param_Test_Bounded_Long_Seq_32);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Bounded_Long_Seq =
  &_tao_tc_Param_Test_Bounded_Long_Seq;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<CORBA::Long>
Param_Test::test_bounded_long_sequence (
  const std::vector<CORBA::Long> & s1,
  std::vector<CORBA::Long> & s2,
  std::vector<CORBA::Long> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<CORBA::Long>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<CORBA::Long>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<CORBA::Long>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<CORBA::Long>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_long_sequence",
      26,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<char *>
Param_Test::test_strseq (
  const std::vector<char *> & s1,
  std::vector<char *> & s2,
  std::vector<char *> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<char *>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<char *>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<char *>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<char *>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_strseq",
      11,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_BOUNDED_STRSEQ_CS_)
#define _PARAM_TEST_BOUNDED_STRSEQ_CS_

Param_Test::Bounded_StrSeq::Bounded_StrSeq (void)
{}

Param_Test::Bounded_StrSeq::Bounded_StrSeq (
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : TAO::bounded_basic_string_sequence<char, 32>
    (length, buffer, release)
{}

Param_Test::Bounded_StrSeq::Bounded_StrSeq (
      const Bounded_StrSeq &seq)
  : TAO::bounded_basic_string_sequence<char, 32> (seq)
{}

Param_Test::Bounded_StrSeq::~Bounded_StrSeq (void)
{}

void Param_Test::Bounded_StrSeq::_tao_any_destructor (
  void * _tao_void_pointer)
{
  Bounded_StrSeq * _tao_tmp_pointer =
    static_cast<Bounded_StrSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Bounded_StrSeq_GUARD
#define _TAO_TYPECODE_Param_Test_Bounded_StrSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Bounded_StrSeq_32 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_string,
          32U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Bounded_StrSeq_32 =
        &Param_Test_Bounded_StrSeq_32;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Bounded_StrSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Bounded_StrSeq (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Bounded_StrSeq:1.0",
    "Bounded_StrSeq",
    &TAO::TypeCode::tc_Param_Test_Bounded_StrSeq_32);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Bounded_StrSeq =
  &_tao_tc_Param_Test_Bounded_StrSeq;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<char *>
Param_Test::test_bounded_strseq (
  const std::vector<char *> & s1,
  std::vector<char *> & s2,
  std::vector<char *> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<char *>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<char *>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<char *>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<char *>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_strseq",
      19,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<CORBA::WChar *>
Param_Test::test_wstrseq (
  const std::vector<CORBA::WChar *> & ws1,
  std::vector<CORBA::WChar *> & ws2,
  std::vector<CORBA::WChar *> & ws3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<CORBA::WChar *>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<CORBA::WChar *>>::in_arg_val _tao_ws1 (ws1);
  TAO::Arg_Traits< std::vector<CORBA::WChar *>>::inout_arg_val _tao_ws2 (ws2);
  TAO::Arg_Traits< std::vector<CORBA::WChar *>>::out_arg_val _tao_ws3 (ws3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ws1,
      &_tao_ws2,
      &_tao_ws3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_wstrseq",
      12,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_BOUNDED_WSTRSEQ_CS_)
#define _PARAM_TEST_BOUNDED_WSTRSEQ_CS_

Param_Test::Bounded_WStrSeq::Bounded_WStrSeq (void)
{}

Param_Test::Bounded_WStrSeq::Bounded_WStrSeq (
    ::CORBA::ULong length,
    ::CORBA::WChar * * buffer,
    ::CORBA::Boolean release
  )
  : TAO::bounded_basic_string_sequence<CORBA::WChar, 32>
    (length, buffer, release)
{}

Param_Test::Bounded_WStrSeq::Bounded_WStrSeq (
      const Bounded_WStrSeq &seq)
  : TAO::bounded_basic_string_sequence<CORBA::WChar, 32> (seq)
{}

Param_Test::Bounded_WStrSeq::~Bounded_WStrSeq (void)
{}

void Param_Test::Bounded_WStrSeq::_tao_any_destructor (
  void * _tao_void_pointer)
{
  Bounded_WStrSeq * _tao_tmp_pointer =
    static_cast<Bounded_WStrSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Bounded_WStrSeq_GUARD
#define _TAO_TYPECODE_Param_Test_Bounded_WStrSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Bounded_WStrSeq_32 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_wstring,
          32U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Bounded_WStrSeq_32 =
        &Param_Test_Bounded_WStrSeq_32;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Bounded_WStrSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Bounded_WStrSeq (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Bounded_WStrSeq:1.0",
    "Bounded_WStrSeq",
    &TAO::TypeCode::tc_Param_Test_Bounded_WStrSeq_32);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Bounded_WStrSeq =
  &_tao_tc_Param_Test_Bounded_WStrSeq;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<CORBA::WChar *>
Param_Test::test_bounded_wstrseq (
  const std::vector<CORBA::WChar *> & ws1,
  std::vector<CORBA::WChar *> & ws2,
  std::vector<CORBA::WChar *> & ws3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<CORBA::WChar *>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<CORBA::WChar *>>::in_arg_val _tao_ws1 (ws1);
  TAO::Arg_Traits< std::vector<CORBA::WChar *>>::inout_arg_val _tao_ws2 (ws2);
  TAO::Arg_Traits< std::vector<CORBA::WChar *>>::out_arg_val _tao_ws3 (ws3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ws1,
      &_tao_ws2,
      &_tao_ws3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_wstrseq",
      20,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_STRUCTSEQ_CS_)
#define _PARAM_TEST_STRUCTSEQ_CS_

Param_Test::StructSeq::StructSeq (void)
{}

Param_Test::StructSeq::StructSeq (
      ::CORBA::ULong max)
  : std::vector<Fixed_Struct> (max)
{}

Param_Test::StructSeq::StructSeq (
      const StructSeq &seq)
  : std::vector<Fixed_Struct> (seq)
{}

Param_Test::StructSeq::~StructSeq (void)
{}

::CORBA::ULong
Param_Test::StructSeq::length (void) const
{
  return this->size ();
}

void
Param_Test::StructSeq::length (::CORBA::ULong length)
{
  this->reserve (length);
}

void Param_Test::StructSeq::_tao_any_destructor (
  void * _tao_void_pointer)
{
  StructSeq * _tao_tmp_pointer =
    static_cast<StructSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_StructSeq_GUARD
#define _TAO_TYPECODE_Param_Test_StructSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_StructSeq_0 (
          ::CORBA::tk_sequence,
          &Param_Test::_tc_Fixed_Struct,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_StructSeq_0 =
        &Param_Test_StructSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_StructSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_StructSeq (
    ::CORBA::tk_alias,
    "IDL:Param_Test/StructSeq:1.0",
    "StructSeq",
    &TAO::TypeCode::tc_Param_Test_StructSeq_0);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_StructSeq =
  &_tao_tc_Param_Test_StructSeq;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<Param_Test::Fixed_Struct>
Param_Test::test_struct_sequence (
  const std::vector<Param_Test::Fixed_Struct> & s1,
  std::vector<Param_Test::Fixed_Struct> & s2,
  std::vector<Param_Test::Fixed_Struct> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Struct>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Struct>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Struct>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Struct>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_struct_sequence",
      20,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_BOUNDED_STRUCTSEQ_CS_)
#define _PARAM_TEST_BOUNDED_STRUCTSEQ_CS_

Param_Test::Bounded_StructSeq::Bounded_StructSeq (void)
{}

Param_Test::Bounded_StructSeq::Bounded_StructSeq (
    ::CORBA::ULong length,
    Param_Test::Fixed_Struct * buffer,
    ::CORBA::Boolean release
  )
  : TAO::bounded_value_sequence<
        Fixed_Struct,
        32
      >
    (length, buffer, release)
{}

Param_Test::Bounded_StructSeq::Bounded_StructSeq (
      const Bounded_StructSeq &seq)
  : TAO::bounded_value_sequence<
        Fixed_Struct,
        32
      > (seq)
{}

Param_Test::Bounded_StructSeq::~Bounded_StructSeq (void)
{}

void Param_Test::Bounded_StructSeq::_tao_any_destructor (
  void * _tao_void_pointer)
{
  Bounded_StructSeq * _tao_tmp_pointer =
    static_cast<Bounded_StructSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Bounded_StructSeq_GUARD
#define _TAO_TYPECODE_Param_Test_Bounded_StructSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Bounded_StructSeq_32 (
          ::CORBA::tk_sequence,
          &Param_Test::_tc_Fixed_Struct,
          32U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Bounded_StructSeq_32 =
        &Param_Test_Bounded_StructSeq_32;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Bounded_StructSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Bounded_StructSeq (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Bounded_StructSeq:1.0",
    "Bounded_StructSeq",
    &TAO::TypeCode::tc_Param_Test_Bounded_StructSeq_32);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Bounded_StructSeq =
  &_tao_tc_Param_Test_Bounded_StructSeq;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<Param_Test::Fixed_Struct>
Param_Test::test_bounded_struct_sequence (
  const std::vector<Param_Test::Fixed_Struct> & s1,
  std::vector<Param_Test::Fixed_Struct> & s2,
  std::vector<Param_Test::Fixed_Struct> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Struct>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Struct>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Struct>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Struct>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_struct_sequence",
      28,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_COFFEE_MIX_CS_)
#define _PARAM_TEST_COFFEE_MIX_CS_

Param_Test::Coffee_Mix::Coffee_Mix (void)
{}

Param_Test::Coffee_Mix::Coffee_Mix (
      ::CORBA::ULong max)
  : std::vector<Coffee> (max)
{}

Param_Test::Coffee_Mix::Coffee_Mix (
      const Coffee_Mix &seq)
  : std::vector<Coffee> (seq)
{}

Param_Test::Coffee_Mix::~Coffee_Mix (void)
{}

::CORBA::ULong
Param_Test::Coffee_Mix::length (void) const
{
  return this->size ();
}

void
Param_Test::Coffee_Mix::length (::CORBA::ULong length)
{
  this->reserve (length);
}

void Param_Test::Coffee_Mix::_tao_any_destructor (
  void * _tao_void_pointer)
{
  Coffee_Mix * _tao_tmp_pointer =
    static_cast<Coffee_Mix *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Coffee_Mix_GUARD
#define _TAO_TYPECODE_Param_Test_Coffee_Mix_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Coffee_Mix_0 (
          ::CORBA::tk_sequence,
          &_tc_Coffee,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Coffee_Mix_0 =
        &Param_Test_Coffee_Mix_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Coffee_Mix_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Coffee_Mix (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Coffee_Mix:1.0",
    "Coffee_Mix",
    &TAO::TypeCode::tc_Param_Test_Coffee_Mix_0);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Coffee_Mix =
  &_tao_tc_Param_Test_Coffee_Mix;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<Coffee>
Param_Test::test_coffe_mix (
  const std::vector<Coffee> & s1,
  std::vector<Coffee> & s2,
  std::vector<Coffee> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<Coffee>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<Coffee>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<Coffee>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<Coffee>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_coffe_mix",
      14,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_BOUNDED_COFFEE_MIX_CS_)
#define _PARAM_TEST_BOUNDED_COFFEE_MIX_CS_

Param_Test::Bounded_Coffee_Mix::Bounded_Coffee_Mix (void)
{}

Param_Test::Bounded_Coffee_Mix::Bounded_Coffee_Mix (
    ::CORBA::ULong length,
    Coffee_ptr * buffer,
    ::CORBA::Boolean release
  )
  : TAO::bounded_object_reference_sequence<
        Coffee,
        Coffee_var,
        32
      >
    (length, buffer, release)
{}

Param_Test::Bounded_Coffee_Mix::Bounded_Coffee_Mix (
      const Bounded_Coffee_Mix &seq)
  : TAO::bounded_object_reference_sequence<
        Coffee,
        Coffee_var,
        32
      > (seq)
{}

Param_Test::Bounded_Coffee_Mix::~Bounded_Coffee_Mix (void)
{}

void Param_Test::Bounded_Coffee_Mix::_tao_any_destructor (
  void * _tao_void_pointer)
{
  Bounded_Coffee_Mix * _tao_tmp_pointer =
    static_cast<Bounded_Coffee_Mix *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Bounded_Coffee_Mix_GUARD
#define _TAO_TYPECODE_Param_Test_Bounded_Coffee_Mix_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Bounded_Coffee_Mix_32 (
          ::CORBA::tk_sequence,
          &_tc_Coffee,
          32U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Bounded_Coffee_Mix_32 =
        &Param_Test_Bounded_Coffee_Mix_32;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Bounded_Coffee_Mix_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Bounded_Coffee_Mix (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Bounded_Coffee_Mix:1.0",
    "Bounded_Coffee_Mix",
    &TAO::TypeCode::tc_Param_Test_Bounded_Coffee_Mix_32);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Bounded_Coffee_Mix =
  &_tao_tc_Param_Test_Bounded_Coffee_Mix;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<Coffee>
Param_Test::test_bounded_coffe_mix (
  const std::vector<Coffee> & s1,
  std::vector<Coffee> & s2,
  std::vector<Coffee> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<Coffee>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<Coffee>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<Coffee>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<Coffee>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_coffe_mix",
      22,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<CORBA::Any>
Param_Test::test_anyseq (
  const std::vector<CORBA::Any> & s1,
  std::vector<CORBA::Any> & s2,
  std::vector<CORBA::Any> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<CORBA::Any>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<CORBA::Any>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<CORBA::Any>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<CORBA::Any>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_anyseq",
      11,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_DUMMY (
    ::CORBA::tk_alias,
    "IDL:Param_Test/DUMMY:1.0",
    "DUMMY",
    &CORBA::_tc_string);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_DUMMY =
  &_tao_tc_Param_Test_DUMMY;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_Var_Struct[] =
      {
        { "dbl", &CORBA::_tc_double },
        { "dummy1", &Param_Test::_tc_DUMMY },
        { "boole", &CORBA::_tc_boolean },
        { "dummy2", &Param_Test::_tc_DUMMY },
        { "shrt", &CORBA::_tc_short },
        { "seq", &CORBA::_tc_StringSeq }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_Var_Struct (
  ::CORBA::tk_struct,
  "IDL:Param_Test/Var_Struct:1.0",
  "Var_Struct",
  _tao_fields_Param_Test_Var_Struct,
  6);

::CORBA::TypeCode_ptr const Param_Test::_tc_Var_Struct =
  &_tao_tc_Param_Test_Var_Struct;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::Var_Struct::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Var_Struct *_tao_tmp_pointer =
    static_cast<Var_Struct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Var_Struct *
Param_Test::test_var_struct (
  const Param_Test::Var_Struct & s1,
  Param_Test::Var_Struct & s2,
  Param_Test::Var_Struct_out s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Var_Struct>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Var_Struct>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< ::Param_Test::Var_Struct>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< ::Param_Test::Var_Struct>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_var_struct",
      15,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_Nested_Struct[] =
      {
        { "vs", &Param_Test::_tc_Var_Struct }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_Nested_Struct (
  ::CORBA::tk_struct,
  "IDL:Param_Test/Nested_Struct:1.0",
  "Nested_Struct",
  _tao_fields_Param_Test_Nested_Struct,
  1);

::CORBA::TypeCode_ptr const Param_Test::_tc_Nested_Struct =
  &_tao_tc_Param_Test_Nested_Struct;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::Nested_Struct::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Nested_Struct *_tao_tmp_pointer =
    static_cast<Nested_Struct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Nested_Struct *
Param_Test::test_nested_struct (
  const Param_Test::Nested_Struct & s1,
  Param_Test::Nested_Struct & s2,
  Param_Test::Nested_Struct_out s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Nested_Struct>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Nested_Struct>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< ::Param_Test::Nested_Struct>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< ::Param_Test::Nested_Struct>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_nested_struct",
      18,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Coffee_ptr
Param_Test::make_coffee (void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Coffee>::ret_val _tao_retval;
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "make_coffee",
      11,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Coffee_ptr
Param_Test::test_objref (
  Coffee_ptr o1,
  Coffee_ptr & o2,
  Coffee_out o3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Coffee>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Coffee>::in_arg_val _tao_o1 (o1);
  TAO::Arg_Traits< ::Coffee>::inout_arg_val _tao_o2 (o2);
  TAO::Arg_Traits< ::Coffee>::out_arg_val _tao_o3 (o3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_o1,
      &_tao_o2,
      &_tao_o3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_objref",
      11,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::CORBA::TypeCode_ptr
Param_Test::test_typecode (
  CORBA::TypeCode_ptr t1,
  CORBA::TypeCode_ptr & t2,
  CORBA::TypeCode_out t3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::TypeCode>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::TypeCode>::in_arg_val _tao_t1 (t1);
  TAO::Arg_Traits< ::CORBA::TypeCode>::inout_arg_val _tao_t2 (t2);
  TAO::Arg_Traits< ::CORBA::TypeCode>::out_arg_val _tao_t3 (t3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_t1,
      &_tao_t2,
      &_tao_t3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_typecode",
      13,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::CORBA::Any *
Param_Test::test_any (
  const CORBA::Any & a1,
  CORBA::Any & a2,
  CORBA::Any_out a3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Any>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_a1 (a1);
  TAO::Arg_Traits< ::CORBA::Any>::inout_arg_val _tao_a2 (a2);
  TAO::Arg_Traits< ::CORBA::Any>::out_arg_val _tao_a3 (a3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a1,
      &_tao_a2,
      &_tao_a3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_any",
      8,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_Objref_Struct[] =
      {
        { "x", &CORBA::_tc_long },
        { "y", &_tc_Coffee }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_Objref_Struct (
  ::CORBA::tk_struct,
  "IDL:Param_Test/Objref_Struct:1.0",
  "Objref_Struct",
  _tao_fields_Param_Test_Objref_Struct,
  2);

::CORBA::TypeCode_ptr const Param_Test::_tc_Objref_Struct =
  &_tao_tc_Param_Test_Objref_Struct;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::Objref_Struct::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Objref_Struct *_tao_tmp_pointer =
    static_cast<Objref_Struct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Objref_Struct *
Param_Test::test_objref_struct (
  const Param_Test::Objref_Struct & t1,
  Param_Test::Objref_Struct & t2,
  Param_Test::Objref_Struct_out t3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Objref_Struct>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Objref_Struct>::in_arg_val _tao_t1 (t1);
  TAO::Arg_Traits< ::Param_Test::Objref_Struct>::inout_arg_val _tao_t2 (t2);
  TAO::Arg_Traits< ::Param_Test::Objref_Struct>::out_arg_val _tao_t3 (t3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_t1,
      &_tao_t2,
      &_tao_t3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_objref_struct",
      18,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:71

#ifndef ACE_HAS_HEADER_ALLOCATED_CLASS_STATIC_CONST_INT_STOREAGE
  const CORBA::ULong Param_Test::DIM1;
#endif // ifndef ACE_HAS_HEADER_ALLOCATED_CLASS_STATIC_CONST_INT_STOREAGE

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_array/array_cs.cpp:109

Param_Test::Fixed_Array_slice *
Param_Test::Fixed_Array_dup (const Param_Test::Fixed_Array_slice *_tao_src_array)
{
  Param_Test::Fixed_Array_slice *_tao_dup_array =
    Param_Test::Fixed_Array_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Param_Test::Fixed_Array_slice *> (0);
    }
  
  Param_Test::Fixed_Array_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Param_Test::Fixed_Array_slice *
Param_Test::Fixed_Array_alloc (void)
{
  Param_Test::Fixed_Array_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Long[10], 0);
  return retval;
}

void
Param_Test::Fixed_Array_free (
    Param_Test::Fixed_Array_slice *_tao_slice
  )
{
  delete [] _tao_slice;
}

void 
Param_Test::Fixed_Array_copy (
    Param_Test::Fixed_Array_slice * _tao_to,
    const Param_Test::Fixed_Array_slice *_tao_from
  )
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 10; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:359


#ifndef _TAO_TYPECODE_Param_Test_Fixed_Array_GUARD
#define _TAO_TYPECODE_Param_Test_Fixed_Array_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Fixed_Array_10 (
          ::CORBA::tk_array,
          &CORBA::_tc_long,
          10U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Fixed_Array =
        &Param_Test_Fixed_Array_10;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Fixed_Array_GUARD */
static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Fixed_Array (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Fixed_Array:1.0",
    "Fixed_Array",
    &TAO::TypeCode::tc_Param_Test_Fixed_Array);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Fixed_Array =
  &_tao_tc_Param_Test_Fixed_Array;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Fixed_Array_slice *
Param_Test::test_fixed_array (
  const Param_Test::Fixed_Array l1,
  Param_Test::Fixed_Array l2,
  Param_Test::Fixed_Array_out l3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Fixed_Array_tag>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Fixed_Array_tag>::in_arg_val _tao_l1 (l1);
  TAO::Arg_Traits< ::Param_Test::Fixed_Array_tag>::inout_arg_val _tao_l2 (l2);
  TAO::Arg_Traits< ::Param_Test::Fixed_Array_tag>::out_arg_val _tao_l3 (l3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_l1,
      &_tao_l2,
      &_tao_l3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_fixed_array",
      16,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:71

#ifndef ACE_HAS_HEADER_ALLOCATED_CLASS_STATIC_CONST_INT_STOREAGE
  const CORBA::ULong Param_Test::DIM2;
#endif // ifndef ACE_HAS_HEADER_ALLOCATED_CLASS_STATIC_CONST_INT_STOREAGE

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_array/array_cs.cpp:109

Param_Test::Var_Array_slice *
Param_Test::Var_Array_dup (const Param_Test::Var_Array_slice *_tao_src_array)
{
  Param_Test::Var_Array_slice *_tao_dup_array =
    Param_Test::Var_Array_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Param_Test::Var_Array_slice *> (0);
    }
  
  Param_Test::Var_Array_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Param_Test::Var_Array_slice *
Param_Test::Var_Array_alloc (void)
{
  Param_Test::Var_Array_slice *retval = 0;
  ACE_NEW_RETURN (retval, TAO::String_Manager[5], 0);
  return retval;
}

void
Param_Test::Var_Array_free (
    Param_Test::Var_Array_slice *_tao_slice
  )
{
  delete [] _tao_slice;
}

void 
Param_Test::Var_Array_copy (
    Param_Test::Var_Array_slice * _tao_to,
    const Param_Test::Var_Array_slice *_tao_from
  )
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 5; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:359


#ifndef _TAO_TYPECODE_Param_Test_Var_Array_GUARD
#define _TAO_TYPECODE_Param_Test_Var_Array_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Var_Array_5 (
          ::CORBA::tk_array,
          &CORBA::_tc_string,
          5U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Var_Array =
        &Param_Test_Var_Array_5;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Var_Array_GUARD */
static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Var_Array (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Var_Array:1.0",
    "Var_Array",
    &TAO::TypeCode::tc_Param_Test_Var_Array);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Var_Array =
  &_tao_tc_Param_Test_Var_Array;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Var_Array_slice *
Param_Test::test_var_array (
  const Param_Test::Var_Array v1,
  Param_Test::Var_Array v2,
  Param_Test::Var_Array_out v3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Var_Array_tag>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Var_Array_tag>::in_arg_val _tao_v1 (v1);
  TAO::Arg_Traits< ::Param_Test::Var_Array_tag>::inout_arg_val _tao_v2 (v2);
  TAO::Arg_Traits< ::Param_Test::Var_Array_tag>::out_arg_val _tao_v3 (v3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_v1,
      &_tao_v2,
      &_tao_v3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_var_array",
      14,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_ARRAYSEQ_CS_)
#define _PARAM_TEST_ARRAYSEQ_CS_

Param_Test::ArraySeq::ArraySeq (void)
{}

Param_Test::ArraySeq::ArraySeq (
      ::CORBA::ULong max)
  : std::vector<Fixed_Array> (max)
{}

Param_Test::ArraySeq::ArraySeq (
      const ArraySeq &seq)
  : std::vector<Fixed_Array> (seq)
{}

Param_Test::ArraySeq::~ArraySeq (void)
{}

::CORBA::ULong
Param_Test::ArraySeq::length (void) const
{
  return this->size ();
}

void
Param_Test::ArraySeq::length (::CORBA::ULong length)
{
  this->reserve (length);
}

void Param_Test::ArraySeq::_tao_any_destructor (
  void * _tao_void_pointer)
{
  ArraySeq * _tao_tmp_pointer =
    static_cast<ArraySeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_ArraySeq_GUARD
#define _TAO_TYPECODE_Param_Test_ArraySeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_ArraySeq_0 (
          ::CORBA::tk_sequence,
          &Param_Test::_tc_Fixed_Array,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_ArraySeq_0 =
        &Param_Test_ArraySeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_ArraySeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_ArraySeq (
    ::CORBA::tk_alias,
    "IDL:Param_Test/ArraySeq:1.0",
    "ArraySeq",
    &TAO::TypeCode::tc_Param_Test_ArraySeq_0);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_ArraySeq =
  &_tao_tc_Param_Test_ArraySeq;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<Param_Test::Fixed_Array>
Param_Test::test_array_sequence (
  const std::vector<Param_Test::Fixed_Array> & s1,
  std::vector<Param_Test::Fixed_Array> & s2,
  std::vector<Param_Test::Fixed_Array> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Array>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Array>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Array>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Array>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_array_sequence",
      19,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_BOUNDED_ARRAYSEQ_CS_)
#define _PARAM_TEST_BOUNDED_ARRAYSEQ_CS_

Param_Test::Bounded_ArraySeq::Bounded_ArraySeq (void)
{}

Param_Test::Bounded_ArraySeq::Bounded_ArraySeq (
    ::CORBA::ULong length,
    Param_Test::Fixed_Array * buffer,
    ::CORBA::Boolean release
  )
  : TAO::bounded_array_sequence<
        Fixed_Array,
        Fixed_Array_slice,
        Fixed_Array_tag,
        32
      >
    (length, buffer, release)
{}

Param_Test::Bounded_ArraySeq::Bounded_ArraySeq (
      const Bounded_ArraySeq &seq)
  : TAO::bounded_array_sequence<
        Fixed_Array,
        Fixed_Array_slice,
        Fixed_Array_tag,
        32
      > (seq)
{}

Param_Test::Bounded_ArraySeq::~Bounded_ArraySeq (void)
{}

void Param_Test::Bounded_ArraySeq::_tao_any_destructor (
  void * _tao_void_pointer)
{
  Bounded_ArraySeq * _tao_tmp_pointer =
    static_cast<Bounded_ArraySeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Bounded_ArraySeq_GUARD
#define _TAO_TYPECODE_Param_Test_Bounded_ArraySeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Bounded_ArraySeq_32 (
          ::CORBA::tk_sequence,
          &Param_Test::_tc_Fixed_Array,
          32U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Bounded_ArraySeq_32 =
        &Param_Test_Bounded_ArraySeq_32;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Bounded_ArraySeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Bounded_ArraySeq (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Bounded_ArraySeq:1.0",
    "Bounded_ArraySeq",
    &TAO::TypeCode::tc_Param_Test_Bounded_ArraySeq_32);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Bounded_ArraySeq =
  &_tao_tc_Param_Test_Bounded_ArraySeq;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

std::vector<Param_Test::Fixed_Array>
Param_Test::test_bounded_array_sequence (
  const std::vector<Param_Test::Fixed_Array> & s1,
  std::vector<Param_Test::Fixed_Array> & s2,
  std::vector<Param_Test::Fixed_Array> & s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Array>>::ret_val _tao_retval;
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Array>>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Array>>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< std::vector<Param_Test::Fixed_Array>>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_bounded_array_sequence",
      27,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_exception/exception_ctor.cpp:66

Param_Test::Ooops::Ooops (
    const char * _tao_reason,
    ::CORBA::ULong _tao_input
  )
  : ::CORBA::UserException (
        "IDL:Param_Test/Ooops:1.0",
        "Ooops"
      )
{
  this->reason = ::CORBA::string_dup (_tao_reason);
  this->input = _tao_input;
}



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:110

Param_Test::Ooops::Ooops (void)
  : ::CORBA::UserException (
        "IDL:Param_Test/Ooops:1.0",
        "Ooops"
      )
{
}

Param_Test::Ooops::~Ooops (void)
{
}

Param_Test::Ooops::Ooops (const ::Param_Test::Ooops &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  this->input = _tao_excp.input;
}

Param_Test::Ooops&
Param_Test::Ooops::operator= (const ::Param_Test::Ooops &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->reason = ::CORBA::string_dup (_tao_excp.reason.in ());
  this->input = _tao_excp.input;
  return *this;
}

void Param_Test::Ooops::_tao_any_destructor (void *_tao_void_pointer)
{
  Ooops *_tao_tmp_pointer =
    static_cast<Ooops *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

Param_Test::Ooops *
Param_Test::Ooops::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<Ooops *> (_tao_excp);
}

const Param_Test::Ooops *
Param_Test::Ooops::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const Ooops *> (_tao_excp);
}

::CORBA::Exception *Param_Test::Ooops::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Param_Test::Ooops, 0);
  return retval;
}

::CORBA::Exception *
Param_Test::Ooops::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::Param_Test::Ooops (*this),
      0
    );
  return result;
}

void Param_Test::Ooops::_raise (void) const
{
  throw *this;
}

void Param_Test::Ooops::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void Param_Test::Ooops::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Param_Test::Ooops::_tao_type (void) const
{
  return ::Param_Test::_tc_Ooops;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_Ooops[] =
      {
        { "reason", &CORBA::_tc_string },
        { "input", &CORBA::_tc_ulong }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_Ooops (
  ::CORBA::tk_except,
  "IDL:Param_Test/Ooops:1.0",
  "Ooops",
  _tao_fields_Param_Test_Ooops,
  2);

::CORBA::TypeCode_ptr const Param_Test::_tc_Ooops =
  &_tao_tc_Param_Test_Ooops;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_exception/exception_cs.cpp:110

Param_Test::BadBoy::BadBoy (void)
  : ::CORBA::UserException (
        "IDL:Param_Test/BadBoy:1.0",
        "BadBoy"
      )
{
}

Param_Test::BadBoy::~BadBoy (void)
{
}

Param_Test::BadBoy::BadBoy (const ::Param_Test::BadBoy &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

Param_Test::BadBoy&
Param_Test::BadBoy::operator= (const ::Param_Test::BadBoy &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  return *this;
}

void Param_Test::BadBoy::_tao_any_destructor (void *_tao_void_pointer)
{
  BadBoy *_tao_tmp_pointer =
    static_cast<BadBoy *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

Param_Test::BadBoy *
Param_Test::BadBoy::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<BadBoy *> (_tao_excp);
}

const Param_Test::BadBoy *
Param_Test::BadBoy::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const BadBoy *> (_tao_excp);
}

::CORBA::Exception *Param_Test::BadBoy::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::Param_Test::BadBoy, 0);
  return retval;
}

::CORBA::Exception *
Param_Test::BadBoy::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::Param_Test::BadBoy (*this),
      0
    );
  return result;
}

void Param_Test::BadBoy::_raise (void) const
{
  throw *this;
}

void Param_Test::BadBoy::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void Param_Test::BadBoy::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr Param_Test::BadBoy::_tao_type (void) const
{
  return ::Param_Test::_tc_BadBoy;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const * const 
    _tao_fields_Param_Test_BadBoy = 0;
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_BadBoy (
  ::CORBA::tk_except,
  "IDL:Param_Test/BadBoy:1.0",
  "BadBoy",
  _tao_fields_Param_Test_BadBoy,
  0);

::CORBA::TypeCode_ptr const Param_Test::_tc_BadBoy =
  &_tao_tc_Param_Test_BadBoy;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::CORBA::ULong
Param_Test::test_exception (
  CORBA::ULong s1,
  CORBA::ULong & s2,
  CORBA::ULong_out s3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::ULong>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::ULong>::in_arg_val _tao_s1 (s1);
  TAO::Arg_Traits< ::CORBA::ULong>::inout_arg_val _tao_s2 (s2);
  TAO::Arg_Traits< ::CORBA::ULong>::out_arg_val _tao_s3 (s3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s1,
      &_tao_s2,
      &_tao_s3
    };
  
  static TAO::Exception_Data
  _tao_Param_Test_test_exception_exceptiondata [] = 
    {
      {
        "IDL:Param_Test/Ooops:1.0",
        Param_Test::Ooops::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , Param_Test::_tc_Ooops
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_exception",
      14,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (
      _tao_Param_Test_test_exception_exceptiondata,
      1
    );
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_array/array_cs.cpp:109

Param_Test::Big_Union::_another_array_slice *
Param_Test::Big_Union::_another_array_dup (const Param_Test::Big_Union::_another_array_slice *_tao_src_array)
{
  Param_Test::Big_Union::_another_array_slice *_tao_dup_array =
    Param_Test::Big_Union::_another_array_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Param_Test::Big_Union::_another_array_slice *> (0);
    }
  
  Param_Test::Big_Union::_another_array_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Param_Test::Big_Union::_another_array_slice *
Param_Test::Big_Union::_another_array_alloc (void)
{
  Param_Test::Big_Union::_another_array_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Short[32], 0);
  return retval;
}

void
Param_Test::Big_Union::_another_array_free (
    Param_Test::Big_Union::_another_array_slice *_tao_slice
  )
{
  delete [] _tao_slice;
}

void 
Param_Test::Big_Union::_another_array_copy (
    Param_Test::Big_Union::_another_array_slice * _tao_to,
    const Param_Test::Big_Union::_another_array_slice *_tao_from
  )
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 32; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_union/union_cs.cpp:91

Param_Test::Big_Union::Big_Union (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

Param_Test::Big_Union::Big_Union (const ::Param_Test::Big_Union &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      // Make a deep copy.
      this->u_.the_array_ = 
        Param_Test::Fixed_Array_dup (u.u_.the_array_);
    }
    break;
    case 1:
    {
      if (u.u_.the_interface_ == 0)
        {
          this->u_.the_interface_ = 0;
        }
      else
        {
          typedef Coffee_var OBJECT_FIELD;
          ACE_NEW (
              this->u_.the_interface_,
              OBJECT_FIELD (
                  Coffee::_duplicate (
                      u.u_.the_interface_->in ()
                    )
                )
            );
        }
    }
    break;
    case 2:
    {
      this->u_.the_long_ = u.u_.the_long_;
    }
    break;
    case 3:
    {
      // Make a deep copy.
      this->u_.another_array_ = 
        Param_Test::Big_Union::_another_array_dup (u.u_.another_array_);
    }
    break;
    case 4:
    {
      this->u_.the_string_ = ::CORBA::string_dup (u.u_.the_string_);
    }
    break;
    case 5:
    {
      if (u.u_.the_sequence_ == 0)
        {
          this->u_.the_sequence_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.the_sequence_,
              CORBA::ShortSeq (*u.u_.the_sequence_)
            );
        }
    }
    break;
    case 6:
    {
      if (u.u_.the_any_ == 0)
        {
          this->u_.the_any_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.the_any_,
              CORBA::Any (*u.u_.the_any_)
            );
        }
    }
    break;
    case 7:
    {
      this->u_.the_octet_ = u.u_.the_octet_;
    }
    break;
    case 8:
    {
      this->u_.the_char_ = u.u_.the_char_;
    }
    break;
    case 9:
    {
      this->u_.the_boolean_ = u.u_.the_boolean_;
    }
    break;
    case 10:
    {
      if (u.u_.the_var_struct_ == 0)
        {
          this->u_.the_var_struct_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.the_var_struct_,
              Param_Test::Var_Struct (*u.u_.the_var_struct_)
            );
        }
    }
    break;
    case 11:
    {
      this->u_.the_fixed_struct_ = u.u_.the_fixed_struct_;
    }
    break;
    default:
    break;
  }
}

Param_Test::Big_Union::~Big_Union (void)
{
  // Finalize.
  this->_reset ();
}

void Param_Test::Big_Union::_tao_any_destructor (void *_tao_void_pointer)
{
  Big_Union *tmp =
    static_cast<Big_Union *> (_tao_void_pointer);
  delete tmp;
}

Param_Test::Big_Union &
Param_Test::Big_Union::operator= (const ::Param_Test::Big_Union &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;
  
  switch (this->disc_)
  {
    case 0:
    {
      // Make a deep copy.
      this->u_.the_array_ = 
        Param_Test::Fixed_Array_dup (u.u_.the_array_);
    }
    break;
    case 1:
    {
      if (u.u_.the_interface_ == 0)
        {
          this->u_.the_interface_ = 0;
        }
      else
        {
          typedef Coffee_var OBJECT_FIELD;
          ACE_NEW_RETURN (
              this->u_.the_interface_,
              OBJECT_FIELD (
                  Coffee::_duplicate (
                      u.u_.the_interface_->in ()
                    )
                ),
              *this
            );
        }
    }
    break;
    case 2:
    {
      this->u_.the_long_ = u.u_.the_long_;
    }
    break;
    case 3:
    {
      // Make a deep copy.
      this->u_.another_array_ = 
        Param_Test::Big_Union::_another_array_dup (u.u_.another_array_);
    }
    break;
    case 4:
    {
      this->u_.the_string_ = ::CORBA::string_dup (u.u_.the_string_);
    }
    break;
    case 5:
    {
      if (u.u_.the_sequence_ == 0)
        {
          this->u_.the_sequence_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.the_sequence_,
              CORBA::ShortSeq (*u.u_.the_sequence_),
              *this
            );
        }
    }
    break;
    case 6:
    {
      if (u.u_.the_any_ == 0)
        {
          this->u_.the_any_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.the_any_,
              CORBA::Any (*u.u_.the_any_),
              *this
            );
        }
    }
    break;
    case 7:
    {
      this->u_.the_octet_ = u.u_.the_octet_;
    }
    break;
    case 8:
    {
      this->u_.the_char_ = u.u_.the_char_;
    }
    break;
    case 9:
    {
      this->u_.the_boolean_ = u.u_.the_boolean_;
    }
    break;
    case 10:
    {
      if (u.u_.the_var_struct_ == 0)
        {
          this->u_.the_var_struct_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.the_var_struct_,
              Param_Test::Var_Struct (*u.u_.the_var_struct_),
              *this
            );
        }
    }
    break;
    case 11:
    {
      this->u_.the_fixed_struct_ = u.u_.the_fixed_struct_;
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void Param_Test::Big_Union::_reset (void)
{
  switch (this->disc_)
  {
    
    case 0:
      Param_Test::Fixed_Array_free (this->u_.the_array_);
      this->u_.the_array_ = 0;
      break;
    case 1:
      delete this->u_.the_interface_;
      this->u_.the_interface_ = 0;
      break;
    case 2:
      break;
    case 3:
      Param_Test::Big_Union::_another_array_free (this->u_.another_array_);
      this->u_.another_array_ = 0;
      break;
    case 4:
      ::CORBA::string_free (this->u_.the_string_);
      this->u_.the_string_ = 0;
      break;
    case 5:
      delete this->u_.the_sequence_;
      this->u_.the_sequence_ = 0;
      break;
    case 6:
      delete this->u_.the_any_;
      this->u_.the_any_ = 0;
      break;
    case 7:
      break;
    case 8:
      break;
    case 9:
      break;
    case 10:
      delete this->u_.the_var_struct_;
      this->u_.the_var_struct_ = 0;
      break;
    case 11:
      break;
    default:
    break;
  }
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/union_typecode.cpp:65



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:359



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:359


#ifndef _TAO_TYPECODE_Param_Test_Big_Union_another_array_GUARD
#define _TAO_TYPECODE_Param_Test_Big_Union_another_array_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Big_Union_another_array_32 (
          ::CORBA::tk_array,
          &CORBA::_tc_short,
          32U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Big_Union_another_array =
        &Param_Test_Big_Union_another_array_32;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Big_Union_another_array_GUARD */


// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__0 (0, "the_array", &Param_Test::_tc_Fixed_Array);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__1 (1, "the_interface", &_tc_Coffee);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__2 (2, "the_long", &CORBA::_tc_long);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__3 (3, "another_array", &TAO::TypeCode::tc_Param_Test_Big_Union_another_array);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__4 (4, "the_string", &CORBA::_tc_string);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__5 (5, "the_sequence", &CORBA::_tc_ShortSeq);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__6 (6, "the_any", &CORBA::_tc_any);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__7 (7, "the_octet", &CORBA::_tc_octet);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__8 (8, "the_char", &CORBA::_tc_char);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__9 (9, "the_boolean", &CORBA::_tc_boolean);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__10 (10, "the_var_struct", &Param_Test::_tc_Var_Struct);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Big_Union__11 (11, "the_fixed_struct", &Param_Test::_tc_Fixed_Struct);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Param_Test_Big_Union[] =
  {
    &_tao_cases_Param_Test_Big_Union__0,
    &_tao_cases_Param_Test_Big_Union__1,
    &_tao_cases_Param_Test_Big_Union__2,
    &_tao_cases_Param_Test_Big_Union__3,
    &_tao_cases_Param_Test_Big_Union__4,
    &_tao_cases_Param_Test_Big_Union__5,
    &_tao_cases_Param_Test_Big_Union__6,
    &_tao_cases_Param_Test_Big_Union__7,
    &_tao_cases_Param_Test_Big_Union__8,
    &_tao_cases_Param_Test_Big_Union__9,
    &_tao_cases_Param_Test_Big_Union__10,
    &_tao_cases_Param_Test_Big_Union__11
    
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Big_Union (
    "IDL:Param_Test/Big_Union:1.0",
    "Big_Union",
    &CORBA::_tc_short,
    _tao_cases_Param_Test_Big_Union,
    12, -1);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Big_Union =
  &_tao_tc_Param_Test_Big_Union;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Big_Union *
Param_Test::test_big_union (
  const Param_Test::Big_Union & u1,
  Param_Test::Big_Union & u2,
  Param_Test::Big_Union_out u3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Big_Union>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Big_Union>::in_arg_val _tao_u1 (u1);
  TAO::Arg_Traits< ::Param_Test::Big_Union>::inout_arg_val _tao_u2 (u2);
  TAO::Arg_Traits< ::Param_Test::Big_Union>::out_arg_val _tao_u3 (u3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_u1,
      &_tao_u2,
      &_tao_u3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_big_union",
      14,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/enum_typecode.cpp:31
static char const * const _tao_enumerators_Param_Test_Small_Union_Switch[] =
  {
    "A_LONG",
    "A_SHORT"
    
  };

static TAO::TypeCode::Enum<char const *,
                           char const * const *,
                           TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Small_Union_Switch (
    "IDL:Param_Test/Small_Union_Switch:1.0",
    "Small_Union_Switch",
    _tao_enumerators_Param_Test_Small_Union_Switch,
    2);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Small_Union_Switch =
  &_tao_tc_Param_Test_Small_Union_Switch;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_union/union_cs.cpp:91

Param_Test::Small_Union::Small_Union (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = Param_Test::A_LONG;
  
}

Param_Test::Small_Union::Small_Union (const ::Param_Test::Small_Union &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Param_Test::A_LONG:
    {
      this->u_.the_long_ = u.u_.the_long_;
    }
    break;
    case Param_Test::A_SHORT:
    {
      this->u_.the_short_ = u.u_.the_short_;
    }
    break;
  }
}

Param_Test::Small_Union::~Small_Union (void)
{
  // Finalize.
  this->_reset ();
}

void Param_Test::Small_Union::_tao_any_destructor (void *_tao_void_pointer)
{
  Small_Union *tmp =
    static_cast<Small_Union *> (_tao_void_pointer);
  delete tmp;
}

Param_Test::Small_Union &
Param_Test::Small_Union::operator= (const ::Param_Test::Small_Union &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;
  
  switch (this->disc_)
  {
    case Param_Test::A_LONG:
    {
      this->u_.the_long_ = u.u_.the_long_;
    }
    break;
    case Param_Test::A_SHORT:
    {
      this->u_.the_short_ = u.u_.the_short_;
    }
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void Param_Test::Small_Union::_reset (void)
{
  switch (this->disc_)
  {
    
    case Param_Test::A_LONG:
      break;
    case Param_Test::A_SHORT:
      break;
  }
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/union_typecode.cpp:65

static TAO::TypeCode::Case_T<Param_Test::Small_Union_Switch, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Small_Union__0 (Param_Test::A_LONG, "the_long", &CORBA::_tc_long);
static TAO::TypeCode::Case_T<Param_Test::Small_Union_Switch, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Small_Union__1 (Param_Test::A_SHORT, "the_short", &CORBA::_tc_short);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Param_Test_Small_Union[] =
  {
    &_tao_cases_Param_Test_Small_Union__0,
    &_tao_cases_Param_Test_Small_Union__1
    
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Small_Union (
    "IDL:Param_Test/Small_Union:1.0",
    "Small_Union",
    &Param_Test::_tc_Small_Union_Switch,
    _tao_cases_Param_Test_Small_Union,
    2, -1);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Small_Union =
  &_tao_tc_Param_Test_Small_Union;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Small_Union
Param_Test::test_small_union (
  const Param_Test::Small_Union & u1,
  Param_Test::Small_Union & u2,
  Param_Test::Small_Union_out u3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Small_Union>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Small_Union>::in_arg_val _tao_u1 (u1);
  TAO::Arg_Traits< ::Param_Test::Small_Union>::inout_arg_val _tao_u2 (u2);
  TAO::Arg_Traits< ::Param_Test::Small_Union>::out_arg_val _tao_u3 (u3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_u1,
      &_tao_u2,
      &_tao_u3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_small_union",
      16,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_level4[] =
      {
        { "level5_string", &CORBA::_tc_string },
        { "level5_any", &CORBA::_tc_any }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_level4 (
  ::CORBA::tk_struct,
  "IDL:Param_Test/level4:1.0",
  "level4",
  _tao_fields_Param_Test_level4,
  2);

::CORBA::TypeCode_ptr const Param_Test::_tc_level4 =
  &_tao_tc_Param_Test_level4;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::level4::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  level4 *_tao_tmp_pointer =
    static_cast<level4 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_level8[] =
      {
        { "level9_string", &CORBA::_tc_string },
        { "level9_boolean", &CORBA::_tc_boolean },
        { "level9_short", &CORBA::_tc_short }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Param_Test_level8 (
  ::CORBA::tk_struct,
  "IDL:Param_Test/level8:1.0",
  "level8",
  _tao_fields_Param_Test_level8,
  3);

::CORBA::TypeCode_ptr const Param_Test::_tc_level8 =
  &_tao_tc_Param_Test_level8;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::level8::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  level8 *_tao_tmp_pointer =
    static_cast<level8 *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::CORBA::Any *
Param_Test::test_complex_any (
  const CORBA::Any & ca1,
  CORBA::Any & ca2,
  CORBA::Any_out ca3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Any>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_ca1 (ca1);
  TAO::Arg_Traits< ::CORBA::Any>::inout_arg_val _tao_ca2 (ca2);
  TAO::Arg_Traits< ::CORBA::Any>::out_arg_val _tao_ca3 (ca3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ca1,
      &_tao_ca2,
      &_tao_ca3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_complex_any",
      16,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/struct_typecode.cpp:84



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__GUARD
#define _TAO_TYPECODE_Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__0 (
          ::CORBA::tk_sequence,
          &Param_Test::_tc_Recursive_Struct,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__0 =
        &Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__GUARD */

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Param_Test_Recursive_Struct[] =
      {
        { "x", &CORBA::_tc_long },
        { "children", &TAO::TypeCode::tc_Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__0 }
      };
  
static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Struct<
    char const *,
    ::CORBA::TypeCode_ptr const *,
    TAO::TypeCode::Struct_Field<
      char const *,
      ::CORBA::TypeCode_ptr const *> const *,
    TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *>
_tao_tc_Param_Test_Recursive_Struct (
  ::CORBA::tk_struct,
  "IDL:Param_Test/Recursive_Struct:1.0",
  "Recursive_Struct",
  _tao_fields_Param_Test_Recursive_Struct,
  2);

::CORBA::TypeCode_ptr const Param_Test::_tc_Recursive_Struct =
  &_tao_tc_Param_Test_Recursive_Struct;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/structure_cs.cpp:65

void 
Param_Test::Recursive_Struct::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Recursive_Struct *_tao_tmp_pointer =
    static_cast<Recursive_Struct *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_RECURSIVE_STRUCT__TAO_SEQ_PARAM_TEST_RECURSIVE_STRUCT__CS_)
#define _PARAM_TEST_RECURSIVE_STRUCT__TAO_SEQ_PARAM_TEST_RECURSIVE_STRUCT__CS_

Param_Test::Recursive_Struct::_tao_seq_Param_Test_Recursive_Struct_::_tao_seq_Param_Test_Recursive_Struct_ (void)
{}

Param_Test::Recursive_Struct::_tao_seq_Param_Test_Recursive_Struct_::_tao_seq_Param_Test_Recursive_Struct_ (
      ::CORBA::ULong max)
  : std::vector<Param_Test::Recursive_Struct> (max)
{}

Param_Test::Recursive_Struct::_tao_seq_Param_Test_Recursive_Struct_::_tao_seq_Param_Test_Recursive_Struct_ (
      const _tao_seq_Param_Test_Recursive_Struct_ &seq)
  : std::vector<Param_Test::Recursive_Struct> (seq)
{}

Param_Test::Recursive_Struct::_tao_seq_Param_Test_Recursive_Struct_::~_tao_seq_Param_Test_Recursive_Struct_ (void)
{}

::CORBA::ULong
Param_Test::Recursive_Struct::_tao_seq_Param_Test_Recursive_Struct_::length (void) const
{
  return this->size ();
}

void
Param_Test::Recursive_Struct::_tao_seq_Param_Test_Recursive_Struct_::length (::CORBA::ULong length)
{
  this->reserve (length);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Recursive_Struct *
Param_Test::test_recursive_struct (
  const Param_Test::Recursive_Struct & rs1,
  Param_Test::Recursive_Struct & rs2,
  Param_Test::Recursive_Struct_out rs3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Recursive_Struct>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Recursive_Struct>::in_arg_val _tao_rs1 (rs1);
  TAO::Arg_Traits< ::Param_Test::Recursive_Struct>::inout_arg_val _tao_rs2 (rs2);
  TAO::Arg_Traits< ::Param_Test::Recursive_Struct>::out_arg_val _tao_rs3 (rs3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_rs1,
      &_tao_rs2,
      &_tao_rs3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_recursive_struct",
      21,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_NESTED_REC_UNION__TAO_SEQ_PARAM_TEST_NESTED_REC_UNION__CS_)
#define _PARAM_TEST_NESTED_REC_UNION__TAO_SEQ_PARAM_TEST_NESTED_REC_UNION__CS_

Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_::_tao_seq_Param_Test_nested_rec_union_ (void)
{}

Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_::_tao_seq_Param_Test_nested_rec_union_ (
      ::CORBA::ULong max)
  : std::vector<Param_Test::nested_rec_union> (max)
{}

Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_::_tao_seq_Param_Test_nested_rec_union_ (
      const _tao_seq_Param_Test_nested_rec_union_ &seq)
  : std::vector<Param_Test::nested_rec_union> (seq)
{}

Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_::~_tao_seq_Param_Test_nested_rec_union_ (void)
{}

::CORBA::ULong
Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_::length (void) const
{
  return this->size ();
}

void
Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_::length (::CORBA::ULong length)
{
  this->reserve (length);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_union/union_cs.cpp:91

Param_Test::nested_rec_union::nested_rec_union (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

Param_Test::nested_rec_union::nested_rec_union (const ::Param_Test::nested_rec_union &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      this->u_.value_ = u.u_.value_;
    }
    break;
    case 1:
    {
      if (u.u_.nested_rec_member_ == 0)
        {
          this->u_.nested_rec_member_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.nested_rec_member_,
              Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_ (*u.u_.nested_rec_member_)
            );
        }
    }
    break;
    default:
    break;
  }
}

Param_Test::nested_rec_union::~nested_rec_union (void)
{
  // Finalize.
  this->_reset ();
}

void Param_Test::nested_rec_union::_tao_any_destructor (void *_tao_void_pointer)
{
  nested_rec_union *tmp =
    static_cast<nested_rec_union *> (_tao_void_pointer);
  delete tmp;
}

Param_Test::nested_rec_union &
Param_Test::nested_rec_union::operator= (const ::Param_Test::nested_rec_union &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;
  
  switch (this->disc_)
  {
    case 0:
    {
      this->u_.value_ = u.u_.value_;
    }
    break;
    case 1:
    {
      if (u.u_.nested_rec_member_ == 0)
        {
          this->u_.nested_rec_member_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.nested_rec_member_,
              Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_ (*u.u_.nested_rec_member_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void Param_Test::nested_rec_union::_reset (void)
{
  switch (this->disc_)
  {
    
    case 0:
      break;
    case 1:
      delete this->u_.nested_rec_member_;
      this->u_.nested_rec_member_ = 0;
      break;
    default:
    break;
  }
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/union_typecode.cpp:65



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__GUARD
#define _TAO_TYPECODE_Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__0 (
          ::CORBA::tk_sequence,
          &Param_Test::_tc_nested_rec_union,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__0 =
        &Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__GUARD */

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_nested_rec_union__0 (0, "value", &CORBA::_tc_long);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_nested_rec_union__1 (1, "nested_rec_member", &TAO::TypeCode::tc_Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__0);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Param_Test_nested_rec_union[] =
  {
    &_tao_cases_Param_Test_nested_rec_union__0,
    &_tao_cases_Param_Test_nested_rec_union__1
    
  };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Union<char const *,
                              ::CORBA::TypeCode_ptr const *,
                              TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                              TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const * >

  _tao_tc_Param_Test_nested_rec_union (
    "IDL:Param_Test/nested_rec_union:1.0",
    "nested_rec_union",
    &CORBA::_tc_short,
    _tao_cases_Param_Test_nested_rec_union,
    2, -1);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_nested_rec_union =
  &_tao_tc_Param_Test_nested_rec_union;

// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_PARAM_TEST_RECURSIVE_UNION__TAO_SEQ_PARAM_TEST_RECURSIVE_UNION__CS_)
#define _PARAM_TEST_RECURSIVE_UNION__TAO_SEQ_PARAM_TEST_RECURSIVE_UNION__CS_

Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_::_tao_seq_Param_Test_Recursive_Union_ (void)
{}

Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_::_tao_seq_Param_Test_Recursive_Union_ (
      ::CORBA::ULong max)
  : std::vector<Param_Test::Recursive_Union> (max)
{}

Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_::_tao_seq_Param_Test_Recursive_Union_ (
      const _tao_seq_Param_Test_Recursive_Union_ &seq)
  : std::vector<Param_Test::Recursive_Union> (seq)
{}

Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_::~_tao_seq_Param_Test_Recursive_Union_ (void)
{}

::CORBA::ULong
Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_::length (void) const
{
  return this->size ();
}

void
Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_::length (::CORBA::ULong length)
{
  this->reserve (length);
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_union/union_cs.cpp:91

Param_Test::Recursive_Union::Recursive_Union (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

Param_Test::Recursive_Union::Recursive_Union (const ::Param_Test::Recursive_Union &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.rec_member_ == 0)
        {
          this->u_.rec_member_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.rec_member_,
              Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_ (*u.u_.rec_member_)
            );
        }
    }
    break;
    case 1:
    {
      if (u.u_.nested_member_ == 0)
        {
          this->u_.nested_member_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.nested_member_,
              Param_Test::nested_rec_union (*u.u_.nested_member_)
            );
        }
    }
    break;
    default:
    break;
  }
}

Param_Test::Recursive_Union::~Recursive_Union (void)
{
  // Finalize.
  this->_reset ();
}

void Param_Test::Recursive_Union::_tao_any_destructor (void *_tao_void_pointer)
{
  Recursive_Union *tmp =
    static_cast<Recursive_Union *> (_tao_void_pointer);
  delete tmp;
}

Param_Test::Recursive_Union &
Param_Test::Recursive_Union::operator= (const ::Param_Test::Recursive_Union &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;
  
  switch (this->disc_)
  {
    case 0:
    {
      if (u.u_.rec_member_ == 0)
        {
          this->u_.rec_member_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.rec_member_,
              Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_ (*u.u_.rec_member_),
              *this
            );
        }
    }
    break;
    case 1:
    {
      if (u.u_.nested_member_ == 0)
        {
          this->u_.nested_member_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.nested_member_,
              Param_Test::nested_rec_union (*u.u_.nested_member_),
              *this
            );
        }
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void Param_Test::Recursive_Union::_reset (void)
{
  switch (this->disc_)
  {
    
    case 0:
      delete this->u_.rec_member_;
      this->u_.rec_member_ = 0;
      break;
    case 1:
      delete this->u_.nested_member_;
      this->u_.nested_member_ = 0;
      break;
    default:
    break;
  }
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/union_typecode.cpp:65



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__GUARD
#define _TAO_TYPECODE_Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__0 (
          ::CORBA::tk_sequence,
          &Param_Test::_tc_Recursive_Union,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__0 =
        &Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__GUARD */

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Recursive_Union__0 (0, "rec_member", &TAO::TypeCode::tc_Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__0);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Param_Test_Recursive_Union__1 (1, "nested_member", &Param_Test::_tc_nested_rec_union);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Param_Test_Recursive_Union[] =
  {
    &_tao_cases_Param_Test_Recursive_Union__0,
    &_tao_cases_Param_Test_Recursive_Union__1
    
  };

static TAO::TypeCode::Recursive_Type<
  TAO::TypeCode::Union<char const *,
                              ::CORBA::TypeCode_ptr const *,
                              TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                              TAO::Null_RefCount_Policy>,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const * >

  _tao_tc_Param_Test_Recursive_Union (
    "IDL:Param_Test/Recursive_Union:1.0",
    "Recursive_Union",
    &CORBA::_tc_short,
    _tao_cases_Param_Test_Recursive_Union,
    2, -1);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Recursive_Union =
  &_tao_tc_Param_Test_Recursive_Union;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Recursive_Union *
Param_Test::test_recursive_union (
  const Param_Test::Recursive_Union & ru1,
  Param_Test::Recursive_Union & ru2,
  Param_Test::Recursive_Union_out ru3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Recursive_Union>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Recursive_Union>::in_arg_val _tao_ru1 (ru1);
  TAO::Arg_Traits< ::Param_Test::Recursive_Union>::inout_arg_val _tao_ru2 (ru2);
  TAO::Arg_Traits< ::Param_Test::Recursive_Union>::out_arg_val _tao_ru3 (ru3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_ru1,
      &_tao_ru2,
      &_tao_ru3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_recursive_union",
      20,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_constant/constant_cs.cpp:71

#ifndef ACE_HAS_HEADER_ALLOCATED_CLASS_STATIC_CONST_INT_STOREAGE
  const CORBA::ULong Param_Test::DIM3;
#endif // ifndef ACE_HAS_HEADER_ALLOCATED_CLASS_STATIC_CONST_INT_STOREAGE

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_array/array_cs.cpp:109

Param_Test::Multdim_Array_slice *
Param_Test::Multdim_Array_dup (const Param_Test::Multdim_Array_slice *_tao_src_array)
{
  Param_Test::Multdim_Array_slice *_tao_dup_array =
    Param_Test::Multdim_Array_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <Param_Test::Multdim_Array_slice *> (0);
    }
  
  Param_Test::Multdim_Array_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

Param_Test::Multdim_Array_slice *
Param_Test::Multdim_Array_alloc (void)
{
  Param_Test::Multdim_Array_slice *retval = 0;
  ACE_NEW_RETURN (retval, Param_Test::Fixed_Array[5][3], 0);
  return retval;
}

void
Param_Test::Multdim_Array_free (
    Param_Test::Multdim_Array_slice *_tao_slice
  )
{
  delete [] _tao_slice;
}

void 
Param_Test::Multdim_Array_copy (
    Param_Test::Multdim_Array_slice * _tao_to,
    const Param_Test::Multdim_Array_slice *_tao_from
  )
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 5; ++i0)
    {
      for ( ::CORBA::ULong i1 = 0; i1 < 3; ++i1)
        {
          // call the underlying _copy
          Param_Test::Fixed_Array_copy (_tao_to[i0][i1], _tao_from[i0][i1]);
        }
    }
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/typecode_defn.cpp:359


#ifndef _TAO_TYPECODE_Param_Test_Multdim_Array_GUARD
#define _TAO_TYPECODE_Param_Test_Multdim_Array_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Multdim_Array_3 (
          ::CORBA::tk_array,
          &Param_Test::_tc_Fixed_Array,
          3U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Multdim_Array_3 =
        &Param_Test_Multdim_Array_3;
      
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Param_Test_Multdim_Array_5_3 (
          ::CORBA::tk_array,
          &tc_Param_Test_Multdim_Array_3,
          5U);
        
      ::CORBA::TypeCode_ptr const tc_Param_Test_Multdim_Array =
        &Param_Test_Multdim_Array_5_3;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Param_Test_Multdim_Array_GUARD */
static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test_Multdim_Array (
    ::CORBA::tk_alias,
    "IDL:Param_Test/Multdim_Array:1.0",
    "Multdim_Array",
    &TAO::TypeCode::tc_Param_Test_Multdim_Array);
  
::CORBA::TypeCode_ptr const Param_Test::_tc_Multdim_Array =
  &_tao_tc_Param_Test_Multdim_Array;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

::Param_Test::Multdim_Array_slice *
Param_Test::test_multdim_array (
  const Param_Test::Multdim_Array m1,
  Param_Test::Multdim_Array m2,
  Param_Test::Multdim_Array_out m3)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::Param_Test::Multdim_Array_tag>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Param_Test::Multdim_Array_tag>::in_arg_val _tao_m1 (m1);
  TAO::Arg_Traits< ::Param_Test::Multdim_Array_tag>::inout_arg_val _tao_m2 (m2);
  TAO::Arg_Traits< ::Param_Test::Multdim_Array_tag>::out_arg_val _tao_m3 (m3);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_m1,
      &_tao_m2,
      &_tao_m3
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "test_multdim_array",
      18,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_operation/operation_cs.cpp:78

void
Param_Test::shutdown (void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Param_Test_Proxy_Broker_ == 0)
    {
      Param_Test_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "shutdown",
      8,
      this->the_TAO_Param_Test_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
}

Param_Test::Param_Test (void)
 : the_TAO_Param_Test_Proxy_Broker_ (0)
{
  this->Param_Test_setup_collocation ();
}

void
Param_Test::Param_Test_setup_collocation ()
{
  if (::_TAO_Param_Test_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Param_Test_Proxy_Broker_ =
        ::_TAO_Param_Test_Proxy_Broker_Factory_function_pointer (this);
    }
}

Param_Test::~Param_Test (void)
{}

void 
Param_Test::_tao_any_destructor (void *_tao_void_pointer)
{
  Param_Test *_tao_tmp_pointer =
    static_cast<Param_Test *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Param_Test_ptr
Param_Test::_narrow (
    ::CORBA::Object_ptr _tao_objref
  )
{
  return
    TAO::Narrow_Utils<Param_Test>::narrow (
        _tao_objref,
        "IDL:Param_Test:1.0",
        _TAO_Param_Test_Proxy_Broker_Factory_function_pointer
      );
}

Param_Test_ptr
Param_Test::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref
  )
{
  return
    TAO::Narrow_Utils<Param_Test>::unchecked_narrow (
        _tao_objref,
        "IDL:Param_Test:1.0",
        _TAO_Param_Test_Proxy_Broker_Factory_function_pointer
      );
}

Param_Test_ptr
Param_Test::_duplicate (Param_Test_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
Param_Test::_tao_release (Param_Test_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Param_Test::_is_a (const char *value)
{
  if (
      !ACE_OS::strcmp (
          value,
          "IDL:Param_Test:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Param_Test::_interface_repository_id (void) const
{
  return "IDL:Param_Test:1.0";
}

::CORBA::Boolean
Param_Test::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_typecode/objref_typecode.cpp:76

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Param_Test (
    ::CORBA::tk_objref,
    "IDL:Param_Test:1.0",
    "Param_Test");
  
::CORBA::TypeCode_ptr const _tc_Param_Test =
  &_tao_tc_Param_Test;

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Coffee>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Coffee_ptr _tao_elem)
{
  Coffee_ptr _tao_objptr =
    Coffee::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Coffee_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Coffee>::insert (
      _tao_any,
      Coffee::_tao_any_destructor,
      _tc_Coffee,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Coffee_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Coffee>::extract (
        _tao_any,
        Coffee::_tao_any_destructor,
        _tc_Coffee,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Coffee::Desc &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Coffee::Desc *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Coffee::Desc>::insert_copy (
        _tao_any,
        Coffee::Desc::_tao_any_destructor,
        Coffee::_tc_Desc,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Coffee::Desc *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Coffee::Desc>::insert (
      _tao_any,
      Coffee::Desc::_tao_any_destructor,
      Coffee::_tc_Desc,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Coffee::Desc *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Coffee::Desc *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Coffee::Desc *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Coffee::Desc>::extract (
        _tao_any,
        Coffee::Desc::_tao_any_destructor,
        Coffee::_tc_Desc,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_interface/any_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Param_Test>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test_ptr _tao_elem)
{
  Param_Test_ptr _tao_objptr =
    Param_Test::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Param_Test>::insert (
      _tao_any,
      Param_Test::_tao_any_destructor,
      _tc_Param_Test,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Param_Test>::extract (
        _tao_any,
        Param_Test::_tao_any_destructor,
        _tc_Param_Test,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Fixed_Struct &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Fixed_Struct *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Fixed_Struct>::insert_copy (
        _tao_any,
        Param_Test::Fixed_Struct::_tao_any_destructor,
        Param_Test::_tc_Fixed_Struct,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Fixed_Struct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Fixed_Struct>::insert (
      _tao_any,
      Param_Test::Fixed_Struct::_tao_any_destructor,
      Param_Test::_tc_Fixed_Struct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Fixed_Struct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Fixed_Struct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Fixed_Struct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Fixed_Struct>::extract (
        _tao_any,
        Param_Test::Fixed_Struct::_tao_any_destructor,
        Param_Test::_tc_Fixed_Struct,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::NameComponent &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::NameComponent *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::NameComponent>::insert_copy (
        _tao_any,
        Param_Test::NameComponent::_tao_any_destructor,
        Param_Test::_tc_NameComponent,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::NameComponent *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::NameComponent>::insert (
      _tao_any,
      Param_Test::NameComponent::_tao_any_destructor,
      Param_Test::_tc_NameComponent,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::NameComponent *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::NameComponent *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::NameComponent *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::NameComponent>::extract (
        _tao_any,
        Param_Test::NameComponent::_tao_any_destructor,
        Param_Test::_tc_NameComponent,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Step &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Step *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Step>::insert_copy (
        _tao_any,
        Param_Test::Step::_tao_any_destructor,
        Param_Test::_tc_Step,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Step *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Step>::insert (
      _tao_any,
      Param_Test::Step::_tao_any_destructor,
      Param_Test::_tc_Step,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Step *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Step *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Step *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Step>::extract (
        _tao_any,
        Param_Test::Step::_tao_any_destructor,
        Param_Test::_tc_Step,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void operator<<= (
  ::CORBA::Any &_tao_any,
  const std::vector<Param_Test::Step> &_tao_elem)
{
  TAO::insert_value_vector<Param_Test::Step> (
    _tao_any,
    _tao_elem);
}

::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  std::vector<Param_Test::Step> &_tao_elem)
{
  return
    TAO::extract_value_vector<Param_Test::Step> (
      _tao_any,
      _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_Short_Seq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Bounded_Short_Seq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_Short_Seq>::insert_copy (
        _tao_any,
        Param_Test::Bounded_Short_Seq::_tao_any_destructor,
        Param_Test::_tc_Bounded_Short_Seq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Bounded_Short_Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Bounded_Short_Seq>::insert (
      _tao_any,
      Param_Test::Bounded_Short_Seq::_tao_any_destructor,
      Param_Test::_tc_Bounded_Short_Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Bounded_Short_Seq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Bounded_Short_Seq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_Short_Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_Short_Seq>::extract (
        _tao_any,
        Param_Test::Bounded_Short_Seq::_tao_any_destructor,
        Param_Test::_tc_Bounded_Short_Seq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_Long_Seq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Bounded_Long_Seq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_Long_Seq>::insert_copy (
        _tao_any,
        Param_Test::Bounded_Long_Seq::_tao_any_destructor,
        Param_Test::_tc_Bounded_Long_Seq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Bounded_Long_Seq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Bounded_Long_Seq>::insert (
      _tao_any,
      Param_Test::Bounded_Long_Seq::_tao_any_destructor,
      Param_Test::_tc_Bounded_Long_Seq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Bounded_Long_Seq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Bounded_Long_Seq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_Long_Seq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_Long_Seq>::extract (
        _tao_any,
        Param_Test::Bounded_Long_Seq::_tao_any_destructor,
        Param_Test::_tc_Bounded_Long_Seq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_StrSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Bounded_StrSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_StrSeq>::insert_copy (
        _tao_any,
        Param_Test::Bounded_StrSeq::_tao_any_destructor,
        Param_Test::_tc_Bounded_StrSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Bounded_StrSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Bounded_StrSeq>::insert (
      _tao_any,
      Param_Test::Bounded_StrSeq::_tao_any_destructor,
      Param_Test::_tc_Bounded_StrSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Bounded_StrSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Bounded_StrSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_StrSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_StrSeq>::extract (
        _tao_any,
        Param_Test::Bounded_StrSeq::_tao_any_destructor,
        Param_Test::_tc_Bounded_StrSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_WStrSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Bounded_WStrSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_WStrSeq>::insert_copy (
        _tao_any,
        Param_Test::Bounded_WStrSeq::_tao_any_destructor,
        Param_Test::_tc_Bounded_WStrSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Bounded_WStrSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Bounded_WStrSeq>::insert (
      _tao_any,
      Param_Test::Bounded_WStrSeq::_tao_any_destructor,
      Param_Test::_tc_Bounded_WStrSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Bounded_WStrSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Bounded_WStrSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_WStrSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_WStrSeq>::extract (
        _tao_any,
        Param_Test::Bounded_WStrSeq::_tao_any_destructor,
        Param_Test::_tc_Bounded_WStrSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void operator<<= (
  ::CORBA::Any &_tao_any,
  const std::vector<Param_Test::Fixed_Struct> &_tao_elem)
{
  TAO::insert_value_vector<Param_Test::Fixed_Struct> (
    _tao_any,
    _tao_elem);
}

::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  std::vector<Param_Test::Fixed_Struct> &_tao_elem)
{
  return
    TAO::extract_value_vector<Param_Test::Fixed_Struct> (
      _tao_any,
      _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_StructSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Bounded_StructSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_StructSeq>::insert_copy (
        _tao_any,
        Param_Test::Bounded_StructSeq::_tao_any_destructor,
        Param_Test::_tc_Bounded_StructSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Bounded_StructSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Bounded_StructSeq>::insert (
      _tao_any,
      Param_Test::Bounded_StructSeq::_tao_any_destructor,
      Param_Test::_tc_Bounded_StructSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Bounded_StructSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Bounded_StructSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_StructSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_StructSeq>::extract (
        _tao_any,
        Param_Test::Bounded_StructSeq::_tao_any_destructor,
        Param_Test::_tc_Bounded_StructSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void operator<<= (
  ::CORBA::Any &_tao_any,
  const std::vector<Coffee> &_tao_elem)
{
  TAO::insert_objref_vector<Coffee_ptr> (
    _tao_any,
    _tao_elem);
}

::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  std::vector<Coffee> &_tao_elem)
{
  return
    TAO::extract_objref_vector<Coffee_ptr> (
      _tao_any,
      _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_Coffee_Mix &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Bounded_Coffee_Mix *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_Coffee_Mix>::insert_copy (
        _tao_any,
        Param_Test::Bounded_Coffee_Mix::_tao_any_destructor,
        Param_Test::_tc_Bounded_Coffee_Mix,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Bounded_Coffee_Mix *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Bounded_Coffee_Mix>::insert (
      _tao_any,
      Param_Test::Bounded_Coffee_Mix::_tao_any_destructor,
      Param_Test::_tc_Bounded_Coffee_Mix,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Bounded_Coffee_Mix *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Bounded_Coffee_Mix *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_Coffee_Mix *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_Coffee_Mix>::extract (
        _tao_any,
        Param_Test::Bounded_Coffee_Mix::_tao_any_destructor,
        Param_Test::_tc_Bounded_Coffee_Mix,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Var_Struct &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Var_Struct *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Var_Struct>::insert_copy (
        _tao_any,
        Param_Test::Var_Struct::_tao_any_destructor,
        Param_Test::_tc_Var_Struct,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Var_Struct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Var_Struct>::insert (
      _tao_any,
      Param_Test::Var_Struct::_tao_any_destructor,
      Param_Test::_tc_Var_Struct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Var_Struct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Var_Struct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Var_Struct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Var_Struct>::extract (
        _tao_any,
        Param_Test::Var_Struct::_tao_any_destructor,
        Param_Test::_tc_Var_Struct,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Nested_Struct &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Nested_Struct *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Nested_Struct>::insert_copy (
        _tao_any,
        Param_Test::Nested_Struct::_tao_any_destructor,
        Param_Test::_tc_Nested_Struct,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Nested_Struct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Nested_Struct>::insert (
      _tao_any,
      Param_Test::Nested_Struct::_tao_any_destructor,
      Param_Test::_tc_Nested_Struct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Nested_Struct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Nested_Struct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Nested_Struct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Nested_Struct>::extract (
        _tao_any,
        Param_Test::Nested_Struct::_tao_any_destructor,
        Param_Test::_tc_Nested_Struct,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Objref_Struct &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Objref_Struct *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Objref_Struct>::insert_copy (
        _tao_any,
        Param_Test::Objref_Struct::_tao_any_destructor,
        Param_Test::_tc_Objref_Struct,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Objref_Struct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Objref_Struct>::insert (
      _tao_any,
      Param_Test::Objref_Struct::_tao_any_destructor,
      Param_Test::_tc_Objref_Struct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Objref_Struct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Objref_Struct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Objref_Struct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Objref_Struct>::extract (
        _tao_any,
        Param_Test::Objref_Struct::_tao_any_destructor,
        Param_Test::_tc_Objref_Struct,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_array/any_op_cs.cpp:55


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Fixed_Array_forany &_tao_elem
  )
{
  TAO::Any_Array_Impl_T<
      Param_Test::Fixed_Array_slice,
      Param_Test::Fixed_Array_forany
    >::insert (
        _tao_any,
        Param_Test::Fixed_Array_forany::_tao_any_destructor,
        Param_Test::_tc_Fixed_Array,
        _tao_elem.nocopy ()
          ? _tao_elem.ptr ()
          : Param_Test::Fixed_Array_dup (_tao_elem.in ())
      );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Fixed_Array_forany &_tao_elem
  )
{
  return
    TAO::Any_Array_Impl_T<
        Param_Test::Fixed_Array_slice,
        Param_Test::Fixed_Array_forany
      >::extract (
          _tao_any,
          Param_Test::Fixed_Array_forany::_tao_any_destructor,
          Param_Test::_tc_Fixed_Array,
          _tao_elem.out ()
        );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_array/any_op_cs.cpp:55


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Var_Array_forany &_tao_elem
  )
{
  TAO::Any_Array_Impl_T<
      Param_Test::Var_Array_slice,
      Param_Test::Var_Array_forany
    >::insert (
        _tao_any,
        Param_Test::Var_Array_forany::_tao_any_destructor,
        Param_Test::_tc_Var_Array,
        _tao_elem.nocopy ()
          ? _tao_elem.ptr ()
          : Param_Test::Var_Array_dup (_tao_elem.in ())
      );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Var_Array_forany &_tao_elem
  )
{
  return
    TAO::Any_Array_Impl_T<
        Param_Test::Var_Array_slice,
        Param_Test::Var_Array_forany
      >::extract (
          _tao_any,
          Param_Test::Var_Array_forany::_tao_any_destructor,
          Param_Test::_tc_Var_Array,
          _tao_elem.out ()
        );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


void operator<<= (
  ::CORBA::Any &_tao_any,
  const std::vector<Param_Test::Fixed_Array> &_tao_elem)
{
  TAO::insert_array_vector<Param_Test::Fixed_Array_forany> (
    _tao_any,
    _tao_elem);
}

::CORBA::Boolean operator>>= (
  const ::CORBA::Any &_tao_any,
  std::vector<Param_Test::Fixed_Array> &_tao_elem)
{
  return
    TAO::extract_array_vector<Param_Test::Fixed_Array_forany> (
      _tao_any,
      _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_sequence/any_op_cs.cpp:50


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_ArraySeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Bounded_ArraySeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_ArraySeq>::insert_copy (
        _tao_any,
        Param_Test::Bounded_ArraySeq::_tao_any_destructor,
        Param_Test::_tc_Bounded_ArraySeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Bounded_ArraySeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Bounded_ArraySeq>::insert (
      _tao_any,
      Param_Test::Bounded_ArraySeq::_tao_any_destructor,
      Param_Test::_tc_Bounded_ArraySeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Bounded_ArraySeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Bounded_ArraySeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Bounded_ArraySeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Bounded_ArraySeq>::extract (
        _tao_any,
        Param_Test::Bounded_ArraySeq::_tao_any_destructor,
        Param_Test::_tc_Bounded_ArraySeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:50
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<Param_Test::Ooops>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;
    
    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }
    
    return true;
  }
}

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Ooops &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Ooops>::insert_copy (
      _tao_any,
      Param_Test::Ooops::_tao_any_destructor,
      Param_Test::_tc_Ooops,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Ooops *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Ooops>::insert (
      _tao_any,
      Param_Test::Ooops::_tao_any_destructor,
      Param_Test::_tc_Ooops,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Ooops *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Ooops *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Ooops *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Ooops>::extract (
        _tao_any,
        Param_Test::Ooops::_tao_any_destructor,
        Param_Test::_tc_Ooops,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_exception/any_op_cs.cpp:50
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<Param_Test::BadBoy>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;
    
    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }
    
    return true;
  }
}

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::BadBoy &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::BadBoy>::insert_copy (
      _tao_any,
      Param_Test::BadBoy::_tao_any_destructor,
      Param_Test::_tc_BadBoy,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::BadBoy *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::BadBoy>::insert (
      _tao_any,
      Param_Test::BadBoy::_tao_any_destructor,
      Param_Test::_tc_BadBoy,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::BadBoy *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::BadBoy *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::BadBoy *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::BadBoy>::extract (
        _tao_any,
        Param_Test::BadBoy::_tao_any_destructor,
        Param_Test::_tc_BadBoy,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_union/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Big_Union &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Big_Union *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Big_Union>::insert_copy (
        _tao_any,
        Param_Test::Big_Union::_tao_any_destructor,
        Param_Test::_tc_Big_Union,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Big_Union *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Big_Union>::insert (
      _tao_any,
      Param_Test::Big_Union::_tao_any_destructor,
      Param_Test::_tc_Big_Union,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Big_Union *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Big_Union *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Big_Union *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Big_Union>::extract (
        _tao_any,
        Param_Test::Big_Union::_tao_any_destructor,
        Param_Test::_tc_Big_Union,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_enum/any_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Small_Union_Switch _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<Param_Test::Small_Union_Switch>::insert (
      _tao_any,
      Param_Test::_tc_Small_Union_Switch,
      _tao_elem
    );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Small_Union_Switch &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<Param_Test::Small_Union_Switch>::extract (
        _tao_any,
        Param_Test::_tc_Small_Union_Switch,
        _tao_elem 
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_union/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Small_Union &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Small_Union *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Small_Union>::insert_copy (
        _tao_any,
        Param_Test::Small_Union::_tao_any_destructor,
        Param_Test::_tc_Small_Union,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Small_Union *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Small_Union>::insert (
      _tao_any,
      Param_Test::Small_Union::_tao_any_destructor,
      Param_Test::_tc_Small_Union,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Small_Union *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Small_Union *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Small_Union *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Small_Union>::extract (
        _tao_any,
        Param_Test::Small_Union::_tao_any_destructor,
        Param_Test::_tc_Small_Union,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::level4 &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::level4 *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::level4>::insert_copy (
        _tao_any,
        Param_Test::level4::_tao_any_destructor,
        Param_Test::_tc_level4,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::level4 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::level4>::insert (
      _tao_any,
      Param_Test::level4::_tao_any_destructor,
      Param_Test::_tc_level4,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::level4 *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::level4 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::level4 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::level4>::extract (
        _tao_any,
        Param_Test::level4::_tao_any_destructor,
        Param_Test::_tc_level4,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::level8 &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::level8 *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::level8>::insert_copy (
        _tao_any,
        Param_Test::level8::_tao_any_destructor,
        Param_Test::_tc_level8,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::level8 *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::level8>::insert (
      _tao_any,
      Param_Test::level8::_tao_any_destructor,
      Param_Test::_tc_level8,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::level8 *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::level8 *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::level8 *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::level8>::extract (
        _tao_any,
        Param_Test::level8::_tao_any_destructor,
        Param_Test::_tc_level8,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Recursive_Struct &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Recursive_Struct *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Recursive_Struct>::insert_copy (
        _tao_any,
        Param_Test::Recursive_Struct::_tao_any_destructor,
        Param_Test::_tc_Recursive_Struct,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Recursive_Struct *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Recursive_Struct>::insert (
      _tao_any,
      Param_Test::Recursive_Struct::_tao_any_destructor,
      Param_Test::_tc_Recursive_Struct,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Recursive_Struct *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Recursive_Struct *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Recursive_Struct *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Recursive_Struct>::extract (
        _tao_any,
        Param_Test::Recursive_Struct::_tao_any_destructor,
        Param_Test::_tc_Recursive_Struct,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_union/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::nested_rec_union &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::nested_rec_union *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::nested_rec_union>::insert_copy (
        _tao_any,
        Param_Test::nested_rec_union::_tao_any_destructor,
        Param_Test::_tc_nested_rec_union,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::nested_rec_union *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::nested_rec_union>::insert (
      _tao_any,
      Param_Test::nested_rec_union::_tao_any_destructor,
      Param_Test::_tc_nested_rec_union,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::nested_rec_union *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::nested_rec_union *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::nested_rec_union *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::nested_rec_union>::extract (
        _tao_any,
        Param_Test::nested_rec_union::_tao_any_destructor,
        Param_Test::_tc_nested_rec_union,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_union/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Recursive_Union &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Param_Test::Recursive_Union *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Param_Test::Recursive_Union>::insert_copy (
        _tao_any,
        Param_Test::Recursive_Union::_tao_any_destructor,
        Param_Test::_tc_Recursive_Union,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Param_Test::Recursive_Union *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Param_Test::Recursive_Union>::insert (
      _tao_any,
      Param_Test::Recursive_Union::_tao_any_destructor,
      Param_Test::_tc_Recursive_Union,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Recursive_Union *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Param_Test::Recursive_Union *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Param_Test::Recursive_Union *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Param_Test::Recursive_Union>::extract (
        _tao_any,
        Param_Test::Recursive_Union::_tao_any_destructor,
        Param_Test::_tc_Recursive_Union,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// w:\tao\tao_idl\be\be_visitor_array/any_op_cs.cpp:55


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

void operator<<= (
    ::CORBA::Any &_tao_any,
    const Param_Test::Multdim_Array_forany &_tao_elem
  )
{
  TAO::Any_Array_Impl_T<
      Param_Test::Multdim_Array_slice,
      Param_Test::Multdim_Array_forany
    >::insert (
        _tao_any,
        Param_Test::Multdim_Array_forany::_tao_any_destructor,
        Param_Test::_tc_Multdim_Array,
        _tao_elem.nocopy ()
          ? _tao_elem.ptr ()
          : Param_Test::Multdim_Array_dup (_tao_elem.in ())
      );
}

::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Param_Test::Multdim_Array_forany &_tao_elem
  )
{
  return
    TAO::Any_Array_Impl_T<
        Param_Test::Multdim_Array_slice,
        Param_Test::Multdim_Array_forany
      >::extract (
          _tao_any,
          Param_Test::Multdim_Array_forany::_tao_any_destructor,
          Param_Test::_tc_Multdim_Array,
          _tao_elem.out ()
        );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Coffee::Desc &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.name.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Coffee::Desc &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.name.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:63

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Coffee_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Coffee_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;
  
  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::Coffee RHS_SCOPED_NAME;
  
  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        _TAO_Coffee_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Fixed_Struct &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.l) &&
    (strm << ::ACE_OutputCDR::from_char (_tao_aggregate.c)) &&
    (strm << _tao_aggregate.s) &&
    (strm << ::ACE_OutputCDR::from_octet (_tao_aggregate.o)) &&
    (strm << _tao_aggregate.f) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.b)) &&
    (strm << _tao_aggregate.d);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Fixed_Struct &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.l) &&
    (strm >> ::ACE_InputCDR::to_char (_tao_aggregate.c)) &&
    (strm >> _tao_aggregate.s) &&
    (strm >> ::ACE_InputCDR::to_octet (_tao_aggregate.o)) &&
    (strm >> _tao_aggregate.f) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.b)) &&
    (strm >> _tao_aggregate.d);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::NameComponent &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.id.in ()) &&
    (strm << _tao_aggregate.kind.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::NameComponent &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.id.out ()) &&
    (strm >> _tao_aggregate.kind.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Step &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.name) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.process));
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Step &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.name) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.process));
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_PathSpec_CPP_
#define _TAO_CDR_OP_Param_Test_PathSpec_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Param_Test::Step> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Param_Test::Step> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Param_Test::Step * tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_PathSpec_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Bounded_Short_Seq_CPP_
#define _TAO_CDR_OP_Param_Test_Bounded_Short_Seq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<CORBA::Short> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<CORBA::Short> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  CORBA::Short tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Bounded_Short_Seq_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Bounded_Long_Seq_CPP_
#define _TAO_CDR_OP_Param_Test_Bounded_Long_Seq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<CORBA::Long> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<CORBA::Long> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  CORBA::Long tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Bounded_Long_Seq_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Bounded_StrSeq_CPP_
#define _TAO_CDR_OP_Param_Test_Bounded_StrSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<char *> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<char *> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  char * * tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Bounded_StrSeq_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Bounded_WStrSeq_CPP_
#define _TAO_CDR_OP_Param_Test_Bounded_WStrSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<CORBA::WChar *> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<CORBA::WChar *> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  CORBA::WChar * * tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Bounded_WStrSeq_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_StructSeq_CPP_
#define _TAO_CDR_OP_Param_Test_StructSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Param_Test::Fixed_Struct> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Param_Test::Fixed_Struct> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Param_Test::Fixed_Struct tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_StructSeq_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Bounded_StructSeq_CPP_
#define _TAO_CDR_OP_Param_Test_Bounded_StructSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Param_Test::Fixed_Struct> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Param_Test::Fixed_Struct> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Param_Test::Fixed_Struct tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Bounded_StructSeq_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Coffee_Mix_CPP_
#define _TAO_CDR_OP_Param_Test_Coffee_Mix_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Coffee> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Coffee> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Coffee * tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Coffee_Mix_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Bounded_Coffee_Mix_CPP_
#define _TAO_CDR_OP_Param_Test_Bounded_Coffee_Mix_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Coffee> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Coffee> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Coffee * tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Bounded_Coffee_Mix_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Var_Struct &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.dbl) &&
    (strm << _tao_aggregate.dummy1.in ()) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.boole)) &&
    (strm << _tao_aggregate.dummy2.in ()) &&
    (strm << _tao_aggregate.shrt) &&
    (strm << _tao_aggregate.seq);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Var_Struct &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.dbl) &&
    (strm >> _tao_aggregate.dummy1.out ()) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.boole)) &&
    (strm >> _tao_aggregate.dummy2.out ()) &&
    (strm >> _tao_aggregate.shrt) &&
    (strm >> _tao_aggregate.seq);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Nested_Struct &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.vs);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Nested_Struct &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.vs);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Objref_Struct &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.x) &&
    ::CORBA::Object::marshal (
        _tao_aggregate.y.in (),
        strm
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Objref_Struct &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.x) &&
    (strm >> _tao_aggregate.y.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_array/cdr_op_cs.cpp:178


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Fixed_Array_forany &_tao_array
  )
{
  return
    strm.write_long_array (
        reinterpret_cast <const ACE_CDR::Long *> (_tao_array.in ()),
        10
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Fixed_Array_forany &_tao_array
  )
{
  return
    strm.read_long_array (
        reinterpret_cast <ACE_CDR::Long *> (_tao_array.out ()),
        10
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_array/cdr_op_cs.cpp:178


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Var_Array_forany &_tao_array
  )
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 5 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0].in ());
    }
  
  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Var_Array_forany &_tao_array
  )
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 5 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0].out ());
    }
  
  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_ArraySeq_CPP_
#define _TAO_CDR_OP_Param_Test_ArraySeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Param_Test::Fixed_Array> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Param_Test::Fixed_Array> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Param_Test::Fixed_Array tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_ArraySeq_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Bounded_ArraySeq_CPP_
#define _TAO_CDR_OP_Param_Test_Bounded_ArraySeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Param_Test::Fixed_Array> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Param_Test::Fixed_Array> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Param_Test::Fixed_Array tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Bounded_ArraySeq_CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:60
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Ooops &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.reason.in ()) &&
        (strm << _tao_aggregate.input)
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Ooops &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.reason.out ()) &&
    (strm >> _tao_aggregate.input)
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_exception/cdr_op_cs.cpp:60
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::BadBoy &_tao_aggregate
  )
{
  // Marshal the repository ID.
  return (strm << _tao_aggregate._rep_id ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &,
    Param_Test::BadBoy&
  )
{
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_array/cdr_op_cs.cpp:178


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Big_Union::_another_array_forany &_tao_array
  )
{
  return
    strm.write_short_array (
        reinterpret_cast <const ACE_CDR::Short *> (_tao_array.in ()),
        32
      );
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Big_Union::_another_array_forany &_tao_array
  )
{
  return
    strm.read_short_array (
        reinterpret_cast <ACE_CDR::Short *> (_tao_array.out ()),
        32
      );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_union/cdr_op_cs.cpp:67


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Big_Union &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_union._d ())
  {
    case 0:
      {
        Param_Test::Fixed_Array_forany _tao_union_tmp (
            _tao_union.the_array ()
          );
        result = strm << _tao_union_tmp;
      }
      break;
    case 1:
      {
        result =
          TAO::Objref_Traits<Coffee>::marshal (
              _tao_union.the_interface (),
              strm
            );
      }
      break;
    case 2:
      {
        result = strm << _tao_union.the_long ();
      }
      break;
    case 3:
      {
        Param_Test::Big_Union::_another_array_forany _tao_union_tmp (
            _tao_union.another_array ()
          );
        result = strm << _tao_union_tmp;
      }
      break;
    case 4:
      {
        result = strm << _tao_union.the_string ();
      }
      break;
    case 5:
      {
        result = strm << _tao_union.the_sequence ();
      }
      break;
    case 6:
      {
        result = strm << _tao_union.the_any ();
      }
      break;
    case 7:
      {
        result = strm << ::ACE_OutputCDR::from_octet (_tao_union.the_octet ());
      }
      break;
    case 8:
      {
        result = strm << ::ACE_OutputCDR::from_char (_tao_union.the_char ());
      }
      break;
    case 9:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.the_boolean ());
      }
      break;
    case 10:
      {
        result = strm << _tao_union.the_var_struct ();
      }
      break;
    case 11:
      {
        result = strm << _tao_union.the_fixed_struct ();
      }
      break;
    default:
      break;
  }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Big_Union &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_discriminant)
  {
    case 0:
      {
        Param_Test::Fixed_Array _tao_union_tmp;
        Param_Test::Fixed_Array_forany _tao_union_helper (
            _tao_union_tmp
          );
        result = strm >> _tao_union_helper;
        
        if (result)
          {
            _tao_union.the_array (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        Coffee_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.inout ();
        
        if (result)
          {
            _tao_union.the_interface (_tao_union_tmp.in ());
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.the_long (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 3:
      {
        Param_Test::Big_Union::_another_array _tao_union_tmp;
        Param_Test::Big_Union::_another_array_forany _tao_union_helper (
            _tao_union_tmp
          );
        result = strm >> _tao_union_helper;
        
        if (result)
          {
            _tao_union.another_array (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 4:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.out ();
        
        if (result)
          {
            _tao_union.the_string (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 5:
      {
        CORBA::ShortSeq _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.the_sequence (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 6:
      {
        CORBA::Any _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.the_any (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 7:
      {
        ::CORBA::Octet _tao_union_tmp;
        ::ACE_InputCDR::to_octet _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;
        
        if (result)
          {
            _tao_union.the_octet (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 8:
      {
        ::CORBA::Char _tao_union_tmp;
        ::ACE_InputCDR::to_char _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;
        
        if (result)
          {
            _tao_union.the_char (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 9:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;
        
        if (result)
          {
            _tao_union.the_boolean (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 10:
      {
        Param_Test::Var_Struct _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.the_var_struct (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 11:
      {
        Param_Test::Fixed_Struct _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.the_fixed_struct (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._d (_tao_discriminant);
      break;
  }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_enum/cdr_op_cs.cpp:51


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, Param_Test::Small_Union_Switch _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, Param_Test::Small_Union_Switch & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<Param_Test::Small_Union_Switch> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_union/cdr_op_cs.cpp:67


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Small_Union &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_union._d ())
  {
    case Param_Test::A_LONG:
      {
        result = strm << _tao_union.the_long ();
      }
      break;
    case Param_Test::A_SHORT:
      {
        result = strm << _tao_union.the_short ();
      }
      break;
  }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Small_Union &_tao_union
  )
{
  Param_Test::Small_Union_Switch _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_discriminant)
  {
    case Param_Test::A_LONG:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.the_long (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case Param_Test::A_SHORT:
      {
        CORBA::Short _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.the_short (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::level4 &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.level5_string.in ()) &&
    (strm << _tao_aggregate.level5_any);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::level4 &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.level5_string.out ()) &&
    (strm >> _tao_aggregate.level5_any);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::level8 &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.level9_string.in ()) &&
    (strm << ::ACE_OutputCDR::from_boolean (_tao_aggregate.level9_boolean)) &&
    (strm << _tao_aggregate.level9_short);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::level8 &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.level9_string.out ()) &&
    (strm >> ::ACE_InputCDR::to_boolean (_tao_aggregate.level9_boolean)) &&
    (strm >> _tao_aggregate.level9_short);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__CPP_
#define _TAO_CDR_OP_Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Param_Test::Recursive_Struct> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Param_Test::Recursive_Struct> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Param_Test::Recursive_Struct * tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Recursive_Struct__tao_seq_Param_Test_Recursive_Struct__CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Recursive_Struct &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.x) &&
    (strm << _tao_aggregate.children);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Recursive_Struct &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.x) &&
    (strm >> _tao_aggregate.children);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__CPP_
#define _TAO_CDR_OP_Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Param_Test::nested_rec_union> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Param_Test::nested_rec_union> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Param_Test::nested_rec_union * tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_nested_rec_union__tao_seq_Param_Test_nested_rec_union__CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_union/cdr_op_cs.cpp:67


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::nested_rec_union &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.value ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.nested_rec_member ();
      }
      break;
    default:
      break;
  }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::nested_rec_union &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_discriminant)
  {
    case 0:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.value (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        Param_Test::nested_rec_union::_tao_seq_Param_Test_nested_rec_union_ _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.nested_rec_member (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._d (_tao_discriminant);
      break;
  }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__CPP_
#define _TAO_CDR_OP_Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
  TAO_OutputCDR &strm,
  const std::vector<Param_Test::Recursive_Union> &_tao_vector)
{
  ::CORBA::ULong length = _tao_vector.size ();
  strm << length;
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm << _tao_vector[i]))
        {
          return false;
        }
    }
  
  return true;
}

::CORBA::Boolean operator>> (
  TAO_InputCDR &strm,
  std::vector<Param_Test::Recursive_Union> &_tao_vector)
{
  ::CORBA::ULong length = 0UL;
  Param_Test::Recursive_Union * tmp;
  
  if (! (strm >> length))
    {
      return false;
    }
  
  for ( ::CORBA::ULong i = 0UL; i < length; ++i)
    {
      if (! (strm >> tmp))
        {
          return false;
        }
      
      _tao_vector[i] = tmp;
    }
  
  return true;
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Param_Test_Recursive_Union__tao_seq_Param_Test_Recursive_Union__CPP_ */

// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_union/cdr_op_cs.cpp:67


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Recursive_Union &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.rec_member ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.nested_member ();
      }
      break;
    default:
      break;
  }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Recursive_Union &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_discriminant)
  {
    case 0:
      {
        Param_Test::Recursive_Union::_tao_seq_Param_Test_Recursive_Union_ _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.rec_member (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        Param_Test::nested_rec_union _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.nested_member (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
        
      }
      break;
    default:
      _tao_union._d (_tao_discriminant);
      break;
  }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_array/cdr_op_cs.cpp:178


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test::Multdim_Array_forany &_tao_array
  )
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 5 && _tao_marshal_flag; ++i0)
    {
      for ( ::CORBA::ULong i1 = 0; i1 < 3 && _tao_marshal_flag; ++i1)
        {
          Param_Test::Fixed_Array_var tmp_var (Param_Test::Fixed_Array_dup (_tao_array[i0][i1]));
          Param_Test::Fixed_Array_forany tmp (tmp_var.inout ());
          _tao_marshal_flag = (strm << tmp);
        }
    }
  
  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test::Multdim_Array_forany &_tao_array
  )
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 5 && _tao_marshal_flag; ++i0)
    {
      for ( ::CORBA::ULong i1 = 0; i1 < 3 && _tao_marshal_flag; ++i1)
        {
          Param_Test::Fixed_Array_forany tmp (Param_Test::Fixed_Array_alloc ());
          _tao_marshal_flag = (strm >> tmp);
          Param_Test::Fixed_Array_copy (_tao_array[i0][i1], tmp.in ());
          Param_Test::Fixed_Array_free (tmp.inout ());
        }
    }
  
  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// w:\tao\tao_idl\be\be_visitor_interface/cdr_op_cs.cpp:63

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Param_Test_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Param_Test_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;
  
  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::Param_Test RHS_SCOPED_NAME;
  
  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        _TAO_Param_Test_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



