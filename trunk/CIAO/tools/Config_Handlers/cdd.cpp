/* $Id$
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 *
 * If you find errors or feel that there are bugfixes to be made,
 * please contact the current XSC maintainer:
 *             Will Otte <wotte@dre.vanderbilt.edu>
 */

// Fix for Borland compilers, which seem to have a broken
// <string> include.
#ifdef __BORLANDC__
# include <string.h>
#endif

#include "cdd.hpp"

// This file has no dependency on ACE, thus we turn 
// all ACE_OS checks off
// FUZZ: disable check_for_lack_ACE_OS

namespace CIAO
{
  namespace Config_Handlers
  {
    // Domain
    // 

    Domain::
    Domain ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    Domain::
    Domain (::CIAO::Config_Handlers::Domain const& s)
    :
    ::XSCRT::Type (),
    UUID_ (s.UUID_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.UUID_) : 0),
    label_ (s.label_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.label_) : 0),
    regulator__ ()
    {
      if (UUID_.get ()) UUID_->container (this);
      if (label_.get ()) label_->container (this);
      {
        for (node_const_iterator i (s.node_.begin ());i != s.node_.end ();++i) add_node (*i);
      }

      {
        for (interconnect_const_iterator i (s.interconnect_.begin ());i != s.interconnect_.end ();++i) add_interconnect (*i);
      }

      {
        for (bridge_const_iterator i (s.bridge_.begin ());i != s.bridge_.end ();++i) add_bridge (*i);
      }

      {
        for (sharedResource_const_iterator i (s.sharedResource_.begin ());i != s.sharedResource_.end ();++i) add_sharedResource (*i);
      }

      {
        for (infoProperty_const_iterator i (s.infoProperty_.begin ());i != s.infoProperty_.end ();++i) add_infoProperty (*i);
      }
    }

    ::CIAO::Config_Handlers::Domain& Domain::
    operator= (::CIAO::Config_Handlers::Domain const& s)
    {
      if (s.UUID_.get ()) UUID (*(s.UUID_));
      else UUID_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (0);

      if (s.label_.get ()) label (*(s.label_));
      else label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (0);

      node_.clear ();
      {
        for (node_const_iterator i (s.node_.begin ());i != s.node_.end ();++i) add_node (*i);
      }

      interconnect_.clear ();
      {
        for (interconnect_const_iterator i (s.interconnect_.begin ());i != s.interconnect_.end ();++i) add_interconnect (*i);
      }

      bridge_.clear ();
      {
        for (bridge_const_iterator i (s.bridge_.begin ());i != s.bridge_.end ();++i) add_bridge (*i);
      }

      sharedResource_.clear ();
      {
        for (sharedResource_const_iterator i (s.sharedResource_.begin ());i != s.sharedResource_.end ();++i) add_sharedResource (*i);
      }

      infoProperty_.clear ();
      {
        for (infoProperty_const_iterator i (s.infoProperty_.begin ());i != s.infoProperty_.end ();++i) add_infoProperty (*i);
      }

      return *this;
    }


    // Domain
    // 
    bool Domain::
    UUID_p () const
    {
      return UUID_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Domain::
    UUID () const
    {
      return *UUID_;
    }

    void Domain::
    UUID (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (UUID_.get ())
      {
        *UUID_ = e;
      }

      else
      {
        UUID_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        UUID_->container (this);
      }
    }

    // Domain
    // 
    bool Domain::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Domain::
    label () const
    {
      return *label_;
    }

    void Domain::
    label (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        label_->container (this);
      }
    }

    // Domain
    // 
    Domain::node_iterator Domain::
    begin_node ()
    {
      return node_.begin ();
    }

    Domain::node_iterator Domain::
    end_node ()
    {
      return node_.end ();
    }

    Domain::node_const_iterator Domain::
    begin_node () const
    {
      return node_.begin ();
    }

    Domain::node_const_iterator Domain::
    end_node () const
    {
      return node_.end ();
    }

    void Domain::
    add_node (::CIAO::Config_Handlers::Node const& e)
    {
      node_.push_back (e);
    }

    size_t Domain::
    count_node(void) const
    {
      return node_.size ();
    }

    // Domain
    // 
    Domain::interconnect_iterator Domain::
    begin_interconnect ()
    {
      return interconnect_.begin ();
    }

    Domain::interconnect_iterator Domain::
    end_interconnect ()
    {
      return interconnect_.end ();
    }

    Domain::interconnect_const_iterator Domain::
    begin_interconnect () const
    {
      return interconnect_.begin ();
    }

    Domain::interconnect_const_iterator Domain::
    end_interconnect () const
    {
      return interconnect_.end ();
    }

    void Domain::
    add_interconnect (::CIAO::Config_Handlers::Interconnect const& e)
    {
      interconnect_.push_back (e);
    }

    size_t Domain::
    count_interconnect(void) const
    {
      return interconnect_.size ();
    }

    // Domain
    // 
    Domain::bridge_iterator Domain::
    begin_bridge ()
    {
      return bridge_.begin ();
    }

    Domain::bridge_iterator Domain::
    end_bridge ()
    {
      return bridge_.end ();
    }

    Domain::bridge_const_iterator Domain::
    begin_bridge () const
    {
      return bridge_.begin ();
    }

    Domain::bridge_const_iterator Domain::
    end_bridge () const
    {
      return bridge_.end ();
    }

    void Domain::
    add_bridge (::CIAO::Config_Handlers::Bridge const& e)
    {
      bridge_.push_back (e);
    }

    size_t Domain::
    count_bridge(void) const
    {
      return bridge_.size ();
    }

    // Domain
    // 
    Domain::sharedResource_iterator Domain::
    begin_sharedResource ()
    {
      return sharedResource_.begin ();
    }

    Domain::sharedResource_iterator Domain::
    end_sharedResource ()
    {
      return sharedResource_.end ();
    }

    Domain::sharedResource_const_iterator Domain::
    begin_sharedResource () const
    {
      return sharedResource_.begin ();
    }

    Domain::sharedResource_const_iterator Domain::
    end_sharedResource () const
    {
      return sharedResource_.end ();
    }

    void Domain::
    add_sharedResource (::CIAO::Config_Handlers::SharedResource const& e)
    {
      sharedResource_.push_back (e);
    }

    size_t Domain::
    count_sharedResource(void) const
    {
      return sharedResource_.size ();
    }

    // Domain
    // 
    Domain::infoProperty_iterator Domain::
    begin_infoProperty ()
    {
      return infoProperty_.begin ();
    }

    Domain::infoProperty_iterator Domain::
    end_infoProperty ()
    {
      return infoProperty_.end ();
    }

    Domain::infoProperty_const_iterator Domain::
    begin_infoProperty () const
    {
      return infoProperty_.begin ();
    }

    Domain::infoProperty_const_iterator Domain::
    end_infoProperty () const
    {
      return infoProperty_.end ();
    }

    void Domain::
    add_infoProperty (::CIAO::Config_Handlers::Property const& e)
    {
      infoProperty_.push_back (e);
    }

    size_t Domain::
    count_infoProperty(void) const
    {
      return infoProperty_.size ();
    }


    // Bridge
    // 

    Bridge::
    Bridge (::XMLSchema::string< ACE_TCHAR > const& name__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      name_->container (this);
    }

    Bridge::
    Bridge (::CIAO::Config_Handlers::Bridge const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    label_ (s.label_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.label_) : 0),
    regulator__ ()
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
      {
        for (connect_const_iterator i (s.connect_.begin ());i != s.connect_.end ();++i) add_connect (*i);
      }

      {
        for (resource_const_iterator i (s.resource_.begin ());i != s.resource_.end ();++i) add_resource (*i);
      }
    }

    ::CIAO::Config_Handlers::Bridge& Bridge::
    operator= (::CIAO::Config_Handlers::Bridge const& s)
    {
      name (s.name ());

      if (s.label_.get ()) label (*(s.label_));
      else label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (0);

      connect_.clear ();
      {
        for (connect_const_iterator i (s.connect_.begin ());i != s.connect_.end ();++i) add_connect (*i);
      }

      resource_.clear ();
      {
        for (resource_const_iterator i (s.resource_.begin ());i != s.resource_.end ();++i) add_resource (*i);
      }

      return *this;
    }


    // Bridge
    // 
    ::XMLSchema::string< ACE_TCHAR > const& Bridge::
    name () const
    {
      return *name_;
    }

    void Bridge::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Bridge
    // 
    bool Bridge::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Bridge::
    label () const
    {
      return *label_;
    }

    void Bridge::
    label (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        label_->container (this);
      }
    }

    // Bridge
    // 
    Bridge::connect_iterator Bridge::
    begin_connect ()
    {
      return connect_.begin ();
    }

    Bridge::connect_iterator Bridge::
    end_connect ()
    {
      return connect_.end ();
    }

    Bridge::connect_const_iterator Bridge::
    begin_connect () const
    {
      return connect_.begin ();
    }

    Bridge::connect_const_iterator Bridge::
    end_connect () const
    {
      return connect_.end ();
    }

    void Bridge::
    add_connect (::CIAO::Config_Handlers::Interconnect const& e)
    {
      connect_.push_back (e);
    }

    size_t Bridge::
    count_connect(void) const
    {
      return connect_.size ();
    }

    // Bridge
    // 
    Bridge::resource_iterator Bridge::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Bridge::resource_iterator Bridge::
    end_resource ()
    {
      return resource_.end ();
    }

    Bridge::resource_const_iterator Bridge::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Bridge::resource_const_iterator Bridge::
    end_resource () const
    {
      return resource_.end ();
    }

    void Bridge::
    add_resource (::CIAO::Config_Handlers::Resource const& e)
    {
      resource_.push_back (e);
    }

    size_t Bridge::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // Interconnect
    // 

    Interconnect::
    Interconnect (::XMLSchema::string< ACE_TCHAR > const& name__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      name_->container (this);
    }

    Interconnect::
    Interconnect (::CIAO::Config_Handlers::Interconnect const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    label_ (s.label_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.label_) : 0),
    regulator__ ()
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
      {
        for (connection_const_iterator i (s.connection_.begin ());i != s.connection_.end ();++i) add_connection (*i);
      }

      {
        for (connect_const_iterator i (s.connect_.begin ());i != s.connect_.end ();++i) add_connect (*i);
      }

      {
        for (resource_const_iterator i (s.resource_.begin ());i != s.resource_.end ();++i) add_resource (*i);
      }
    }

    ::CIAO::Config_Handlers::Interconnect& Interconnect::
    operator= (::CIAO::Config_Handlers::Interconnect const& s)
    {
      name (s.name ());

      if (s.label_.get ()) label (*(s.label_));
      else label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (0);

      connection_.clear ();
      {
        for (connection_const_iterator i (s.connection_.begin ());i != s.connection_.end ();++i) add_connection (*i);
      }

      connect_.clear ();
      {
        for (connect_const_iterator i (s.connect_.begin ());i != s.connect_.end ();++i) add_connect (*i);
      }

      resource_.clear ();
      {
        for (resource_const_iterator i (s.resource_.begin ());i != s.resource_.end ();++i) add_resource (*i);
      }

      return *this;
    }


    // Interconnect
    // 
    ::XMLSchema::string< ACE_TCHAR > const& Interconnect::
    name () const
    {
      return *name_;
    }

    void Interconnect::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Interconnect
    // 
    bool Interconnect::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Interconnect::
    label () const
    {
      return *label_;
    }

    void Interconnect::
    label (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        label_->container (this);
      }
    }

    // Interconnect
    // 
    Interconnect::connection_iterator Interconnect::
    begin_connection ()
    {
      return connection_.begin ();
    }

    Interconnect::connection_iterator Interconnect::
    end_connection ()
    {
      return connection_.end ();
    }

    Interconnect::connection_const_iterator Interconnect::
    begin_connection () const
    {
      return connection_.begin ();
    }

    Interconnect::connection_const_iterator Interconnect::
    end_connection () const
    {
      return connection_.end ();
    }

    void Interconnect::
    add_connection (::CIAO::Config_Handlers::Bridge const& e)
    {
      connection_.push_back (e);
    }

    size_t Interconnect::
    count_connection(void) const
    {
      return connection_.size ();
    }

    // Interconnect
    // 
    Interconnect::connect_iterator Interconnect::
    begin_connect ()
    {
      return connect_.begin ();
    }

    Interconnect::connect_iterator Interconnect::
    end_connect ()
    {
      return connect_.end ();
    }

    Interconnect::connect_const_iterator Interconnect::
    begin_connect () const
    {
      return connect_.begin ();
    }

    Interconnect::connect_const_iterator Interconnect::
    end_connect () const
    {
      return connect_.end ();
    }

    void Interconnect::
    add_connect (::CIAO::Config_Handlers::Node const& e)
    {
      connect_.push_back (e);
    }

    size_t Interconnect::
    count_connect(void) const
    {
      return connect_.size ();
    }

    // Interconnect
    // 
    Interconnect::resource_iterator Interconnect::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Interconnect::resource_iterator Interconnect::
    end_resource ()
    {
      return resource_.end ();
    }

    Interconnect::resource_const_iterator Interconnect::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Interconnect::resource_const_iterator Interconnect::
    end_resource () const
    {
      return resource_.end ();
    }

    void Interconnect::
    add_resource (::CIAO::Config_Handlers::Resource const& e)
    {
      resource_.push_back (e);
    }

    size_t Interconnect::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // Node
    // 

    Node::
    Node (::XMLSchema::string< ACE_TCHAR > const& name__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    regulator__ ()
    {
      name_->container (this);
    }

    Node::
    Node (::CIAO::Config_Handlers::Node const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    label_ (s.label_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.label_) : 0),
    regulator__ ()
    {
      name_->container (this);
      if (label_.get ()) label_->container (this);
      {
        for (connection_const_iterator i (s.connection_.begin ());i != s.connection_.end ();++i) add_connection (*i);
      }

      {
        for (sharedResource_const_iterator i (s.sharedResource_.begin ());i != s.sharedResource_.end ();++i) add_sharedResource (*i);
      }

      {
        for (resource_const_iterator i (s.resource_.begin ());i != s.resource_.end ();++i) add_resource (*i);
      }
    }

    ::CIAO::Config_Handlers::Node& Node::
    operator= (::CIAO::Config_Handlers::Node const& s)
    {
      name (s.name ());

      if (s.label_.get ()) label (*(s.label_));
      else label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (0);

      connection_.clear ();
      {
        for (connection_const_iterator i (s.connection_.begin ());i != s.connection_.end ();++i) add_connection (*i);
      }

      sharedResource_.clear ();
      {
        for (sharedResource_const_iterator i (s.sharedResource_.begin ());i != s.sharedResource_.end ();++i) add_sharedResource (*i);
      }

      resource_.clear ();
      {
        for (resource_const_iterator i (s.resource_.begin ());i != s.resource_.end ();++i) add_resource (*i);
      }

      return *this;
    }


    // Node
    // 
    ::XMLSchema::string< ACE_TCHAR > const& Node::
    name () const
    {
      return *name_;
    }

    void Node::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // Node
    // 
    bool Node::
    label_p () const
    {
      return label_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& Node::
    label () const
    {
      return *label_;
    }

    void Node::
    label (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (label_.get ())
      {
        *label_ = e;
      }

      else
      {
        label_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        label_->container (this);
      }
    }

    // Node
    // 
    Node::connection_iterator Node::
    begin_connection ()
    {
      return connection_.begin ();
    }

    Node::connection_iterator Node::
    end_connection ()
    {
      return connection_.end ();
    }

    Node::connection_const_iterator Node::
    begin_connection () const
    {
      return connection_.begin ();
    }

    Node::connection_const_iterator Node::
    end_connection () const
    {
      return connection_.end ();
    }

    void Node::
    add_connection (::CIAO::Config_Handlers::Interconnect const& e)
    {
      connection_.push_back (e);
    }

    size_t Node::
    count_connection(void) const
    {
      return connection_.size ();
    }

    // Node
    // 
    Node::sharedResource_iterator Node::
    begin_sharedResource ()
    {
      return sharedResource_.begin ();
    }

    Node::sharedResource_iterator Node::
    end_sharedResource ()
    {
      return sharedResource_.end ();
    }

    Node::sharedResource_const_iterator Node::
    begin_sharedResource () const
    {
      return sharedResource_.begin ();
    }

    Node::sharedResource_const_iterator Node::
    end_sharedResource () const
    {
      return sharedResource_.end ();
    }

    void Node::
    add_sharedResource (::CIAO::Config_Handlers::SharedResource const& e)
    {
      sharedResource_.push_back (e);
    }

    size_t Node::
    count_sharedResource(void) const
    {
      return sharedResource_.size ();
    }

    // Node
    // 
    Node::resource_iterator Node::
    begin_resource ()
    {
      return resource_.begin ();
    }

    Node::resource_iterator Node::
    end_resource ()
    {
      return resource_.end ();
    }

    Node::resource_const_iterator Node::
    begin_resource () const
    {
      return resource_.begin ();
    }

    Node::resource_const_iterator Node::
    end_resource () const
    {
      return resource_.end ();
    }

    void Node::
    add_resource (::CIAO::Config_Handlers::Resource const& e)
    {
      resource_.push_back (e);
    }

    size_t Node::
    count_resource(void) const
    {
      return resource_.size ();
    }


    // SharedResource
    // 

    SharedResource::
    SharedResource (::XMLSchema::string< ACE_TCHAR > const& name__,
                    ::XMLSchema::string< ACE_TCHAR > const& resourceType__,
                    ::CIAO::Config_Handlers::Node const& node__,
                    ::CIAO::Config_Handlers::SatisfierProperty const& property__)
    : 
    ::XSCRT::Type (), 
    name_ (new ::XMLSchema::string< ACE_TCHAR > (name__)),
    resourceType_ (new ::XMLSchema::string< ACE_TCHAR > (resourceType__)),
    node_ (new ::CIAO::Config_Handlers::Node (node__)),
    property_ (new ::CIAO::Config_Handlers::SatisfierProperty (property__)),
    regulator__ ()
    {
      name_->container (this);
      resourceType_->container (this);
      node_->container (this);
      property_->container (this);
    }

    SharedResource::
    SharedResource (::CIAO::Config_Handlers::SharedResource const& s)
    :
    ::XSCRT::Type (),
    name_ (new ::XMLSchema::string< ACE_TCHAR > (*s.name_)),
    resourceType_ (new ::XMLSchema::string< ACE_TCHAR > (*s.resourceType_)),
    node_ (new ::CIAO::Config_Handlers::Node (*s.node_)),
    property_ (new ::CIAO::Config_Handlers::SatisfierProperty (*s.property_)),
    regulator__ ()
    {
      name_->container (this);
      resourceType_->container (this);
      node_->container (this);
      property_->container (this);
    }

    ::CIAO::Config_Handlers::SharedResource& SharedResource::
    operator= (::CIAO::Config_Handlers::SharedResource const& s)
    {
      name (s.name ());

      resourceType (s.resourceType ());

      node (s.node ());

      property (s.property ());

      return *this;
    }


    // SharedResource
    // 
    ::XMLSchema::string< ACE_TCHAR > const& SharedResource::
    name () const
    {
      return *name_;
    }

    void SharedResource::
    name (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *name_ = e;
    }

    // SharedResource
    // 
    ::XMLSchema::string< ACE_TCHAR > const& SharedResource::
    resourceType () const
    {
      return *resourceType_;
    }

    void SharedResource::
    resourceType (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      *resourceType_ = e;
    }

    // SharedResource
    // 
    ::CIAO::Config_Handlers::Node const& SharedResource::
    node () const
    {
      return *node_;
    }

    void SharedResource::
    node (::CIAO::Config_Handlers::Node const& e)
    {
      *node_ = e;
    }

    // SharedResource
    // 
    ::CIAO::Config_Handlers::SatisfierProperty const& SharedResource::
    property () const
    {
      return *property_;
    }

    void SharedResource::
    property (::CIAO::Config_Handlers::SatisfierProperty const& e)
    {
      *property_ = e;
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    // Domain
    //

    Domain::
    Domain (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "UUID")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          UUID (t);
        }

        else if (n == "label")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          label (t);
        }

        else if (n == "node")
        {
          ::CIAO::Config_Handlers::Node t (e);
          add_node (t);
        }

        else if (n == "interconnect")
        {
          ::CIAO::Config_Handlers::Interconnect t (e);
          add_interconnect (t);
        }

        else if (n == "bridge")
        {
          ::CIAO::Config_Handlers::Bridge t (e);
          add_bridge (t);
        }

        else if (n == "sharedResource")
        {
          ::CIAO::Config_Handlers::SharedResource t (e);
          add_sharedResource (t);
        }

        else if (n == "infoProperty")
        {
          ::CIAO::Config_Handlers::Property t (e);
          add_infoProperty (t);
        }

        else 
        {
        }
      }
    }

    // Bridge
    //

    Bridge::
    Bridge (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "label")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          label (t);
        }

        else if (n == "connect")
        {
          ::CIAO::Config_Handlers::Interconnect t (e);
          add_connect (t);
        }

        else if (n == "resource")
        {
          ::CIAO::Config_Handlers::Resource t (e);
          add_resource (t);
        }

        else 
        {
        }
      }
    }

    // Interconnect
    //

    Interconnect::
    Interconnect (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "label")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          label (t);
        }

        else if (n == "connection")
        {
          ::CIAO::Config_Handlers::Bridge t (e);
          add_connection (t);
        }

        else if (n == "connect")
        {
          ::CIAO::Config_Handlers::Node t (e);
          add_connect (t);
        }

        else if (n == "resource")
        {
          ::CIAO::Config_Handlers::Resource t (e);
          add_resource (t);
        }

        else 
        {
        }
      }
    }

    // Node
    //

    Node::
    Node (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "label")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          label (t);
        }

        else if (n == "connection")
        {
          ::CIAO::Config_Handlers::Interconnect t (e);
          add_connection (t);
        }

        else if (n == "sharedResource")
        {
          ::CIAO::Config_Handlers::SharedResource t (e);
          add_sharedResource (t);
        }

        else if (n == "resource")
        {
          ::CIAO::Config_Handlers::Resource t (e);
          add_resource (t);
        }

        else 
        {
        }
      }
    }

    // SharedResource
    //

    SharedResource::
    SharedResource (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "name")
        {
          name_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          name_->container (this);
        }

        else if (n == "resourceType")
        {
          resourceType_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
          resourceType_->container (this);
        }

        else if (n == "node")
        {
          node_ = ::std::auto_ptr< ::CIAO::Config_Handlers::Node > (new ::CIAO::Config_Handlers::Node (e));
          node_->container (this);
        }

        else if (n == "property")
        {
          property_ = ::std::auto_ptr< ::CIAO::Config_Handlers::SatisfierProperty > (new ::CIAO::Config_Handlers::SatisfierProperty (e));
          property_->container (this);
        }

        else 
        {
        }
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
  }
}

#include "XMLSchema/TypeInfo.hpp"

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace
    {
      ::XMLSchema::TypeInfoInitializer < ACE_TCHAR > XMLSchemaTypeInfoInitializer_ (::XSCRT::extended_type_info_map ());

      struct DomainTypeInfoInitializer
      {
        DomainTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (Domain));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      DomainTypeInfoInitializer DomainTypeInfoInitializer_;

      struct BridgeTypeInfoInitializer
      {
        BridgeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (Bridge));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      BridgeTypeInfoInitializer BridgeTypeInfoInitializer_;

      struct InterconnectTypeInfoInitializer
      {
        InterconnectTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (Interconnect));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      InterconnectTypeInfoInitializer InterconnectTypeInfoInitializer_;

      struct NodeTypeInfoInitializer
      {
        NodeTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (Node));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      NodeTypeInfoInitializer NodeTypeInfoInitializer_;

      struct SharedResourceTypeInfoInitializer
      {
        SharedResourceTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (SharedResource));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      SharedResourceTypeInfoInitializer SharedResourceTypeInfoInitializer_;
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace Traversal
    {
      // Domain
      //
      //

      void Domain::
      traverse (Type& o)
      {
        pre (o);
        if (o.UUID_p ()) UUID (o);
        else UUID_none (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        node (o);
        interconnect (o);
        bridge (o);
        sharedResource (o);
        infoProperty (o);
        post (o);
      }

      void Domain::
      traverse (Type const& o)
      {
        pre (o);
        if (o.UUID_p ()) UUID (o);
        else UUID_none (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        node (o);
        interconnect (o);
        bridge (o);
        sharedResource (o);
        infoProperty (o);
        post (o);
      }

      void Domain::
      pre (Type&)
      {
      }

      void Domain::
      pre (Type const&)
      {
      }

      void Domain::
      UUID (Type& o)
      {
        dispatch (o.UUID ());
      }

      void Domain::
      UUID (Type const& o)
      {
        dispatch (o.UUID ());
      }

      void Domain::
      UUID_none (Type&)
      {
      }

      void Domain::
      UUID_none (Type const&)
      {
      }

      void Domain::
      label (Type& o)
      {
        dispatch (o.label ());
      }

      void Domain::
      label (Type const& o)
      {
        dispatch (o.label ());
      }

      void Domain::
      label_none (Type&)
      {
      }

      void Domain::
      label_none (Type const&)
      {
      }

      void Domain::
      node (Type& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::node_iterator b (o.begin_node()), e (o.end_node());

        if (b != e)
        {
          node_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) node_next (o);
          }

          node_post (o);
        }
      }

      void Domain::
      node (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::node_const_iterator b (o.begin_node()), e (o.end_node());

        if (b != e)
        {
          node_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) node_next (o);
          }

          node_post (o);
        }
      }

      void Domain::
      node_pre (Type&)
      {
      }

      void Domain::
      node_pre (Type const&)
      {
      }

      void Domain::
      node_next (Type&)
      {
      }

      void Domain::
      node_next (Type const&)
      {
      }

      void Domain::
      node_post (Type&)
      {
      }

      void Domain::
      node_post (Type const&)
      {
      }

      void Domain::
      interconnect (Type& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::interconnect_iterator b (o.begin_interconnect()), e (o.end_interconnect());

        if (b != e)
        {
          interconnect_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) interconnect_next (o);
          }

          interconnect_post (o);
        }

        else interconnect_none (o);
      }

      void Domain::
      interconnect (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::interconnect_const_iterator b (o.begin_interconnect()), e (o.end_interconnect());

        if (b != e)
        {
          interconnect_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) interconnect_next (o);
          }

          interconnect_post (o);
        }

        else interconnect_none (o);
      }

      void Domain::
      interconnect_pre (Type&)
      {
      }

      void Domain::
      interconnect_pre (Type const&)
      {
      }

      void Domain::
      interconnect_next (Type&)
      {
      }

      void Domain::
      interconnect_next (Type const&)
      {
      }

      void Domain::
      interconnect_post (Type&)
      {
      }

      void Domain::
      interconnect_post (Type const&)
      {
      }

      void Domain::
      interconnect_none (Type&)
      {
      }

      void Domain::
      interconnect_none (Type const&)
      {
      }

      void Domain::
      bridge (Type& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::bridge_iterator b (o.begin_bridge()), e (o.end_bridge());

        if (b != e)
        {
          bridge_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) bridge_next (o);
          }

          bridge_post (o);
        }

        else bridge_none (o);
      }

      void Domain::
      bridge (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::bridge_const_iterator b (o.begin_bridge()), e (o.end_bridge());

        if (b != e)
        {
          bridge_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) bridge_next (o);
          }

          bridge_post (o);
        }

        else bridge_none (o);
      }

      void Domain::
      bridge_pre (Type&)
      {
      }

      void Domain::
      bridge_pre (Type const&)
      {
      }

      void Domain::
      bridge_next (Type&)
      {
      }

      void Domain::
      bridge_next (Type const&)
      {
      }

      void Domain::
      bridge_post (Type&)
      {
      }

      void Domain::
      bridge_post (Type const&)
      {
      }

      void Domain::
      bridge_none (Type&)
      {
      }

      void Domain::
      bridge_none (Type const&)
      {
      }

      void Domain::
      sharedResource (Type& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::sharedResource_iterator b (o.begin_sharedResource()), e (o.end_sharedResource());

        if (b != e)
        {
          sharedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) sharedResource_next (o);
          }

          sharedResource_post (o);
        }

        else sharedResource_none (o);
      }

      void Domain::
      sharedResource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::sharedResource_const_iterator b (o.begin_sharedResource()), e (o.end_sharedResource());

        if (b != e)
        {
          sharedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) sharedResource_next (o);
          }

          sharedResource_post (o);
        }

        else sharedResource_none (o);
      }

      void Domain::
      sharedResource_pre (Type&)
      {
      }

      void Domain::
      sharedResource_pre (Type const&)
      {
      }

      void Domain::
      sharedResource_next (Type&)
      {
      }

      void Domain::
      sharedResource_next (Type const&)
      {
      }

      void Domain::
      sharedResource_post (Type&)
      {
      }

      void Domain::
      sharedResource_post (Type const&)
      {
      }

      void Domain::
      sharedResource_none (Type&)
      {
      }

      void Domain::
      sharedResource_none (Type const&)
      {
      }

      void Domain::
      infoProperty (Type& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::infoProperty_iterator b (o.begin_infoProperty()), e (o.end_infoProperty());

        if (b != e)
        {
          infoProperty_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) infoProperty_next (o);
          }

          infoProperty_post (o);
        }

        else infoProperty_none (o);
      }

      void Domain::
      infoProperty (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Domain::Type::infoProperty_const_iterator b (o.begin_infoProperty()), e (o.end_infoProperty());

        if (b != e)
        {
          infoProperty_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) infoProperty_next (o);
          }

          infoProperty_post (o);
        }

        else infoProperty_none (o);
      }

      void Domain::
      infoProperty_pre (Type&)
      {
      }

      void Domain::
      infoProperty_pre (Type const&)
      {
      }

      void Domain::
      infoProperty_next (Type&)
      {
      }

      void Domain::
      infoProperty_next (Type const&)
      {
      }

      void Domain::
      infoProperty_post (Type&)
      {
      }

      void Domain::
      infoProperty_post (Type const&)
      {
      }

      void Domain::
      infoProperty_none (Type&)
      {
      }

      void Domain::
      infoProperty_none (Type const&)
      {
      }

      void Domain::
      post (Type&)
      {
      }

      void Domain::
      post (Type const&)
      {
      }

      // Bridge
      //
      //

      void Bridge::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connect (o);
        resource (o);
        post (o);
      }

      void Bridge::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connect (o);
        resource (o);
        post (o);
      }

      void Bridge::
      pre (Type&)
      {
      }

      void Bridge::
      pre (Type const&)
      {
      }

      void Bridge::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Bridge::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Bridge::
      label (Type& o)
      {
        dispatch (o.label ());
      }

      void Bridge::
      label (Type const& o)
      {
        dispatch (o.label ());
      }

      void Bridge::
      label_none (Type&)
      {
      }

      void Bridge::
      label_none (Type const&)
      {
      }

      void Bridge::
      connect (Type& o)
      {
        // VC6 anathema strikes again
        //
        Bridge::Type::connect_iterator b (o.begin_connect()), e (o.end_connect());

        if (b != e)
        {
          connect_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) connect_next (o);
          }

          connect_post (o);
        }
      }

      void Bridge::
      connect (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Bridge::Type::connect_const_iterator b (o.begin_connect()), e (o.end_connect());

        if (b != e)
        {
          connect_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) connect_next (o);
          }

          connect_post (o);
        }
      }

      void Bridge::
      connect_pre (Type&)
      {
      }

      void Bridge::
      connect_pre (Type const&)
      {
      }

      void Bridge::
      connect_next (Type&)
      {
      }

      void Bridge::
      connect_next (Type const&)
      {
      }

      void Bridge::
      connect_post (Type&)
      {
      }

      void Bridge::
      connect_post (Type const&)
      {
      }

      void Bridge::
      resource (Type& o)
      {
        // VC6 anathema strikes again
        //
        Bridge::Type::resource_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Bridge::
      resource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Bridge::Type::resource_const_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Bridge::
      resource_pre (Type&)
      {
      }

      void Bridge::
      resource_pre (Type const&)
      {
      }

      void Bridge::
      resource_next (Type&)
      {
      }

      void Bridge::
      resource_next (Type const&)
      {
      }

      void Bridge::
      resource_post (Type&)
      {
      }

      void Bridge::
      resource_post (Type const&)
      {
      }

      void Bridge::
      resource_none (Type&)
      {
      }

      void Bridge::
      resource_none (Type const&)
      {
      }

      void Bridge::
      post (Type&)
      {
      }

      void Bridge::
      post (Type const&)
      {
      }

      // Interconnect
      //
      //

      void Interconnect::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connection (o);
        connect (o);
        resource (o);
        post (o);
      }

      void Interconnect::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connection (o);
        connect (o);
        resource (o);
        post (o);
      }

      void Interconnect::
      pre (Type&)
      {
      }

      void Interconnect::
      pre (Type const&)
      {
      }

      void Interconnect::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Interconnect::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Interconnect::
      label (Type& o)
      {
        dispatch (o.label ());
      }

      void Interconnect::
      label (Type const& o)
      {
        dispatch (o.label ());
      }

      void Interconnect::
      label_none (Type&)
      {
      }

      void Interconnect::
      label_none (Type const&)
      {
      }

      void Interconnect::
      connection (Type& o)
      {
        // VC6 anathema strikes again
        //
        Interconnect::Type::connection_iterator b (o.begin_connection()), e (o.end_connection());

        if (b != e)
        {
          connection_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) connection_next (o);
          }

          connection_post (o);
        }

        else connection_none (o);
      }

      void Interconnect::
      connection (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Interconnect::Type::connection_const_iterator b (o.begin_connection()), e (o.end_connection());

        if (b != e)
        {
          connection_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) connection_next (o);
          }

          connection_post (o);
        }

        else connection_none (o);
      }

      void Interconnect::
      connection_pre (Type&)
      {
      }

      void Interconnect::
      connection_pre (Type const&)
      {
      }

      void Interconnect::
      connection_next (Type&)
      {
      }

      void Interconnect::
      connection_next (Type const&)
      {
      }

      void Interconnect::
      connection_post (Type&)
      {
      }

      void Interconnect::
      connection_post (Type const&)
      {
      }

      void Interconnect::
      connection_none (Type&)
      {
      }

      void Interconnect::
      connection_none (Type const&)
      {
      }

      void Interconnect::
      connect (Type& o)
      {
        // VC6 anathema strikes again
        //
        Interconnect::Type::connect_iterator b (o.begin_connect()), e (o.end_connect());

        if (b != e)
        {
          connect_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) connect_next (o);
          }

          connect_post (o);
        }
      }

      void Interconnect::
      connect (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Interconnect::Type::connect_const_iterator b (o.begin_connect()), e (o.end_connect());

        if (b != e)
        {
          connect_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) connect_next (o);
          }

          connect_post (o);
        }
      }

      void Interconnect::
      connect_pre (Type&)
      {
      }

      void Interconnect::
      connect_pre (Type const&)
      {
      }

      void Interconnect::
      connect_next (Type&)
      {
      }

      void Interconnect::
      connect_next (Type const&)
      {
      }

      void Interconnect::
      connect_post (Type&)
      {
      }

      void Interconnect::
      connect_post (Type const&)
      {
      }

      void Interconnect::
      resource (Type& o)
      {
        // VC6 anathema strikes again
        //
        Interconnect::Type::resource_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Interconnect::
      resource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Interconnect::Type::resource_const_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Interconnect::
      resource_pre (Type&)
      {
      }

      void Interconnect::
      resource_pre (Type const&)
      {
      }

      void Interconnect::
      resource_next (Type&)
      {
      }

      void Interconnect::
      resource_next (Type const&)
      {
      }

      void Interconnect::
      resource_post (Type&)
      {
      }

      void Interconnect::
      resource_post (Type const&)
      {
      }

      void Interconnect::
      resource_none (Type&)
      {
      }

      void Interconnect::
      resource_none (Type const&)
      {
      }

      void Interconnect::
      post (Type&)
      {
      }

      void Interconnect::
      post (Type const&)
      {
      }

      // Node
      //
      //

      void Node::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connection (o);
        sharedResource (o);
        resource (o);
        post (o);
      }

      void Node::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        if (o.label_p ()) label (o);
        else label_none (o);
        connection (o);
        sharedResource (o);
        resource (o);
        post (o);
      }

      void Node::
      pre (Type&)
      {
      }

      void Node::
      pre (Type const&)
      {
      }

      void Node::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void Node::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void Node::
      label (Type& o)
      {
        dispatch (o.label ());
      }

      void Node::
      label (Type const& o)
      {
        dispatch (o.label ());
      }

      void Node::
      label_none (Type&)
      {
      }

      void Node::
      label_none (Type const&)
      {
      }

      void Node::
      connection (Type& o)
      {
        // VC6 anathema strikes again
        //
        Node::Type::connection_iterator b (o.begin_connection()), e (o.end_connection());

        if (b != e)
        {
          connection_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) connection_next (o);
          }

          connection_post (o);
        }

        else connection_none (o);
      }

      void Node::
      connection (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Node::Type::connection_const_iterator b (o.begin_connection()), e (o.end_connection());

        if (b != e)
        {
          connection_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) connection_next (o);
          }

          connection_post (o);
        }

        else connection_none (o);
      }

      void Node::
      connection_pre (Type&)
      {
      }

      void Node::
      connection_pre (Type const&)
      {
      }

      void Node::
      connection_next (Type&)
      {
      }

      void Node::
      connection_next (Type const&)
      {
      }

      void Node::
      connection_post (Type&)
      {
      }

      void Node::
      connection_post (Type const&)
      {
      }

      void Node::
      connection_none (Type&)
      {
      }

      void Node::
      connection_none (Type const&)
      {
      }

      void Node::
      sharedResource (Type& o)
      {
        // VC6 anathema strikes again
        //
        Node::Type::sharedResource_iterator b (o.begin_sharedResource()), e (o.end_sharedResource());

        if (b != e)
        {
          sharedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) sharedResource_next (o);
          }

          sharedResource_post (o);
        }

        else sharedResource_none (o);
      }

      void Node::
      sharedResource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Node::Type::sharedResource_const_iterator b (o.begin_sharedResource()), e (o.end_sharedResource());

        if (b != e)
        {
          sharedResource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) sharedResource_next (o);
          }

          sharedResource_post (o);
        }

        else sharedResource_none (o);
      }

      void Node::
      sharedResource_pre (Type&)
      {
      }

      void Node::
      sharedResource_pre (Type const&)
      {
      }

      void Node::
      sharedResource_next (Type&)
      {
      }

      void Node::
      sharedResource_next (Type const&)
      {
      }

      void Node::
      sharedResource_post (Type&)
      {
      }

      void Node::
      sharedResource_post (Type const&)
      {
      }

      void Node::
      sharedResource_none (Type&)
      {
      }

      void Node::
      sharedResource_none (Type const&)
      {
      }

      void Node::
      resource (Type& o)
      {
        // VC6 anathema strikes again
        //
        Node::Type::resource_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Node::
      resource (Type const& o)
      {
        // VC6 anathema strikes again
        //
        Node::Type::resource_const_iterator b (o.begin_resource()), e (o.end_resource());

        if (b != e)
        {
          resource_pre (o);
          for (; b != e;)
          {
            dispatch (*b);
            if (++b != e) resource_next (o);
          }

          resource_post (o);
        }

        else resource_none (o);
      }

      void Node::
      resource_pre (Type&)
      {
      }

      void Node::
      resource_pre (Type const&)
      {
      }

      void Node::
      resource_next (Type&)
      {
      }

      void Node::
      resource_next (Type const&)
      {
      }

      void Node::
      resource_post (Type&)
      {
      }

      void Node::
      resource_post (Type const&)
      {
      }

      void Node::
      resource_none (Type&)
      {
      }

      void Node::
      resource_none (Type const&)
      {
      }

      void Node::
      post (Type&)
      {
      }

      void Node::
      post (Type const&)
      {
      }

      // SharedResource
      //
      //

      void SharedResource::
      traverse (Type& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        node (o);
        property (o);
        post (o);
      }

      void SharedResource::
      traverse (Type const& o)
      {
        pre (o);
        name (o);
        resourceType (o);
        node (o);
        property (o);
        post (o);
      }

      void SharedResource::
      pre (Type&)
      {
      }

      void SharedResource::
      pre (Type const&)
      {
      }

      void SharedResource::
      name (Type& o)
      {
        dispatch (o.name ());
      }

      void SharedResource::
      name (Type const& o)
      {
        dispatch (o.name ());
      }

      void SharedResource::
      resourceType (Type& o)
      {
        dispatch (o.resourceType ());
      }

      void SharedResource::
      resourceType (Type const& o)
      {
        dispatch (o.resourceType ());
      }

      void SharedResource::
      node (Type& o)
      {
        dispatch (o.node ());
      }

      void SharedResource::
      node (Type const& o)
      {
        dispatch (o.node ());
      }

      void SharedResource::
      property (Type& o)
      {
        dispatch (o.property ());
      }

      void SharedResource::
      property (Type const& o)
      {
        dispatch (o.property ());
      }

      void SharedResource::
      post (Type&)
      {
      }

      void SharedResource::
      post (Type const&)
      {
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace Writer
    {
      // Domain
      //
      //

      Domain::
      Domain (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Domain::
      Domain ()
      {
      }

      void Domain::
      traverse (Type const& o)
      {
        Traversal::Domain::traverse (o);
      }

      void Domain::
      UUID (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("UUID", top_ ()));
        Traversal::Domain::UUID (o);
        pop_ ();
      }

      void Domain::
      label (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("label", top_ ()));
        Traversal::Domain::label (o);
        pop_ ();
      }

      void Domain::
      node_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("node", top_ ()));
      }

      void Domain::
      node_next (Type const& o)
      {
        node_post (o);
        node_pre (o);
      }

      void Domain::
      node_post (Type const&)
      {
        pop_ ();
      }

      void Domain::
      interconnect_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("interconnect", top_ ()));
      }

      void Domain::
      interconnect_next (Type const& o)
      {
        interconnect_post (o);
        interconnect_pre (o);
      }

      void Domain::
      interconnect_post (Type const&)
      {
        pop_ ();
      }

      void Domain::
      bridge_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("bridge", top_ ()));
      }

      void Domain::
      bridge_next (Type const& o)
      {
        bridge_post (o);
        bridge_pre (o);
      }

      void Domain::
      bridge_post (Type const&)
      {
        pop_ ();
      }

      void Domain::
      sharedResource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("sharedResource", top_ ()));
      }

      void Domain::
      sharedResource_next (Type const& o)
      {
        sharedResource_post (o);
        sharedResource_pre (o);
      }

      void Domain::
      sharedResource_post (Type const&)
      {
        pop_ ();
      }

      void Domain::
      infoProperty_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("infoProperty", top_ ()));
      }

      void Domain::
      infoProperty_next (Type const& o)
      {
        infoProperty_post (o);
        infoProperty_pre (o);
      }

      void Domain::
      infoProperty_post (Type const&)
      {
        pop_ ();
      }

      // Bridge
      //
      //

      Bridge::
      Bridge (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Bridge::
      Bridge ()
      {
      }

      void Bridge::
      traverse (Type const& o)
      {
        Traversal::Bridge::traverse (o);
      }

      void Bridge::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::Bridge::name (o);
        pop_ ();
      }

      void Bridge::
      label (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("label", top_ ()));
        Traversal::Bridge::label (o);
        pop_ ();
      }

      void Bridge::
      connect_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("connect", top_ ()));
      }

      void Bridge::
      connect_next (Type const& o)
      {
        connect_post (o);
        connect_pre (o);
      }

      void Bridge::
      connect_post (Type const&)
      {
        pop_ ();
      }

      void Bridge::
      resource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("resource", top_ ()));
      }

      void Bridge::
      resource_next (Type const& o)
      {
        resource_post (o);
        resource_pre (o);
      }

      void Bridge::
      resource_post (Type const&)
      {
        pop_ ();
      }

      // Interconnect
      //
      //

      Interconnect::
      Interconnect (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Interconnect::
      Interconnect ()
      {
      }

      void Interconnect::
      traverse (Type const& o)
      {
        Traversal::Interconnect::traverse (o);
      }

      void Interconnect::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::Interconnect::name (o);
        pop_ ();
      }

      void Interconnect::
      label (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("label", top_ ()));
        Traversal::Interconnect::label (o);
        pop_ ();
      }

      void Interconnect::
      connection_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("connection", top_ ()));
      }

      void Interconnect::
      connection_next (Type const& o)
      {
        connection_post (o);
        connection_pre (o);
      }

      void Interconnect::
      connection_post (Type const&)
      {
        pop_ ();
      }

      void Interconnect::
      connect_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("connect", top_ ()));
      }

      void Interconnect::
      connect_next (Type const& o)
      {
        connect_post (o);
        connect_pre (o);
      }

      void Interconnect::
      connect_post (Type const&)
      {
        pop_ ();
      }

      void Interconnect::
      resource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("resource", top_ ()));
      }

      void Interconnect::
      resource_next (Type const& o)
      {
        resource_post (o);
        resource_pre (o);
      }

      void Interconnect::
      resource_post (Type const&)
      {
        pop_ ();
      }

      // Node
      //
      //

      Node::
      Node (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Node::
      Node ()
      {
      }

      void Node::
      traverse (Type const& o)
      {
        Traversal::Node::traverse (o);
      }

      void Node::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::Node::name (o);
        pop_ ();
      }

      void Node::
      label (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("label", top_ ()));
        Traversal::Node::label (o);
        pop_ ();
      }

      void Node::
      connection_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("connection", top_ ()));
      }

      void Node::
      connection_next (Type const& o)
      {
        connection_post (o);
        connection_pre (o);
      }

      void Node::
      connection_post (Type const&)
      {
        pop_ ();
      }

      void Node::
      sharedResource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("sharedResource", top_ ()));
      }

      void Node::
      sharedResource_next (Type const& o)
      {
        sharedResource_post (o);
        sharedResource_pre (o);
      }

      void Node::
      sharedResource_post (Type const&)
      {
        pop_ ();
      }

      void Node::
      resource_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("resource", top_ ()));
      }

      void Node::
      resource_next (Type const& o)
      {
        resource_post (o);
        resource_pre (o);
      }

      void Node::
      resource_post (Type const&)
      {
        pop_ ();
      }

      // SharedResource
      //
      //

      SharedResource::
      SharedResource (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      SharedResource::
      SharedResource ()
      {
      }

      void SharedResource::
      traverse (Type const& o)
      {
        Traversal::SharedResource::traverse (o);
      }

      void SharedResource::
      name (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("name", top_ ()));
        Traversal::SharedResource::name (o);
        pop_ ();
      }

      void SharedResource::
      resourceType (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("resourceType", top_ ()));
        Traversal::SharedResource::resourceType (o);
        pop_ ();
      }

      void SharedResource::
      node (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("node", top_ ()));
        Traversal::SharedResource::node (o);
        pop_ ();
      }

      void SharedResource::
      property (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("property", top_ ()));
        Traversal::SharedResource::property (o);
        pop_ ();
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
  }
}

