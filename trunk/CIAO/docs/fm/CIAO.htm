<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 7.0/HTML Export Filter">
<LINK REL="STYLESHEET" HREF="CIAO.css" CHARSET="UTF-8" TYPE="text/css">
<TITLE> Chapter 32</TITLE></HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<H2 CLASS="ChapterNum">
<A NAME="pgfId-163697"></A><A NAME="11143"></A>&nbsp;</H2>
</DIV>
<DIV>
<H1 CLASS="Head1">
<A NAME="pgfId-163698"></A><A NAME="85433"></A>CIAO and CCM</H1>
<DIV>
<H3 CLASS="Head2">
<A NAME="pgfId-260561"></A>Introduction<DIV>
<IMG SRC="CIAO-1.gif">
</DIV>
</H3>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-260563"></A>The OMG <A NAME="marker-260562"></A>CORBA Component Model (CCM) (<A NAME="marker-260567"></A>OMG Document formal/06-04-01) defines a specification for implementing <EM CLASS="Emphasis">
component middleware</EM>
. The <A NAME="marker-260564"></A>Component-Integrated ACE ORB (CIAO) is TAO’s implementation of the CCM specification.</LI>
<LI CLASS="Body">
<A NAME="pgfId-222450"></A>The CORBA Component Model is a step in the longtime evolution of software engineering best practices towards higher levels of abstraction. CCM is a realization of the concept of composing software from reusable, pluggable <A NAME="marker-260568"></A>components, assembled into an application at run time. When properly applied, component-based software development promotes improved software reuse, <A NAME="marker-261102"></A>deployment flexibility, and programmer productivity.</LI>
</UL>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-235255"></A>Prerequisites</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-274039"></A>To better understand this chapter, the reader should be familiar with the content of the following chapters from this guide:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-274046"></A><A HREF="BuildingACE+TAO.htm#26824" CLASS="XRef"></A><A HREF="BuildingACE+TAO.htm#98544" CLASS="XRef"></A>&nbsp;</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-274053"></A><A HREF="MakeProjectCreator.htm#62540" CLASS="XRef"></A><A HREF="MakeProjectCreator.htm#25226" CLASS="XRef"></A>&nbsp;</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-234105"></A><A HREF="IDL_Complr.htm#28886" CLASS="XRef"></A><A HREF="IDL_Complr.htm#82061" CLASS="XRef"></A>&nbsp;</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-234023"></A><A HREF="Valuetype.htm#47985" CLASS="XRef"></A><A HREF="Valuetype.htm#56470" CLASS="XRef"></A>&nbsp;</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-234000"></A><A HREF="LocalObjects.htm#91424" CLASS="XRef"></A><A HREF="LocalObjects.htm#65938" CLASS="XRef"></A>&nbsp;</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-222482"></A>What is a Component?</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-222610"></A>A <A NAME="marker-260571"></A>component is a pluggable, self-contained software entity consisting of its own encapsulated business logic and data with clearly defined interfaces for collaboration. A component defines both the capabilities it <A NAME="marker-261045"></A>provides and the services it requires as well as <A NAME="marker-260987"></A>events it <A NAME="marker-260988"></A>publishes and <A NAME="marker-260989"></A>consumes, as illustrated by the diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-222503"></A> A CCM <A NAME="marker-263473"></A>Component</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-222501"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-2.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-163702"></A>The CORBA 2.x object model lacks the expressiveness required to create pluggable components. A CORBA 2.x IDL interface specifies a contract between a client and a server. That contract specifies what the server provides and what the client can expect. However, a great deal of information is missing from that IDL contract. A client or server has no formal mechanism to specify what it requires—namely, which IDL interfaces it depends upon to accomplish its tasks. These dependencies are hidden in the implementation code. Without knowledge of what each client or server requires, it is impossible to connect the clients and servers at run time in a generic way.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163703"></A>The CORBA Component Model includes new IDL constructs for expressing both the client and the server sides of <A NAME="marker-263484"></A>component collaboration. This new edition of IDL is called <A NAME="marker-260578"></A>IDL3. IDL3 is a superset of traditional CORBA IDL, or <A NAME="marker-260580"></A>IDL2. The TAO IDL compiler accepts both IDL3 and IDL2 interface specifications.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163704"></A>A <A NAME="marker-263606"></A>component defines its collaborations in terms of provided and required interfaces. An IDL3 component specification consists of <A NAME="marker-260592"></A>ports that indicate how the component interacts with other components as both a client and a server. There are several types of <A NAME="marker-263251"></A>ports providing various capabilities:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163705"></A>A <A NAME="marker-260594"></A>facet defines an IDL interface provided by a <A NAME="marker-263519"></A>component. This is the server-side of the traditional IDL contract.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163706"></A>A <A NAME="marker-260607"></A>receptacle defines an IDL interface that is used by a <A NAME="marker-263549"></A>component. The component may interact with that interface either through synchronous calls or through AMI. Facets and receptacles are connected via <A NAME="marker-260685"></A>assembly descriptors that are processed at run-time.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163707"></A>An <A NAME="marker-260620"></A>event source or <A NAME="marker-260633"></A>publisher defines an <A NAME="marker-265828"></A>event type that is published by a component. CCM <A NAME="marker-260994"></A>events are strongly typed, as our example will illustrate.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163708"></A>An <A NAME="marker-260659"></A>event sink or <A NAME="marker-260646"></A>consumer defines an <A NAME="marker-265832"></A>event type that is consumed by a component. Event sources and sinks are connected via <A NAME="marker-263623"></A>assembly descriptors that are processed at run-time.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-222440"></A>An <A NAME="marker-260672"></A>attribute provides a mechanism for configuring <A NAME="marker-263575"></A>component properties at application start-up.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163709"></A>An application consists of several components packaged together and deployed at run time. A CCM-based application may consist of numerous binary <A NAME="marker-263590"></A>component implementations implemented in several different programming languages communicating through CORBA.</LI>
<LI CLASS="Body">
<A NAME="pgfId-260740"></A>The CCM specification defines a <A NAME="marker-260739"></A>Component Implementation Framework (CIF) consisting of tools to simplify the implementation of components. The CIF uses the <A NAME="marker-260741"></A>Component Implementation Definition Language (CIDL), through which a component developer defines a <A NAME="marker-260742"></A>composition to describe a <A NAME="marker-263640"></A>component’s implementation details. A <A NAME="marker-268628"></A>CIDL compiler generates a skeletal version of the component’s C++ implementation, or <A NAME="marker-260754"></A>executor. The developer is left to concentrate on application logic.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-222690"></A>Component <A NAME="marker-261086"></A>Deployment</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-226044"></A>A developer configures an application’s <A NAME="marker-263656"></A>component connections—<A NAME="marker-262441"></A>facet to <A NAME="marker-262454"></A>receptacle, <A NAME="marker-261000"></A>event source to <A NAME="marker-261001"></A>event sink—via descriptor files that a <A NAME="marker-260805"></A>component server process loads at run time. The component server creates a <A NAME="marker-260818"></A>component container to instantiate a component and connect it to any collaborating components through the appropriate <A NAME="marker-263266"></A>ports. The component itself is deployed in a library that is dynamically loaded into the component server at run time.</LI>
<LI CLASS="Body">
<A NAME="pgfId-228528"></A>CORBA is the underlying middleware infrastructure for the <A NAME="marker-263683"></A>component containers. The container programming model is built on the Portable Object Adapter (POA). Components communicate through CORBA, assuring interoperability. The diagram illustrates the <A NAME="marker-263690"></A>component container’s relationship to the CORBA infrastructure.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-228779"></A> The Component Container and the CORBA Infrastructure</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-228777"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-3.gif">
</DIV>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-222573"></A>Summary of the CCM <A NAME="marker-260936"></A>Programming Model</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-163710"></A>The CCM model of component programming extends the CORBA 2.x programming model in the following ways:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163711"></A>A component specifies not only what it provides, but also what it requires.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-211138"></A>A component can provide multiple interfaces that are not related through inheritance.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163712"></A>A component specifies <A NAME="marker-261004"></A>events it publishes and consumes directly in its interface. Events are strongly typed value objects.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-261979"></A>An application developer assembles and deploys a component-based application by writing standard XML-based <A NAME="marker-262000"></A>assembly and <A NAME="marker-261980"></A>deployment descriptors. The <A NAME="marker-264026"></A>component server reads the descriptors at run-time to load libraries and connect components, promoting loose coupling of component implementations.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163714"></A>A component developer can add capabilities to an existing component without affecting existing clients by providing a new <A NAME="marker-262469"></A>facet.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163715"></A>A component developer does not need to have any direct interaction with the Portable Object Adapter. The <A NAME="marker-263701"></A>component container interacts with the POA.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163716"></A>A component developer does not write a <EM CLASS="Code">
main()</EM>
 function.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163717"></A>The <A NAME="marker-263724"></A>component container instantiates and destroys the component.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-163718"></A>The <A NAME="marker-264049"></A>component server provides standard services such as event publication, transactions, persistent state, and security and enforces usage policies consistently.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163719"></A>A CCM client does not have to be component-aware. A CORBA 2.x client can bind to a component <A NAME="marker-262492"></A>facet and interact with it without any knowledge that it is part of a CCM component.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-163720"></A>Road Map</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-229585"></A>The following sections illustrate the CCM programming model with an example. The example illustrates the steps involved in developing a CIAO application by tracing the road map outlined in the diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-229593"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-229591"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-4.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-229594"></A>As you can see, component development and deployment primarily consists of five phases: defining interfaces, implementing interfaces, describing the <A NAME="marker-260937"></A>deployment, building, and running. Defining and implementing interfaces should be familiar to any CORBA developer. We will find that some of the steps in implementing an IDL3 interface are a bit different as we take advantage of the CCM programming model. Describing the <A NAME="marker-261139"></A>deployment, involves defining XML descriptors to define how each component is composed from its libraries and how the components are connected together to form an application. In the fourth step, building, we create a set of dynamic libraries for each component. Finally, we run the application by executing component servers to load the dynamic libraries and connect the components together.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Head2">
<A NAME="pgfId-163721"></A><A NAME="marker-260837"></A>Example - The Messenger Application<DIV>
<IMG SRC="CIAO-1.gif">
</DIV>
</H3>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163722"></A>Our CIAO example builds on the Messenger example used throughout this guide. The example’s source code, build files, and XML descriptor files ares in the <EM CLASS="Code">
$CIAO_ROOT/examples/DevGuideExamples/Messenger</EM>
 directory.</LI>
<LI CLASS="Body">
<A NAME="pgfId-211139"></A>The CIAO Messenger example consists of three components: a Messenger, a Receiver, and an Administrator. The Messenger <A NAME="marker-264491"></A>publishes message <A NAME="marker-265479"></A>events and provides a history of all published messages. The Receiver subscribes to message events and retrieves the Messenger’s message history. The Administrator controls the Messenger, starting and stopping publication and changing the <A NAME="marker-267952"></A>attributes of what the Messenger publishes. The relationship between the three component types is demonstrated by the following component diagram:</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-163730"></A> Messenger Component Diagram</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163728"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-5.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-163731"></A>The diagram illustrates that the Messenger component provides three <A NAME="marker-260841"></A>facets, <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, and <EM CLASS="Code">
History</EM>
. Each facet is an IDL interface. The Messenger component also <A NAME="marker-264937"></A>publishes <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265487"></A>events. Each <EM CLASS="Code">
Message</EM>
 event is a value-based <A NAME="marker-260842"></A>event type. The Receiver component has a <A NAME="marker-260843"></A>receptacle that connects to the Messenger’s <EM CLASS="Code">
History</EM>
 <A NAME="marker-262518"></A>facet. It also consumes <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265496"></A>events <A NAME="marker-264943"></A>published by the Messenger. Finally, the Administrator component has two receptacles connected to the Messenger’s <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
 facets, respectively.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163732"></A>The Messenger does not start <A NAME="marker-264949"></A>publishing messages immediately at start-up. The Administrator connects to the Messenger’s <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-262526"></A>facet and invokes the <EM CLASS="Code">
start()</EM>
 operation on it to trigger message publication. Upon receiving a <EM CLASS="Code">
start()</EM>
 request, the <EM CLASS="Code">
Messenger</EM>
 publishes messages to all connected Receivers until the Administrator tells it to <EM CLASS="Code">
stop()</EM>
. The “start publication” collaboration is illustrated in the following interaction diagram:</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-163740"></A> Start Message Publication</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163738"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-6.gif">
</DIV>
</TD>
</TR>
</TABLE>
</UL>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-163741"></A>The Messenger Application’s IDL Interfaces</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-163742"></A>The first task is to specify the Messenger application’s interfaces using IDL. Or, more accurately, using IDL3. Next, we create a component type specification for the Messenger, Receiver, and Administrator. After that, we specify standard IDL interfaces for each of the <A NAME="marker-260852"></A>facets provided by the Messenger, namely the <EM CLASS="Code">
History</EM>
, <EM CLASS="Code">
Runnable</EM>
, and <EM CLASS="Code">
Publication</EM>
. Finally, we create a <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265849"></A>event type whose instances the Messenger <A NAME="marker-264955"></A>publishes.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-230676"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-230674"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-7.gif">
</DIV>
</TD>
</TR>
</TABLE>
</UL>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-163743"></A>The Messenger Component and Facets</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-260869"></A>The Messenger component provides <A NAME="marker-262536"></A>facets that implement the <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, and <EM CLASS="Code">
History</EM>
 interfaces. It also <A NAME="marker-260870"></A>publishes a <EM CLASS="Code">
Message</EM>
. Each Receiver component <A NAME="marker-260871"></A>consumes the <EM CLASS="Code">
Message</EM>
s published by the Messenger and uses the <EM CLASS="Code">
History</EM>
 <A NAME="marker-262541"></A>facet provided by the Messenger. The Administrator component uses the <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
 facets provided by the Messenger.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163745"></A>First, we specify IDL interfaces for the <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-262549"></A>facets. Both of these are <A NAME="marker-260884"></A>IDL2 interfaces that would be recognized by any CORBA client:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163746"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163747"></A>// file Runnable.idl</P>
<P CLASS="Code">
<A NAME="pgfId-163748"></A>interface Runnable {</P>
<P CLASS="Code">
<A NAME="pgfId-163749"></A>   void start();</P>
<P CLASS="Code">
<A NAME="pgfId-163750"></A>   void stop();</P>
<P CLASS="Code">
<A NAME="pgfId-163751"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163752"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163753"></A>// file Publication.idl</P>
<P CLASS="Code">
<A NAME="pgfId-163754"></A>interface Publication {</P>
<P CLASS="Code">
<A NAME="pgfId-163755"></A>  attribute string text;</P>
<P CLASS="Code">
<A NAME="pgfId-163756"></A>  attribute unsigned short period;</P>
<P CLASS="Code">
<A NAME="pgfId-163757"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163758"></A><EM CLASS="Code">
</EM>
&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163759"></A>We put each IDL interface in its own file as a programming convention. The <EM CLASS="Code">
Runnable</EM>
 interface provides control over starting and stopping of message publication. The <EM CLASS="Code">
Publication</EM>
 interface provides control over the <A NAME="marker-264962"></A>published message text and the period, in seconds, between messages.</LI>
<LI CLASS="Body">
<A NAME="pgfId-272975"></A>The Messenger component publishes <EM CLASS="Code">
Message</EM>
 <A NAME="marker-272974"></A>events. We define the <EM CLASS="Code">
Message</EM>
 type using the new <A NAME="marker-272976"></A>IDL3 keyword <A NAME="marker-272977"></A><EM CLASS="Code">
eventtype</EM>
. An <EM CLASS="Code">
eventtype</EM>
 is an IDL value type that inherits from the abstract value type <EM CLASS="Code">
Components::EventBase</EM>
<A NAME="marker-272978"></A>. Our <EM CLASS="Code">
Message</EM>
 <A NAME="marker-272979"></A>event type has three public string members: <EM CLASS="Code">
subject</EM>
, <EM CLASS="Code">
user</EM>
, and <EM CLASS="Code">
text</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163761"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163762"></A>// file Message.idl</P>
<P CLASS="Code">
<A NAME="pgfId-163763"></A>#include &lt;Components.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163764"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163765"></A>eventtype Message {</P>
<P CLASS="Code">
<A NAME="pgfId-163766"></A>  public string subject;</P>
<P CLASS="Code">
<A NAME="pgfId-163767"></A>  public string user;</P>
<P CLASS="Code">
<A NAME="pgfId-163768"></A>  public string text;</P>
<P CLASS="Code">
<A NAME="pgfId-163769"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163770"></A>typedef sequence&lt;Message&gt; Messages;</P>
<P CLASS="Code">
<A NAME="pgfId-258535"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163772"></A>We must include the IDL file <EM CLASS="Code">
Components.idl</EM>
 to use IDL3 keywords such as <EM CLASS="Code">
eventtype</EM>
. Like any IDL value type, The <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265863"></A>event type may contain operations and a <A NAME="marker-265958"></A>factory. For more information on value types, see <A HREF="Valuetype.htm#47985" CLASS="XRef"></A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-234152"></A>However, we can simplify our <A NAME="marker-260917"></A>event type implementation by restricting the contents of the event type to public data members. For such an event type, the IDL compiler generates a full event type implementation and automatically registers the <A NAME="marker-265933"></A>event type factory for us. Therefore, we do not add operations or a factory to the event type.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163773"></A>The <EM CLASS="Code">
History</EM>
 <A NAME="marker-262556"></A>facet contains operations to retrieve <A NAME="marker-264969"></A>published <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265527"></A>events.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-250804"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-250809"></A>// file History.idl</P>
<P CLASS="Code">
<A NAME="pgfId-163775"></A>#include &lt;Components.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163778"></A>#include &lt;Message.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163779"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163780"></A>interface History {</P>
<P CLASS="Code">
<A NAME="pgfId-163781"></A>  Messages get_all();</P>
<P CLASS="Code">
<A NAME="pgfId-163782"></A>  Message get_latest();</P>
<P CLASS="Code">
<A NAME="pgfId-163783"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163784"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-260926"></A>The implementation of the <EM CLASS="Code">
History</EM>
 <A NAME="marker-260931"></A>facet must keep track of each message that it <A NAME="marker-260930"></A>publishes for later retrieval by clients.</LI>
<LI CLASS="Body">
<A NAME="pgfId-260927"></A>Finally, we declare the Messenger component. The Messenger declaration illustrates several of the new <A NAME="marker-260941"></A>IDL3 keywords introduced for component-based programming.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163787"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163788"></A>// file Messenger.idl</P>
<P CLASS="Code">
<A NAME="pgfId-163789"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163790"></A>#include &lt;Components.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163791"></A>#include &lt;Runnable.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163792"></A>#include &lt;Publication.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163793"></A>#include &lt;Message.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163794"></A>#include &lt;History.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163795"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163796"></A>component Messenger {	</P>
<P CLASS="Code">
<A NAME="pgfId-163797"></A>  attribute string subject;</P>
<P CLASS="Code">
<A NAME="pgfId-163798"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163799"></A>  provides Runnable control;</P>
<P CLASS="Code">
<A NAME="pgfId-163800"></A>  provides Publication content;</P>
<P CLASS="Code">
<A NAME="pgfId-163801"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163802"></A>  publishes Message message_publisher;</P>
<P CLASS="Code">
<A NAME="pgfId-163803"></A>  provides History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-163804"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163805"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163806"></A>home MessengerHome manages Messenger {};</P>
<P CLASS="Code">
<A NAME="pgfId-250834"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163808"></A>The Messenger’s component specification must include <EM CLASS="Code">
Components.idl</EM>
 to make the <A NAME="marker-260946"></A>IDL3 keywords available. It also includes IDL files for each of its three <A NAME="marker-262565"></A>facets and for the <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265534"></A>events it publishes.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163809"></A>The keyword <A NAME="marker-260955"></A><EM CLASS="Code">
component</EM>
 is a new <A NAME="marker-260951"></A>IDL3 keyword that is used to define a component.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163810"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163811"></A><A NAME="marker-261056"></A>component Messenger {</P>
<P CLASS="Code">
<A NAME="pgfId-163812"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163813"></A>The component’s definition can contain IDL <A NAME="marker-260963"></A>attributes just like an IDL2 interface. However, the component’s definition may not contain IDL operations.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163814"></A>The Messenger component contains one <A NAME="marker-275458"></A>attribute, the subject.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163815"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163816"></A>  <A NAME="marker-261057"></A>attribute string subject;</P>
<P CLASS="Code">
<A NAME="pgfId-163817"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163818"></A>Despite of the fact that the <EM CLASS="Code">
subject</EM>
 attribute is writable it is not exposed to the Messenger’s clients.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163819"></A>The Messenger component <EM CLASS="Code">
provides</EM>
 three <A NAME="marker-260957"></A>facets. </LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163820"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163821"></A>  <A NAME="marker-261058"></A>provides Runnable control;</P>
<P CLASS="Code">
<A NAME="pgfId-163822"></A>  provides Publication content;</P>
<P CLASS="Code">
<A NAME="pgfId-163823"></A>  provides History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-163824"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-260964"></A>Each <A NAME="marker-262574"></A>facet is an IDL interface. A component uses the <EM CLASS="Code">
provides</EM>
<A NAME="marker-260961"></A> keyword to indicate the services that it <EM CLASS="Emphasis">
offers</EM>
. In the example, the Messenger’s three facets are a <EM CLASS="Code">
Runnable</EM>
 facet called <EM CLASS="Code">
control</EM>
 for starting and stopping message publication, a <EM CLASS="Code">
Publication</EM>
 facet called <EM CLASS="Code">
content</EM>
 for control over the message content and publication period, and a <EM CLASS="Code">
History</EM>
 facet called <EM CLASS="Code">
message_history</EM>
 for access to all messages <A NAME="marker-264978"></A>published by the component. There is no limit to the number of clients that may access the Messenger’s facets.</LI>
<LI CLASS="Body">
<A NAME="pgfId-218934"></A>The Messenger component <EM CLASS="Code">
publishes</EM>
<A NAME="marker-260962"></A> <A NAME="marker-265541"></A>events:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-218935"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-218936"></A>  <A NAME="marker-261060"></A>publishes Message message_publisher;</P>
<P CLASS="Code">
<A NAME="pgfId-250878"></A>};</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163829"></A>&nbsp;</LI>
<LI CLASS="Body">
<A NAME="pgfId-261024"></A>Recall that a <EM CLASS="Code">
Message</EM>
 is an <A NAME="marker-261022"></A>event type. Published <A NAME="marker-261023"></A>events are strongly typed. There is no limit to the number of <A NAME="marker-266080"></A>subscribers for a published event. The Messenger component has neither direct knowledge of the event’s subscribers nor knowledge of the underlying messaging mechanism.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163831"></A>A <EM CLASS="Code">
publishes</EM>
 <A NAME="marker-263283"></A>port may publish to an unlimited number of <A NAME="marker-261037"></A>subscribers. A second kind of <A NAME="marker-261036"></A>publisher, called an <EM CLASS="Emphasis">
emitter</EM>
<A NAME="marker-261035"></A>, is limited to one <A NAME="marker-266071"></A>subscriber. An emitter uses the <EM CLASS="Code">
emits</EM>
<A NAME="marker-261038"></A> keyword instead of the <EM CLASS="Code">
publishes</EM>
<A NAME="marker-261039"></A> keyword. The CCM <A NAME="marker-261154"></A>deployment framework enforces the emitter’s limitation to one subscriber at deployment time. Aside from the keyword, the emitter’s IDL syntax is the same as the publisher’s. For example:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163832"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163833"></A>  emits Message message_publisher;</P>
<P CLASS="Code">
<A NAME="pgfId-163834"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-261040"></A>The <EM CLASS="Code">
home</EM>
<A NAME="marker-261067"></A>, called <EM CLASS="Code">
MessengerHome</EM>
, manages the life cycle of the component.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163836"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163837"></A>home MessengerHome <A NAME="marker-261071"></A>manages Messenger {};</P>
<P CLASS="Code">
<A NAME="pgfId-163838"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163839"></A>Each component has a corresponding <A NAME="marker-267477"></A>home. The <A NAME="marker-264072"></A>component server uses the <EM CLASS="Code">
home</EM>
 to create and destroy component instances. Our Messenger’s <EM CLASS="Code">
home</EM>
 is the simplest possible home, implicitly defining a <EM CLASS="Code">
create()</EM>
<A NAME="marker-261068"></A> operation. The <EM CLASS="Code">
home</EM>
 construct will be discussed in more detail later.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-163840"></A>The Receiver Component</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-163841"></A>The Receiver component receives <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265553"></A>events from the Messenger and retrieves the message <EM CLASS="Code">
History</EM>
 from the <EM CLASS="Code">
Messenger</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163842"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163843"></A>// file Receiver.idl</P>
<P CLASS="Code">
<A NAME="pgfId-163844"></A>#include &lt;Components.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163845"></A>#include &lt;Messsage.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163846"></A>#include &lt;History.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163847"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163848"></A>component Receiver {</P>
<P CLASS="Code">
<A NAME="pgfId-163849"></A>  consumes Message message_consumer;</P>
<P CLASS="Code">
<A NAME="pgfId-163850"></A>  uses History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-163851"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163852"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163853"></A>home ReceiverHome manages Receiver {};</P>
<P CLASS="Code">
<A NAME="pgfId-163854"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-272707"></A>The Receiver does not expose any <A NAME="marker-262586"></A>facets, but instead indicates what it <EM CLASS="Emphasis">
requires</EM>
 via a <EM CLASS="Code">
uses</EM>
<A NAME="marker-261072"></A> specification. The Receiver <EM CLASS="Emphasis">
uses</EM>
 a <EM CLASS="Code">
History</EM>
 facet, and <A NAME="marker-272717"></A><EM CLASS="Emphasis">
consumes</EM>
 <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265564"></A>events. The specification of not only what a component <EM CLASS="Emphasis">
offers</EM>
 but also what it <EM CLASS="Emphasis">
requires</EM>
 is a significant step forward, as it enables connection of components at <A NAME="marker-261164"></A>deployment time. Both of these Receiver receptacles are connected to corresponding facets on the Messenger component at deployment.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163856"></A>The Receiver also has a <A NAME="marker-267495"></A><EM CLASS="Code">
home</EM>
, <EM CLASS="Code">
ReceiverHome</EM>
, which is responsible for creating and destroying Receiver component instances. Again, this is the simplest possible home declaration.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163857"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163858"></A>home ReceiverHome manages Receiver {};</P>
<P CLASS="Code">
<A NAME="pgfId-163859"></A>&nbsp;</P>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-163860"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-212058"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
The Receiver’s<EM CLASS="CodeEmph">
 </EM>
IDL file does not have a dependency on the Messenger<EM CLASS="CodeEmph">
. </EM>
The Receiver knows about <EM CLASS="CodeEmph">
Message</EM>
 and <EM CLASS="CodeEmph">
History</EM>
, but it does not need to know anything about the component that provides those services. A component may depend on IDL interfaces and <A NAME="marker-265575"></A>event types, but it need not depend on other components.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-163861"></A>The Administrator Component</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-163862"></A>Finally, the third component type, an Administrator, triggers the Messenger’s <A NAME="marker-265586"></A>event publication and controls the period of its publication and the text that it <A NAME="marker-264984"></A>publishes.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163863"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163864"></A>// file Administrator.idl</P>
<P CLASS="Code">
<A NAME="pgfId-163865"></A>#include &lt;Components.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163866"></A>#include &lt;Runnable.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163867"></A>#include &lt;Publication.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163868"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163869"></A>component Administrator {    </P>
<P CLASS="Code">
<A NAME="pgfId-163870"></A>  uses multiple Runnable runnables;</P>
<P CLASS="Code">
<A NAME="pgfId-163871"></A>  uses multiple Publication content;</P>
<P CLASS="Code">
<A NAME="pgfId-163872"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163873"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163874"></A><A NAME="marker-267513"></A>home AdministratorHome manages Administrator {};</P>
<P CLASS="Code">
<A NAME="pgfId-163875"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163876"></A>The Administrator <EM CLASS="Code">
</EM>
<A NAME="marker-272601"></A>uses both the <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-262602"></A>facets provided by the Messenger. These two receptacles are later connected to corresponding facets provided by the Messenger. The Administrator’s <A NAME="marker-267524"></A>home is responsible for creating and destroying the Administrator component instance at run time.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163877"></A>The <EM CLASS="Code">
uses multiple</EM>
<A NAME="marker-272608"></A> keyword on the Administrator’s <EM CLASS="Code">
runnables</EM>
 and <EM CLASS="Code">
content</EM>
 receptacles indicates that the Administrator can connect to more than one <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-262610"></A>facet and more than one <EM CLASS="Code">
Publication</EM>
 facet. These facets may be provided by the same component or by different components; the Administrator does not need to know. In our sample <A NAME="marker-261172"></A>deployment the Administrator connects to one <EM CLASS="Code">
Runnable</EM>
 facet and one <EM CLASS="Code">
Publication</EM>
 facet, both from the same Messenger component.</LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-212924"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-163878"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
The Administrator’s IDL file does not have a dependency on the Messenger. The Administrator knows about <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
, but it does not need to know anything about the component that provides those services.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163879"></A>The Administrator, like all components, has a <A NAME="marker-267531"></A><EM CLASS="Code">
home</EM>
 to manage its life cycle:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163880"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163881"></A>home AdministratorHome manages Administrator {};</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163882"></A>&nbsp;</LI>
<LI CLASS="Body">
<A NAME="pgfId-163883"></A>The <A NAME="marker-267540"></A>homes in our example are the simplest possible. The default home contains a factory that acts like a default constructor. It is possible to override that factory and provide parameters to be passed into it.</LI>
<LI CLASS="Body">
<A NAME="pgfId-264582"></A>To summarize, we’ve been exposed to several new IDL3 keywords:</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-163886"></A>IDL3 Keywords</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-163890"></A>IDL3 Keyword</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-163892"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163894"></A><A NAME="marker-272380"></A>component</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163896"></A>Declares a component that can provide and use facets, publish and consume <A NAME="marker-265597"></A>events</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163898"></A><A NAME="marker-272385"></A>provides</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163900"></A>Declares an IDL interface that the component offers; the interface defines a service offered</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163902"></A><A NAME="marker-272390"></A>uses</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163904"></A>Declares an IDL interface that the component requires</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163906"></A><A NAME="marker-272395"></A>uses multiple</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163908"></A>Declares that the component can connect to one or more instances of the required interface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163910"></A><A NAME="marker-272400"></A>eventtype</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163912"></A>Declares an <A NAME="marker-265608"></A>event type that the component publishes; the <EM CLASS="Code">
eventtype</EM>
 is an IDL <EM CLASS="TableCode">
valuetype</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163914"></A><A NAME="marker-272405"></A>publishes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163916"></A>Declares that the component <A NAME="marker-264994"></A>publishes instances of an <A NAME="marker-265629"></A>event type to a potentially unlimited number of consumers</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163918"></A><A NAME="marker-272410"></A>emits</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163920"></A>Declares that the component publishes instances of an <A NAME="marker-265639"></A>event type to exactly one <A NAME="marker-266058"></A>consumer</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163922"></A><A NAME="marker-272415"></A>consumes</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163924"></A>Declares that the component expects the <A NAME="marker-265649"></A>event type to be published to it by one or more <A NAME="marker-265000"></A>publishers</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163926"></A><A NAME="marker-267548"></A>home</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163928"></A>Declares an interface used by the <A NAME="marker-263747"></A>component container to manage the component’s life cycle</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-163930"></A><A NAME="marker-272420"></A>manages</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-163932"></A>Declares which component is managed by the <EM CLASS="TableCode">
home</EM>
<A NAME="marker-267558"></A></P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-163934"></A>Implementing the Components</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-163935"></A>The CORBA Component Model specification defines a <A NAME="marker-269544"></A>Component Implementation Framework (CIF) consisting of tools to simplify and automate the implementation of components. A significant part of the CIF is the <A NAME="marker-268239"></A>Component Implementation Definition Language (CIDL), through which a component developer provides implementation details for each component type. The <A NAME="marker-268642"></A>CIDL compiler compiles the CIDL files and generates a significant portion of the C++ implementation code. The developer is left to concentrate on application logic.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163936"></A>We write <A NAME="marker-268248"></A>CIDL files for the Messenger, Receiver, and Administrator component types. Each CIDL file contains a component <A NAME="marker-269559"></A>composition.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-230918"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-230916"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-9.gif">
</DIV>
</TD>
</TR>
</TABLE>
</UL>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-163937"></A>The Messenger Composition</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-163938"></A>The primary entity of a <A NAME="marker-268256"></A>CIDL file is a <EM CLASS="Code">
composition</EM>
. A <A NAME="marker-269573"></A><EM CLASS="Code">
composition</EM>
 describes how a <EM CLASS="Code">
component</EM>
 is connected to its <A NAME="marker-267572"></A><EM CLASS="Code">
home</EM>
. A <EM CLASS="Code">
component</EM>
 can be instantiated by more than one <EM CLASS="Code">
home</EM>
; the <EM CLASS="Code">
composition</EM>
 designates the <EM CLASS="Code">
home</EM>
 responsible for the <EM CLASS="Code">
component</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163939"></A>The declaration of the Messenger’s composition follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163940"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163941"></A>// file Messenger.cidl</P>
<P CLASS="Code">
<A NAME="pgfId-163942"></A>#include &lt;Messenger.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163943"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163944"></A>composition session Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-163945"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-163946"></A>    home executor MessengerHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-163947"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-163948"></A>        implements MessengerHome;</P>
<P CLASS="Code">
<A NAME="pgfId-163949"></A>        manages    Messenger_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-163950"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-163951"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163952"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163953"></A>The <EM CLASS="Code">
session</EM>
 is the component’s <EM CLASS="Emphasis">
life cycle category</EM>
. A <A NAME="marker-269580"></A><EM CLASS="Code">
session</EM>
 composition provides transient object references and maintains its transient state for the lifetime of the session. Once the component is destroyed, its object references are invalidated and its state is lost. The other valid composition life cycle categories are <A NAME="marker-269585"></A><EM CLASS="Code">
entity</EM>
, <A NAME="marker-269598"></A><EM CLASS="Code">
service</EM>
, and <A NAME="marker-269611"></A><EM CLASS="Code">
process</EM>
. They are discussed later.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163954"></A>The name of the composition is <EM CLASS="Code">
Messenger_Impl</EM>
. The <A NAME="marker-268646"></A>CIDL compiler generates its implementation code into a C++ namespace called <EM CLASS="Code">
Messenger_Impl</EM>
. The <A NAME="marker-269624"></A>composition can have any name; it is customary to end the name with <EM CLASS="Code">
_Impl</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-250944"></A>An implementation of a component or a <A NAME="marker-267584"></A>home is called an <A NAME="marker-266094"></A>executor. A CCM developer implements an <EM CLASS="Emphasis">
executor</EM>
 rather than a <EM CLASS="Emphasis">
servant</EM>
. The <A NAME="marker-268661"></A>CIDL compiler generates two abstract C++ <EM CLASS="Emphasis">
executor</EM>
 classes, one for the <EM CLASS="Code">
component</EM>
 and one for its <EM CLASS="Code">
home</EM>
, using the names <EM CLASS="Code">
Messenger_Exec</EM>
 and <EM CLASS="Code">
MessengerHome_Exec</EM>
 specified in the <A NAME="marker-268267"></A>CIDL <A NAME="marker-269637"></A>composition. The Messenger executors may have any name; it is customary to end the each with the suffix <EM CLASS="Code">
_Exec</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-251082"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-251083"></A>    home executor MessengerHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-251084"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-251085"></A>        implements MessengerHome;</P>
<P CLASS="Code">
<A NAME="pgfId-251086"></A>        manages    Messenger_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-251087"></A>    };</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-251088"></A>&nbsp;</LI>
<LI CLASS="Body">
<A NAME="pgfId-251056"></A>The <A NAME="marker-267314"></A><EM CLASS="Code">
home executor</EM>
 defines which <A NAME="marker-267606"></A><EM CLASS="Code">
home</EM>
 is used to manage the life cycle of the Messenger component.</LI>
<LI CLASS="Body">
<A NAME="pgfId-251064"></A>The <EM CLASS="Code">
implements</EM>
 declaration declares which of the component’s <A NAME="marker-267621"></A>homes manages the component’s life cycle. The Messenger component only has one home, the <EM CLASS="Code">
MessengerHome</EM>
, so that is the <EM CLASS="Code">
home</EM>
 we’ll use. Note that we don’t need to indicate that the <EM CLASS="Code">
MessengerHome</EM>
 manages the Messenger component; that relationship is defined in the <EM CLASS="Code">
MessengerHome</EM>
’s declaration.</LI>
<LI CLASS="Body">
<A NAME="pgfId-163964"></A>The component developer overrides pure virtual methods in the generated <A NAME="marker-266113"></A>executor classes to provide the component implementation. The <A NAME="marker-268676"></A>CIDL compiler can optionally generate a default implementation of each C++ executor class. By default, it appends <EM CLASS="Code">
_i</EM>
 to the executor class name. The default implementation of the Messenger executor is <EM CLASS="Code">
Messenger_exec_i</EM>
, and the default implementation of the <EM CLASS="Code">
MessengerHome</EM>
 <A NAME="marker-267335"></A>executor is <EM CLASS="Code">
MessengerHome_exec_i</EM>
. The component developer fills the application logic into the generated Messenger executor implementation. The CIDL compiler generates a full implementation for the <EM CLASS="Code">
MessengerHome</EM>
’s executor, so no developer intervention is required.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-163965"></A>The Receiver and Administrator Compositions</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-163966"></A>The Receiver and Administrator <A NAME="marker-269652"></A>compositions are similar to the Messenger composition.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163967"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163968"></A>// file Receiver.cidl</P>
<P CLASS="Code">
<A NAME="pgfId-163969"></A>#include &lt;Receiver.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163970"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163971"></A>composition session Receiver_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-163972"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-163973"></A>    home executor ReceiverHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-163974"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-163975"></A>        implements ReceiverHome;</P>
<P CLASS="Code">
<A NAME="pgfId-163976"></A>        manages    Receiver_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-163977"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-163978"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163979"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163980"></A>The Receiver’s <A NAME="marker-269669"></A>composition is called <EM CLASS="Code">
Receiver_Impl</EM>
, and it’s home <A NAME="marker-267362"></A>executor implements the <EM CLASS="Code">
ReceiverHome</EM>
. <A NAME="marker-268692"></A>CIDL compiler generates an abstract executor class for the <EM CLASS="Code">
ReceiverHome</EM>
 called <EM CLASS="Code">
ReceiverHome_Exec</EM>
 and an abstract executor class for the Receiver component called <EM CLASS="Code">
Receiver_Exec</EM>
. Optionally, the CIDL compiler can generate default implementations of the two executors.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-163981"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163982"></A>// file Administrator.cidl</P>
<P CLASS="Code">
<A NAME="pgfId-163983"></A>#include &lt;Administrator.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-163984"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-163985"></A>composition session Administrator_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-163986"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-163987"></A>    home executor AdministratorHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-163988"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-163989"></A>        implements AdministratorHome;</P>
<P CLASS="Code">
<A NAME="pgfId-163990"></A>        manages    Administrator_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-163991"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-163992"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-163993"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-163994"></A>The Administrator’s <A NAME="marker-269677"></A>composition is called <EM CLASS="Code">
Administrator_Impl</EM>
, and its home <A NAME="marker-267369"></A>executor implements the <EM CLASS="Code">
AdministratorHome</EM>
. The <A NAME="marker-268700"></A>CIDL compiler generates an abstract executor class for the <EM CLASS="Code">
AdministratorHome</EM>
 called <EM CLASS="Code">
AdministratorHome_Exec</EM>
 and an abstract executor class for the Administrator component called <EM CLASS="Code">
Administrator_Exec</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-266153"></A>To summarize, we’ve been exposed to several new <A NAME="marker-268289"></A>CIDL keywords:</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-213481"></A>CIDL Keywords</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-213485"></A>CIDL Keyword</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-213487"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-213489"></A><A NAME="marker-272433"></A>composition</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-213491"></A>Declares a set of entities that work together to manage the component’s life cycle and implement the component’s behavior</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-213493"></A><A NAME="marker-272438"></A>session</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-213495"></A>A component category characterized by transient state and transient object identity</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-213497"></A><A NAME="marker-272443"></A>service</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-213499"></A>A component category characterized by objects having no duration beyond the lifetime of a single client interaction</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-213501"></A><A NAME="marker-272448"></A>entity</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-213503"></A>A component category characterized by persistent state that is visible to the user and persistent object identity</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-213505"></A><A NAME="marker-272453"></A>process</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-213507"></A>A component category characterized by persistent state that is not visible to the user and persistent object identity</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-213509"></A><A NAME="marker-272460"></A>executor</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-213511"></A>Declares the name of the abstract component <A NAME="marker-267375"></A>home executor class</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-213513"></A><A NAME="marker-272465"></A>implements</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-213515"></A>Declares the <A NAME="marker-267658"></A>home that manages the component</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-213517"></A><A NAME="marker-272470"></A>manages</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-213519"></A>Declares the name of the abstract component <A NAME="marker-266170"></A>executor class</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-213521"></A><A NAME="19107"></A>Compiling the IDL and CIDL</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-213532"></A>We compile the IDL files with TAO’s IDL compiler. The TAO IDL compiler recognizes IDL3 constructs such as <EM CLASS="Code">
component</EM>
 and <EM CLASS="Code">
eventtype</EM>
. Additional information on compiling the Messenger’s IDL files is contained in <A HREF="CIAO.htm#66494" CLASS="XRef">See Building the Messenger Application</A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-214390"></A>We compile the <A NAME="marker-268299"></A>CIDL files with CIAO’s <A NAME="marker-268707"></A>CIDL compiler. Additional information on compiling the Messenger’s <A NAME="marker-268307"></A>CIDL files is also contained in <A HREF="CIAO.htm#66494" CLASS="XRef">See Building the Messenger Application</A>. The <A NAME="marker-268714"></A>CIDL Compiler Reference in <A HREF="CIAO.htm#68030" CLASS="XRef">See CIDL Compiler Reference</A> contains more extensive information on using the CIDL compiler.</LI>
<LI CLASS="Body">
<A NAME="pgfId-219130"></A>This section concentrates on the output of the IDL and <A NAME="marker-268721"></A>CIDL compilers rather than the mechanics of executing the IDL and CIDL compilers.</LI>
<LI CLASS="Body">
<A NAME="pgfId-214407"></A>The <A NAME="marker-268729"></A>CIDL compiler can generate most of the code for <A NAME="marker-267668"></A>home, <A NAME="marker-267674"></A>component, and <A NAME="marker-262622"></A>facet <A NAME="marker-266180"></A>executor implementations through its <EM CLASS="Code">
--gen-exec-impl</EM>
 command-line option. For each component, home, or facet it generates a C++ class that inherits from a generated abstract executor class, leaving the component developer to fill in the application logic.</LI>
<LI CLASS="Body">
<A NAME="pgfId-214887"></A>The diagram shows the files that the <A NAME="marker-268736"></A>CIDL compiler generates when it compiles <EM CLASS="Code">
Messenger.cidl</EM>
.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-214897"></A> Running the CIDL Compiler</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-214895"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-10.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-214400"></A>We show both <EM CLASS="Code">
Messenger.cidl</EM>
 and <EM CLASS="Code">
Messenger.idl</EM>
 as inputs to the <A NAME="marker-268744"></A>CIDL compiler because the <EM CLASS="Code">
Messenger.cidl</EM>
 file includes <EM CLASS="Code">
Messenger.idl</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-215076"></A>The <A NAME="marker-268751"></A>CIDL compiler generates an IDL file, <EM CLASS="Code">
MessengerE.idl</EM>
, containing local interfaces for the Messenger’s <A NAME="marker-267696"></A>component, <A NAME="marker-267687"></A>home, and <A NAME="marker-262633"></A>facet executors. We compile this IDL file with the IDL compiler to generate an abstract C++ <A NAME="marker-266188"></A>executor class for each component and facet. Each component, home, and facet executor implementation implements one of the local interfaces declared in <EM CLASS="Code">
MessengerE.idl</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-216837"></A>The <A NAME="marker-268758"></A>CIDL compiler also generates complete C++ header and implementation files for the servant classes. There is a servant class for each <A NAME="marker-267701"></A>component, <A NAME="marker-267706"></A>home, and <A NAME="marker-262642"></A>facet <A NAME="marker-266196"></A>executor class. The CCM developer does not directly instantiate servants; instead, the <A NAME="marker-263757"></A>component container instantiates servants and registers them with the Portable Object Adapter automatically.</LI>
<LI CLASS="Body">
<A NAME="pgfId-215931"></A>The <A NAME="marker-268765"></A>CIDL compiler optionally generates default component, home, and <A NAME="marker-262649"></A>facet <A NAME="marker-266203"></A>executor implementation classes in files called <EM CLASS="Code">
Messenger_exec.h</EM>
 and <EM CLASS="Code">
Messenger_exec.cpp</EM>
. Those files contain definitions for five classes: <EM CLASS="Code">
Messenger_exec_i</EM>
, <EM CLASS="Code">
MessengerHome_exec_i, Runnable_exec_i</EM>
, <EM CLASS="Code">
Publication_exec_i</EM>
, and <EM CLASS="Code">
History_exec_i</EM>
. The latter three classes are executors for the Messenger’s <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, and <EM CLASS="Code">
History</EM>
 <A NAME="marker-262656"></A>facets. For safety, <A NAME="Copy CIDL-generated Executor impl file"></A>copy the <EM CLASS="Code">
Messenger_exec.h</EM>
 and <EM CLASS="Code">
Messenger_exec.cpp</EM>
 files to something like <EM CLASS="Code">
Messenger_exec_i.h</EM>
 and <EM CLASS="Code">
Messenger_exec_i.cpp</EM>
. You may also want to break the implementations for <EM CLASS="Code">
History_exec_i</EM>
, <EM CLASS="Code">
Runnable_exec_i</EM>
, etc., into different header and implementation files as we’ve done in our sample code.</LI>
<LI CLASS="Body">
<A NAME="pgfId-216492"></A>The diagram illustrates the Messenger <A NAME="marker-266210"></A>executor’s classes.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-216497"></A> The Messenger Executor’s Classes</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-216495"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-11.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-215970"></A>The table summarizes the Messenger’s <A NAME="marker-266234"></A>executor implementation classes.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-215943"></A>Executor Implementation Classes</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-215947"></A>Executor Implementation Class</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-215949"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-216456"></A>Messenger_exec_i</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-216458"></A>Implements the <EM CLASS="Code">
Messenger</EM>
 component</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-216460"></A>MessengerHome_exec_i</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-216462"></A>Implements the <EM CLASS="Code">
MessengerHome</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-215951"></A>Runnable_exec_i</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-215953"></A>Implements the <EM CLASS="Code">
Runnable</EM>
 facet</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-215955"></A>Publication_exec_i</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-215957"></A>Implements the <EM CLASS="Code">
Publication</EM>
 facet</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-215959"></A>History_exec_i</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-215961"></A>Implements the <EM CLASS="Code">
History</EM>
 facet</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-164089"></A>Implementing the Executors</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-164090"></A>The CIAO <A NAME="marker-268772"></A>CIDL compiler generates an empty implementation of each component and <A NAME="marker-262666"></A>facet <A NAME="marker-266259"></A>executor. In the following sections, we implement the facet executors for the <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, and <EM CLASS="Code">
History</EM>
 facets and the component executors for the Messenger, Receiver, and Administrator components.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-230947"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-230945"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-12.gif">
</DIV>
</TD>
</TR>
</TABLE>
</UL>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-164091"></A>The Runnable Facet <A NAME="marker-266282"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-164092"></A>The <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-262692"></A>facet is provided by the Messenger component and permits a client to start and stop message publication. The component diagram highlights the role of the Messenger’s <EM CLASS="Code">
Runnable</EM>
 facet.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-164100"></A> The Messenger’s Runnable Facet</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-164098"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-13.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-164102"></A>Recall that the <EM CLASS="Code">
Runnable</EM>
 IDL interface is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164103"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164104"></A>// file Runnable.idl</P>
<P CLASS="Code">
<A NAME="pgfId-164105"></A>interface Runnable {</P>
<P CLASS="Code">
<A NAME="pgfId-164106"></A>   void start();</P>
<P CLASS="Code">
<A NAME="pgfId-164107"></A>   void stop();</P>
<P CLASS="Code">
<A NAME="pgfId-164108"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-164109"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164110"></A>The <A NAME="marker-268795"></A>CIDL compiler generates a default <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-266300"></A>executor with empty implementations of <EM CLASS="Code">
start()</EM>
 and <EM CLASS="Code">
stop()</EM>
. The class diagram illustrates the <EM CLASS="Code">
Runnable</EM>
 executor’s class hierarchy.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-164118"></A> Class Diagram for the Runnable Executor</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-164116"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-14.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-164119"></A>The IDL compiler generates a <EM CLASS="Code">
Runnable</EM>
 stub. The <A NAME="marker-268810"></A>CIDL compiler generates an abstract <A NAME="marker-266317"></A>executor base class, <EM CLASS="Code">
CCM_Runnable</EM>
, and optionally generates an empty executor implementation, <EM CLASS="Code">
Runnable_exec_i</EM>
. The CIDL compiler generates a default constructor, a destructor, and a virtual method for each of <EM CLASS="Code">
Runnable</EM>
’s IDL operations and <A NAME="marker-275464"></A>attributes. </LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-216681"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-164120"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
For each IDL interface “MyInterface” that is a <A NAME="marker-262709"></A>facet of a component, the <A NAME="marker-268826"></A>CIDL compiler generates an abstract facet <A NAME="marker-266333"></A>executor class called “CCM_MyInterface.”<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164121"></A>An <A NAME="marker-266348"></A>executor is a local CORBA object. Its generated implementation class also inherits from ::<EM CLASS="Code">
CORBA::LocalObject</EM>
. Additional information on local objects can be found in <A HREF="LocalObjects.htm#91424" CLASS="XRef"></A>. </LI>
<LI CLASS="Body">
<A NAME="pgfId-251110"></A>The Messenger component only <A NAME="marker-265007"></A>publishes messages when it can acquire the <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-266361"></A>executor’s <EM CLASS="Code">
run_lock</EM>
. If the Messenger cannot acquire the run lock, it blocks waiting for it to be released. A client of the <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-262725"></A>facet controls the run lock via the <EM CLASS="Code">
start()</EM>
 and <EM CLASS="Code">
stop()</EM>
 operations.</LI>
<LI CLASS="Body">
<A NAME="pgfId-251123"></A>The <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-266368"></A>executor implementation follows. Changes to the CIDL-generated empty executor implementation are in bold:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164123"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164124"></A>// file Runnable_exec_i.h</P>
<P CLASS="Code">
<A NAME="pgfId-291782"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-291783"></A>#include &quot;Messenger_svnt.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-291784"></A>#include &quot;tao/LocalObject.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-291611"></A>#include &lt;ace/Thread_Mutex.h&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-291612"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164130"></A>namespace Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164131"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164132"></A>  class MESSENGER_EXEC_Export Runnable_exec_i </P>
<P CLASS="Code">
<A NAME="pgfId-164133"></A>    : public virtual ::CCM_Runnable, </P>
<P CLASS="Code">
<A NAME="pgfId-164134"></A>      public virtual ::CORBA::LocalObject</P>
<P CLASS="Code">
<A NAME="pgfId-164135"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164136"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-164137"></A>    Runnable_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164138"></A>    virtual ~Runnable_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164139"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164140"></A>    // Operations from ::Runnable</P>
<P CLASS="Code">
<A NAME="pgfId-164141"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164142"></A>    virtual void start ();</P>
<P CLASS="Code">
<A NAME="pgfId-164144"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164145"></A>    virtual void stop ();</P>
<P CLASS="Code">
<A NAME="pgfId-164147"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164148"></A>    ACE_Thread_Mutex&amp; get_run_lock();</P>
<P CLASS="Code">
<A NAME="pgfId-164149"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-291674"></A>  private:</P>
<P CLASS="Code">
<A NAME="pgfId-291675"></A>    ACE_Thread_Mutex run_lock_;</P>
<P CLASS="Code">
<A NAME="pgfId-291676"></A>  };</P>
<P CLASS="Code">
<A NAME="pgfId-164153"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-291770"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-291771"></A>The included <EM CLASS="Code">
Messenger_svnt.h</EM>
 header file contains the servant class definitions for the <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, <EM CLASS="Code">
History</EM>
, <EM CLASS="Code">
Messenger</EM>
, and <EM CLASS="Code">
MessengerHome</EM>
. A component developer does not implement <EM CLASS="Emphasis">
servant</EM>
 classes; instead, the <A NAME="marker-291772"></A>CIDL compiler generates servant classes and the <A NAME="marker-291773"></A>component container automatically instantiates them at run time. A component developer implements <A NAME="marker-291774"></A>executor classes that have no relationship to the server’s POA. The automatically-generated servant class delegates its execution to the developer-written local executor object.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164156"></A>The <A NAME="marker-266384"></A>executor implementation inherits from the generated abstract executor base class, <EM CLASS="Code">
CCM_Runnable</EM>
, and from <EM CLASS="Code">
::CORBA::LocalObject</EM>
. <EM CLASS="Code">
CCM_Runnable</EM>
, in turn, inherits from the generated <EM CLASS="Code">
Runnable</EM>
 stub class that the client uses. Thus, the executor implements the <EM CLASS="Code">
Runnable</EM>
 interface generated by the IDL compiler. The <EM CLASS="Code">
start()</EM>
 and <EM CLASS="Code">
stop()</EM>
 operations are declared as pure virtual methods in the <EM CLASS="Code">
CCM_Runnable</EM>
 class, forcing the executor to implement them.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164157"></A>Note the lack of inheritance from a <EM CLASS="Code">
POA_Runnable</EM>
 class; instead, the <A NAME="marker-268843"></A>CIDL compiler generates a <EM CLASS="Code">
Runnable_Servant</EM>
 class for us.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164158"></A>The inheritance from <EM CLASS="Code">
::CORBA::LocalObject</EM>
 enforces two behaviors: first, the <A NAME="marker-266394"></A>executor is a ::<EM CLASS="Code">
CORBA::LocalObject</EM>
<A NAME="marker-272997"></A>, meaning that it can only be used from within the server process; second the executor has reference counting, meaning that the inherited <EM CLASS="Code">
_add_ref() </EM>
<A NAME="marker-272995"></A>and <EM CLASS="Code">
_remove_ref()</EM>
<A NAME="marker-272996"></A> operations must be used to manage the executor’s memory.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164159"></A>Our <EM CLASS="Code">
Runnable</EM>
 implementation contains a private <EM CLASS="Code">
ACE_Thread_Mutex</EM>
<A NAME="marker-272998"></A> lock and a public accessor method to retrieve it. The Messenger acquires this <EM CLASS="Code">
run_lock</EM>
 before publishing each message and releases it after publishing each message. If the Messenger cannot acquire the <EM CLASS="Code">
run_lock</EM>
, it blocks until the lock is released. A <EM CLASS="Code">
Runnable</EM>
 client can acquire and release the <EM CLASS="Code">
run_lock</EM>
 through the <EM CLASS="Code">
start()</EM>
 and <EM CLASS="Code">
stop()</EM>
 operations. In this way, a client can control whether or not the Messenger <A NAME="marker-265013"></A>publishes any messages.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164160"></A>The <A NAME="marker-268846"></A>CIDL compiler also generates an empty, default implementation of the <EM CLASS="Code">
Runnable_exec_i</EM>
 class. We implement a constructor, the <EM CLASS="Code">
start()</EM>
 and <EM CLASS="Code">
stop()</EM>
 operations, and an accessor for the mutex lock. Changes to the CIDL-generated default <A NAME="marker-266404"></A>executor implementation code are in bold.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164161"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164162"></A>// file Runnable_exec_i.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-164163"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164164"></A>#include &quot;Messenger_exec_i.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164165"></A>#include &quot;ciao/CIAO_common.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164166"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164167"></A>namespace Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164168"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164169"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164170"></A>  // Facet Executor Implementation Class:   Runnable_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164171"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164172"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164173"></A>  Runnable_exec_i::Runnable_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-164174"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164175"></A>    // initially, the Messenger does not publish</P>
<P CLASS="Code">
<A NAME="pgfId-164176"></A>    this-&gt;stop();</P>
<P CLASS="Code">
<A NAME="pgfId-164177"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164178"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164179"></A>  Runnable_exec_i::~Runnable_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-164180"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164181"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164182"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164183"></A>  // Operations from ::Runnable</P>
<P CLASS="Code">
<A NAME="pgfId-164184"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164185"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-164186"></A>  Runnable_exec_i::start ()</P>
<P CLASS="Code">
<A NAME="pgfId-164188"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164189"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164190"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164191"></A>    // allows the Messenger to acquire the lock and publish</P>
<P CLASS="Code">
<A NAME="pgfId-164192"></A>    this-&gt;run_lock_.release()</P>
<P CLASS="Code">
<A NAME="pgfId-164193"></A>   }</P>
<P CLASS="Code">
<A NAME="pgfId-164194"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164195"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-164196"></A>  Runnable_exec_i::stop ()</P>
<P CLASS="Code">
<A NAME="pgfId-164198"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164199"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164200"></A> &nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164201"></A>    // prevents the Messenger from acquiring the lock; can’t publish</P>
<P CLASS="Code">
<A NAME="pgfId-164202"></A>    this-&gt;run_lock_.acquire()</P>
<P CLASS="Code">
<A NAME="pgfId-164203"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164204"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164205"></A>  ACE_Thread_Mutex&amp;</P>
<P CLASS="Code">
<A NAME="pgfId-164206"></A>  Runnable_exec_i::get_run_lock()</P>
<P CLASS="Code">
<A NAME="pgfId-164207"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164208"></A>    return this-&gt;run_lock_;</P>
<P CLASS="Code">
<A NAME="pgfId-164209"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164210"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-164211"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164212"></A>The <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-266412"></A>executor creates an <EM CLASS="Code">
ACE_Thread_Mutex</EM>
 lock for the Messenger to acquire in its event loop before <A NAME="marker-265019"></A>publishing messages. If the Messenger can’t acquire the lock, then it does not publish messages. This agreement between the <EM CLASS="Code">
Runnable</EM>
 executor and the Messenger executor controls the suspension and resumption of message publication. Initially, the <EM CLASS="Code">
Runnable</EM>
 executor holds the lock. The implementations of <EM CLASS="Code">
start()</EM>
 and <EM CLASS="Code">
stop()</EM>
 release and acquire the lock, respectively. The <EM CLASS="Code">
get_run_lock()</EM>
 accessor exposes the lock to the Messenger executor.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164213"></A>The <A NAME="marker-268849"></A>CIDL compiler also generates <A NAME="marker-266423"></A>executor implementations for the <EM CLASS="Code">
Publication</EM>
 and <EM CLASS="Code">
History</EM>
 interfaces and the Messenger, Receiver, and Administrator components.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-164214"></A>The Publication Facet <A NAME="marker-266430"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-164215"></A>The <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-262734"></A>facet is provided by the Messenger component and permits a client to modify the text <A NAME="marker-265025"></A>published and the period (in seconds) between published messages.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164216"></A>Recall that the <EM CLASS="Code">
Publication</EM>
 IDL interface is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164217"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164218"></A>interface Publication {</P>
<P CLASS="Code">
<A NAME="pgfId-164219"></A>  attribute string text;</P>
<P CLASS="Code">
<A NAME="pgfId-164220"></A>  attribute unsigned short period;</P>
<P CLASS="Code">
<A NAME="pgfId-164221"></A>};    </P>
<P CLASS="Code">
<A NAME="pgfId-164222"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164223"></A>The <A NAME="marker-268852"></A>CIDL compiler generates an empty implementation of the <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-266440"></A>executor. We add private class <A NAME="marker-275478"></A>attributes to keep track of the message subject, text, and period. Changes to the CIDL-generated code are in <EM CLASS="Bold">
bold</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164224"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164225"></A><EM CLASS="Bold">
#include &lt;string&gt;</EM>
</P>
<P CLASS="Code">
<A NAME="pgfId-164226"></A><EM CLASS="Bold">
#include &lt;ace/Thread_Mutex.h&gt;</EM>
</P>
<P CLASS="Code">
<A NAME="pgfId-164227"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164228"></A>namespace Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164229"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164230"></A>  class MESSENGER_EXEC_Export Publication_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164231"></A>  : public virtual ::CCM_Publication,</P>
<P CLASS="Code">
<A NAME="pgfId-164232"></A>    public virtual ::CORBA::LocalObject</P>
<P CLASS="Code">
<A NAME="pgfId-164233"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164234"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-164235"></A>    Publication_exec_i (const char* text,</P>
<P CLASS="Code">
<A NAME="pgfId-164236"></A>                        CORBA::UShort period);</P>
<P CLASS="Code">
<A NAME="pgfId-164237"></A>    virtual ~Publication_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164238"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164239"></A>    // Operations from ::Publication</P>
<P CLASS="Code">
<A NAME="pgfId-164240"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164241"></A>    vrtual char* text ();</P>
<P CLASS="Code">
<A NAME="pgfId-164243"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164244"></A>    virtual void text (const char* text);</P>
<P CLASS="Code">
<A NAME="pgfId-164246"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164247"></A>    virtual CORBA::UShort period ();</P>
<P CLASS="Code">
<A NAME="pgfId-164249"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164250"></A>    virtual void period (CORBA::UShort period);</P>
<P CLASS="Code">
<A NAME="pgfId-164252"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164253"></A>  private:</P>
<P CLASS="Code">
<A NAME="pgfId-164254"></A>    std::string text_;</P>
<P CLASS="Code">
<A NAME="pgfId-164255"></A>    CORBA::UShort period_;</P>
<P CLASS="Code">
<A NAME="pgfId-164256"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164257"></A>    ACE_Thread_Mutex lock_;</P>
<P CLASS="Code">
<A NAME="pgfId-164258"></A>  };</P>
<P CLASS="Code">
<A NAME="pgfId-164259"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-164260"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164261"></A>The pattern is similar to the <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-266447"></A>executor’s. The <EM CLASS="Code">
Publication_exec_i</EM>
 executor inherits from both the generated <EM CLASS="Code">
CCM_Publication</EM>
 class and TAO’s <EM CLASS="Code">
::CORBA::LocalObject</EM>
 class. The accessor and modifier for the <EM CLASS="Code">
text</EM>
 and <EM CLASS="Code">
period</EM>
 <A NAME="marker-275484"></A>attributes are declared as pure virtual methods in the <EM CLASS="Code">
CCM_Publication</EM>
 class, forcing us to implement them in our executor.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164262"></A>The <EM CLASS="Code">
text_</EM>
 and <EM CLASS="Code">
period_</EM>
 class members hold information about the publication. Because clients can modify the text and period, the <A NAME="marker-266456"></A>executor uses an <EM CLASS="Code">
ACE_Thread_Mutex</EM>
 lock to protect them from simultaneous access. We have to assume that a provided <A NAME="marker-262741"></A>facet might be accessed by multiple threads at the same time.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164263"></A>The implementation of the <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-266463"></A>executor follows. Again, changes to the CIDL-generated default executor implementation code are in bold.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164264"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164265"></A>#include &quot;Publication_exec_i.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164266"></A>#include &quot;ciao/CIAO_common.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164267"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164268"></A>namespace Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164269"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164270"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164271"></A>  // Facet Executor Implementation Class:   Publication_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164272"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164273"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-292170"></A>  Publication_exec_i::Publication_exec_i (const char* text,</P>
<P CLASS="Code">
<A NAME="pgfId-292171"></A>                                          CORBA::UShort period)</P>
<P CLASS="Code">
<A NAME="pgfId-292172"></A>    : text_( text ),</P>
<P CLASS="Code">
<A NAME="pgfId-164277"></A>      period_( period)</P>
<P CLASS="Code">
<A NAME="pgfId-164278"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164279"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164280"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164281"></A>  Publication_exec_i::~Publication_exec_i (void) </P>
<P CLASS="Code">
<A NAME="pgfId-164282"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164283"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164284"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164285"></A>  // Operations from ::Publication</P>
<P CLASS="Code">
<A NAME="pgfId-164286"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164287"></A>  char*</P>
<P CLASS="Code">
<A NAME="pgfId-164288"></A>  Publication_exec_i::text ()</P>
<P CLASS="Code">
<A NAME="pgfId-164290"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164291"></A>    ACE_Guard&lt;ACE_Thread_Mutex&gt; guard(this-&gt;lock_);</P>
<P CLASS="Code">
<A NAME="pgfId-164292"></A>    return CORBA::string_dup( this-&gt;text_.c_str() );</P>
<P CLASS="Code">
<A NAME="pgfId-164293"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164294"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164295"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-164296"></A>  Publication_exec_i::text (const char* text)</P>
<P CLASS="Code">
<A NAME="pgfId-164298"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164299"></A>    ACE_Guard&lt;ACE_Thread_Mutex&gt; guard(this-&gt;lock_);</P>
<P CLASS="Code">
<A NAME="pgfId-164300"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164301"></A>    this-&gt;text_ = text;</P>
<P CLASS="Code">
<A NAME="pgfId-164302"></A>    ACE_DEBUG((LM_INFO, ACE_TEXT(&quot;publication text changed to %C\n&quot;), text ));</P>
<P CLASS="Code">
<A NAME="pgfId-164303"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164304"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164305"></A>  CORBA::UShort</P>
<P CLASS="Code">
<A NAME="pgfId-164306"></A>  Publication_exec_i::period ()</P>
<P CLASS="Code">
<A NAME="pgfId-164308"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164309"></A>    ACE_Guard&lt;ACE_Thread_Mutex&gt; guard(this-&gt;lock_);</P>
<P CLASS="Code">
<A NAME="pgfId-164310"></A>    return this-&gt;period_;</P>
<P CLASS="Code">
<A NAME="pgfId-164311"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164312"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164313"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-164314"></A>  Publication_exec_i::period (CORBA::UShort period)</P>
<P CLASS="Code">
<A NAME="pgfId-164316"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164317"></A>    ACE_Guard&lt;ACE_Thread_Mutex&gt; guard( this-&gt;lock_ );</P>
<P CLASS="Code">
<A NAME="pgfId-164318"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164319"></A>    if ( period &gt; 0 ) {</P>
<P CLASS="Code">
<A NAME="pgfId-164320"></A>      this-&gt;period_ = period;</P>
<P CLASS="Code">
<A NAME="pgfId-164321"></A>      ACE_DEBUG((LM_INFO, </P>
<P CLASS="Code">
<A NAME="pgfId-164322"></A>                 ACE_TEXT(&quot;publication period changed to %d seconds\n&quot;), period ));</P>
<P CLASS="Code">
<A NAME="pgfId-164323"></A>    } else {</P>
<P CLASS="Code">
<A NAME="pgfId-164324"></A>      ACE_DEBUG((LM_INFO, </P>
<P CLASS="Code">
<A NAME="pgfId-164325"></A>                 ACE_TEXT(&quot;ignoring a negative period of %d\n&quot;), period ));</P>
<P CLASS="Code">
<A NAME="pgfId-164326"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-164327"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164328"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-164329"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164330"></A>The <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-266472"></A>executor contains text and a publication period. Because the client may change either the text or publication period, we protect both with a mutex lock. The constructor sets the text and period values. The <A NAME="marker-275490"></A>attribute accessors and modifiers are straightforward, protecting those values with the mutex lock. The period modifier ensures that the new period is a positive number.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-164331"></A>The History <A NAME="marker-262766"></A>Facet <A NAME="marker-266479"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-164332"></A>The Messenger component stores the messages that it <A NAME="marker-265031"></A>publishes in a <EM CLASS="Code">
History</EM>
 <A NAME="marker-266493"></A>executor. The <EM CLASS="Code">
History</EM>
 executor contains an STL list of published <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265722"></A>events. We protect access to the list with an <EM CLASS="Code">
ACE_Thread_Mutex</EM>
 lock because multiple threads might add to and query the <EM CLASS="Code">
History</EM>
 list simultaneously. We must assume that simultaneous access will happen.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164333"></A>Recall that the <EM CLASS="Code">
History</EM>
 IDL interface is as follows, where <EM CLASS="Code">
Message</EM>
 is an <A NAME="marker-265884"></A>event type:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164334"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164335"></A>#include &lt;Message.idl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-164336"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164337"></A>interface History {</P>
<P CLASS="Code">
<A NAME="pgfId-164338"></A>  Messages get_all();</P>
<P CLASS="Code">
<A NAME="pgfId-164339"></A>  Message get_latest();</P>
<P CLASS="Code">
<A NAME="pgfId-164340"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-164341"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164342"></A>The CIDL-generated <EM CLASS="Code">
History</EM>
 <A NAME="marker-266501"></A>executor implementation follows, with our changes in bold.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164343"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164344"></A>#include &quot;Messenger_svnt.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164345"></A>#include &quot;Messenger_exec_export.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164346"></A>#include &quot;tao/LocalObject.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164347"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164348"></A>#include &lt;list&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-164349"></A>#include &lt;ace/Thread_Mutex.h&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-164350"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164351"></A>namespace Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164352"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164353"></A>  class MESSENGER_EXEC_Export History_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164354"></A>  : public virtual ::CCM_History,</P>
<P CLASS="Code">
<A NAME="pgfId-164355"></A>    public virtual ::CORBA::LocalObject</P>
<P CLASS="Code">
<A NAME="pgfId-164356"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164357"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-164358"></A>    History_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164359"></A>    virtual ~History_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164360"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164361"></A>    // Operations from ::History</P>
<P CLASS="Code">
<A NAME="pgfId-164362"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164363"></A>    virtual ::Messages* get_all ();</P>
<P CLASS="Code">
<A NAME="pgfId-164365"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164366"></A>    virtual ::Message* get_latest ();</P>
<P CLASS="Code">
<A NAME="pgfId-164368"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164369"></A>    void add(::Message* message);</P>
<P CLASS="Code">
<A NAME="pgfId-164370"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164371"></A>  private:</P>
<P CLASS="Code">
<A NAME="pgfId-164372"></A>    ACE_Thread_Mutex lock_;</P>
<P CLASS="Code">
<A NAME="pgfId-164373"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164374"></A>    typedef std::list&lt;::Message_var&gt; MessageList;</P>
<P CLASS="Code">
<A NAME="pgfId-164375"></A>    MessageList messages_;</P>
<P CLASS="Code">
<A NAME="pgfId-164376"></A>  };</P>
<P CLASS="Code">
<A NAME="pgfId-164377"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-164378"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164379"></A>We add a mutex lock and an STL <EM CLASS="Code">
list</EM>
 of messages as private class <A NAME="marker-275496"></A>attributes. The lock protects the message list from simultaneous access by multiple threads. The STL list stores <EM CLASS="Code">
Message_var</EM>
s to properly handle reference counting and memory ownership. The Messenger component uses the public <EM CLASS="Code">
add()</EM>
 method to add messages to the history as it <A NAME="marker-265037"></A>publishes them.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164380"></A>The <EM CLASS="Code">
History</EM>
 <A NAME="marker-266508"></A>executor implementation follows. As always, changes to the CIDL-generated default executor implementation code are in bold. Comments are interspersed with the code.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164381"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164382"></A>namespace Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164383"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164384"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164385"></A>  // Facet Executor Implementation Class:   History_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164386"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164387"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164388"></A>  History_exec_i::History_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-164389"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164390"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164391"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164392"></A>  History_exec_i::~History_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-164393"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164394"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164395"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164396"></A>  // Operations from ::History</P>
<P CLASS="Code">
<A NAME="pgfId-164397"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164398"></A>The implementation of the history’s <EM CLASS="Code">
get_all()</EM>
 operation is the most challenging. It converts the STL list of <EM CLASS="Code">
Message_var</EM>
s into an IDL sequence of <EM CLASS="Code">
Messages</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164399"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164400"></A>  ::Messages* </P>
<P CLASS="Code">
<A NAME="pgfId-164401"></A>  History_exec_i::get_all ()</P>
<P CLASS="Code">
<A NAME="pgfId-164403"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164404"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164405"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164406"></A>    ACE_Guard&lt;ACE_Thread_Mutex&gt; guard(this-&gt;lock_);</P>
<P CLASS="Code">
<A NAME="pgfId-164407"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164408"></A>    ACE_DEBUG((LM_INFO, ACE_TEXT(&quot;History_i::get_all\n&quot;) ));</P>
<P CLASS="Code">
<A NAME="pgfId-164409"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164410"></A>    // create a Messages sequence, set its length</P>
<P CLASS="Code">
<A NAME="pgfId-164411"></A>    ::Messages* retval = new ::Messages();</P>
<P CLASS="Code">
<A NAME="pgfId-164412"></A>    retval-&gt;length( this-&gt;messages_.size() );</P>
<P CLASS="Code">
<A NAME="pgfId-292249"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-292250"></A>     // iterate through the MessageList, copying messages into the return sequence</P>
<P CLASS="Code">
<A NAME="pgfId-292251"></A>    CORBA::ULong i = 0;</P>
<P CLASS="Code">
<A NAME="pgfId-164416"></A>    for ( MessageList::iterator messageItr = this-&gt;messages_.begin();</P>
<P CLASS="Code">
<A NAME="pgfId-164417"></A>          messageItr != this-&gt;messages_.end(); </P>
<P CLASS="Code">
<A NAME="pgfId-164418"></A>          ++messageItr ) </P>
<P CLASS="Code">
<A NAME="pgfId-292307"></A>      {</P>
<P CLASS="Code">
<A NAME="pgfId-292309"></A>        // because the MessageList contains Message_vars, reference counting</P>
<P CLASS="Code">
<A NAME="pgfId-164421"></A>        // upon assignment into the sequence is handled properly for us.</P>
<P CLASS="Code">
<A NAME="pgfId-164422"></A>        (*retval)[i++] = *messageItr;</P>
<P CLASS="Code">
<A NAME="pgfId-164423"></A>      }</P>
<P CLASS="Code">
<A NAME="pgfId-164424"></A>    return retval;</P>
<P CLASS="Code">
<A NAME="pgfId-164425"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164426"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164427"></A>The <EM CLASS="Code">
get_all()</EM>
 operation creates a new <EM CLASS="Code">
Messages</EM>
 sequence, setting its length. It then iterates through the internal STL list of <EM CLASS="Code">
Message_var</EM>
, adding each <EM CLASS="Code">
Message</EM>
 to the sequence. Because the STL list stores <EM CLASS="Code">
Message_var</EM>
s the assignment of each Message from the STL list to the sequence handles memory management properly for us by incrementing the reference count on each returned <EM CLASS="Code">
Message</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164428"></A>The <EM CLASS="Code">
get_latest()</EM>
 operation simply retrieves the last <EM CLASS="Code">
Message</EM>
 added to the list and returns it.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164429"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164430"></A>  ::Message*</P>
<P CLASS="Code">
<A NAME="pgfId-164431"></A>  History_exec_i::get_latest ()</P>
<P CLASS="Code">
<A NAME="pgfId-164433"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164434"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164435"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164436"></A>    ACE_Guard&lt;ACE_Thread_Mutex&gt; guard(this-&gt;lock_);</P>
<P CLASS="Code">
<A NAME="pgfId-164437"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164438"></A>    ACE_DEBUG((LM_INFO, ACE_TEXT(&quot;History_i::get_latest\n&quot;) ));</P>
<P CLASS="Code">
<A NAME="pgfId-164439"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164440"></A>    // just get the last message from the history.  because the MessageList</P>
<P CLASS="Code">
<A NAME="pgfId-164441"></A>    // contains Message_vars, _var to _var assigmnent handles the reference</P>
<P CLASS="Code">
<A NAME="pgfId-164442"></A>    // counting properly for us.</P>
<P CLASS="Code">
<A NAME="pgfId-164443"></A>    ::Message_var retval = this-&gt;messages_.back();</P>
<P CLASS="Code">
<A NAME="pgfId-164444"></A>    return retval._retn();</P>
<P CLASS="Code">
<A NAME="pgfId-164445"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164446"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164447"></A>We extract the last <EM CLASS="Code">
Message</EM>
 into a <EM CLASS="Code">
Message_var</EM>
 and return it with the <EM CLASS="Code">
_retn()</EM>
<A NAME="marker-273014"></A> operation to handle the reference counting of the Message properly. We give up ownership of the <EM CLASS="Code">
Message</EM>
 when we return it, but we also want to keep the <EM CLASS="Code">
Message</EM>
 in the internal list. The reference counting handles that for us.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164448"></A>The <EM CLASS="Code">
Messenger</EM>
 calls the local <EM CLASS="Code">
add()</EM>
 method to store published <EM CLASS="Code">
Message</EM>
s.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164449"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164450"></A>  void History_exec_i::add (::Message* message) </P>
<P CLASS="Code">
<A NAME="pgfId-164451"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164452"></A>    ACE_Guard&lt;ACE_Thread_Mutex&gt; guard(lock_);</P>
<P CLASS="Code">
<A NAME="pgfId-164453"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164454"></A>    // bump up the reference count; we don't own the parameter.</P>
<P CLASS="Code">
<A NAME="pgfId-164455"></A>    // the _var in the STL list takes ownership of the &quot;copy&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164456"></A>    message-&gt;_add_ref();</P>
<P CLASS="Code">
<A NAME="pgfId-164457"></A>    this-&gt;messages_.push_back( message );</P>
<P CLASS="Code">
<A NAME="pgfId-164458"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164459"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-164460"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164461"></A>It increments the reference count of the <EM CLASS="Code">
Message</EM>
 and stores it in the class’s STL list. If we do not increment the reference count, then the STL list would attempt to take ownership of a <EM CLASS="Code">
Message</EM>
 that it does not own.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164462"></A>The <EM CLASS="Code">
get_all()</EM>
 and <EM CLASS="Code">
get_latest()</EM>
 operations are exposed to clients through the <EM CLASS="Code">
History</EM>
 interface. The <EM CLASS="Code">
add()</EM>
 method is not part of the IDL interface and is visible only through the Messenger implementation.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-164463"></A>The Messenger Component <A NAME="marker-266517"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-164464"></A>The Messenger component provides the <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, and <EM CLASS="Code">
History</EM>
 <A NAME="marker-262751"></A>facets and <A NAME="marker-265043"></A>publishes <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265707"></A>events. It delegates much of its work to the <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, and <EM CLASS="Code">
History</EM>
 executors.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-164472"></A> The Messenger Component</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-164470"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-15.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-164473"></A>Recall that the Messenger’s IDL specification is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164474"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164475"></A>component Messenger {</P>
<P CLASS="Code">
<A NAME="pgfId-164476"></A>  attribute string subject;</P>
<P CLASS="Code">
<A NAME="pgfId-164477"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164478"></A>  provides Runnable control;</P>
<P CLASS="Code">
<A NAME="pgfId-164479"></A>  provides Publication content;</P>
<P CLASS="Code">
<A NAME="pgfId-164480"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164481"></A>  publishes Message message_publisher;</P>
<P CLASS="Code">
<A NAME="pgfId-164482"></A>  provides History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-164483"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-164484"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164485"></A>home MessengerHome manages Messenger {};</P>
<P CLASS="Code">
<A NAME="pgfId-164486"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164487"></A>The Messenger’s component <A NAME="marker-266535"></A>executor contains a <EM CLASS="Code">
get_&lt;facet_name&gt;()</EM>
 operation for each of its three provided <A NAME="marker-262779"></A>facets to expose the facet to the <A NAME="marker-263771"></A>component container. As a general rule, for each IDL3 statement of the form</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164488"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164489"></A>provides &lt;facet_interface&gt; &lt;facet_name&gt;;</P>
<P CLASS="Code">
<A NAME="pgfId-164490"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164491"></A>the <A NAME="marker-268855"></A>CIDL compiler generates a operation of the form</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164492"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164493"></A>::CCM_&lt;facet_interface&gt;_ptr get_&lt;facet_name&gt;();</P>
<P CLASS="Code">
<A NAME="pgfId-164494"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164495"></A>Thus, the IDL statement</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164496"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164497"></A>provides Publication content;</P>
<P CLASS="Code">
<A NAME="pgfId-164498"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164499"></A>causes the <A NAME="marker-268858"></A>CIDL compiler to generate an operation in the Messenger <A NAME="marker-266542"></A>executor with the signature</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164500"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164501"></A>::CCM_Publication_ptr get_content();</P>
<P CLASS="Code">
<A NAME="pgfId-164502"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164503"></A>The Messenger’s <EM CLASS="Code">
MessengerHome</EM>
 manages the Messenger’s life cycle. The <A NAME="marker-263778"></A>component container creates an instance of the Messenger executor through its <EM CLASS="Code">
MessengerHome</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164504"></A>Recall that the Messenger’s <A NAME="marker-268346"></A>CIDL <A NAME="marker-269685"></A>composition is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164505"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164506"></A>composition session Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164507"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164508"></A>    home executor MessengerHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-164509"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-164510"></A>        implements MessengerHome;</P>
<P CLASS="Code">
<A NAME="pgfId-164511"></A>        manages    Messenger_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-164512"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-164513"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-164514"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164515"></A>The <A NAME="marker-268861"></A>CIDL compiler uses both the Messenger’s IDL interface and its <A NAME="marker-268356"></A>CIDL <A NAME="marker-269693"></A>composition to generate an implementation of its <A NAME="marker-266551"></A>executor. It generates a default Messenger executor with empty implementations of the <EM CLASS="Code">
get_control()</EM>
, <EM CLASS="Code">
get_content()</EM>
, and <EM CLASS="Code">
get_message_history()</EM>
 <A NAME="marker-262791"></A>facet accessors. The class diagram illustrates the <EM CLASS="Code">
Messenger</EM>
 <A NAME="marker-266559"></A>executor class hierarchy.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-164523"></A> Messenger Executor Class Diagram</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-164521"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-16.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-164524"></A>The IDL compiler does not generate a <EM CLASS="Code">
Messenger</EM>
 stub. The <EM CLASS="Code">
Messenger</EM>
 component is not an IDL2 interface. The <A NAME="marker-268864"></A>CIDL compiler generates an abstract <A NAME="marker-266567"></A>executor base class, <EM CLASS="Code">
CCM_Messenger</EM>
, just as it did for the <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-262798"></A>facet. The CIDL compiler also generates a <EM CLASS="Code">
Messenger_exec</EM>
 class that identifies the <EM CLASS="Code">
Messenger</EM>
 as a session component. A session component exports transient object references and is responsible for managing its own persistent state if it has any.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164525"></A>The <A NAME="marker-268868"></A>CIDL compiler optionally generates an empty <A NAME="marker-266574"></A>executor implementation, <EM CLASS="Code">
Messenger_exec_i</EM>
. The CIDL compiler generates a default constructor, a destructor, and a virtual method for each of the <EM CLASS="Code">
Messenger</EM>
’s <A NAME="marker-262805"></A>facets.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164526"></A>The <A NAME="marker-266581"></A>executor implementation class also inherits from <EM CLASS="Code">
::CORBA::LocalObject</EM>
, marking the <EM CLASS="Code">
Messenger_exec_i</EM>
 as a <EM CLASS="Code">
CORBA::LocalObject</EM>
 and allowing the <A NAME="marker-263785"></A>component container to manage the executor’s memory through reference counting.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164527"></A>The CIDL-generated <A NAME="marker-266593"></A>executor implementation is as follows; as always, our changes are in bold. Comments are interspersed through the class definition.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164528"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164529"></A>#include &quot;Messenger_svnt.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164530"></A>#include &quot;Messenger_exec_export.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164531"></A>#include &quot;tao/LocalObject.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164532"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164533"></A>#include &lt;string&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-164534"></A>#include &lt;ace/Task.h&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-164535"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164536"></A>namespace Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164537"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164538"></A>  // forward declarations for executor implementations referenced</P>
<P CLASS="Code">
<A NAME="pgfId-164539"></A>  // in the Messenger_exec_i class definition</P>
<P CLASS="Code">
<A NAME="pgfId-164540"></A>  class Runnable_exec_i;</P>
<P CLASS="Code">
<A NAME="pgfId-164541"></A>  class Publication_exec_i;</P>
<P CLASS="Code">
<A NAME="pgfId-164542"></A>  class History_exec_i;</P>
<P CLASS="Code">
<A NAME="pgfId-164543"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164544"></A>The Messenger <A NAME="marker-266601"></A>executor is an active object, <A NAME="marker-265057"></A>publishing messages in its own thread. It inherits from <EM CLASS="Code">
ACE_Task_Base</EM>
 to realize the active object behavior. There will be more on the implications of this later.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164545"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164546"></A>  class MESSENGER_EXEC_Export Messenger_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164547"></A>    : public virtual Messenger_Exec, </P>
<P CLASS="Code">
<A NAME="pgfId-164548"></A>      public virtual ::CORBA::LocalObject,</P>
<P CLASS="Code">
<A NAME="pgfId-164549"></A>      public virtual ACE_Task_Base</P>
<P CLASS="Code">
<A NAME="pgfId-164553"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164554"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-164555"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164556"></A>The <A NAME="marker-268872"></A>CIDL compiler generates a default constructor and destructor. There is no reason to change the signatures of these methods.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164557"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164558"></A>    Messenger_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164559"></A>    virtual ~Messenger_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164560"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164561"></A>The <A NAME="marker-268875"></A>CIDL compiler generates an empty accessor and modifier for the <EM CLASS="Code">
subject</EM>
 <A NAME="marker-275502"></A>attribute.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164562"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-287159"></A>    virtual char* subject ();</P>
<P CLASS="Code">
<A NAME="pgfId-287161"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-287162"></A>    virtual void subject (const char* subject);</P>
<P CLASS="Code">
<A NAME="pgfId-164568"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164569"></A>The <A NAME="marker-268878"></A>CIDL compiler generates a <EM CLASS="Code">
get_</EM>
 operation for each of the Messenger’s three provided <A NAME="marker-262812"></A>facets.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164570"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164571"></A>    virtual ::CCM_Runnable_ptr get_control ();</P>
<P CLASS="Code">
<A NAME="pgfId-164573"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164574"></A>    virtual ::CCM_Publication_ptr get_content ();</P>
<P CLASS="Code">
<A NAME="pgfId-164576"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164577"></A>    virtual ::CCM_History_ptr get_message_history ();</P>
<P CLASS="Code">
<A NAME="pgfId-164579"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164580"></A>The Messenger has three <A NAME="marker-262820"></A>facets: a <EM CLASS="Code">
Runnable</EM>
 facet called <EM CLASS="Code">
control</EM>
, a <EM CLASS="Code">
Publication</EM>
 facet called <EM CLASS="Code">
content</EM>
, and a <EM CLASS="Code">
History</EM>
 facet called <EM CLASS="Code">
message_history</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164581"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164582"></A>    // Operations from Components::SessionComponent</P>
<P CLASS="Code">
<A NAME="pgfId-164583"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164584"></A>The <A NAME="marker-268881"></A>CIDL compiler generates a callback operation to set the component’s <EM CLASS="Emphasis">
session context. It generates a session context class that is specific to the component type. The </EM>
<A NAME="marker-263792"></A><EM CLASS="Emphasis">
component container instantiates and sets the component instance’s session context at application startup.</EM>
</LI>
<LI CLASS="Body">
<A NAME="pgfId-217616"></A><EM CLASS="Emphasis">
The session context contains methods that enable the component to interact with the other components to which it is connected. Contexts are the glue that plug collaborating components together.</EM>
 As we’ll see later, the Messenger component <A NAME="marker-265063"></A>publishes <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265701"></A>events to interested consumers through its context.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164585"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164586"></A>    virtual void set_session_context (::Components::SessionContext_ptr ctx);</P>
<P CLASS="Code">
<A NAME="pgfId-164588"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164589"></A>The <A NAME="marker-263799"></A>component container calls <EM CLASS="Code">
set_session_context()</EM>
<A NAME="marker-273025"></A> after it instantiates the component <A NAME="marker-266608"></A>executor instance. The <A NAME="marker-268884"></A>CIDL compiler also generates a private class member called <EM CLASS="Code">
context_</EM>
 to store the context and generates the implementation of the <EM CLASS="Code">
set_session_context()</EM>
<A NAME="marker-273581"></A> operation. No work is required on the part of the component developer.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164590"></A>The <A NAME="marker-268887"></A>CIDL compiler generates three callback operations through which the <A NAME="marker-263811"></A>component container indicates when the component is being activated, passivated, or removed.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164591"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164592"></A>    virtual void ccm_activate ();</P>
<P CLASS="Code">
<A NAME="pgfId-164594"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164595"></A>    virtual void ccm_passivate ();</P>
<P CLASS="Code">
<A NAME="pgfId-164597"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164598"></A>    virtual void ccm_remove ();</P>
<P CLASS="Code">
<A NAME="pgfId-164600"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164601"></A>The <A NAME="marker-263818"></A>component container calls <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273029"></A> to notify component that it has been activated. The <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273206"></A> call completes before any other component operations are invoked. The component <A NAME="marker-266615"></A>executor may perform its initialization in <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273211"></A>. The component developer can assume that the session context has been initialized when the <A NAME="marker-263825"></A>component container calls <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273216"></A>. The Messenger’s implementation of <EM CLASS="Code">
ccm_activate() </EM>
<A NAME="marker-273221"></A>calls <EM CLASS="Code">
ACE_Task_Base::activate()</EM>
<A NAME="marker-273370"></A> to launch a message-publishing thread.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164602"></A>The <A NAME="marker-263832"></A>component container calls <EM CLASS="Code">
ccm_passivate()</EM>
<A NAME="marker-273226"></A> to notify the component that it has been deactivated. Here, the component <A NAME="marker-266622"></A>executor should release any resources acquired in <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273192"></A>. The <A NAME="marker-263839"></A>component container then calls <EM CLASS="Code">
ccm_remove()</EM>
<A NAME="marker-273295"></A> when the component executor is about to be destroyed. The component developer can assume that the session context is still available when the <A NAME="marker-263846"></A>component container calls <EM CLASS="Code">
ccm_passivate()</EM>
<A NAME="marker-273233"></A> or <EM CLASS="Code">
ccm_remove()</EM>
<A NAME="marker-273266"></A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164603"></A>The <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273199"></A>, <EM CLASS="Code">
ccm_passivate()</EM>
<A NAME="marker-273033"></A>, and <EM CLASS="Code">
ccm_remove()</EM>
<A NAME="marker-273038"></A> operations are required by the <A NAME="marker-261284"></A>OMG CORBA Component Model specification.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164613"></A>&nbsp;</LI>
<LI CLASS="Body">
<A NAME="pgfId-164614"></A>The <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273074"></A> method is an implementation detail that is specific to our implementation of the <EM CLASS="Code">
Messenger</EM>
 <A NAME="marker-266630"></A>executor.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164615"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164616"></A>    virtual int svc();</P>
<P CLASS="Code">
<A NAME="pgfId-164617"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164618"></A>It is overridden from the inherited <EM CLASS="Code">
ACE_Task_Base</EM>
<A NAME="marker-273080"></A> class. Our implementation of <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273076"></A> calls <EM CLASS="Code">
ACE_Task_Base::activate() </EM>
<A NAME="marker-273387"></A>to launch a thread that executes the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273440"></A> method. The implementation of the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273447"></A> method <A NAME="marker-265069"></A>publishes <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265692"></A>events to interested consumers.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164619"></A>The <A NAME="marker-268890"></A>CIDL compiler automatically generates a <EM CLASS="Code">
context_</EM>
 class member.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164620"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-292360"></A>  private:</P>
<P CLASS="Code">
<A NAME="pgfId-292361"></A>    ::CCM_Messenger_Context_var context_;</P>
<P CLASS="Code">
<A NAME="pgfId-292362"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-273088"></A>The <A NAME="marker-273087"></A>component container calls <EM CLASS="Code">
set_session_context()</EM>
<A NAME="marker-273093"></A> to set the context when it initializes the component <A NAME="marker-273089"></A>executor. The Messenger publishes its <EM CLASS="Code">
Message</EM>
 <A NAME="marker-273090"></A>events through the context.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164625"></A>The component developer may add additional class members required to implement the component <A NAME="marker-266644"></A>executor. We add several.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164626"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164627"></A>  private:</P>
<P CLASS="Code">
<A NAME="pgfId-164628"></A>    Runnable_exec_i*    control_;</P>
<P CLASS="Code">
<A NAME="pgfId-164629"></A>    Publication_exec_i* content_;</P>
<P CLASS="Code">
<A NAME="pgfId-164630"></A>    History_exec_i*     history_;</P>
<P CLASS="Code">
<A NAME="pgfId-164631"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164632"></A>    std::string       subject_;</P>
<P CLASS="Code">
<A NAME="pgfId-164633"></A>    const std::string user_;</P>
<P CLASS="Code">
<A NAME="pgfId-164634"></A> };</P>
<P CLASS="Code">
<A NAME="pgfId-164635"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-164636"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164637"></A>The private <EM CLASS="Code">
control_</EM>
, <EM CLASS="Code">
content_</EM>
, and <EM CLASS="Code">
history_</EM>
 class members will be initialized by the user’s code to contain pointers to the <A NAME="marker-262830"></A>facet executors for the <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, and <EM CLASS="Code">
History</EM>
 facets of the Messenger component. The <EM CLASS="Code">
user_</EM>
 class member is a string that contains a user name that the Messenger embeds into each <EM CLASS="Code">
Message</EM>
 it <A NAME="marker-265075"></A>publishes.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164638"></A>The Messenger <A NAME="marker-266651"></A>executor implementation follows. As always, changes to the CIDL-generated default executor implementation code are in bold. Comments are interspersed with the code.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164639"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164640"></A>#include &quot;Messenger_exec_i.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164641"></A>#include &quot;ciao/CIAO_common.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164642"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164643"></A>The Messenger <A NAME="marker-266659"></A>executor includes the executor class definitions for its <EM CLASS="Code">
History</EM>
, <EM CLASS="Code">
Runnable</EM>
, and <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-262838"></A>facets.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164644"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164645"></A>#include &lt;ace/OS.h&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-164646"></A>#include &quot;History_exec_i.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164647"></A>#include &quot;Runnable_exec_i.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164648"></A>#include &quot;Publication_exec_i.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-164649"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164650"></A>namespace Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164651"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164652"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164653"></A>  // Component Executor Implementation Class:   Messenger_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164654"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164655"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164656"></A>The constructor creates executors for each of the <EM CLASS="Code">
Messenger</EM>
’s three <A NAME="marker-262845"></A>facets and initializes a “username.”</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164657"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164658"></A>  Messenger_exec_i::Messenger_exec_i () </P>
<P CLASS="Code">
<A NAME="pgfId-164659"></A>    : subject_(&quot;Test Subject&quot;),</P>
<P CLASS="Code">
<A NAME="pgfId-164660"></A>      user_( &quot;ciao_user&quot; )</P>
<P CLASS="Code">
<A NAME="pgfId-164661"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-251212"></A>    // initialize user-defined data members</P>
<P CLASS="Code">
<A NAME="pgfId-164662"></A>    this-&gt;control_ = new Runnable_exec_i();</P>
<P CLASS="Code">
<A NAME="pgfId-164663"></A>    this-&gt;history_ = new History_exec_i();</P>
<P CLASS="Code">
<A NAME="pgfId-164664"></A>    this-&gt;content_ = new Publication_exec_i( </P>
<P CLASS="Code">
<A NAME="pgfId-164665"></A>      &quot;Test Subject&quot;,</P>
<P CLASS="Code">
<A NAME="pgfId-164666"></A>      &quot;The quick brown fox jumped over the lazy dog&quot;,</P>
<P CLASS="Code">
<A NAME="pgfId-164667"></A>      2 );</P>
<P CLASS="Code">
<A NAME="pgfId-164668"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164669"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164670"></A>The destructor releases the memory for the Messenger’s three <A NAME="marker-262851"></A>facet executors. Because an <A NAME="marker-266668"></A>executor is reference counted, we call <EM CLASS="Code">
_remove_ref()</EM>
<A NAME="marker-273097"></A> to release the memory of the executor rather than use the C++ <EM CLASS="Code">
delete</EM>
 operation.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164671"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164672"></A>  Messenger_exec_i::~Messenger_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-164673"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164674"></A>    this-&gt;control_-&gt;_remove_ref();</P>
<P CLASS="Code">
<A NAME="pgfId-164675"></A>    this-&gt;history_-&gt;_remove_ref();</P>
<P CLASS="Code">
<A NAME="pgfId-164676"></A>    this-&gt;content_-&gt;_remove_ref();</P>
<P CLASS="Code">
<A NAME="pgfId-164677"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164678"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164679"></A>The bulk of the Messenger’s logic is in the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273454"></A> method.</P>
<P CLASS="Code">
<A NAME="pgfId-164680"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164681"></A>  int Messenger_exec_i::svc() {</P>
<P CLASS="Code">
<A NAME="pgfId-164682"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164683"></A>    ACE_DEBUG((LM_INFO, ACE_TEXT(&quot;svc()\n&quot;)));</P>
<P CLASS="Code">
<A NAME="pgfId-164684"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164685"></A>    while (1)</P>
<P CLASS="Code">
<A NAME="pgfId-164686"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-164687"></A>      ACE_OS::sleep( this-&gt;content_-&gt;period() );</P>
<P CLASS="Code">
<A NAME="pgfId-164688"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164689"></A>      // get the run_lock from the Runnable executor; we have an</P>
<P CLASS="Code">
<A NAME="pgfId-164690"></A>      // agreement with the Runnable executor that we must wait for</P>
<P CLASS="Code">
<A NAME="pgfId-251215"></A>      // the run_lock to be released before we publish.</P>
<P CLASS="Code">
<A NAME="pgfId-164692"></A>      ACE_Guard&lt;ACE_Thread_Mutex&gt; guard( this-&gt;control_-&gt;get_run_lock() );</P>
<P CLASS="Code">
<A NAME="pgfId-164693"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164694"></A>      // create a message to publish</P>
<P CLASS="Code">
<A NAME="pgfId-164695"></A>      ::Message_var msg = new ::OBV_Message();</P>
<P CLASS="Code">
<A NAME="pgfId-164696"></A>      msg-&gt;subject( this-&gt;subject() );</P>
<P CLASS="Code">
<A NAME="pgfId-164697"></A>      msg-&gt;text( this-&gt;content_-&gt;text() );</P>
<P CLASS="Code">
<A NAME="pgfId-164698"></A>      msg-&gt;user( CORBA::string_dup( this-&gt;user_.c_str() ) );</P>
<P CLASS="Code">
<A NAME="pgfId-164699"></A>        </P>
<P CLASS="Code">
<A NAME="pgfId-164700"></A>      // add the message to the message history</P>
<P CLASS="Code">
<A NAME="pgfId-164701"></A>      this-&gt;history_-&gt;add( msg.in() );</P>
<P CLASS="Code">
<A NAME="pgfId-164702"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164703"></A>      ACE_DEBUG((LM_INFO, </P>
<P CLASS="Code">
<A NAME="pgfId-164704"></A>                 ACE_TEXT(&quot;Messenger_exec_i::svc: publishing message\n&quot;) ));</P>
<P CLASS="Code">
<A NAME="pgfId-164705"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164706"></A>      // publish to all interested consumers</P>
<P CLASS="Code">
<A NAME="pgfId-164707"></A>      this-&gt;context_-&gt;push_message_publisher( msg.in() );</P>
<P CLASS="Code">
<A NAME="pgfId-164708"></A>      </P>
<P CLASS="Code">
<A NAME="pgfId-164709"></A>      ACE_DEBUG((LM_INFO, </P>
<P CLASS="Code">
<A NAME="pgfId-164710"></A>        ACE_TEXT(&quot;Published Message on subject %C\n   User %C\n   Text %C\n&quot;),</P>
<P CLASS="Code">
<A NAME="pgfId-164711"></A>        msg-&gt;subject(),</P>
<P CLASS="Code">
<A NAME="pgfId-164712"></A>        msg-&gt;user(),</P>
<P CLASS="Code">
<A NAME="pgfId-164713"></A>        msg-&gt;text() ));</P>
<P CLASS="Code">
<A NAME="pgfId-164714"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-164715"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164716"></A>    // not reached</P>
<P CLASS="Code">
<A NAME="pgfId-218233"></A>    return 0;</P>
<P CLASS="Code">
<A NAME="pgfId-164718"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164719"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164720"></A>We override the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273463"></A> method from the inherited <EM CLASS="Code">
ACE_Task_Base</EM>
<A NAME="marker-273098"></A> class. Our implementation of <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273099"></A> calls the <EM CLASS="Code">
ACE_Task_Base::activate()</EM>
<A NAME="marker-273395"></A> method which launches the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273470"></A> method in a new thread. This method performs the bulk of the Messenger’s work, looping continuously and <A NAME="marker-265081"></A>publishing messages.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164721"></A>First, the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273477"></A> method sleeps for the period of time defined by the <EM CLASS="Code">
period</EM>
 <A NAME="marker-275508"></A>attribute of the Messenger’s <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-266678"></A>executor. Next, the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273484"></A> method attempts to acquire a lock from its <EM CLASS="Code">
Runnable</EM>
 executor. The Messenger executor and the <EM CLASS="Code">
Runnable</EM>
 executor have an agreement that the Messenger will not publish messages unless it can acquire the <EM CLASS="Code">
Runnable</EM>
 executor’s <EM CLASS="Code">
ACE_Thread_Mutex</EM>
 lock. This permits the <EM CLASS="Code">
Runnable</EM>
 executor to start and stop message publication.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164722"></A>Once the Messenger acquires the <EM CLASS="Code">
Runnable</EM>
’s lock, it <A NAME="marker-265087"></A>publishes a message through its <EM CLASS="Code">
context_</EM>
. The context acts like a proxy representing all interested consumers.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164723"></A>The <A NAME="marker-268893"></A>CIDL compiler generates an empty accessor and modifier for the <EM CLASS="Code">
subject</EM>
 <A NAME="marker-275514"></A>attribute. We add an implementation to each.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164724"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164725"></A>  char*</P>
<P CLASS="Code">
<A NAME="pgfId-164726"></A>  Messenger_exec_i::subject ()</P>
<P CLASS="Code">
<A NAME="pgfId-164728"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164729"></A>    return CORBA::string_dup( this-&gt;subject_.c_str() );</P>
<P CLASS="Code">
<A NAME="pgfId-164730"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164731"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164732"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-287404"></A>  Messenger_exec_i::subject (const char* subject)</P>
<P CLASS="Code">
<A NAME="pgfId-287406"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-287407"></A>    this-&gt;subject_ = CORBA::string_dup( subject );</P>
<P CLASS="Code">
<A NAME="pgfId-164737"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164738"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164739"></A>The <A NAME="marker-268896"></A>CIDL compiler generates an empty implementation of each of the <EM CLASS="Code">
get_content()</EM>
, <EM CLASS="Code">
get_control()</EM>
, and <EM CLASS="Code">
get_message_history()</EM>
 <A NAME="marker-262858"></A>facet accessor operations. We modify each to return the appropriate facet <A NAME="marker-266690"></A>executor, incrementing its reference count before returning it.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164740"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164741"></A>  ::CCM_Publication_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-164742"></A>  Messenger_exec_i::get_content ()</P>
<P CLASS="Code">
<A NAME="pgfId-164744"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164745"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164746"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164747"></A>    // bump up ref count because we give up ownership when we return this</P>
<P CLASS="Code">
<A NAME="pgfId-164748"></A>    this-&gt;content_-&gt;_add_ref();</P>
<P CLASS="Code">
<A NAME="pgfId-164749"></A>    return this-&gt;content_;</P>
<P CLASS="Code">
<A NAME="pgfId-164750"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164751"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164752"></A>The <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-262866"></A>facet controls the Messenger’s message text and publication period. It is important to increment the reference count before returning the facet <A NAME="marker-266697"></A>executor because we give up ownership of the facet executor when we return it. This behavior is consistent with the CORBA’s memory management rules. Notice that we do not need to convert the executor to an object reference; we merely return it an allow the <A NAME="marker-263874"></A>component container to do the heavy lifting.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164753"></A>The implementation of the <EM CLASS="Code">
get_control()</EM>
 <A NAME="marker-262875"></A>facet accessor is nearly identical...</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164754"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164755"></A>  ::CCM_Runnable_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-164756"></A>  Messenger_exec_i::get_control ()</P>
<P CLASS="Code">
<A NAME="pgfId-164758"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164759"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164760"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164761"></A>    // bump up ref count because we give up ownership when we return this</P>
<P CLASS="Code">
<A NAME="pgfId-164762"></A>    this-&gt;control_-&gt;_add_ref();</P>
<P CLASS="Code">
<A NAME="pgfId-164763"></A>    return this-&gt;control_;</P>
<P CLASS="Code">
<A NAME="pgfId-164764"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164765"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164766"></A>...as is the implementation of <EM CLASS="Code">
get_message_history()</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164767"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164768"></A>  ::CCM_History_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-164769"></A>  Messenger_exec_i::get_message_history ()</P>
<P CLASS="Code">
<A NAME="pgfId-164771"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164772"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164773"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164774"></A>    // bump up ref count because we give up ownership when we return this</P>
<P CLASS="Code">
<A NAME="pgfId-164775"></A>    this-&gt;history_-&gt;_add_ref();</P>
<P CLASS="Code">
<A NAME="pgfId-164776"></A>    return this-&gt;history_;</P>
<P CLASS="Code">
<A NAME="pgfId-164777"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164778"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164779"></A>The <A NAME="marker-268899"></A>CIDL compiler generates a complete implementation of the <EM CLASS="Code">
set_session_context()</EM>
<A NAME="marker-273100"></A> operation.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164780"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164781"></A>  // Operations from Components::SessionComponent</P>
<P CLASS="Code">
<A NAME="pgfId-164782"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164783"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-164784"></A>  Messenger_exec_i::set_session_context (::Components::SessionContext_ptr ctx)</P>
<P CLASS="Code">
<A NAME="pgfId-164786"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164787"></A>    this-&gt;context_ = ::CCM_Messenger_Context::_narrow (ctx);</P>
<P CLASS="Code">
<A NAME="pgfId-164788"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164789"></A>    if (CORBA::is_nil (this-&gt;context_.in ()))</P>
<P CLASS="Code">
<A NAME="pgfId-164790"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-164791"></A>      throw CORBA::INTERNAL ());</P>
<P CLASS="Code">
<A NAME="pgfId-164792"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-164793"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164794"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164795"></A>The <A NAME="marker-263881"></A>component container calls this operation immediately after it instantiates the Messenger <A NAME="marker-266706"></A>executor. The component container calls <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273101"></A> to notify the component that it has been activated.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164797"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164798"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-164799"></A>  Messenger_exec_i::ccm_activate ()</P>
<P CLASS="Code">
<A NAME="pgfId-164801"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164802"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164803"></A>    ACE_DEBUG((LM_INFO, ACE_TEXT(&quot;Messenger_exec_i::ccm_activate\n&quot;)));</P>
<P CLASS="Code">
<A NAME="pgfId-164804"></A>    this-&gt;activate();</P>
<P CLASS="Code">
<A NAME="pgfId-164805"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164806"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164807"></A>The container does not send any requests to the component until <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273103"></A> completes. This is typically where the component <A NAME="marker-266713"></A>executor initializes itself. The Messenger executor calls the <EM CLASS="Code">
ACE_Task_Base::activate()</EM>
<A NAME="marker-273405"></A> method to spawn a thread running the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273491"></A> method.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164808"></A>The <A NAME="marker-263890"></A>component container calls <EM CLASS="Code">
ccm_passivate()</EM>
<A NAME="marker-273108"></A> to notify the component that it has been deactivated and the component container will call <EM CLASS="Code">
ccm_remove()</EM>
<A NAME="marker-273113"></A> when the component executor is about to be destroyed. Once <EM CLASS="Code">
ccm_passivate()</EM>
<A NAME="marker-273118"></A> is called, the component instance cannot be reactivated.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164809"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164810"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-164811"></A>  Messenger_exec_i::ccm_passivate ()</P>
<P CLASS="Code">
<A NAME="pgfId-164813"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164814"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164815"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164816"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164817"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-164818"></A>  Messenger_exec_i::ccm_remove ()</P>
<P CLASS="Code">
<A NAME="pgfId-164820"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164821"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-164822"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164823"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164824"></A>Typically, a component <A NAME="marker-266722"></A>executor cleans up after itself in <EM CLASS="Code">
ccm_passivate()</EM>
<A NAME="marker-273123"></A>, where it is guaranteed that the <A NAME="marker-263898"></A>container hasn’t started destroying its other component executors yet. Our executor has nothing to clean up.</LI>
<LI CLASS="Body">
<A NAME="pgfId-273142"></A>&nbsp;</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-251229"></A>The MessengerHome <A NAME="marker-267386"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-251230"></A>The <A NAME="marker-268908"></A>CIDL compiler generates an implementation of the Messenger’s <A NAME="marker-267731"></A>home. Recall that the <EM CLASS="Code">
MessengerHome</EM>
’s IDL3 interface is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164844"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164845"></A>component Messenger { ... };</P>
<P CLASS="Code">
<A NAME="pgfId-164846"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164847"></A>home MessengerHome manages Messenger {};</P>
<P CLASS="Code">
<A NAME="pgfId-164848"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164849"></A>and the Messenger’s <A NAME="marker-268382"></A>CIDL <A NAME="marker-269700"></A>composition is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164850"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164851"></A>composition session Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164852"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164853"></A>    home executor MessengerHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-164854"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-164855"></A>        implements MessengerHome;</P>
<P CLASS="Code">
<A NAME="pgfId-164856"></A>        manages    Messenger_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-164857"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-164858"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-164859"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164860"></A>The <A NAME="marker-268911"></A>CIDL compiler generates a complete implementation of the <EM CLASS="Code">
MessengerHome</EM>
 <A NAME="marker-267396"></A>executor and a library entry point function. The <A NAME="marker-263912"></A>component container instantiates the <EM CLASS="Code">
MessengerHome</EM>
 through the entry point function when it dynamically loads the Messenger’s library. It generates the <EM CLASS="Code">
MessengerHome</EM>
 executor in the same file as the Messenger component executor.</LI>
<LI CLASS="Body">
<A NAME="pgfId-274704"></A>The <EM CLASS="Code">
MessengerHome</EM>
 is responsible for creating and destroying instances of the Messenger <A NAME="marker-274705"></A>executor. The <A NAME="marker-274706"></A>component container instantiates the Messenger executor through its <A NAME="marker-274707"></A>home when it activates the Messenger. In our example the component developer does not need to modify any of the generated <EM CLASS="Code">
MessengerHome</EM>
 code nor the library entry point function.</LI>
<LI CLASS="Body">
<A NAME="pgfId-274717"></A>The class diagram illustrates the <EM CLASS="Code">
MessengerHome</EM>
 <A NAME="marker-274708"></A>executor class hierarchy.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-274716"></A> Messenger Home Executor Class Diagram</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-274714"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-17.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-274718"></A>Both the class definition and the implementation of the <EM CLASS="Code">
MessengerHome</EM>
 and its entry point function are as follows. We make no changes to the generated code; thus, nothing is shown in bold. Comments are interspersed.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164872"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164873"></A>namespace CIDL_Messenger_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164874"></A>{</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164875"></A>Like the Messenger <A NAME="marker-266772"></A>executor, the <EM CLASS="Code">
MessengerHome</EM>
 <A NAME="marker-267412"></A>executor inherits from a generated executor base class.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164876"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164877"></A>  class MESSENGER_EXEC_Export MessengerHome_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164878"></A>  : public virtual MessengerHome_Exec,</P>
<P CLASS="Code">
<A NAME="pgfId-164879"></A>    public virtual ::CORBA::LocalObject</P>
<P CLASS="Code">
<A NAME="pgfId-164880"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164881"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164882"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-164883"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164884"></A>The <A NAME="marker-268914"></A>CIDL compiler generates a default constructor and destructor.</P>
<P CLASS="Code">
<A NAME="pgfId-164885"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164886"></A>    MessengerHome_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164887"></A>    virtual ~MessengerHome_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164888"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164889"></A>The <A NAME="marker-268917"></A>CIDL compiler generates a default <EM CLASS="Code">
create()</EM>
<A NAME="marker-273673"></A> operation. The <A NAME="marker-263926"></A>component container calls this <EM CLASS="Code">
create()</EM>
<A NAME="marker-273677"></A> operation to instantiate the Messenger component <A NAME="marker-266781"></A>executor.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164890"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164891"></A>    virtual ::Components::EnterpriseComponent_ptr create ();</P>
<P CLASS="Code">
<A NAME="pgfId-251317"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-251318"></A>  };</P>
<P CLASS="Code">
<A NAME="pgfId-164895"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164896"></A>Finally, the <A NAME="marker-268920"></A>CIDL compiler generates a library entry point function. The <A NAME="marker-263933"></A>component container’s underlying ACE Service Configurator calls this entry point function to instantiate the <EM CLASS="Code">
MessengerHome</EM>
 <A NAME="marker-267418"></A>executor when it dynamically loads the component’s library. The entry point function must have “C” linkage to prevent C++ name mangling. The name of the function is CIAO-specific, but every CCM implementation generates an entry point function with this signature.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164897"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164898"></A>  extern &quot;C&quot; MESSENGER_EXEC_Export ::Components::HomeExecutorBase_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-164899"></A>    create_MessengerHome_Impl (void);</P>
<P CLASS="Code">
<A NAME="pgfId-164900"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-164901"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164902"></A>As you can see, we also make no changes to the generated <EM CLASS="Code">
MessengerHome</EM>
 implementation, which follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164903"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164904"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164905"></A>  // Home Executor Implementation Class:   MessengerHome_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-164906"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-164907"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164908"></A>The <A NAME="marker-268923"></A>CIDL compiler generates a default constructor and an empty destructor. The component developer may modify these. However, if the developer modifies the signature of the constructor, the developer must modify the implementation of the component <A NAME="marker-267774"></A>home’s library entry point function to pass the appropriate constructor arguments. The library entry point function will be shown in a few paragraphs.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164909"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164910"></A>  MessengerHome_exec_i::MessengerHome_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-164911"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164912"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164913"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164914"></A>  MessengerHome_exec_i::~MessengerHome_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-164915"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164916"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164917"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164918"></A>The Messenger’s <A NAME="marker-267786"></A>home has one operation, <EM CLASS="Code">
create()</EM>
<A NAME="marker-273684"></A>. The CIDL-generated implementation of <EM CLASS="Code">
create()</EM>
 simply invokes the Messenger <A NAME="marker-266796"></A>executor’s default constructor.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164919"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164920"></A>  ::Components::EnterpriseComponent_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-164921"></A>  MessengerHome_exec_i::create ()</P>
<P CLASS="Code">
<A NAME="pgfId-164923"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164924"></A>    ::Components::EnterpriseComponent_ptr retval =</P>
<P CLASS="Code">
<A NAME="pgfId-164925"></A>      ::Components::EnterpriseComponent::_nil ();</P>
<P CLASS="Code">
<A NAME="pgfId-164926"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164927"></A>    ACE_NEW_THROW_EX (retval,</P>
<P CLASS="Code">
<A NAME="pgfId-164928"></A>                      Messenger_exec_i,</P>
<P CLASS="Code">
<A NAME="pgfId-164929"></A>                      CORBA::NO_MEMORY ());</P>
<P CLASS="Code">
<A NAME="pgfId-164931"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164932"></A>    return retval;</P>
<P CLASS="Code">
<A NAME="pgfId-164933"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164934"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164935"></A>Finally, the <A NAME="marker-268926"></A>CIDL compiler generates a library entry point function for the Messenger. This function simply creates an instance of the Messenger’s <A NAME="marker-267794"></A>home <A NAME="marker-267425"></A>executor. The <A NAME="marker-263940"></A>component container calls this function to create a <EM CLASS="Code">
MessengerHome</EM>
 when it loads the Messenger’s dynamic library. </LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164936"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164937"></A>  extern &quot;C&quot; MESSENGER_EXEC_Export ::Components::HomeExecutorBase_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-164938"></A>  create_MessengerHome_Impl (void)</P>
<P CLASS="Code">
<A NAME="pgfId-164939"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-164940"></A>    ::Components::HomeExecutorBase_ptr retval =</P>
<P CLASS="Code">
<A NAME="pgfId-164941"></A>      ::Components::HomeExecutorBase::_nil ();</P>
<P CLASS="Code">
<A NAME="pgfId-164942"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164943"></A>    ACE_NEW_RETURN (retval,</P>
<P CLASS="Code">
<A NAME="pgfId-164944"></A>                    MessengerHome_exec_i,</P>
<P CLASS="Code">
<A NAME="pgfId-164945"></A>                    ::Components::HomeExecutorBase::_nil ());</P>
<P CLASS="Code">
<A NAME="pgfId-164946"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164947"></A>    return retval;</P>
<P CLASS="Code">
<A NAME="pgfId-164948"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-164949"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-164950"></A>&nbsp;</P>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-164951"></A>The Receiver Component <A NAME="marker-266810"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-164952"></A>The Receiver component connects to the Messenger component in two ways. First, its <EM CLASS="Code">
message_consumer</EM>
 <A NAME="marker-263294"></A>port connects to the Messenger’s <EM CLASS="Code">
message_publisher</EM>
 port. Second, its <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-264200"></A>receptacle connects to the Messenger’s <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-262882"></A>facet.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-164960"></A> The Receiver Component</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-164958"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-18.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-164961"></A>Recall that the Receiver’s IDL specification is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164962"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164963"></A>component Receiver {</P>
<P CLASS="Code">
<A NAME="pgfId-164964"></A>  consumes Message message_consumer;</P>
<P CLASS="Code">
<A NAME="pgfId-164965"></A>  uses History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-164966"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-164967"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164968"></A>home ReceiverHome manages Receiver {};</P>
<P CLASS="Code">
<A NAME="pgfId-164969"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164970"></A>The Receiver component subscribes to <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265742"></A>events and uses a <EM CLASS="Code">
History</EM>
 <A NAME="marker-262889"></A>facet through which it retrieves a history of messages <A NAME="marker-265093"></A>published. Both of these facets happen to be provided by the Messenger component, but the Receiver does not know that and does not need to know that. In fact, the <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265749"></A>events could be published by several different suppliers without the Receiver being aware of it.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164971"></A>The Receiver’s <EM CLASS="Code">
ReceiverHome</EM>
 manages the Receiver’s life cycle. The <A NAME="marker-263947"></A>component container creates an instance of the Receiver <A NAME="marker-266819"></A>executor through its <EM CLASS="Code">
ReceiverHome</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164972"></A>Recall that the Receiver’s <A NAME="marker-269708"></A>composition is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164973"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164974"></A>composition session Receiver_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-164975"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-164976"></A>    home executor ReceiverHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-164977"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-164978"></A>        implements ReceiverHome;</P>
<P CLASS="Code">
<A NAME="pgfId-164979"></A>        manages    Receiver_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-164980"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-164981"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-164982"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164983"></A>There are many similarities between the Receiver’s <A NAME="marker-266827"></A>executor and the Messenger’s executor. As with the Messenger, the <A NAME="marker-268929"></A>CIDL compiler uses both the Receiver’s IDL interface and its <A NAME="marker-268398"></A>CIDL <A NAME="marker-269716"></A>composition to generate its executor. The CIDL compiler generates a class definition for the Receiver executor, another for the <EM CLASS="Code">
ReceiverHome</EM>
, and a library entry point function. The CIDL compiler generates the Receiver’s executor classes into the <EM CLASS="Code">
Receiver_Impl</EM>
 C++ namespace as specified by the Receiver’s <A NAME="marker-268407"></A>CIDL composition.</LI>
<LI CLASS="Body">
<A NAME="pgfId-164984"></A>The most noticeable difference between the Messenger and the Receiver executors is the Receiver’s message consumption callback operation. As a general rule, an IDL3 statement of the form</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164985"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164986"></A>consumes &lt;event_type&gt; &lt;facet_name&gt;;</P>
<P CLASS="Code">
<A NAME="pgfId-164987"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164988"></A>causes the <A NAME="marker-268934"></A>CIDL compiler to generate a callback operation in the component’s <A NAME="marker-266838"></A>executor of the form:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164989"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164990"></A>virtual void push_&lt;facet_name&gt;( &lt;event_type&gt;* ev );</P>
<P CLASS="Code">
<A NAME="pgfId-164991"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164992"></A>In our example, the IDL statement</P>
<P CLASS="Code">
<A NAME="pgfId-164993"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164994"></A>consumes Message message_consumer;</P>
<P CLASS="Code">
<A NAME="pgfId-164995"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-164996"></A>causes the <A NAME="marker-268937"></A>CIDL compiler to generate a callback operation with the signature</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-164997"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-164998"></A>virtual void push_message_consumer( ::Message* ev);</P>
<P CLASS="Code">
<A NAME="pgfId-164999"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165000"></A>The <A NAME="marker-263954"></A>component container calls this operation when a connected <EM CLASS="Code">
Message</EM>
 supplier (in our case, the Messenger) <A NAME="marker-265099"></A>publishes a <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265758"></A>event. The component container connects the suppliers and consumers dynamically at <A NAME="marker-261182"></A>deployment time.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165001"></A>The CIDL-generated <EM CLASS="Code">
Receiver</EM>
 and <EM CLASS="Code">
ReceiverHome</EM>
 <A NAME="marker-267432"></A>executor implementation class definitions are as follows. We make no changes to the generated Receiver executor class definition. Comments are interspersed.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165002"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165003"></A>#include &quot;Receiver_svnt.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165004"></A>#include &quot;Receiver_exec_export.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165005"></A>#include &quot;tao/LocalObject.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165006"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165007"></A>namespace Receiver_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-165008"></A>{</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165009"></A>The Receiver’s <A NAME="marker-266854"></A>executor implements the abstract executor base class <EM CLASS="Code">
Receiver_exec</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165010"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165011"></A>  class RECEIVER_EXEC_Export Receiver_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-165012"></A>  : public virtual Receiver_Exec,</P>
<P CLASS="Code">
<A NAME="pgfId-165013"></A>    public virtual ::CORBA::LocalObject</P>
<P CLASS="Code">
<A NAME="pgfId-165014"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165015"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165016"></A>The <A NAME="marker-268940"></A>CIDL compiler generates a default constructor and a destructor.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165017"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165018"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-165019"></A>    Receiver_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165020"></A>    virtual ~Receiver_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165021"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165022"></A>The <A NAME="marker-263962"></A>component container calls <EM CLASS="Code">
push_message_consumer()</EM>
 on the Receiver when the Messenger <A NAME="marker-265105"></A>publishes a <EM CLASS="Code">
Message</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165023"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165024"></A>    virtual void push_message_consumer (::Message *ev);</P>
<P CLASS="Code">
<A NAME="pgfId-165026"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165027"></A>Like the Messenger component, the Receiver component has a CIDL-generated <EM CLASS="Code">
set_session_context()</EM>
<A NAME="marker-273591"></A> callback operation. Again, the <A NAME="marker-263969"></A>component container calls this operation after it instantiates the Receiver <A NAME="marker-266862"></A>executor.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165028"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165029"></A>    virtual void set_session_context (::Components::SessionContext_ptr ctx);</P>
<P CLASS="Code">
<A NAME="pgfId-165031"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165032"></A>The <A NAME="marker-268943"></A>CIDL compiler also generates standard <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273154"></A>, <EM CLASS="Code">
ccm_passivate()</EM>
<A NAME="marker-273245"></A>, and <EM CLASS="Code">
ccm_remove()</EM>
<A NAME="marker-273276"></A> operations.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165033"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165034"></A>    virtual void ccm_activate ();</P>
<P CLASS="Code">
<A NAME="pgfId-165036"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165037"></A>    virtual void ccm_passivate ();</P>
<P CLASS="Code">
<A NAME="pgfId-165039"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165040"></A>    virtual void ccm_remove ();</P>
<P CLASS="Code">
<A NAME="pgfId-165048"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165049"></A>Finally, the <A NAME="marker-268946"></A>CIDL compiler generates type-specific context member for the Receiver component.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165050"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165051"></A>  private:</P>
<P CLASS="Code">
<A NAME="pgfId-165052"></A>    ::CCM_Receiver_Context_var context_;</P>
<P CLASS="Code">
<A NAME="pgfId-165053"></A>  };</P>
<P CLASS="Code">
<A NAME="pgfId-165054"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165055"></A>Our Receiver <A NAME="marker-266869"></A>executor has no state nor private methods, so we make no changes to the CIDL-generated Receiver executor class definition.</LI>
<LI CLASS="Body">
<A NAME="pgfId-219726"></A>The <A NAME="marker-268949"></A>CIDL compiler also generates an implementation of the Receiver <A NAME="marker-266877"></A>executor. The bulk of the work in implementing the Receiver executor is in the <EM CLASS="Code">
push_message_consumer()</EM>
<A NAME="marker-273701"></A> operation. The <EM CLASS="Code">
push_message_consumer()</EM>
<A NAME="marker-273704"></A> implementation uses the Receiver’s <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-262899"></A>facet to get a list of all <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265765"></A>events <A NAME="marker-265112"></A>published. The Receiver accesses the <EM CLASS="Code">
message_history</EM>
 facet through its session context.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165058"></A>As a general rule, an IDL3 statement of the form</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165059"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165060"></A>uses &lt;facet_interface&gt; &lt;facet_name&gt;;</P>
<P CLASS="Code">
<A NAME="pgfId-165061"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165062"></A>is mapped to a C++ function in the component’s session context with the signature</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165063"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165064"></A>::&lt;facet_interface&gt;_ptr get_connection_&lt;facet_name&gt;();</P>
<P CLASS="Code">
<A NAME="pgfId-165065"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165066"></A>Thus, the Receiver’s IDL3 statement</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165067"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165068"></A>uses History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-165069"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165070"></A>is mapped to a C++ function in the Receiver’s context with the signature</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165071"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165072"></A>::History_ptr get_connection_message_history();</P>
<P CLASS="Code">
<A NAME="pgfId-165073"></A>&nbsp;</P>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-165074"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-219786"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
The Receiver specifies the services that it requires through the <EM CLASS="Code">
uses</EM>
<A NAME="marker-272632"></A> statement. This syntax enables the dynamic connection of service providers and service users at run time.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165075"></A>The Receiver <A NAME="marker-266885"></A>executor implementation follows. Changes to CIDL-generated executor implementation code are noted in bold:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165076"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165077"></A>#include &quot;Receiver_exec_i.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165078"></A>#include &quot;ciao/CIAO_common.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165079"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165080"></A>namespace Receiver_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-165081"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-165082"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-165083"></A>  // Component Executor Implementation Class:   Receiver_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-165084"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-165085"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165086"></A>  Receiver_exec_i::Receiver_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165087"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165088"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165089"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165090"></A>  Receiver_exec_i::~Receiver_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165091"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165092"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165093"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165094"></A>The <A NAME="marker-263976"></A>component container invokes the <EM CLASS="Code">
push_message_consumer()</EM>
<A NAME="marker-273723"></A> operation a connected supplier <A NAME="marker-265118"></A>publishes a <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265772"></A>event.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165095"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165096"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165097"></A>  Receiver_exec_i::push_message_consumer (::Message * ev)</P>
<P CLASS="Code">
<A NAME="pgfId-165099"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165100"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-165101"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165102"></A>    CORBA::String_var subject = ev-&gt;subject();</P>
<P CLASS="Code">
<A NAME="pgfId-165103"></A>    CORBA::String_var user = ev-&gt;user();</P>
<P CLASS="Code">
<A NAME="pgfId-165104"></A>    CORBA::String_var text = ev-&gt;text();</P>
<P CLASS="Code">
<A NAME="pgfId-165105"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165106"></A>    ACE_DEBUG(</P>
<P CLASS="Code">
<A NAME="pgfId-165107"></A>      (LM_INFO, </P>
<P CLASS="Code">
<A NAME="pgfId-165108"></A>       ACE_TEXT(&quot;Received Message:\n   Subject: %C\n   User: %C\n   Text: %C\n&quot;),</P>
<P CLASS="Code">
<A NAME="pgfId-165109"></A>       subject.in(),</P>
<P CLASS="Code">
<A NAME="pgfId-165110"></A>       user.in(),</P>
<P CLASS="Code">
<A NAME="pgfId-165111"></A>       text.in() ));</P>
<P CLASS="Code">
<A NAME="pgfId-165112"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165113"></A>    // Use the history to (inefficiently) get the total number of messages</P>
<P CLASS="Code">
<A NAME="pgfId-165114"></A>    // published on this item so far</P>
<P CLASS="Code">
<A NAME="pgfId-165115"></A>    ::History_var history = this-&gt;context_-&gt;get_connection_message_history();</P>
<P CLASS="Code">
<A NAME="pgfId-165116"></A>    ::Messages_var messages = history-&gt;get_all();</P>
<P CLASS="Code">
<A NAME="pgfId-165117"></A>    ACE_DEBUG((LM_INFO, </P>
<P CLASS="Code">
<A NAME="pgfId-165118"></A>               ACE_TEXT(&quot;   Subject \&quot;%C\&quot; has published %d messages so far\n&quot;),</P>
<P CLASS="Code">
<A NAME="pgfId-165119"></A>               subject.in(),</P>
<P CLASS="Code">
<A NAME="pgfId-165120"></A>               messages-&gt;length() ));               </P>
<P CLASS="Code">
<A NAME="pgfId-165121"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165122"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165123"></A>The implementation of <EM CLASS="Code">
push_message_consumer()</EM>
 prints out the message’s subject, user, and text. Then, it gets the component’s <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-262911"></A>facet, gets a list of all <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265779"></A>events <A NAME="marker-265124"></A>published, and prints out the number of messages published so far.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165124"></A>As with the Messenger component, the <A NAME="marker-268952"></A>CIDL compiler generates a complete implementation of the <EM CLASS="Code">
set_session_context()</EM>
<A NAME="marker-273599"></A> method.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165125"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165126"></A>  // Operations from Components::SessionComponent</P>
<P CLASS="Code">
<A NAME="pgfId-165127"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165128"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165129"></A>  Receiver_exec_i::set_session_context (::Components::SessionContext_ptr ctx)</P>
<P CLASS="Code">
<A NAME="pgfId-165131"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165132"></A>    this-&gt;context_ = ::CCM_Receiver_Context::_narrow (ctx)</P>
<P CLASS="Code">
<A NAME="pgfId-165133"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165134"></A>    if (CORBA::is_nil (this-&gt;context_.in ()))</P>
<P CLASS="Code">
<A NAME="pgfId-165135"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-165136"></A>      throw CORBA::INTERNAL();</P>
<P CLASS="Code">
<A NAME="pgfId-165137"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-165138"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165139"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165140"></A>The <A NAME="marker-263983"></A>component container calls the <EM CLASS="Code">
set_session_context()</EM>
<A NAME="marker-273607"></A> operation to set the Receiver’s context immediately after it instantiates the Receiver <A NAME="marker-266894"></A>executor. The Receiver uses this context to access its connected <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-262918"></A>facet. We do not make any changes to this method.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165141"></A>The <A NAME="marker-268955"></A>CIDL compiler generates empty implementations of <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273162"></A>, <EM CLASS="Code">
ccm_passivate()</EM>
<A NAME="marker-273253"></A>, and <EM CLASS="Code">
ccm_remove()</EM>
<A NAME="marker-273284"></A>. We do not modify any of these methods.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165142"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165143"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165144"></A>  Receiver_exec_i::ccm_activate ()</P>
<P CLASS="Code">
<A NAME="pgfId-165146"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165147"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-165148"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165149"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165150"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165151"></A>  Receiver_exec_i::ccm_passivate ()</P>
<P CLASS="Code">
<A NAME="pgfId-165153"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165154"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-165155"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165156"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165157"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165158"></A>  Receiver_exec_i::ccm_remove ()</P>
<P CLASS="Code">
<A NAME="pgfId-165160"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165161"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-165162"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165163"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165177"></A>&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-165178"></A>The ReceiverHome <A NAME="marker-267438"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-165179"></A>Recall that the <EM CLASS="Code">
ReceiverHome</EM>
’s IDL3 interface is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165180"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165181"></A>component Receiver { ... };</P>
<P CLASS="Code">
<A NAME="pgfId-165182"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165183"></A>home ReceiverHome manages Receiver {};</P>
<P CLASS="Code">
<A NAME="pgfId-165184"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165185"></A>and the Receiver’s <A NAME="marker-268426"></A>CIDL <A NAME="marker-269724"></A>composition is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165186"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165187"></A>composition session Receiver_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-165188"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-165189"></A>    home executor ReceiverHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-165190"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-165191"></A>        implements ReceiverHome;</P>
<P CLASS="Code">
<A NAME="pgfId-165192"></A>        manages    Receiver_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-165193"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-165194"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-165195"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165196"></A>The <EM CLASS="Code">
ReceiverHome</EM>
 class definition and implementation are nearly identical to the <EM CLASS="Code">
MessengerHome</EM>
 class definition and implementation. We make no changes to the CIDL-generated code.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165197"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165198"></A>  class RECEIVER_EXEC_Export ReceiverHome_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-165199"></A>  : public virtual ReceiverHome_Exec,</P>
<P CLASS="Code">
<A NAME="pgfId-165200"></A>    public virtual ::CORBA::LocalObject</P>
<P CLASS="Code">
<A NAME="pgfId-165201"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165202"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-165203"></A>    ReceiverHome_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165204"></A>    virtual ~ReceiverHome_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165205"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165206"></A>    virtual ::Components::EnterpriseComponent_ptr create ();</P>
<P CLASS="Code">
<A NAME="pgfId-165208"></A>  };</P>
<P CLASS="Code">
<A NAME="pgfId-165209"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165210"></A>  extern &quot;C&quot; RECEIVER_EXEC_Export ::Components::HomeExecutorBase_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-165211"></A>    create_ReceiverHome_Impl (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165212"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-165213"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165214"></A>Finally, the <A NAME="marker-268958"></A>CIDL compiler generates implementations of the <EM CLASS="Code">
ReceiverHome</EM>
 <A NAME="marker-267448"></A>executor and the Receiver’s library entry point function. We do not modify these implementations.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165215"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165216"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-165217"></A>  // Home Executor Implementation Class:   ReceiverHome_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-165218"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-165219"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165220"></A>  ReceiverHome_exec_i::ReceiverHome_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165221"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165222"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165223"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165224"></A>  ReceiverHome_exec_i::~ReceiverHome_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165225"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165226"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165227"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165228"></A>  ::Components::EnterpriseComponent_ptr </P>
<P CLASS="Code">
<A NAME="pgfId-165229"></A>  ReceiverHome_exec_i::create ()</P>
<P CLASS="Code">
<A NAME="pgfId-165231"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165232"></A>    ::Components::EnterpriseComponent_ptr retval =</P>
<P CLASS="Code">
<A NAME="pgfId-165233"></A>    ::Components::EnterpriseComponent::_nil ();</P>
<P CLASS="Code">
<A NAME="pgfId-165234"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165235"></A>    ACE_NEW_THROW_EX (retval,</P>
<P CLASS="Code">
<A NAME="pgfId-165236"></A>                      Receiver_exec_i,</P>
<P CLASS="Code">
<A NAME="pgfId-165237"></A>                      CORBA::NO_MEMORY ());</P>
<P CLASS="Code">
<A NAME="pgfId-165238"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165239"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165240"></A>    return retval;</P>
<P CLASS="Code">
<A NAME="pgfId-165241"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165242"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165243"></A>  extern &quot;C&quot; RECEIVER_EXEC_Export ::Components::HomeExecutorBase_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-165244"></A>  create_ReceiverHome_Impl (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165245"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165246"></A>    ::Components::HomeExecutorBase_ptr retval =</P>
<P CLASS="Code">
<A NAME="pgfId-165247"></A>    ::Components::HomeExecutorBase::_nil ();</P>
<P CLASS="Code">
<A NAME="pgfId-165248"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165249"></A>    ACE_NEW_RETURN (retval,</P>
<P CLASS="Code">
<A NAME="pgfId-165250"></A>                    ReceiverHome_exec_i,</P>
<P CLASS="Code">
<A NAME="pgfId-165251"></A>                    ::Components::HomeExecutorBase::_nil ());</P>
<P CLASS="Code">
<A NAME="pgfId-165252"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165253"></A>    return retval;</P>
<P CLASS="Code">
<A NAME="pgfId-165254"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165255"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-165256"></A>&nbsp;</P>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-165257"></A>The Administrator Component <A NAME="marker-266920"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-262929"></A>The Administrator component starts and stops the Messenger’s message publication and controls the <A NAME="marker-265130"></A>published text and the publication period. The Administrator component demonstrates use of the <A NAME="marker-272640"></A><EM CLASS="Code">
uses multiple</EM>
 mechanism of connecting a component <A NAME="marker-264207"></A>receptacle to multiple <A NAME="marker-262935"></A>facets simultaneously.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165267"></A>&nbsp;</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-165266"></A> The Administrator Component</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-165264"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-19.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-165268"></A>Recall that the Administrator’s IDL3 interface is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165269"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165270"></A>component Administrator {    </P>
<P CLASS="Code">
<A NAME="pgfId-165271"></A>  uses multiple Runnable runnables;</P>
<P CLASS="Code">
<A NAME="pgfId-165272"></A>  uses multiple Publication content;</P>
<P CLASS="Code">
<A NAME="pgfId-165273"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-165274"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165275"></A>home AdministratorHome manages Administrator {};</P>
<P CLASS="Code">
<A NAME="pgfId-165276"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165277"></A>At <A NAME="marker-261189"></A>deployment time, we connect the Administrator’s <EM CLASS="Code">
runnables</EM>
 and <EM CLASS="Code">
content</EM>
 receptacles to the Messenger’s <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-262942"></A>facets. The Administrator controls the starting and stopping of message publication through the <EM CLASS="Code">
Runnable</EM>
 facet and controls the message text <A NAME="marker-265136"></A>published and the publication period through the <EM CLASS="Code">
Publication</EM>
 facet.</LI>
<LI CLASS="Body">
<A NAME="pgfId-219942"></A>The <A NAME="marker-272652"></A><EM CLASS="Code">
uses multiple</EM>
 modifier on the <EM CLASS="Code">
runnables</EM>
 and <EM CLASS="Code">
content</EM>
 receptacles permits the Administrator to connect an unlimited number of <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-262951"></A>facets. This type of <A NAME="marker-264214"></A>receptacle is a <A NAME="marker-264226"></A>multiplex <A NAME="marker-264221"></A>receptacle. Our example uses only one of each; however, an application deployer may add additional Messengers into the application through XML-based configuration at <A NAME="marker-261196"></A>deployment time. More information on deployment is available in <A HREF="CIAO.htm#66043" CLASS="XRef">See Deploying the Messenger Application</A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165279"></A>Recall that the Administrator’s <A NAME="marker-269732"></A>composition, describing the implementation of the Administrator component, is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165280"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165281"></A>composition session Administrator_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-165282"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-165283"></A>    home executor AdministratorHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-165284"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-165285"></A>        implements AdministratorHome;</P>
<P CLASS="Code">
<A NAME="pgfId-165286"></A>        manages    Administrator_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-165287"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-165288"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-165289"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-219965"></A>The <A NAME="marker-268961"></A>CIDL compiler generates the Administrator’s <A NAME="marker-266931"></A>executor implementation code into an <EM CLASS="Code">
Administrator_Impl</EM>
 namespace. It generates an <EM CLASS="Code">
Administrator_exec</EM>
 executor base class for the Administrator and an <EM CLASS="Code">
AdministratorHome_exec</EM>
 executor base class for the Administrator’s <A NAME="marker-267856"></A>home. In addition, the CIDL compiler optionally generates default implementations of the executors. These are analogous to the CIDL-generated classes for the Messenger and Receiver components.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165291"></A>It is not surprising that there are many similarities between the Administrator <A NAME="marker-266940"></A>executor and the Messenger and Receiver executors. The most noticeable change we make to the CIDL-generated executor implementation is to add inheritance from the <EM CLASS="Code">
ACE_Task_Base</EM>
 class and override the <EM CLASS="Code">
ACE_Task_Base::svc()</EM>
<A NAME="marker-273498"></A> method. The Administrator’s implementation launches a thread that displays a simple text menu to start, stop, and otherwise control the Messenger’s message publication. A more realistic application might use a GUI of some kind. The purpose of this example implementation is to demonstrate that a user can manually interact with a deployed component.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165292"></A>The Administrator’s IDL3 interface introduces the <A NAME="marker-272663"></A><EM CLASS="Code">
uses multiple</EM>
 <A NAME="marker-264233"></A>receptacle, or <A NAME="marker-264335"></A>multiplex receptacle. A multiplex receptacle can connect to an unlimited number of type-compatible <A NAME="marker-262958"></A>facets. The mapping from IDL to C++ is different for a multiplex receptacle than for a <A NAME="marker-264366"></A>simplex receptacle, which connects to exactly one facet.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165293"></A>You might remember that for a <A NAME="marker-264244"></A>receptacle of the form</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165294"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165295"></A>uses &lt;facet_interface&gt; &lt;facet_name&gt;;</P>
<P CLASS="Code">
<A NAME="pgfId-165296"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165297"></A>the <A NAME="marker-268965"></A>CIDL compiler generates a C++ function in the component’s context with the signature</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165298"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165299"></A>::&lt;facet_interface&gt;_ptr get_connection_&lt;facet_name&gt;();</P>
<P CLASS="Code">
<A NAME="pgfId-165300"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165301"></A>For example, </LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165302"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165303"></A>uses History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-165304"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165305"></A>is mapped to a C++ function in the component’s context with the signature</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165306"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165307"></A>::History_ptr get_connection_message_history();</P>
<P CLASS="Code">
<A NAME="pgfId-165308"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165309"></A>This type of <A NAME="marker-264251"></A>receptacle is called a <A NAME="marker-264373"></A>simplex receptacle because it connects to exactly one <A NAME="marker-262970"></A>facet. However, a <A NAME="marker-264344"></A>multiplex receptacle of the form</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165310"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165311"></A>uses multiple &lt;facet_interface&gt; &lt;facet_name&gt;;</P>
<P CLASS="Code">
<A NAME="pgfId-165312"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165313"></A>causes the IDL and <A NAME="marker-268968"></A>CIDL compilers to generate the following:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-165314"></A>A C++ struct called <EM CLASS="Code">
&lt;facet_name&gt;Connection</EM>
:</LI>
</UL>
<P CLASS="Code-Line3">
<A NAME="pgfId-165315"></A>&nbsp;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165316"></A>struct &lt;facet_name&gt;Connection</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165317"></A>{</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165318"></A>  typedef &lt;facet_name&gt;Connection_var _var_type;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165319"></A>  &lt;facet_type&gt;_var objref;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165320"></A>  Components::Cookie_var ck;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165321"></A>};</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165322"></A>&nbsp;</P>
<UL>
<LI CLASS="Bullet1">
<A NAME="pgfId-165323"></A>A typedef for a sequence of <EM CLASS="Code">
&lt;facet_name&gt;Connection</EM>
 elements called <EM CLASS="Code">
&lt;facet_name&gt;Connections</EM>
. We illustrate with the equivalent IDL2:</LI>
</UL>
<P CLASS="Code-Line3">
<A NAME="pgfId-165324"></A>&nbsp;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165325"></A>typedef sequence&lt; &lt;facet_name&gt;Connection &gt; &lt;facet_name&gt;Connections;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165326"></A>&nbsp;</P>
<UL>
<LI CLASS="Bullet1">
<A NAME="pgfId-165327"></A>A <A NAME="marker-262988"></A>facet accessor C++ function through which the component retrieves a sequence of connected facets:</LI>
</UL>
<P CLASS="Code-Line3">
<A NAME="pgfId-165328"></A>&nbsp;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165329"></A>::&lt;component name&gt;::&lt;facet_name&gt;Connections*</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-258655"></A>  get_connections_&lt;facet_name&gt;();</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165330"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165331"></A>In our example, the <A NAME="marker-264351"></A>multiplex <EM CLASS="Code">
Runnables</EM>
 <A NAME="marker-264260"></A>receptacle</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165332"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165333"></A>uses multiple Runnable runnables;</P>
<P CLASS="Code">
<A NAME="pgfId-165334"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165335"></A>causes the IDL and <A NAME="marker-268971"></A>CIDL compilers to generate the following:</P>
<UL>
<LI CLASS="Bullet1">
<A NAME="pgfId-165336"></A>A C++ struct called <EM CLASS="Code">
runnablesConnection</EM>
:</LI>
</UL>
<P CLASS="Code-Line3">
<A NAME="pgfId-165337"></A>&nbsp;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165338"></A>struct runnablesConnection</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165339"></A>{</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165340"></A>  typedef runnablesConnection_var _var_type;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165341"></A>  Runnable_var objref;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165342"></A>  Components::Cookie_var ck;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165343"></A>};</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165344"></A>&nbsp;</P>
<UL>
<LI CLASS="Bullet1">
<A NAME="pgfId-165345"></A>A C++ sequence type of <EM CLASS="Code">
runnablesConnection</EM>
 elements called <EM CLASS="Code">
runnablesConnections</EM>
. Again, we illustrate with the equivalent IDL2:</LI>
</UL>
<P CLASS="Code-Line3">
<A NAME="pgfId-165346"></A>&nbsp;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165347"></A>typedef sequence&lt; runnablesConnection &gt; runnablesConnections;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165348"></A>&nbsp;</P>
<UL>
<LI CLASS="Bullet1">
<A NAME="pgfId-165349"></A>A <A NAME="marker-262998"></A>facet accessor C++ function through which the component retrieves a sequence of connected <EM CLASS="Code">
Runnable</EM>
 facets:</LI>
</UL>
<P CLASS="Code-Line3">
<A NAME="pgfId-165350"></A>&nbsp;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165351"></A>::Administrator::runnablesConnections* get_connections_runnables();</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-165352"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165353"></A>The <EM CLASS="Code">
startPublishing()</EM>
, <EM CLASS="Code">
stopPublishing()</EM>
, <EM CLASS="Code">
changePublicationText()</EM>
, and <EM CLASS="Code">
changePublicationPeriod()</EM>
 helper methods illustrate the usage of the <A NAME="marker-264358"></A>multiplex <A NAME="marker-264267"></A>receptacle.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165354"></A>The <EM CLASS="Code">
Administrator</EM>
 <A NAME="marker-266948"></A>executor follows. Changes to CIDL-generated code are in bold.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165355"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165356"></A>#include &quot;Administrator_svnt.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165357"></A>#include &quot;Administrator_exec_export.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165358"></A>#include &quot;tao/LocalObject.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165359"></A>#include &lt;ace/Task.h&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-165360"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165361"></A>namespace Administrator_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-165362"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-258665"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165363"></A>The <A NAME="marker-266955"></A>executor inherits from <EM CLASS="Code">
ACE_Task_Base</EM>
 to realize the active object pattern.</P>
<P CLASS="Code">
<A NAME="pgfId-165364"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165365"></A>  class ADMINISTRATOR_EXEC_Export Administrator_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-165366"></A>  : public virtual Administrator_Exec,</P>
<P CLASS="Code">
<A NAME="pgfId-165367"></A>    public virtual ACE_Task_Base,</P>
<P CLASS="Code">
<A NAME="pgfId-165368"></A>    public virtual ::CORBA::LocalObject</P>
<P CLASS="Code">
<A NAME="pgfId-165369"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165370"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-165371"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165372"></A>The remainder of the <A NAME="marker-266962"></A>executor class definition is the analogous to the Messenger’s and Receiver’s...</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165373"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165374"></A>    Administrator_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165375"></A>    virtual ~Administrator_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165376"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165377"></A>    virtual void set_session_context (::Components::SessionContext_ptr ctx);</P>
<P CLASS="Code">
<A NAME="pgfId-165379"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165380"></A>    virtual void ccm_activate ();</P>
<P CLASS="Code">
<A NAME="pgfId-165382"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165383"></A>    virtual void ccm_passivate ();</P>
<P CLASS="Code">
<A NAME="pgfId-165385"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165386"></A>    virtual void ccm_remove ();</P>
<P CLASS="Code">
<A NAME="pgfId-165388"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165394"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165395"></A>  private:</P>
<P CLASS="Code">
<A NAME="pgfId-165396"></A>    ::CCM_Administrator_Context_var context_;</P>
<P CLASS="Code">
<A NAME="pgfId-165397"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165398"></A>...except that we override the <EM CLASS="Code">
ACE_Task_Base::svc()</EM>
<A NAME="marker-273505"></A> method and add several private helper methods to control the connected <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-263006"></A>facets.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165399"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165400"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-165401"></A>    // Overridden from ACE_Task_Base</P>
<P CLASS="Code">
<A NAME="pgfId-165402"></A>    int svc();</P>
<P CLASS="Code">
<A NAME="pgfId-165403"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165404"></A>  private:</P>
<P CLASS="Code">
<A NAME="pgfId-165405"></A>    void startPublishing();</P>
<P CLASS="Code">
<A NAME="pgfId-165406"></A>    void stopPublishing();</P>
<P CLASS="Code">
<A NAME="pgfId-165407"></A>    void changePublicationPeriod();</P>
<P CLASS="Code">
<A NAME="pgfId-165408"></A>    void changePublicationText();</P>
<P CLASS="Code">
<A NAME="pgfId-165409"></A>  };</P>
<P CLASS="Code">
<A NAME="pgfId-165410"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165411"></A>The Administrator’s <A NAME="marker-266969"></A>executor implementation follows, with changes to CIDL-generated code in bold:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165412"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165413"></A>#include &quot;Administrator_exec_i.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165414"></A>#include &quot;ciao/CIAO_common.h&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-165415"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165416"></A>#include &lt;iostream&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-165417"></A>#include &lt;string&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-165418"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165419"></A>namespace Administrator_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-165420"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-165421"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-165422"></A>  // Component Executor Implementation Class:   Administrator_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-165423"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-165424"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165425"></A>  Administrator_exec_i::Administrator_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165426"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165427"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165428"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165429"></A>  Administrator_exec_i::~Administrator_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165430"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165431"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165432"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165433"></A>As usual, we have no need to modify the generated <EM CLASS="Code">
set_session_context()</EM>
<A NAME="marker-273615"></A> callback operation.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165434"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165435"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165436"></A>  Administrator_exec_i::set_session_context (</P>
<P CLASS="Code">
<A NAME="pgfId-165437"></A>    ::Components::SessionContext_ptr ctx)</P>
<P CLASS="Code">
<A NAME="pgfId-165439"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165440"></A>    this-&gt;context_ = ::CCM_Administrator_Context::_narrow (ctx);</P>
<P CLASS="Code">
<A NAME="pgfId-165441"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165442"></A>    if (CORBA::is_nil (this-&gt;context_.in ()))</P>
<P CLASS="Code">
<A NAME="pgfId-165443"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-165444"></A>      throw CORBA::INTERNAL ();</P>
<P CLASS="Code">
<A NAME="pgfId-165445"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-165446"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165447"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165448"></A>In the <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273171"></A> implementation, the <A NAME="marker-266977"></A>executor calls <EM CLASS="Code">
ACE_Task_Base::activate()</EM>
<A NAME="marker-273422"></A> to launch its <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273513"></A> method in a thread.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165449"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165450"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165451"></A>  Administrator_exec_i::ccm_activate ()</P>
<P CLASS="Code">
<A NAME="pgfId-165453"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165454"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-165455"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165456"></A>    // Activate the Task, triggering its svc() method</P>
<P CLASS="Code">
<A NAME="pgfId-165457"></A>    this-&gt;activate();</P>
<P CLASS="Code">
<A NAME="pgfId-165458"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165459"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165460"></A> We have no need to modify any of the remaining generated operations.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165461"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165462"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165463"></A>  Administrator_exec_i::ccm_passivate ()</P>
<P CLASS="Code">
<A NAME="pgfId-165465"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165466"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-165467"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165468"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165469"></A>  void</P>
<P CLASS="Code">
<A NAME="pgfId-165470"></A>  Administrator_exec_i::ccm_remove ()</P>
<P CLASS="Code">
<A NAME="pgfId-165472"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165473"></A>    // Your code here.</P>
<P CLASS="Code">
<A NAME="pgfId-165474"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165475"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165490"></A>The Administrator’s implementation of the <EM CLASS="Code">
ccm_activate()</EM>
<A NAME="marker-273179"></A> launches a thread and calls <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273521"></A>. The <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273529"></A> method creates a small text menu through which a user can start and stop message publication, change the message text, and change the publication period for every Messenger attached to the Administrator. Helper methods implement those behaviors. Nothing in the implementation of the <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273534"></A> method involves the CORBA Component Model. Code relevant to CCM is in the helper methods, described later.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165491"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165492"></A>  int</P>
<P CLASS="Code">
<A NAME="pgfId-165493"></A>  Administrator_exec_i::svc() </P>
<P CLASS="Code">
<A NAME="pgfId-165494"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165495"></A>    enum SelectionType { START=1, STOP, CHANGE_PERIOD, CHANGE_TEXT }; </P>
<P CLASS="Code">
<A NAME="pgfId-165496"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165497"></A>    while ( 1 ) {</P>
<P CLASS="Code">
<A NAME="pgfId-165498"></A>      std::cout &lt;&lt; &quot;\nWhat do you want to do to the Messenger(s)?&quot; &lt;&lt; std::endl;</P>
<P CLASS="Code">
<A NAME="pgfId-165499"></A>      std::cout &lt;&lt; START &lt;&lt; &quot;.  Start&quot; &lt;&lt; std::endl;</P>
<P CLASS="Code">
<A NAME="pgfId-165500"></A>      std::cout &lt;&lt; STOP &lt;&lt; &quot;.  Stop&quot; &lt;&lt; std::endl;</P>
<P CLASS="Code">
<A NAME="pgfId-165501"></A>      std::cout &lt;&lt; CHANGE_PERIOD &lt;&lt; &quot;.  Change Publication Period&quot; &lt;&lt; std::endl;</P>
<P CLASS="Code">
<A NAME="pgfId-165502"></A>      std::cout &lt;&lt; CHANGE_TEXT &lt;&lt; &quot;.  Change Publication Text&quot; &lt;&lt; std::endl;</P>
<P CLASS="Code">
<A NAME="pgfId-165503"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165504"></A>      char selection_text[10];</P>
<P CLASS="Code">
<A NAME="pgfId-165505"></A>      std::cout &lt;&lt; &quot;Please enter a selection: &quot;;</P>
<P CLASS="Code">
<A NAME="pgfId-165506"></A>      std::cin.getline( selection_text, sizeof(selection_text) );</P>
<P CLASS="Code">
<A NAME="pgfId-165507"></A>      int selection = ACE_OS::atoi(selection_text);</P>
<P CLASS="Code">
<A NAME="pgfId-165508"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165509"></A>      switch (selection) {</P>
<P CLASS="Code">
<A NAME="pgfId-165510"></A>        case START: </P>
<P CLASS="Code">
<A NAME="pgfId-165511"></A>          startPublishing(); </P>
<P CLASS="Code">
<A NAME="pgfId-165512"></A>          break;</P>
<P CLASS="Code">
<A NAME="pgfId-165513"></A>        case STOP: </P>
<P CLASS="Code">
<A NAME="pgfId-165514"></A>          stopPublishing(); </P>
<P CLASS="Code">
<A NAME="pgfId-165515"></A>          break;</P>
<P CLASS="Code">
<A NAME="pgfId-165516"></A>        case CHANGE_PERIOD: </P>
<P CLASS="Code">
<A NAME="pgfId-165517"></A>          changePublicationPeriod();</P>
<P CLASS="Code">
<A NAME="pgfId-165518"></A>          break;</P>
<P CLASS="Code">
<A NAME="pgfId-165519"></A>        case CHANGE_TEXT: </P>
<P CLASS="Code">
<A NAME="pgfId-165520"></A>          changePublicationText();</P>
<P CLASS="Code">
<A NAME="pgfId-165521"></A>          break;</P>
<P CLASS="Code">
<A NAME="pgfId-165522"></A>        default: </P>
<P CLASS="Code">
<A NAME="pgfId-165523"></A>          std::cout &lt;&lt; &quot;Please enter a valid option&quot; &lt;&lt; std::endl;</P>
<P CLASS="Code">
<A NAME="pgfId-165524"></A>      }</P>
<P CLASS="Code">
<A NAME="pgfId-165525"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-165526"></A>    return 0;</P>
<P CLASS="Code">
<A NAME="pgfId-165527"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165528"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165529"></A>The following four developer-written methods are helper methods invoked by <EM CLASS="Code">
svc()</EM>
<A NAME="marker-273542"></A> in response to user interaction. The first method, <EM CLASS="Code">
startPublishing()</EM>
, retrieves the <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-263013"></A>facets connected to the Administrator’s <EM CLASS="Code">
runnables</EM>
 <A NAME="marker-264274"></A>receptacle and invokes <EM CLASS="Code">
start()</EM>
 on each one.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165530"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165531"></A>  void Administrator_exec_i::startPublishing()</P>
<P CLASS="Code">
<A NAME="pgfId-165532"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165533"></A>    // Get the attached Runnable facet(s)</P>
<P CLASS="Code">
<A NAME="pgfId-165534"></A>    ::Administrator::runnablesConnections_var connections = </P>
<P CLASS="Code">
<A NAME="pgfId-165535"></A>      this-&gt;context_-&gt;get_connections_runnables();</P>
<P CLASS="Code">
<A NAME="pgfId-165536"></A>      </P>
<P CLASS="Code">
<A NAME="pgfId-165537"></A>    std::cout &lt;&lt; &quot;Starting Publication&quot; &lt;&lt; std::endl;</P>
<P CLASS="Code">
<A NAME="pgfId-165538"></A>    for ( CORBA::ULong i = 0; i &lt; connections-&gt;length(); ++i ) {</P>
<P CLASS="Code">
<A NAME="pgfId-165539"></A>      Runnable_var runnable = (*connections)[i].objref;</P>
<P CLASS="Code">
<A NAME="pgfId-165540"></A>      runnable-&gt;start();</P>
<P CLASS="Code">
<A NAME="pgfId-165541"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-165542"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165543"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165544"></A>In <EM CLASS="Code">
startPublishing()</EM>
, we use the Administrator context’s <EM CLASS="Code">
get_connections_runnables()</EM>
 method to get a list of the <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-263021"></A>facets connected to the Administrator’s <EM CLASS="Code">
runnables</EM>
 <A NAME="marker-264281"></A>receptacle. That method returns a sequence of <EM CLASS="Code">
runnablesConnection</EM>
 structs. One of the members of the <EM CLASS="Code">
runnablesConnection</EM>
 struct is a <EM CLASS="Code">
Runnable</EM>
 object reference called <EM CLASS="Code">
objref</EM>
. We pull the object reference out of the struct and call <EM CLASS="Code">
start()</EM>
 on it to start message publication.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165545"></A>The <EM CLASS="Code">
stopPublishing()</EM>
 method is almost identical to the <EM CLASS="Code">
startPublishing()</EM>
 method...</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165546"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165547"></A>  void Administrator_exec_i::stopPublishing() </P>
<P CLASS="Code">
<A NAME="pgfId-165548"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165549"></A>    // Get the attached Runnable facet(s)</P>
<P CLASS="Code">
<A NAME="pgfId-165550"></A>    ::Administrator::runnablesConnections_var connections = </P>
<P CLASS="Code">
<A NAME="pgfId-165551"></A>      this-&gt;context_-&gt;get_connections_runnables();</P>
<P CLASS="Code">
<A NAME="pgfId-165552"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165553"></A>    std::cout &lt;&lt; &quot;Stopping Publication&quot; &lt;&lt; std::endl;</P>
<P CLASS="Code">
<A NAME="pgfId-165554"></A>    for ( CORBA::ULong i = 0; i &lt; connections-&gt;length(); ++i ) {</P>
<P CLASS="Code">
<A NAME="pgfId-165555"></A>      Runnable_var runnable = (*connections)[i].objref;</P>
<P CLASS="Code">
<A NAME="pgfId-165556"></A>      runnable-&gt;stop();</P>
<P CLASS="Code">
<A NAME="pgfId-165557"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-165558"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165559"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165560"></A>..., except it calls <EM CLASS="Code">
stop()</EM>
 on each connected <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-263029"></A>facet instead of <EM CLASS="Code">
start()</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165561"></A>The <EM CLASS="Code">
changePublicationPeriod()</EM>
 and <EM CLASS="Code">
changePublicationText()</EM>
 methods are similar to <EM CLASS="Code">
startPublishing()</EM>
 and <EM CLASS="Code">
stopPublishing()</EM>
. The main difference is that they operate on the <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-264288"></A>receptacle rather than the <EM CLASS="Code">
Runnables</EM>
 receptacle.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165562"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165563"></A>  void Administrator_exec_i::changePublicationPeriod()</P>
<P CLASS="Code">
<A NAME="pgfId-165564"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165565"></A>    // Get the attached Publication facet(s)</P>
<P CLASS="Code">
<A NAME="pgfId-165566"></A>    ::Administrator::contentConnections_var contents = </P>
<P CLASS="Code">
<A NAME="pgfId-165567"></A>      this-&gt;context_-&gt;get_connections_content();</P>
<P CLASS="Code">
<A NAME="pgfId-165568"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165569"></A>    char period[10];</P>
<P CLASS="Code">
<A NAME="pgfId-165570"></A>    std::cout &lt;&lt; &quot;Please enter a new period in seconds: &quot;;</P>
<P CLASS="Code">
<A NAME="pgfId-165571"></A>    std::cin.getline( period, sizeof( period ) );</P>
<P CLASS="Code">
<A NAME="pgfId-165572"></A>    for ( CORBA::ULong i = 0; i &lt; contents-&gt;length(); ++i ) {</P>
<P CLASS="Code">
<A NAME="pgfId-165573"></A>      Publication_var publication = (*contents)[i].objref;</P>
<P CLASS="Code">
<A NAME="pgfId-165574"></A>      publication-&gt;period( ACE_OS::atoi(period) );</P>
<P CLASS="Code">
<A NAME="pgfId-165575"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-165576"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165577"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165578"></A>In <EM CLASS="Code">
changePublicationPeriod()</EM>
, we use the Administrator context’s <EM CLASS="Code">
get_connections_content()</EM>
<A NAME="marker-273745"></A> operation to get a list of the <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-263037"></A>facets connected to the Administrator’s <EM CLASS="Code">
content</EM>
 <A NAME="marker-264296"></A>receptacle. That method returns a sequence of <EM CLASS="Code">
contentConnection</EM>
 structs. One of the members of the <EM CLASS="Code">
contentConnection</EM>
 struct is a <EM CLASS="Code">
Publication</EM>
 object reference called <EM CLASS="Code">
objref</EM>
. We pull the object reference out of the struct and call <EM CLASS="Code">
period()</EM>
 on it to change the message publication period.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165579"></A>The <EM CLASS="Code">
changePublicationText()</EM>
 method is nearly identical to <EM CLASS="Code">
changePublicationPeriod()</EM>
...</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165580"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165581"></A>  void Administrator_exec_i::changePublicationText()</P>
<P CLASS="Code">
<A NAME="pgfId-165582"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165583"></A>    // Get the attached Publication facet(s)</P>
<P CLASS="Code">
<A NAME="pgfId-165584"></A>    ::Administrator::contentConnections_var contents = </P>
<P CLASS="Code">
<A NAME="pgfId-165585"></A>      this-&gt;context_-&gt;get_connections_content();</P>
<P CLASS="Code">
<A NAME="pgfId-165586"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165587"></A>    char buffer[1024];</P>
<P CLASS="Code">
<A NAME="pgfId-165588"></A>    std::cout &lt;&lt; &quot;Please enter new text: &quot;;         </P>
<P CLASS="Code">
<A NAME="pgfId-165589"></A>    std::cin.getline( buffer, sizeof(buffer) );</P>
<P CLASS="Code">
<A NAME="pgfId-165590"></A>    for ( CORBA::ULong i = 0; i &lt; contents-&gt;length(); ++i ) {</P>
<P CLASS="Code">
<A NAME="pgfId-165591"></A>      Publication_var publication = (*contents)[i].objref;</P>
<P CLASS="Code">
<A NAME="pgfId-165592"></A>      publication-&gt;text( buffer );</P>
<P CLASS="Code">
<A NAME="pgfId-165593"></A>    }</P>
<P CLASS="Code">
<A NAME="pgfId-165594"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165595"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165596"></A>... except it calls the <EM CLASS="Code">
text()</EM>
 method on each <EM CLASS="Code">
Publication</EM>
 object reference to change the <A NAME="marker-265142"></A>published text.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-165597"></A>The AdministratorHome <A NAME="marker-267456"></A>Executor</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-165598"></A>Recall that the <EM CLASS="Code">
AdministratorHome</EM>
’s IDL3 interface is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165599"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165600"></A>component Administrator { ... };</P>
<P CLASS="Code">
<A NAME="pgfId-165601"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165602"></A>home AdministratorHome manages Administrator {};</P>
<P CLASS="Code">
<A NAME="pgfId-165603"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165604"></A>and the <EM CLASS="Code">
Administrator</EM>
’s <A NAME="marker-268444"></A>CIDL <A NAME="marker-269740"></A>composition is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165605"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165606"></A>composition session Administrator_Impl</P>
<P CLASS="Code">
<A NAME="pgfId-165607"></A>{</P>
<P CLASS="Code">
<A NAME="pgfId-165608"></A>    home executor AdministratorHome_Exec</P>
<P CLASS="Code">
<A NAME="pgfId-165609"></A>    {</P>
<P CLASS="Code">
<A NAME="pgfId-165610"></A>        implements AdministratorHome;</P>
<P CLASS="Code">
<A NAME="pgfId-165611"></A>        manages    Administrator_Exec;</P>
<P CLASS="Code">
<A NAME="pgfId-165612"></A>    };</P>
<P CLASS="Code">
<A NAME="pgfId-165613"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-165614"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165615"></A>The <EM CLASS="Code">
AdministratorHome</EM>
 class definition and implementation are nearly identical to the <EM CLASS="Code">
MessengerHome</EM>
 and <EM CLASS="Code">
ReceiverHome</EM>
 class definition and implementation. As with those, the <A NAME="marker-268974"></A>CIDL compiler can optionally generate the full class definition, implementation, and library entry point function.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165616"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165617"></A> class ADMINISTRATOR_EXEC_Export AdministratorHome_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-165618"></A>  : public virtual AdministratorHome_Exec,</P>
<P CLASS="Code">
<A NAME="pgfId-165619"></A>    public virtual ::CORBA::LocalObject</P>
<P CLASS="Code">
<A NAME="pgfId-165620"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165621"></A>  public:</P>
<P CLASS="Code">
<A NAME="pgfId-165622"></A>    AdministratorHome_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165623"></A>    virtual ~AdministratorHome_exec_i (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165624"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165625"></A>   virtual ::Components::EnterpriseComponent_ptr create ();</P>
<P CLASS="Code">
<A NAME="pgfId-165627"></A>  };</P>
<P CLASS="Code">
<A NAME="pgfId-165628"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165629"></A>  extern &quot;C&quot; ADMINISTRATOR_EXEC_Export ::Components::HomeExecutorBase_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-165630"></A>    create_AdministratorHome_Impl (void);</P>
<P CLASS="Code">
<A NAME="pgfId-165631"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-165632"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-165633"></A>The implementation of the class and the library entry point function follows.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-165634"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165635"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-165636"></A>  // Home Executor Implementation Class:   AdministratorHome_exec_i</P>
<P CLASS="Code">
<A NAME="pgfId-165637"></A>  //==================================================================</P>
<P CLASS="Code">
<A NAME="pgfId-165638"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165639"></A>  AdministratorHome_exec_i::AdministratorHome_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165640"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165641"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165642"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165643"></A>  AdministratorHome_exec_i::~AdministratorHome_exec_i (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165644"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165645"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165646"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165647"></A>  ::Components::EnterpriseComponent_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-165648"></A>  AdministratorHome_exec_i::create ()</P>
<P CLASS="Code">
<A NAME="pgfId-165650"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165651"></A>    ::Components::EnterpriseComponent_ptr retval =</P>
<P CLASS="Code">
<A NAME="pgfId-165652"></A>    ::Components::EnterpriseComponent::_nil ();</P>
<P CLASS="Code">
<A NAME="pgfId-165653"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165654"></A>    ACE_NEW_THROW_EX (retval,</P>
<P CLASS="Code">
<A NAME="pgfId-165655"></A>                      Administrator_exec_i,</P>
<P CLASS="Code">
<A NAME="pgfId-165656"></A>                      CORBA::NO_MEMORY ());</P>
<P CLASS="Code">
<A NAME="pgfId-165657"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165658"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165659"></A>    return retval;</P>
<P CLASS="Code">
<A NAME="pgfId-165660"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165661"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165662"></A>  extern &quot;C&quot; ADMINISTRATOR_EXEC_Export ::Components::HomeExecutorBase_ptr</P>
<P CLASS="Code">
<A NAME="pgfId-165663"></A>  create_AdministratorHome_Impl (void)</P>
<P CLASS="Code">
<A NAME="pgfId-165664"></A>  {</P>
<P CLASS="Code">
<A NAME="pgfId-165665"></A>    ::Components::HomeExecutorBase_ptr retval =</P>
<P CLASS="Code">
<A NAME="pgfId-165666"></A>    ::Components::HomeExecutorBase::_nil ();</P>
<P CLASS="Code">
<A NAME="pgfId-165667"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165668"></A>    ACE_NEW_RETURN (retval,</P>
<P CLASS="Code">
<A NAME="pgfId-165669"></A>                    AdministratorHome_exec_i,</P>
<P CLASS="Code">
<A NAME="pgfId-165670"></A>                    ::Components::HomeExecutorBase::_nil ());</P>
<P CLASS="Code">
<A NAME="pgfId-165671"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-165672"></A>    return retval;</P>
<P CLASS="Code">
<A NAME="pgfId-165673"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-165674"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-258672"></A>&nbsp;</P>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-165675"></A>Summary of the Code</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-165676"></A>The code for our Messenger example is complete. We have implemented executors for the Messenger, Receiver, and Administrator components. We also implemented executors for the <EM CLASS="Code">
Runnable</EM>
, <EM CLASS="Code">
Publication</EM>
, and <EM CLASS="Code">
History</EM>
 <A NAME="marker-263045"></A>facets of the Messenger component.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165677"></A>We have seen how the <A NAME="marker-263990"></A>component container injects a context into each component <A NAME="marker-266996"></A>executor to facilitate connections between facets and receptacles and between <A NAME="marker-265148"></A>publishers and consumers.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165678"></A>Consider what we have not done. We have not written a <EM CLASS="Code">
main()</EM>
. We have not interacted with the Portable Object Adapter, nor have we been exposed to any classes with the prefix <EM CLASS="Code">
POA_</EM>
. We have not written any code that attempts to find another component or object; instead, those connections are provided through each component’s context.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165679"></A>In the following sections we deploy the Messenger example through CIAO’s implementation of the CCM <A NAME="marker-261204"></A>Deployment and Configuration specification.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-165807"></A><A NAME="66043"></A><A NAME="marker-261341"></A>Deploying the Messenger Application</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-165808"></A>As the previous sections have demonstrated, a CCM-based application consists of small, self-contained, reusable software components defined using IDL3. A component defines its interactions with other components via ports indicating provided and required interfaces and messages <A NAME="marker-265154"></A>published and consumed. The <A NAME="marker-261210"></A>deployment activity separates business application logic from process and interaction details.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-231338"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231336"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-20.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-220093"></A>An <A NAME="marker-262023"></A>assembly is a set of interconnected component instances. Each <A NAME="marker-262030"></A>assembly is itself a component; an assembly may be deployable as a full application, or may represent a higher-level component for use in a larger application. An assembly is a realizations of the <A NAME="marker-265973"></A>composite pattern; an assembly may be composed of other assemblies and may be a part of other assemblies.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165810"></A>A component deployer deploys an <A NAME="marker-262040"></A>assembly into one or more application servers that might be distributed across a network. XML descriptor files describe how the components are plugged together into an assembly and how each component of the assembly is mapped to an application server process. Thus, component <A NAME="marker-261222"></A>assembly and <A NAME="marker-261217"></A>deployment is completely independent of component implementation, achieving a separation of concerns.</LI>
<LI CLASS="Body">
<A NAME="pgfId-220084"></A>Each component may be platform-specific, but an <A NAME="marker-262050"></A>assembly may be heterogeneous. A component implementation neither knows nor cares which assemblies it may be a part of nor knows to which other components it may connect.</LI>
<LI CLASS="Body">
<A NAME="pgfId-167399"></A>Our <A NAME="marker-261229"></A>deployment of the Messenger application is described by the following UML <A NAME="marker-261236"></A>deployment diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-167406"></A> Deployment of the Messenger Application</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-167404"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-21.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-167400"></A>The <A NAME="marker-261244"></A>deployment consists of one Messenger instance, two Receiver instances, and one Administrator instance. We deploy each instance in its own <A NAME="marker-264083"></A>component server, although it is not necessary to do that. In our <A NAME="marker-261251"></A>deployment, the four component servers execute on the same host, although we could distribute them across the network with no code changes and minimal configuration changes.</LI>
<LI CLASS="Body">
<A NAME="pgfId-167459"></A>The “Deployment and Configuration of Component-based Distributed Applications” specification (<A NAME="marker-261275"></A>OMG Document ptc/03-07-08) prescribes how components are instantiated, connected, and assigned to processes in a distributed software system. The following sections illustrate the salient points of the D&amp;C specification through the <A NAME="marker-261358"></A>deployment of the Messenger application.</LI>
<LI CLASS="Body">
<A NAME="pgfId-242467"></A>The example’s XML descriptor files ares in the <EM CLASS="Code">
$CIAO_ROOT/examples/DevGuideExamples/Messenger/descriptors</EM>
 directory.</LI>
</UL>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-165811"></A>Deployment and Configuration Specification</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-165812"></A>The OMG’s specification for the “<A NAME="marker-261295"></A>Deployment and Configuration of Component-based Distributed Applications” is a <A NAME="marker-261365"></A>deployment and configuration specification that is independent of the CORBA Component Model. It describes a general-purpose deployment and configuration framework for use by any component-based application. The specification defines IDL interfaces and XML descriptor file formats for configuring individual components and component assemblies for deployment.</LI>
<LI CLASS="Body">
<A NAME="pgfId-258774"></A>This <A NAME="marker-261305"></A>Deployment and Configuration specification supersedes the “Packaging and Deployment” chapter of the OMG CORBA Component Model (CCM) (<A NAME="marker-261300"></A>OMG Document formal/02-06-65) specification.</LI>
<LI CLASS="Body">
<A NAME="pgfId-167679"></A>CIAO’s realization of the <A NAME="marker-261310"></A>Deployment and Configuration specification is called DAnCE (<A NAME="marker-261314"></A>Deployment And Configuration Engine). DAnCE supersedes CIAO’s implementation of the CCM specification’s “Packaging and Deployment” chapter. We deploy the Messenger application using DAnCE in this section.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-165815"></A><A NAME="marker-270077"></A>Deployment Descriptors</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-165816"></A>The <A NAME="marker-261316"></A>Deployment and Configuration specification presents a set of XML descriptors for describing <A NAME="marker-261381"></A>deployment aspects of a software system. Each component has a set of descriptors to define its libraries, exposed ports, and implementation. Each application consists of one or more assemblies that describe the application’s packaging and deployment onto <A NAME="marker-261322"></A>component servers.</LI>
<LI CLASS="Body">
<A NAME="pgfId-167091"></A>A CCM application deployer writes many <A NAME="marker-261389"></A>deployment descriptor files to describe the application’s deployment. These files are written by hand. Usually, an application deployer copies and edits an existing set of XML deployment descriptors to describe a new application’s deployment. In the future, we might expect tools such as Vanderbilt’s <A NAME="marker-261320"></A>CoSMIC or Kansas State’s <A NAME="marker-261321"></A>Cadena to generate the bulk of our CIAO application’s <A NAME="marker-261399"></A>deployment descriptors.</LI>
<LI CLASS="Body">
<A NAME="pgfId-220347"></A>A component such as the Messenger component describes its <A NAME="marker-261406"></A>deployment using the following descriptors:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167094"></A>An <A NAME="marker-270085"></A>Implementation Artifact Descriptor (.iad) file for each of the Messenger’s libraries.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167099"></A>A <A NAME="marker-270087"></A>CORBA Component Descriptor (.ccd) file defining the Messenger’s exposed ports and <A NAME="marker-275520"></A>attributes.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167106"></A>A <A NAME="marker-270092"></A>Component Implementation Descriptor (.cid) file describing the component’s implementation in terms of its Implementation Artifact Descriptors and its <A NAME="marker-270466"></A>CORBA Component Descriptor.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167111"></A>A <A NAME="marker-270097"></A>Component Package Descriptor (.cpd) file describing one or more implementations of the component.</LI>
<LI CLASS="Body">
<A NAME="pgfId-165835"></A>An <A NAME="marker-262057"></A>assembly is a composite component, consisting of interconnected subcomponents. We assemble a Messenger component instance, two Receiver component instances, and an Administrator component instance into a deployable assembly. The assembly describes its <A NAME="marker-261413"></A>deployment using the following descriptors:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167202"></A>Another <A NAME="marker-270102"></A>CORBA Component Descriptor (.ccd) file defining the <A NAME="marker-262066"></A>assembly’s exposed ports and <A NAME="marker-275526"></A>attributes, if any.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167203"></A>Another <A NAME="marker-270107"></A>Component Implementation Descriptor (.cid) file describing the <A NAME="marker-262073"></A>assembly’s implementation in terms of its subcomponents and the connections between their ports.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-182881"></A>Another <A NAME="marker-270112"></A>Component Package Descriptor (.cpd) file describing one or more implementations of the <A NAME="marker-262080"></A>assembly.</LI>
<LI CLASS="Body">
<A NAME="pgfId-182882"></A>An application consists of one or more assemblies. The application describes its <A NAME="marker-261420"></A>deployment using the following descriptors:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167280"></A>A <A NAME="marker-270117"></A>Package Configuration Descriptor (.pcd) that describes a deployable component package.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167287"></A>A <A NAME="marker-270122"></A>Top-level Package Descriptor (package.tpd) that contains one or more <A NAME="marker-270930"></A>Package Configuration Descriptors.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167288"></A>A <A NAME="marker-270127"></A>Component Deployment Plan (.cdp) that maps each component instance in the <A NAME="marker-262087"></A>assembly’s Component Implementation Description to a logical node.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167289"></A>A <A NAME="marker-270140"></A>Component Domain Descriptor (.cdd) that describes available nodes, interconnects, and bridges.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-167302"></A>A <A NAME="marker-269988"></A>Node Map that maps each logical node to a physical <A NAME="marker-264090"></A>component server process.</LI>
<LI CLASS="Body">
<A NAME="pgfId-167846"></A>The <A NAME="marker-261428"></A>deployment engineer may choose to combine several of these descriptor files into one. In fact, we could describe the Messenger application’s deployment with one rather large XML descriptor. However, we will keep the descriptor files separate for maximum flexibility.</LI>
<LI CLASS="Body">
<A NAME="pgfId-183027"></A>The following sections outline the <A NAME="marker-261444"></A>deployment of the individual components, the Messenger <A NAME="marker-262102"></A>assembly, and the full application.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-183029"></A>Deployment.xsd and XMI.xsd Files</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-183480"></A>The <A NAME="marker-270160"></A>deployment descriptors are described by two XML Schema Definition (XSD) files: <EM CLASS="Code">
Deployment.xsd</EM>
 and <EM CLASS="Code">
XMI.xsd</EM>
. The directory containing the Messenger application’s deployment descriptors must contain a copy of each of these files. Each file can be copied from <A NAME="marker-269786"></A>DAnCE’s root directory, <EM CLASS="Code">
$CIAO_ROOT/DAnCE</EM>
<A NAME="marker-271799"></A> or <EM CLASS="Code">
%CIAO_ROOT%\DAnCE</EM>
<A NAME="marker-271814"></A>. These directories are referred to as $DANCE_ROOT or %DANCE_ROOT% from this point forward.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-183359"></A>Deploying the Messenger Component</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-165837"></A>The Messenger component’s <A NAME="marker-270178"></A>deployment descriptors package its libraries and its exposed ports into one deployable package.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-231191"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231189"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-22.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-263058"></A>Six XML descriptors describe the Messenger component’s <A NAME="marker-263057"></A>deployment: three descriptors describe each of the Messenger’s three libraries; one descriptor describes its exposed <A NAME="marker-270209"></A>ports; one descriptor combines the library descriptors and the port descriptor into an implementation; and one descriptor packages the Messenger into a deployable package.</LI>
<LI CLASS="Body">
<A NAME="pgfId-168025"></A>The drawing illustrates the relationships between the six Messenger <A NAME="marker-261501"></A>deployment descriptors.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-168033"></A> Messenger Component Deployment Descriptors</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-168031"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-23.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-167313"></A>The Messenger’s implementation is linked into three dynamic libraries: <EM CLASS="Code">
Messenger_stub</EM>
, containing the Messenger’s IDL-generated stub code; <EM CLASS="Code">
Messenger_svnt</EM>
, containing the Messenger’s IDL- and CIDL-generated skeleton and servant code; and <EM CLASS="Code">
Messenger_exec</EM>
, containing the Messenger’s <A NAME="marker-267892"></A>home and <A NAME="marker-267897"></A>component <A NAME="marker-267902"></A>executors. We create an <A NAME="marker-270223"></A>Implementation Artifact Descriptor for each of these libraries.</LI>
<LI CLASS="Body">
<A NAME="pgfId-167326"></A>A <A NAME="marker-270228"></A>CORBA Component Descriptor describes the Messenger’s public interface. It contains information about each of the component’s ports, including the <A NAME="marker-263310"></A>port name, the type of port (<EM CLASS="Code">
Facet</EM>
, <EM CLASS="Code">
EventPublisher</EM>
<A NAME="marker-264822"></A>, <EM CLASS="Code">
EventConsumer</EM>
<A NAME="marker-265980"></A>, etc.) and the port’s supported IDL interfaces.</LI>
<LI CLASS="Body">
<A NAME="pgfId-168140"></A>The <A NAME="marker-270233"></A>Component Implementation Descriptor describes the Messenger component’s <A NAME="marker-270259"></A>monolithic implementation. A monolithic component implementation consists of one or more implementation artifacts. In a C++ application, an implementation artifact is a dynamic library.</LI>
<LI CLASS="Body">
<A NAME="pgfId-167358"></A>At the top level, a <A NAME="marker-270238"></A>Component Package Descriptor may describe several alternate implementations of a component, permitting the <A NAME="marker-264105"></A>component server to choose the correct implementation at run-time based on platform and QoS requirements. Our example provides one implementation of the Messenger component.</LI>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-168217"></A>Messenger Component - <A NAME="marker-270271"></A>Implementation Artifact Descriptors (.iad)</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-270276"></A>An implementation artifact is a library, a jar file, or some other artifact containing a component’s executable code. We create an Implementation Artifact Descriptor for each of our three Messenger libraries. We also create a separate Implementation Artifact Descriptor for the ACE, TAO, and CIAO libraries.</LI>
<LI CLASS="Body">
<A NAME="pgfId-270277"></A>The <A NAME="marker-270286"></A>Implementation Artifact Descriptor for the ACE, TAO, and CIAO libraries is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-168278"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-168361"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168279"></A>&lt;Deployment:ImplementationArtifactDescription </P>
<P CLASS="Code">
<A NAME="pgfId-168280"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot; </P>
<P CLASS="Code">
<A NAME="pgfId-168281"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168282"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </P>
<P CLASS="Code">
<A NAME="pgfId-168283"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168284"></A>  &lt;label&gt;ACE/TAO/CIAO Libraries&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168285"></A>  &lt;location&gt;$ACE_ROOT/lib/ACE&lt;/location&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168286"></A>  &lt;location&gt;$ACE_ROOT/lib/TAO&lt;/location&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168287"></A>  &lt;location&gt;$ACE_ROOT/lib/CIAO_Client&lt;/location&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168288"></A>&lt;/Deployment:ImplementationArtifactDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168356"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-168251"></A>The optional <EM CLASS="Code">
&lt;label&gt;</EM>
 element contains a human-readable description of the implementation artifact. It may be used by a tool for display purposes. The mandatory <EM CLASS="Code">
&lt;location&gt;</EM>
 elements reference the <EM CLASS="Code">
ACE</EM>
, <EM CLASS="Code">
TAO</EM>
 and <EM CLASS="Code">
CIAO_Client</EM>
 libraries that the Messenger depends upon. File extensions for the libraries are not necessary, or even desired. Multiple alternate location for the same entity can be provided. The underlying implementation uses the operating system’s dynamic library capabilities, meaning that it can use the contents of the <EM CLASS="Code">
PATH</EM>
<A NAME="marker-271882"></A> and/or the <EM CLASS="Code">
LD_LIBRARY_PATH</EM>
<A NAME="marker-271839"></A> to find the dynamic libraries.</LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-168763"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-218444"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
Notice the simplicity of the specified library names. The ACE library is specified merely as <EM CLASS="Code">
ACE</EM>
, not as <EM CLASS="Code">
ACE.dll</EM>
, <EM CLASS="Code">
ACEd.dll</EM>
, <EM CLASS="Code">
libACE.so</EM>
, etc. The simplified name enables the component developer to describe an <A NAME="marker-270294"></A>implementation artifact in a platform-independent manner. This behavior is specific to CIAO.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-168414"></A>An <A NAME="marker-270301"></A>Implementation Artifact Descriptor describes each of the three Messenger libraries. The <EM CLASS="Code">
Messenger_stub</EM>
 library is described as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-168440"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-168495"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168441"></A>&lt;Deployment:ImplementationArtifactDescription</P>
<P CLASS="Code">
<A NAME="pgfId-168442"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168443"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168444"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168445"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168446"></A>  &lt;label&gt;Messenger Stub Artifact&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168447"></A>  &lt;location&gt;Messenger_stub&lt;/location&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168448"></A>  &lt;dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168449"></A>    &lt;name&gt;ACE/TAO/CIAO&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168450"></A>    &lt;referencedArtifact href=&quot;Libraries.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168451"></A>  &lt;/dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168452"></A>&lt;/Deployment:ImplementationArtifactDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168494"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-168438"></A>The optional <EM CLASS="Code">
&lt;label&gt;</EM>
 element may be used by a tool for display purposes. The <EM CLASS="Code">
&lt;location&gt;</EM>
 element contains the simplified name of the library. Since we have not provided a path, the library must be in the application’s <EM CLASS="Code">
PATH</EM>
<A NAME="marker-271889"></A> (Windows) or <EM CLASS="Code">
LD_LIBRARY_PATH</EM>
<A NAME="marker-271846"></A> (UNIX). Optionally, we could provide a path, as we did for the ACE, TAO, and CIAO libraries.</LI>
<LI CLASS="Body">
<A NAME="pgfId-168493"></A>Each <EM CLASS="Code">
&lt;dependsOn&gt;</EM>
 element contains references to dependent implementation artifacts. We depend on the ACE/TAO/CIAO libraries, so our <EM CLASS="Code">
&lt;dependsOn&gt;</EM>
 entry references the <EM CLASS="Code">
Libraries.iad</EM>
 file containing references to the ACE/TAO/CIAO libraries. The mandatory <EM CLASS="Code">
&lt;name&gt;</EM>
 sub-element may be used by a tool for display purposes.</LI>
<LI CLASS="Body">
<A NAME="pgfId-170913"></A>The descriptor also recognizes one or more optional <A NAME="&lt;infoProperty&gt;"></A><EM CLASS="Code">
&lt;infoProperty&gt;</EM>
 elements that provide non-functional information that might be displayed by a tool. For example:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-170914"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-170915"></A>  &lt;infoProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170916"></A>    &lt;name&gt;comment&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170917"></A>    &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170918"></A>      &lt;type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170919"></A>        &lt;kind&gt;tk_string&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170920"></A>      &lt;/type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170921"></A>      &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170922"></A>        &lt;string&gt;This IAD describes the Messenger's stub library&lt;/string&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170923"></A>      &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170924"></A>    &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170925"></A>  &lt;/infoProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170926"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-168837"></A>The Messenger has two more <A NAME="marker-270309"></A>Implementation Artifact Descriptors, one for its <EM CLASS="Code">
Messenger_svnt</EM>
 library and one for its <EM CLASS="Code">
Messenger_exec</EM>
 library. The <EM CLASS="Code">
Messenger_svnt.iad</EM>
 files is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-168838"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-168839"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168840"></A>&lt;Deployment:ImplementationArtifactDescription</P>
<P CLASS="Code">
<A NAME="pgfId-168841"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168842"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168843"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168844"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168845"></A>  &lt;label&gt;Messenger Servant Artifact&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168846"></A>  &lt;location&gt;Messenger_svnt&lt;/location&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168847"></A>  &lt;dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168848"></A>    &lt;name&gt;ACE/TAO/CIAO&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168849"></A>    &lt;referencedArtifact href=&quot;Libraries.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168850"></A>  &lt;/dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168851"></A>  &lt;dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168852"></A>    &lt;name&gt;Messenger_Stub&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168853"></A>    &lt;referencedArtifact href=&quot;Messenger_Stub.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168854"></A>  &lt;/dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168855"></A>  &lt;execParameter&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168856"></A>    &lt;name&gt;entryPoint&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168857"></A>    &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168858"></A>      &lt;type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168859"></A>        &lt;kind&gt;tk_string&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168860"></A>      &lt;/type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168861"></A>      &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168862"></A>        &lt;string&gt;createMessengerHome_Servant&lt;/string&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168863"></A>      &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168864"></A>    &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168865"></A>  &lt;/execParameter&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168866"></A>&lt;/Deployment:ImplementationArtifactDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168867"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-168868"></A>The <EM CLASS="Code">
&lt;label&gt;</EM>
, <EM CLASS="Code">
&lt;location&gt;</EM>
, and first <EM CLASS="Code">
&lt;dependsOn&gt;</EM>
 elements contain similar information to that in the <EM CLASS="Code">
Messenger_stub.iad</EM>
 file. However, the <EM CLASS="Code">
Messenger_svnt</EM>
 library also depends on the <EM CLASS="Code">
Messenger_stub</EM>
 library, as reflected in the additional <EM CLASS="Code">
&lt;dependsOn&gt;</EM>
 element. In addition, the <EM CLASS="Code">
Messenger_svnt</EM>
 library has an entry point function, configured through the <EM CLASS="Code">
&lt;execParameter&gt;</EM>
 element. An entry point function always has the <EM CLASS="Code">
&lt;name&gt;</EM>
 of “entryPoint”. The execution parameter’s <EM CLASS="Code">
&lt;value&gt;</EM>
 element is actually an XML representation of a CORBA Any. The <EM CLASS="Code">
&lt;value&gt;</EM>
 element’s string value matches the name of the Messenger’s library entry point function as generated by the <A NAME="marker-268977"></A>CIDL compiler. Additional information on the CIDL compiler is available in <A HREF="CIAO.htm#68030" CLASS="XRef">See CIDL Compiler Reference</A>.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-170881"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-218492"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
CIAO looks for an “entryPoint” execution parameter for any <A NAME="marker-270316"></A>implementation artifact that ends in _svnt or _exec. Thus, your servant and <A NAME="marker-267003"></A>executor implementation artifacts should end in _svnt and _exec, respectively.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-168970"></A>The <EM CLASS="Code">
Messenger_exec</EM>
 <A NAME="marker-270324"></A>Implementation Artifact Descriptor is nearly identical to the <EM CLASS="Code">
Messenger_svnt</EM>
 descriptor, as is shown below:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-168981"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169082"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168982"></A>&lt;Deployment:ImplementationArtifactDescription</P>
<P CLASS="Code">
<A NAME="pgfId-168983"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168984"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168985"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-168986"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168987"></A>  &lt;label&gt;Messenger Executor Artifact&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168988"></A>  &lt;location&gt;Messenger_exec&lt;/location&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168989"></A>  &lt;dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168990"></A>    &lt;name&gt;ACE/TAO/CIAO&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168991"></A>    &lt;referencedArtifact href=&quot;Libraries.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168992"></A>  &lt;/dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168993"></A>  &lt;dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168994"></A>    &lt;name&gt;Messenger_Stub&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168995"></A>    &lt;referencedArtifact href=&quot;Messenger_Stub.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168996"></A>  &lt;/dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168997"></A>  &lt;execParameter&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168998"></A>    &lt;name&gt;entryPoint&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-168999"></A>    &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169000"></A>      &lt;type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169001"></A>        &lt;kind&gt;tk_string&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169002"></A>      &lt;/type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169003"></A>      &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169004"></A>        &lt;string&gt;createMessengerHome_Impl&lt;/string&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169005"></A>      &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169006"></A>    &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169007"></A>  &lt;/execParameter&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169008"></A>&lt;/Deployment:ImplementationArtifactDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169083"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-184037"></A>The <EM CLASS="Code">
Messenger_exec</EM>
 implementation artifact also has a library entry point function, matching the name of the entry point function generated by the <A NAME="marker-268981"></A>CIDL compiler.</LI>
<LI CLASS="Body">
<A NAME="pgfId-185223"></A>In summary, each of the component’s <A NAME="marker-270332"></A>Implementation Artifact Descriptor files contains information about one of the component’s libraries. There is an <A NAME="marker-270339"></A>Implementation Artifact Descriptor for each of the <EM CLASS="Code">
Messenger_stub</EM>
, <EM CLASS="Code">
Messenger_svnt</EM>
, and <EM CLASS="Code">
Messenger_exec</EM>
 libraries.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-165993"></A>Messenger Component - CORBA Component Descriptor (.ccd)</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-165994"></A>The <A NAME="marker-270476"></A>CORBA Component Descriptor describes the component’s IDL3 interface in an XML format. Primarily, it describes the component’s exposed ports and <A NAME="marker-275532"></A>attributes. The mapping from a component’s IDL file to a CORBA Component Descriptor is purely mechanical.</LI>
<LI CLASS="Body">
<A NAME="pgfId-170299"></A>There are six kinds of component ports: <A NAME="marker-263093"></A><EM CLASS="Code">
Facet</EM>
, <A NAME="marker-264386"></A><EM CLASS="Code">
SimplexReceptacle</EM>
, <A NAME="marker-264435"></A><EM CLASS="Code">
MultiplexReceptacle</EM>
, <A NAME="marker-265160"></A><EM CLASS="Code">
EventPublisher</EM>
, <EM CLASS="Code">
EventEmitter</EM>
<A NAME="marker-266018"></A>, and <EM CLASS="Code">
EventConsumer</EM>
<A NAME="marker-265987"></A>, as shown in <A HREF="CIAO.htm#27680" CLASS="XRef">See Component Port Types</A>:</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-170320"></A><A NAME="27680"></A>Component <A NAME="marker-263319"></A>Port Types</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-170324"></A>Port Kind</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-170326"></A>Sample IDL3 Declaration</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170415"></A>Facet</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170417"></A>provides Runnable control</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170379"></A>SimplexReceptacle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170381"></A>uses Runnable control</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170383"></A>MultiplexReceptacle</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170385"></A>uses multiple Runnable controls</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170387"></A>EventPublisher</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170389"></A>publishes Message message_publisher</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170391"></A>EventEmitter</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170393"></A>emits Message message_emitter</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170328"></A>EventConsumer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-170330"></A>consumes Message message_consumer</P>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-170300"></A>Recall that the Messenger component’s IDL3 is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-169325"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169344"></A>component Messenger {	</P>
<P CLASS="Code">
<A NAME="pgfId-169326"></A>  attribute string subject;</P>
<P CLASS="Code">
<A NAME="pgfId-169327"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169328"></A>  provides Runnable control;</P>
<P CLASS="Code">
<A NAME="pgfId-169329"></A>  provides Publication content;</P>
<P CLASS="Code">
<A NAME="pgfId-169330"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169331"></A>  publishes Message message_publisher;</P>
<P CLASS="Code">
<A NAME="pgfId-169332"></A>  provides History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-169333"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-169334"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-169322"></A>We create the <EM CLASS="Code">
Messenger.ccd</EM>
 file describing the Messenger’s IDL3 interface as follows. Comments are interspersed. </LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-169149"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169842"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169150"></A>&lt;Deployment:ComponentInterfaceDescription</P>
<P CLASS="Code">
<A NAME="pgfId-169151"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-169152"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-169153"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-169154"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169155"></A>  &lt;label&gt;Messenger Component&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169156"></A>  &lt;specificType&gt;IDL:Messenger:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169157"></A>  &lt;supportedType&gt;IDL:Messenger:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169350"></A>  &lt;idlFile&gt;Messenger.idl&lt;/idlFile&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169158"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-169373"></A>The optional <EM CLASS="Code">
&lt;label&gt;</EM>
 element contains a description that may be used by a tool for display purposes. The <EM CLASS="Code">
&lt;specificType&gt;</EM>
 element contains the Interface Repository Id of the component’s IDL interface.</LI>
<LI CLASS="Body">
<A NAME="pgfId-184515"></A>The descriptor has a <EM CLASS="Code">
&lt;supportedType&gt;</EM>
 element for the component’s Interface Repository Id. It also has a <EM CLASS="Code">
&lt;supportedType&gt;</EM>
 element for each IDL2 interface supported by the component either directly or through inheritance. A component may indicate that it supports an IDL2 interface through the <A NAME="marker-272484"></A><EM CLASS="Code">
supports</EM>
 keyword. For example.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-184504"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-184509"></A>component Messenger supports MyInterface {</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-184510"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-184505"></A>would map to an additional <EM CLASS="Code">
&lt;supportedType&gt;</EM>
 element such as this:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-220382"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-220385"></A>  &lt;supportedType&gt;IDL:MyInterface:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-220386"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-220375"></A>A component supporting an interface inherits the operations, <A NAME="marker-275538"></A>attributes, etc. from that interface. However, we don’t use the <A NAME="marker-272495"></A><EM CLASS="Code">
supports</EM>
 keyword in our examples.</LI>
<LI CLASS="Body">
<A NAME="pgfId-184514"></A>The optional <EM CLASS="Code">
&lt;idlFile&gt;</EM>
 element points to the IDL file that is the source of this information. It is for documentation purposes.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-169374"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169159"></A>  &lt;property&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169160"></A>    &lt;name&gt;subject&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169161"></A>    &lt;type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169162"></A>      &lt;kind&gt;tk_string&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169163"></A>    &lt;/type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169164"></A>  &lt;/property&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169165"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-169385"></A>A <EM CLASS="Code">
&lt;property&gt;</EM>
 element describes each of the component’s IDL <A NAME="marker-275544"></A>attributes. This <EM CLASS="Code">
&lt;property&gt;</EM>
 element describes the component’s <EM CLASS="Code">
subject</EM>
 attribute. The <EM CLASS="Code">
&lt;name&gt;</EM>
 element’s value matches the <A NAME="marker-275550"></A>attribute name in the IDL file. The <EM CLASS="Code">
&lt;type&gt;</EM>
 element’s <EM CLASS="Code">
&lt;kind&gt;</EM>
 is a type code. In our example, the attribute is a string. The “Deployment and Configuration” specification (<A NAME="marker-261547"></A>OMG Document ptc/03-07-08) and the <EM CLASS="Code">
Deployment.xsd</EM>
 schema file contain more information on representing data types in XML descriptors.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-169390"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169166"></A>  &lt;port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169167"></A>    &lt;name&gt;control&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169729"></A>    &lt;exclusiveProvider&gt;false&lt;/exclusiveProvider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169730"></A>    &lt;exclusiveUser&gt;false&lt;/exclusiveUser&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169638"></A>    &lt;optional&gt;true&lt;/optional&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169639"></A>    &lt;provider&gt;true&lt;/provider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169713"></A>    &lt;specificType&gt;IDL:Runnable:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169714"></A>    &lt;supportedType&gt;IDL:Runnable:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169715"></A>    &lt;kind&gt;Facet&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169175"></A>  &lt;/port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169176"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-272685"></A>Each <A NAME="marker-272511"></A><EM CLASS="Code">
provides</EM>
, <A NAME="marker-272550"></A><EM CLASS="Code">
uses</EM>
, <A NAME="marker-272545"></A>uses <EM CLASS="Code">
multiple</EM>
, <A NAME="marker-272526"></A><EM CLASS="Code">
publishes</EM>
, <A NAME="marker-272531"></A><EM CLASS="Code">
emits</EM>
, and <A NAME="marker-272536"></A><EM CLASS="Code">
consumes</EM>
 declaration has a matching <EM CLASS="Code">
&lt;port&gt;</EM>
 element. This <A NAME="marker-263344"></A>port corresponds to the</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-184548"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-220399"></A>provides Runnable control;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-220400"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-184549"></A><A NAME="marker-263076"></A>facet. The <EM CLASS="Code">
&lt;name&gt;</EM>
 element’s value matches the <A NAME="marker-263103"></A>facet name in the IDL file. The <EM CLASS="Code">
&lt;specificType&gt;</EM>
 element contains the Interface Repository Id of the facet’s IDL interface. There may be several <EM CLASS="Code">
&lt;supportedType&gt;</EM>
 elements; there is one for the facet’s most specific IDL interface and one for each inherited interface regardless of whether the inheritance is direct or indirect.</LI>
<LI CLASS="Body">
<A NAME="pgfId-220412"></A>The <EM CLASS="Code">
&lt;kind&gt;</EM>
 element’s value is <A NAME="marker-263088"></A><EM CLASS="Code">
Facet</EM>
. Valid <EM CLASS="Code">
&lt;kind&gt;</EM>
 values are <EM CLASS="Code">
Facet</EM>
, <A NAME="marker-264394"></A><EM CLASS="Code">
SimplexReceptacle</EM>
, <A NAME="marker-264443"></A><EM CLASS="Code">
MultiplexReceptacle</EM>
, <A NAME="marker-265166"></A><EM CLASS="Code">
EventPublisher</EM>
, <EM CLASS="Code">
EventEmitter</EM>
<A NAME="marker-266026"></A>, and <EM CLASS="Code">
EventConsumer</EM>
<A NAME="marker-265995"></A>. The <EM CLASS="Code">
&lt;optional&gt;</EM>
 element indicates if connecting to the <A NAME="marker-263356"></A>port is optional or mandatory. The <EM CLASS="Code">
&lt;provider&gt;</EM>
 element’s value is true for <A NAME="marker-272557"></A><EM CLASS="Code">
provides</EM>
 and <A NAME="marker-272562"></A><EM CLASS="Code">
consumes</EM>
, false for <A NAME="marker-272567"></A><EM CLASS="Code">
uses</EM>
 and <A NAME="marker-272572"></A><EM CLASS="Code">
publishes</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-169177"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-184599"></A>  &lt;port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169178"></A>    &lt;name&gt;content&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169760"></A>    &lt;exclusiveProvider&gt;false&lt;/exclusiveProvider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169761"></A>    &lt;exclusiveUser&gt;false&lt;/exclusiveUser&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169676"></A>    &lt;optional&gt;true&lt;/optional&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169677"></A>    &lt;provider&gt;true&lt;/provider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169744"></A>    &lt;supportedType&gt;IDL:Publication:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169745"></A>    &lt;specificType&gt;IDL:Publication:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169746"></A>    &lt;kind&gt;Facet&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169186"></A>  &lt;/port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-170462"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-170463"></A>This is the <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-263115"></A>facet called <EM CLASS="Code">
content</EM>
. Its declaration is nearly identical to that of the <EM CLASS="Code">
Runnable</EM>
 facet</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-170464"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-170465"></A>  &lt;port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169189"></A>    &lt;name&gt;message_publisher&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169190"></A>    &lt;exclusiveProvider&gt;false&lt;/exclusiveProvider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169191"></A>    &lt;exclusiveUser&gt;false&lt;/exclusiveUser&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169192"></A>    &lt;optional&gt;true&lt;/optional&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169193"></A>    &lt;provider&gt;false&lt;/provider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169194"></A>    &lt;supportedType&gt;IDL:Message:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169195"></A>    &lt;specificType&gt;IDL:Message:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169196"></A>    &lt;kind&gt;EventPublisher&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169197"></A>  &lt;/port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169198"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-169781"></A>This is the <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265172"></A>publishing <A NAME="marker-263367"></A>port called <EM CLASS="Code">
message_publisher</EM>
. The <EM CLASS="Code">
&lt;supportedType&gt;</EM>
 and <EM CLASS="Code">
&lt;specificType&gt;</EM>
 are the Interface Repository Id of the <A NAME="marker-265891"></A>event type being published. The port’s <EM CLASS="Code">
&lt;kind&gt;</EM>
 is <A NAME="marker-265178"></A><EM CLASS="Code">
EventPublisher</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-169782"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169199"></A>  &lt;port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169200"></A>    &lt;name&gt;message_history&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169201"></A>    &lt;exclusiveProvider&gt;false&lt;/exclusiveProvider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169202"></A>    &lt;exclusiveUser&gt;false&lt;/exclusiveUser&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169203"></A>    &lt;optional&gt;true&lt;/optional&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169204"></A>    &lt;provider&gt;true&lt;/provider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169205"></A>    &lt;supportedType&gt;IDL:History:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169206"></A>    &lt;specificType&gt;IDL:History:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169207"></A>    &lt;kind&gt;Facet&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169208"></A>  &lt;/port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169209"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-170470"></A>This is the <EM CLASS="Code">
History</EM>
 <A NAME="marker-263124"></A>facet called <EM CLASS="Code">
message_history</EM>
. Its declaration is nearly identical to that of the to the <EM CLASS="Code">
Runnable</EM>
 and <EM CLASS="Code">
Publication</EM>
 facets.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-170468"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-169213"></A>  &lt;configProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169214"></A>    &lt;name&gt;subject&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169215"></A>    &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169216"></A>      &lt;type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169217"></A>        &lt;kind&gt;tk_string&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169218"></A>      &lt;/type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169219"></A>      &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169220"></A>        &lt;string&gt;Default Subject&lt;/string&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169221"></A>      &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169222"></A>    &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169223"></A>  &lt;/configProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-169224"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-184772"></A>This <EM CLASS="Code">
&lt;configProperty&gt;</EM>
 element sets a default value for the Messenger’s <EM CLASS="Code">
subject</EM>
 <A NAME="marker-275556"></A>attribute. Both the “Deployment and Configuration” specification and the <EM CLASS="Code">
Deployment.xsd</EM>
 schema file contain more information on representing data types and values in XML descriptors.</LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-251988"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-252582"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
CIAO currently ignores <EM CLASS="CodeEmph">
&lt;configProperty&gt; </EM>
elements that set values for IDL <A NAME="marker-275562"></A>attributes.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<P CLASS="Code">
<A NAME="pgfId-252583"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-252584"></A>&lt;/Deployment:ComponentInterfaceDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-184777"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-234222"></A>The descriptor also recognizes one or more optional <EM CLASS="Code">
&lt;infoProperty&gt;</EM>
 elements that provide non-functional information that might be displayed by a tool as explained above.</LI>
<LI CLASS="Body">
<A NAME="pgfId-234223"></A>In summary, the Messenger’s <A NAME="marker-270484"></A>CORBA Component Descriptor file, <EM CLASS="Code">
Messenger.ccd</EM>
, is an XML rendition of the component’s IDL3 interface. It contains a <EM CLASS="Code">
&lt;property&gt;</EM>
 element for each component <A NAME="marker-275568"></A>attribute and a <EM CLASS="Code">
&lt;port&gt;</EM>
 element for each <A NAME="marker-263378"></A>port.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-166099"></A><A NAME="18177"></A>Messenger Component - Component Implementation Descriptor (.cid)</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-166100"></A>The Messenger’s <A NAME="marker-270654"></A>Component Implementation Descriptor describes the <A NAME="marker-262122"></A>monolithic implementation of the Messenger component. A monolithic implementation consists of a set of implementation artifacts, or libraries. (By contrast, an <A NAME="marker-262117"></A>assembly implementation is a component implementation that consists of subcomponents). Our monolithic Messenger implementation pulls together the Messenger’s three dynamic libraries—<EM CLASS="Code">
Messenger_stub</EM>
, <EM CLASS="Code">
Messenger_svnt</EM>
, and <EM CLASS="Code">
Messenger_exec</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-171096"></A>The Messenger component’s <A NAME="marker-270661"></A>Component Implementation Descriptor follows. Comments are interspersed.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171182"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171317"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171183"></A>&lt;Deployment:ComponentImplementationDescription</P>
<P CLASS="Code">
<A NAME="pgfId-171184"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-171185"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-171186"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-171187"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171188"></A>  &lt;label&gt;Messenger Implementation&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171189"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-171321"></A>The optional <EM CLASS="Code">
&lt;label&gt;</EM>
 element describes the implementation. A tool may use it for display purposes.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171318"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171319"></A>  &lt;implements href=&quot;Messenger.ccd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171190"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-171357"></A>The <EM CLASS="Code">
&lt;implements&gt;</EM>
 element describes the interface that the component implements by referencing the component’s <A NAME="marker-270491"></A>CORBA Component Descriptor file.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171350"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171351"></A>  &lt;monolithicImpl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171191"></A>    &lt;primaryArtifact&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171192"></A>      &lt;name&gt;Messenger_Stub&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171193"></A>      &lt;referencedArtifact href=&quot;Messenger_Stub.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171194"></A>    &lt;/primaryArtifact&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171195"></A>    &lt;primaryArtifact&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171196"></A>      &lt;name&gt;Messenger_Svnt&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171197"></A>      &lt;referencedArtifact href=&quot;Messenger_Svnt.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171198"></A>    &lt;/primaryArtifact&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171199"></A>    &lt;primaryArtifact&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171200"></A>      &lt;name&gt;Messenger_Exec&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171201"></A>      &lt;referencedArtifact href=&quot;Messenger_Exec.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171202"></A>    &lt;/primaryArtifact&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171203"></A>  &lt;/monolithicImpl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171204"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-171609"></A>The <EM CLASS="Code">
&lt;monolithicImpl&gt;</EM>
 element pulls together the Messenger’s three libraries. Each library is a <EM CLASS="Code">
&lt;primaryArtifact&gt;</EM>
 represented by a reference to an <A NAME="marker-270347"></A>Implementation Artifact Descriptor file. </LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171205"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-185249"></A>  &lt;configProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171206"></A>    &lt;name&gt;ComponentIOR&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171207"></A>    &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171208"></A>      &lt;type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171209"></A>        &lt;kind&gt;tk_string&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171210"></A>      &lt;/type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171211"></A>      &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171212"></A>        &lt;string&gt;Messenger.ior&lt;/string&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171213"></A>      &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171214"></A>    &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171215"></A>  &lt;/configProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171216"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-171382"></A>CIAO supports one optional <EM CLASS="Code">
&lt;configProperty&gt;</EM>
, the <EM CLASS="Code">
ComponentIOR</EM>
 property, for a component implementation. At run time, the <A NAME="marker-264112"></A>component server writes the component’s object reference to the file indicated by the <EM CLASS="Code">
ComponentIOR</EM>
 property value. By default, the component server writes the file to the directory from which it was launched. A non-CCM CORBA client may use that IOR file to discover the component.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171380"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171217"></A>&lt;/Deployment:ComponentImplementationDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171168"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-166106"></A>The <A NAME="marker-270668"></A>Component Implementation Descriptor also accepts <EM CLASS="Code">
&lt;capability&gt;</EM>
 elements which can be used by the <A NAME="marker-264120"></A>component server to choose between component implementations. It also accepts non-functional <EM CLASS="Code">
&lt;infoProperty&gt;</EM>
 elements as explained above.</LI>
<LI CLASS="Body">
<A NAME="pgfId-185278"></A>In summary, the Messenger’s <A NAME="marker-270675"></A>Component Implementation Descriptor constructs a <A NAME="marker-270265"></A>monolithic Messenger implementation from the Messenger’s libraries.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-185285"></A>Messenger Component - Component Package Descriptor (.cpd)</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-185286"></A>The <A NAME="marker-270815"></A>Component Package Descriptor is the component’s top-level packaging file. It can describe multiple alternative implementations of the same component interface and can contain configuration properties for the component.</LI>
<LI CLASS="Body">
<A NAME="pgfId-171666"></A>In our example, we merely reference the component implementation defined in the previous subsection.</LI>
<LI CLASS="Body">
<A NAME="pgfId-166164"></A>The <A NAME="marker-270822"></A>Component Package Descriptor for the Messenger component is as follows, with comments interspersed:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171705"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171784"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171706"></A>&lt;Deployment:ComponentPackageDescription </P>
<P CLASS="Code">
<A NAME="pgfId-171707"></A>xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot; </P>
<P CLASS="Code">
<A NAME="pgfId-171708"></A>xmlns:xmi=&quot;http://www.omg.org/XMI&quot; </P>
<P CLASS="Code">
<A NAME="pgfId-171709"></A>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </P>
<P CLASS="Code">
<A NAME="pgfId-171710"></A>xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171711"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171712"></A>  &lt;label&gt;Messenger Component&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171792"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-171793"></A>The optional <EM CLASS="Code">
&lt;label&gt;</EM>
 element is a human readable package label that may be used by a tool for display purposes.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171794"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171713"></A>  &lt;realizes href=&quot;Messenger.ccd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171818"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-171819"></A>The <EM CLASS="Code">
&lt;realizes&gt;</EM>
 element indicates the component’s IDL3 interface by referencing the component’s <A NAME="marker-270498"></A>CORBA Component Descriptor file.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171828"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-171714"></A>  &lt;implementation&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171715"></A>    &lt;name&gt;MessengerImpl&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171716"></A>    &lt;referencedImplementation href=&quot;Messenger.cid&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171717"></A>  &lt;/implementation&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171718"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-171848"></A>The <EM CLASS="Code">
&lt;implementation&gt;</EM>
 element references one or more Component Implementations Descriptors. Our example has just one Messenger implementation, so we refer to that implementation here. A more complex example may have multiple implementations and may use <EM CLASS="Code">
&lt;deployRequirement&gt;</EM>
 elements to enable a <A NAME="marker-264127"></A>component server to choose between them.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-171719"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-185437"></A>&lt;/Deployment:ComponentPackageDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-171787"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-166166"></A>The <A NAME="marker-270829"></A>Component Package Descriptor also recognizes &lt;infoProperty&gt; documentation elements and <EM CLASS="Code">
&lt;configProperty&gt;</EM>
 default <A NAME="marker-275574"></A>attribute value configuration elements.</LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-244977"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-244978"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
CIAO does not yet support the setting of a default <A NAME="marker-275580"></A>attribute value through a <EM CLASS="Code">
&lt;configProperty&gt;</EM>
 element, so this value is currently ignored.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-172017"></A>To summarize, the <A NAME="marker-270836"></A>Component Package Descriptor is the component’s top-level descriptor, representing the component to the rest of the application.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-185843"></A>Messenger Component - Summary</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-185882"></A>The table summarizes the six Messenger component descriptor files</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-185851"></A>: Messenger Descriptor Files</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-185855"></A>File</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-185857"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-185859"></A>Messenger_stub.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-185861"></A><A NAME="marker-270385"></A>Implementation Artifact Descriptor for the Messenger’s stub library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-185863"></A>Messenger_svnt.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-185865"></A><A NAME="marker-270362"></A>Implementation Artifact Descriptor for the Messenger’s servant library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-185867"></A>Messenger_exec.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-185869"></A><A NAME="marker-270378"></A>Implementation Artifact Descriptor for the Messenger’s <A NAME="marker-270374"></A>executor library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-185871"></A>Messenger.ccd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-185873"></A><A NAME="marker-270505"></A>CORBA Component Descriptor for the Messenger’s IDL3 interface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-185875"></A>Messenger.cid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-185877"></A><A NAME="marker-270682"></A>Component Implementation Descriptor describing the Messenger’s implementation in terms of its libraries</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-185879"></A>Messenger.cpd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-185881"></A><A NAME="marker-270843"></A>Component Package Descriptor packaging the Messenger component into one deployable package.</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-185883"></A>Receiver Component Descriptors</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-185884"></A>The Receiver component type has a similar set of descriptor files, as illustrated by the diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-185893"></A> Receiver Descriptor Files</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-185891"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-24.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-172495"></A>The primary differences between the Receiver’s and the Messenger’s descriptor files are in the <A NAME="marker-270394"></A>Implementation Artifact Descriptor and the <A NAME="marker-270512"></A>CORBA Component Descriptor.</LI>
<LI CLASS="Body">
<A NAME="pgfId-186140"></A>The Receiver’s three <A NAME="marker-270401"></A>Implementation Artifact Descriptors reflect the fact that each of the Receiver’s three libraries has a dependency on the Messenger’s stub library. The dependency is illustrated by the <EM CLASS="Code">
Receiver_stub.iad</EM>
 file:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-172643"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-172756"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172644"></A>&lt;Deployment:ImplementationArtifactDescription</P>
<P CLASS="Code">
<A NAME="pgfId-172645"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-172646"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-172647"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-172648"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172649"></A>  &lt;label&gt;Receiver Stub Artifact&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172650"></A>  &lt;location&gt;Receiver_stub&lt;/location&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172651"></A>  &lt;dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172652"></A>    &lt;name&gt;ACE/TAO/CIAO&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172653"></A>    &lt;referencedArtifact href=&quot;Libraries.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172654"></A>  &lt;/dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172655"></A>  &lt;dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172656"></A>    &lt;name&gt;Messenger_Stub&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172657"></A>    &lt;referencedArtifact href=&quot;Messenger_Stub.iad&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172658"></A>  &lt;/dependsOn&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172671"></A>&lt;/Deployment:ImplementationArtifactDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-198356"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-198364"></A>The Receiver’s servant and <A NAME="marker-267018"></A>executor <A NAME="marker-270408"></A>Implementation Artifact Descriptor files are analogous to the Messenger’s with the additional dependency on the <EM CLASS="Code">
Messenger_stub</EM>
 library. We do not show them here.</LI>
<LI CLASS="Body">
<A NAME="pgfId-172758"></A>The Receiver’s <A NAME="marker-270519"></A>CORBA Component Descriptor file describes the Receiver’s IDL3 interface, which is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-172785"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-172811"></A>component Receiver {</P>
<P CLASS="Code">
<A NAME="pgfId-172786"></A>  consumes Message message_consumer;</P>
<P CLASS="Code">
<A NAME="pgfId-172787"></A>  uses History message_history;</P>
<P CLASS="Code">
<A NAME="pgfId-172788"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-172820"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-172775"></A>The <A NAME="marker-270526"></A>CORBA Component Descriptor describes the Receiver’s two ports, an <EM CLASS="Code">
EventConsumer</EM>
<A NAME="marker-266002"></A> and a <A NAME="marker-264401"></A><EM CLASS="Code">
SimplexReceptacle</EM>
. It is as follows, with comments interspersed:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-172839"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-172980"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172840"></A>&lt;Deployment:ComponentInterfaceDescription</P>
<P CLASS="Code">
<A NAME="pgfId-172841"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-172842"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-172843"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-172844"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172845"></A>  &lt;label&gt;Receiver Component&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172846"></A>  &lt;specificType&gt;IDL:Receiver:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172847"></A>  &lt;supportedType&gt;IDL:Receiver:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172848"></A>  &lt;idlFile&gt;Receiver.idl&lt;/idlFile&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172849"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-172850"></A>  &lt;port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172851"></A>    &lt;name&gt;message_consumer&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172852"></A>    &lt;exclusiveProvider&gt;false&lt;/exclusiveProvider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172853"></A>    &lt;exclusiveUser&gt;false&lt;/exclusiveUser&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172854"></A>    &lt;optional&gt;false&lt;/optional&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172855"></A>    &lt;provider&gt;true&lt;/provider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172856"></A>    &lt;supportedType&gt;IDL:Message:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172857"></A>    &lt;specificType&gt;IDL:Message:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172858"></A>    &lt;kind&gt;EventConsumer&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172859"></A>  &lt;/port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172860"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-172978"></A>The <EM CLASS="Code">
message_consumer</EM>
 <A NAME="marker-263387"></A>port is an <EM CLASS="Code">
EventConsumer</EM>
<A NAME="marker-266010"></A> that consumes <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265804"></A>events. The <EM CLASS="Code">
&lt;supportedType&gt;</EM>
 and <EM CLASS="Code">
&lt;specificType&gt;</EM>
 elements contain the Interface Repository Id of the <A NAME="marker-265184"></A>published <A NAME="marker-265898"></A>event type.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-172979"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-172861"></A>  &lt;port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172862"></A>    &lt;name&gt;message_history&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172863"></A>    &lt;exclusiveProvider&gt;false&lt;/exclusiveProvider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172864"></A>    &lt;exclusiveUser&gt;true&lt;/exclusiveUser&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172865"></A>    &lt;optional&gt;true&lt;/optional&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172866"></A>    &lt;provider&gt;false&lt;/provider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172867"></A>    &lt;supportedType&gt;IDL:History:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172868"></A>    &lt;specificType&gt;IDL:History:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172869"></A>    &lt;kind&gt;SimplexReceptacle&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172870"></A>  &lt;/port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172871"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-173013"></A>The <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-263396"></A>port uses the Messenger’s <EM CLASS="Code">
History</EM>
 interface. The <EM CLASS="Code">
uses</EM>
 keyword in the component’s interface indicates that it is a <A NAME="marker-264409"></A><EM CLASS="Code">
SimplexReceptacle</EM>
, meaning that the <A NAME="marker-264303"></A>receptacle connects to exactly one <EM CLASS="Code">
History</EM>
 <A NAME="marker-263132"></A>facet. The <EM CLASS="Code">
message_consumer</EM>
 port may receive <EM CLASS="Code">
Message</EM>
 <A NAME="marker-265812"></A>events from multiple <A NAME="marker-265190"></A>publishers, but the <EM CLASS="Code">
message_history</EM>
 port may only retrieve the <EM CLASS="Code">
History</EM>
 from one provider.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-173003"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-172885"></A>&lt;/Deployment:ComponentInterfaceDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-172886"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-172572"></A>The table summarizes the six Receiver descriptor files.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-172541"></A>Receiver Descriptor Files</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-172545"></A>File</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-172547"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-172549"></A>Receiver_stub.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-172551"></A><A NAME="marker-270415"></A>Implementation Artifact Descriptor for the Receiver’s stub library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-172553"></A>Receiver_svnt.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-172555"></A><A NAME="marker-270422"></A>Implementation Artifact Descriptor for the Receiver’s servant library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-172557"></A>Receiver_exec.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-172559"></A><A NAME="marker-270429"></A>Implementation Artifact Descriptor for the Receiver’s <A NAME="marker-267025"></A>executor library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-172561"></A>Receiver.ccd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-172563"></A><A NAME="marker-270542"></A>CORBA Component Descriptor for the Receiver’s IDL3 interface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-172565"></A>Receiver.cid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-172567"></A><A NAME="marker-270689"></A>Component Implementation Descriptor describing the Receiver’s implementation in terms of its libraries</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-172569"></A>Receiver.cpd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-172571"></A><A NAME="marker-270850"></A>Component Package Descriptor packaging the Receiver component into one deployable package.</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-186192"></A>Administrator Component Descriptors</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-220625"></A>The Administrator component type also has a similar set of descriptor files, as illustrated in the diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-220633"></A> Administrator Descriptor Files</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-220631"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-25.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-220634"></A>Like the Receiver, each of the Administrator’s libraries depends on the Messenger’s <EM CLASS="Code">
Messenger_stub</EM>
 library. We won’t replicate the <A NAME="marker-270436"></A>Implementation Artifact Descriptor files here.</LI>
<LI CLASS="Body">
<A NAME="pgfId-173147"></A>The Administrator’s <A NAME="marker-270549"></A>CORBA Component Descriptor file describes the Administrator’s IDL3 interface, which is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-173148"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-173165"></A>component Administrator {</P>
<P CLASS="Code">
<A NAME="pgfId-173166"></A>  uses multiple Runnable runnables;</P>
<P CLASS="Code">
<A NAME="pgfId-173167"></A>  uses multiple Publication content;</P>
<P CLASS="Code">
<A NAME="pgfId-173168"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-173153"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-173154"></A>The Administrator’s <A NAME="marker-270556"></A>CORBA Component Descriptor describes the two Administrator <A NAME="marker-264450"></A><EM CLASS="Code">
MultiplexReceptacle</EM>
 ports. It is as follows, with comments interspersed:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-173189"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-186204"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173190"></A>&lt;Deployment:ComponentInterfaceDescription</P>
<P CLASS="Code">
<A NAME="pgfId-173191"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-173192"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-173193"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-173194"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173195"></A>  &lt;label&gt;Administrator Component&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173196"></A>  &lt;specificType&gt;IDL:Administrator:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173197"></A>  &lt;supportedType&gt;IDL:Administrator:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173198"></A>  &lt;idlFile&gt;Administrator.idl&lt;/idlFile&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173199"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-173200"></A>  &lt;port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173201"></A>    &lt;name&gt;runnables&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173202"></A>    &lt;exclusiveProvider&gt;false&lt;/exclusiveProvider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173203"></A>    &lt;exclusiveUser&gt;true&lt;/exclusiveUser&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173204"></A>    &lt;optional&gt;true&lt;/optional&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173205"></A>    &lt;provider&gt;false&lt;/provider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173206"></A>    &lt;supportedType&gt;IDL:Runnable:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173207"></A>    &lt;specificType&gt;IDL:Runnable:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173208"></A>    &lt;kind&gt;MultiplexReceptacle&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173209"></A>  &lt;/port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173210"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-173322"></A>The <EM CLASS="Code">
runnables</EM>
 <A NAME="marker-263407"></A>port uses the Messenger’s <EM CLASS="Code">
Runnable</EM>
 interface. The <EM CLASS="Code">
uses multiple</EM>
 keyword in the IDL3 interface indicates that it is a <A NAME="marker-264458"></A><EM CLASS="Code">
MultiplexReceptacle</EM>
, meaning that it may connect to many <EM CLASS="Code">
Runnable</EM>
 <A NAME="marker-263139"></A>facets.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-173316"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-173211"></A>  &lt;port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173212"></A>    &lt;name&gt;content&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173213"></A>    &lt;exclusiveProvider&gt;false&lt;/exclusiveProvider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173214"></A>    &lt;exclusiveUser&gt;true&lt;/exclusiveUser&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173215"></A>    &lt;optional&gt;true&lt;/optional&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173216"></A>    &lt;provider&gt;false&lt;/provider&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173217"></A>    &lt;supportedType&gt;IDL:Publication:1.0&lt;/supportedType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173218"></A>    &lt;specificType&gt;IDL:Publication:1.0&lt;/specificType&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173219"></A>    &lt;kind&gt;MultiplexReceptacle&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173220"></A>  &lt;/port&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173221"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-173344"></A>The <EM CLASS="Code">
content</EM>
 <A NAME="marker-263416"></A>port uses the Messenger’s <EM CLASS="Code">
Publication</EM>
 interface. It is also a <A NAME="marker-264466"></A><EM CLASS="Code">
MultiplexReceptacle</EM>
, meaning that it may connect to many <EM CLASS="Code">
Publication</EM>
 <A NAME="marker-263146"></A>facets.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-173342"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-173235"></A>&lt;/Deployment:ComponentInterfaceDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176364"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-173174"></A>The table summarizes the six Administrator descriptor files.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-173408"></A>Administrator Descriptor Files</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-173412"></A>File</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-173414"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-173416"></A>Administrator_stub.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-173418"></A><A NAME="marker-270443"></A>Implementation Artifact Descriptor for the Administrator’s stub library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-173420"></A>Administrator_svnt.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-173422"></A><A NAME="marker-270450"></A>Implementation Artifact Descriptor for the Administrator’s servant library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-173424"></A>Administrator_exec.iad</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-173426"></A><A NAME="marker-270457"></A>Implementation Artifact Descriptor for the Administrator’s <A NAME="marker-267032"></A>executor library</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-173428"></A>Administrator.ccd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-173430"></A><A NAME="marker-270563"></A>CORBA Component Descriptor for the Administrator’s IDL3 interface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-173432"></A>Administrator.cid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-173434"></A><A NAME="marker-270696"></A>Component Implementation Descriptor describing the Administrator’s implementation in terms of its libraries</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-173436"></A>Administrator.cpd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-173438"></A><A NAME="marker-270857"></A>Component Package Descriptor packaging the Administrator component into one deployable package.</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-166307"></A>Messenger Assembly Descriptors</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-173694"></A>An <A NAME="marker-262132"></A>assembly is a component implementation that consists of a set of subcomponent instances connected through their ports.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-231217"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231215"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-26.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-231212"></A>We package the Messenger, Receiver, and Application components into one top-level component we refer to as the Messenger <A NAME="marker-262149"></A>Assembly. Our Messenger Assembly consists of one Messenger component instance, two Receiver component instances, and one Administrator component instance.</LI>
<LI CLASS="Body">
<A NAME="pgfId-173624"></A>The Messenger <A NAME="marker-262154"></A>Assembly’s <A NAME="marker-261591"></A>deployment is described by three descriptor files: a <A NAME="marker-270570"></A>CORBA Component Descriptor describing the assembly’s exposed properties and ports; a <A NAME="marker-270703"></A>Component Implementation Descriptor describing the assembly’s implementation in terms of its subcomponent instances and the connections between them; and a <A NAME="marker-270864"></A>Component Package Descriptor that packages the <A NAME="marker-262163"></A>assembly into a deployable component. The relationships between the descriptor files are illustrated in the diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-173813"></A> Messenger Assembly Descriptor Files</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-173811"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-27.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-173846"></A>A <A NAME="marker-270577"></A>CORBA Component Descriptor describes the Messenger <A NAME="marker-262171"></A>Assembly’s public interface. An assembly may expose ports and <A NAME="marker-275586"></A>attributes of its subcomponents to the outside world. The Messenger Assembly exposes the Messenger component’s subject attribute, but does not expose any Messenger, Receiver, or Administrator ports.</LI>
<LI CLASS="Body">
<A NAME="pgfId-173847"></A>A <A NAME="marker-270710"></A>Component Implementation Descriptor describes the Messenger <A NAME="marker-262180"></A>Assembly’s implementation. Its implementation is composed of one instance of the Messenger component, two instances of the Receiver component, and one instance of the Administrator component. The <A NAME="marker-270717"></A>Component Implementation Descriptor describes how the component instances’ <A NAME="marker-263161"></A>facets and event <A NAME="marker-265196"></A>publishers connect to receptacles and event consumers to comprise the assembly.</LI>
<LI CLASS="Body">
<A NAME="pgfId-173848"></A>A <A NAME="marker-270871"></A>Component Package Descriptor can describe many alternate implementations of the <A NAME="marker-262188"></A>assembly. Our example provides one implementation of the Messenger Assembly.</LI>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-220641"></A>Messenger <A NAME="marker-262196"></A>Assembly - CORBA Component Descriptor</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-220642"></A>A <A NAME="marker-270585"></A>CORBA Component Descriptor describes a component’s ports and <A NAME="marker-275592"></A>attributes. An assembled component may expose ports or attributes of its subcomponents. Our Messenger Assembly merely exposes the Messenger component’s subject attribute.</LI>
<LI CLASS="Body">
<A NAME="pgfId-173915"></A>The Messenger <A NAME="marker-262207"></A>Assembly’s <A NAME="marker-270592"></A>CORBA Component Descriptor follows.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-173988"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-174088"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173989"></A>&lt;Deployment:ComponentInterfaceDescription</P>
<P CLASS="Code">
<A NAME="pgfId-173990"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-173991"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-173992"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-173993"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173994"></A>  &lt;label&gt;Messenger Assembly&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173995"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-173996"></A>  &lt;property&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173997"></A>    &lt;name&gt;subject&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173998"></A>    &lt;type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-173999"></A>      &lt;kind&gt;tk_string&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-174000"></A>    &lt;/type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-174001"></A>  &lt;/property&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-174002"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-174018"></A>&lt;/Deployment:ComponentInterfaceDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-174113"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-173978"></A>The <EM CLASS="Code">
&lt;property&gt;</EM>
 element indicates that the <A NAME="marker-262215"></A>assembly exposes an <A NAME="marker-275598"></A>attribute called “subject”, whose type is a string. The assembly’s <A NAME="marker-270724"></A>Component Implementation Descriptor file, described in the next section, defines how the assembly’s subject attribute is mapped to the subject attribute of its Messenger subcomponent.</LI>
<LI CLASS="Body">
<A NAME="pgfId-174953"></A>We can think of the Messenger <A NAME="marker-262224"></A>Assembly as a component whose implied IDL3 interface is the following:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-174970"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-174994"></A>component MessengerAssembly {</P>
<P CLASS="Code">
<A NAME="pgfId-174975"></A>  attribute string subject;</P>
<P CLASS="Code">
<A NAME="pgfId-174976"></A>};</P>
<P CLASS="Code">
<A NAME="pgfId-174999"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-174163"></A>Messenger Assembly - Component Implementation Descriptor</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-174287"></A>The Messenger <A NAME="marker-262233"></A>Assembly’s <A NAME="marker-270732"></A>Component Implementation Descriptor describes the subcomponent instances that comprise the assembly and the connections between their ports. The <A NAME="marker-270739"></A>Component Implementation Descriptor describes the subcomponent instances and connections as shown in the <A NAME="marker-261604"></A>deployment diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-174286"></A> Messenger Application Deployment Diagram</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-174284"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-28.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-258826"></A>The Messenger <A NAME="marker-262241"></A>Assembly’s <A NAME="marker-270746"></A>Component Implementation Descriptor is as follows, with comments interspersed.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175014"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-186254"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175015"></A>&lt;Deployment:ComponentImplementationDescription</P>
<P CLASS="Code">
<A NAME="pgfId-175016"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-175017"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-175018"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-175019"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175020"></A>  &lt;label&gt;Messenger Assembly&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175021"></A>  &lt;implements href=&quot;MessengerAssembly.ccd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175022"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-175220"></A>The <EM CLASS="Code">
&lt;implements&gt;</EM>
 element references the Messenger <A NAME="marker-262250"></A>Assembly’s <A NAME="marker-270599"></A>CORBA Component Descriptor documented in the previous section.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175229"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-175238"></A>  &lt;assemblyImpl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175255"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-175264"></A>An <EM CLASS="Code">
&lt;assemblyImpl&gt;</EM>
 element indicates that this is an <A NAME="marker-262259"></A>assembly-based component, meaning that is composed of subcomponent instances. </LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175273"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-175023"></A>    &lt;instance xmi:id=&quot;a_Messenger&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175024"></A>      &lt;name&gt;Messenger_Instance&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175025"></A>      &lt;package href=&quot;Messenger.cpd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175026"></A>    &lt;/instance&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175027"></A>    &lt;instance xmi:id=&quot;first_Receiver&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175028"></A>      &lt;name&gt;First_Receiver_Instance&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175029"></A>      &lt;package href=&quot;Receiver.cpd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175030"></A>    &lt;/instance&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175031"></A>    &lt;instance xmi:id=&quot;second_Receiver&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175032"></A>      &lt;name&gt;Second_Receiver_Instance&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175033"></A>      &lt;package href=&quot;Receiver.cpd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175034"></A>    &lt;/instance&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175035"></A>    &lt;instance xmi:id=&quot;a_Administrator&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175036"></A>      &lt;name&gt;Administrator_Instance&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175037"></A>      &lt;package href=&quot;Administrator.cpd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175038"></A>    &lt;/instance&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-220655"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-220656"></A>The <EM CLASS="Code">
&lt;instance&gt;</EM>
 elements create the Messenger instance, the two Receiver instances, and the Administrator instance. Each <EM CLASS="Code">
&lt;instance&gt;</EM>
 refers to the <A NAME="marker-270878"></A>Component Package Descriptor of its component type. The <EM CLASS="Code">
xml::id</EM>
 <A NAME="marker-275604"></A>attributes of the instances are used by <EM CLASS="Code">
&lt;connection&gt;</EM>
 elements to connect the instances’ ports.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175301"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-175040"></A>    &lt;connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175041"></A>      &lt;name&gt;Messenger_to_First_Receiver_Publish&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175042"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175043"></A>        &lt;portName&gt;message_publisher&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175044"></A>        &lt;instance xmi:idref=&quot;a_Messenger&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175045"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175046"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175047"></A>        &lt;portName&gt;message_consumer&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175048"></A>        &lt;instance xmi:idref=&quot;first_Receiver&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175049"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175050"></A>    &lt;/connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175382"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-175391"></A>This connection connects the Messenger instance’s <EM CLASS="Code">
message_publisher</EM>
 <A NAME="marker-263432"></A>port to one Receiver instance’s <EM CLASS="Code">
message_consumer</EM>
 port. The connection’s <EM CLASS="Code">
&lt;name&gt;</EM>
 is a unique identifier for the connection within the <A NAME="marker-262266"></A>assembly. The value in each <EM CLASS="Code">
&lt;portName&gt;</EM>
 element must match the port name in the Messenger’s and Receiver’s <A NAME="marker-270606"></A>CORBA Component Descriptor files. The <EM CLASS="Code">
&lt;instance&gt;</EM>
 element’s <EM CLASS="Code">
xml::idref</EM>
 <A NAME="marker-275610"></A>attribute matches the <EM CLASS="Code">
&lt;instance&gt;</EM>
 element’s <EM CLASS="Code">
xml::id</EM>
 attribute above.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175400"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-175051"></A>    &lt;connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175052"></A>      &lt;name&gt;Messenger_to_First_Receiver_History&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175053"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175054"></A>        &lt;portName&gt;message_history&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175055"></A>        &lt;instance xmi:idref=&quot;a_Messenger&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175056"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175057"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175058"></A>        &lt;portName&gt;message_history&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175059"></A>        &lt;instance xmi:idref=&quot;first_Receiver&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175060"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175061"></A>    &lt;/connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175062"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-175475"></A>This connection connects the Messenger’s <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-263168"></A>facet to a Receiver instance’s <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-264310"></A>receptacle.</LI>
<LI CLASS="Body">
<A NAME="pgfId-175927"></A>The <EM CLASS="Code">
message_publisher</EM>
-to-<EM CLASS="Code">
message_consumer</EM>
 connection and the <EM CLASS="Code">
message_history</EM>
-to-<EM CLASS="Code">
message_history</EM>
 connection are illustrated by the highlights in the <A NAME="marker-261617"></A>deployment diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-175949"></A> One Messenger and Receiver Connection</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-175947"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-29.gif">
</DIV>
</TD>
</TR>
</TABLE>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175484"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-175063"></A>    &lt;connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175064"></A>      &lt;name&gt;Messenger_to_Second_Receiver_Publisher&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175065"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175066"></A>        &lt;portName&gt;message_publisher&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175067"></A>        &lt;instance xmi:idref=&quot;a_Messenger&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175068"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175069"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175070"></A>        &lt;portName&gt;message_consumer&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175071"></A>        &lt;instance xmi:idref=&quot;second_Receiver&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175072"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175073"></A>    &lt;/connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175074"></A>    &lt;connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175075"></A>      &lt;name&gt;Messenger_to_Second_Receiver_History&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175076"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175077"></A>        &lt;portName&gt;message_history&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175078"></A>        &lt;instance xmi:idref=&quot;a_Messenger&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175079"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175080"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175081"></A>        &lt;portName&gt;message_history&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175082"></A>        &lt;instance xmi:idref=&quot;second_Receiver&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175083"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175084"></A>    &lt;/connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175085"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-175515"></A>These two connections connect the second Receiver instance to the Messenger instance. The Messenger instance’s <EM CLASS="Code">
message_publisher</EM>
 <A NAME="marker-263441"></A>port connects to the Receiver instance’s <EM CLASS="Code">
message_consumer</EM>
 port and the Messenger instance’s <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-263175"></A>facet connects to the Receiver instance’s <EM CLASS="Code">
message_history</EM>
 <A NAME="marker-264317"></A>receptacle.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175505"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-175086"></A>    &lt;connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175087"></A>      &lt;name&gt;Messenger_to_Administrator_Control&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175088"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175089"></A>        &lt;portName&gt;control&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175090"></A>        &lt;instance xmi:idref=&quot;a_Messenger&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175091"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175092"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175093"></A>        &lt;portName&gt;runnables&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175094"></A>        &lt;instance xmi:idref=&quot;a_Administrator&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175095"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175096"></A>    &lt;/connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175097"></A>    &lt;connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175098"></A>      &lt;name&gt;Messenger_to_Administrator_Content&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175099"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175100"></A>        &lt;portName&gt;content&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175101"></A>        &lt;instance xmi:idref=&quot;a_Messenger&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175102"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175103"></A>      &lt;internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175104"></A>        &lt;portName&gt;content&lt;/portName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175105"></A>        &lt;instance xmi:idref=&quot;a_Administrator&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175106"></A>      &lt;/internalEndpoint&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175107"></A>    &lt;/connection&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175108"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-175552"></A>These two connections connect the Administrator instance to the Messenger instance. The Messenger instance’s <EM CLASS="Code">
control</EM>
 <A NAME="marker-263182"></A>facet connects to the Administrator instance’s <EM CLASS="Code">
runnables</EM>
 <A NAME="marker-264324"></A>receptacle and the Messenger instance’s <EM CLASS="Code">
content</EM>
 facet connects to the Administrator instance’s <EM CLASS="Code">
content</EM>
 receptacle.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175561"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-175113"></A>    &lt;externalProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175114"></A>        &lt;name&gt;Subject Mapping&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175115"></A>        &lt;externalName&gt;subject&lt;/externalName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175116"></A>        &lt;delegatesTo&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175117"></A>            &lt;propertyName&gt;subject&lt;/propertyName&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175118"></A>            &lt;instance xmi:idref=&quot;a_Messenger&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175119"></A>        &lt;/delegatesTo&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175120"></A>    &lt;/externalProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175121"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-175636"></A>The <EM CLASS="Code">
&lt;externalProperty&gt;</EM>
 element maps the Messenger <A NAME="marker-262273"></A>Assembly’s exposed <EM CLASS="Code">
subject</EM>
 <A NAME="marker-275616"></A>attribute to the Messenger component instance’s <EM CLASS="Code">
subject</EM>
 attribute. The Messenger Assembly doesn’t implement its own subject attribute; it must map to an attribute of one of its subcomponents.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-175645"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-175122"></A>  &lt;/assemblyImpl&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175123"></A>&lt;/Deployment:ComponentImplementationDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-175795"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-174183"></A>In summary, the Messenger <A NAME="marker-262282"></A>Assembly’s <A NAME="marker-270753"></A>Component Implementation Descriptor describes the four subcomponent instances that comprise the <A NAME="marker-262289"></A>assembly and describes the connections that connect their ports together.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-175834"></A>Messenger Assembly - Component Package Descriptor</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-176043"></A>The Messenger <A NAME="marker-262297"></A>Assembly’s <A NAME="marker-270886"></A>Component Package Descriptor is the top-level descriptor that represents the assembly as a deployable component. That should sound familiar; the Messenger, Receiver, and Administrator <A NAME="marker-270893"></A>Component Package Descriptors serve exactly the same purpose.</LI>
<LI CLASS="Body">
<A NAME="pgfId-176158"></A>The Messenger <A NAME="marker-262305"></A>Assembly’s <A NAME="marker-270900"></A>Component Package Descriptor is nearly identical to the Messenger component’s.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-176159"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-176195"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176160"></A>&lt;Deployment:ComponentPackageDescription</P>
<P CLASS="Code">
<A NAME="pgfId-176161"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-176162"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-176163"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-176164"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176165"></A>  &lt;label&gt;Messenger Assembly Package&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176166"></A>  &lt;realizes href=&quot;MessengerAssembly.ccd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176167"></A>  &lt;implementation&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176168"></A>    &lt;name&gt;Messenger Application&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176169"></A>    &lt;referencedImplementation href=&quot;MessengerAssembly.cid&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176170"></A>  &lt;/implementation&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176171"></A>&lt;/Deployment:ComponentPackageDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176196"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-176172"></A>The <EM CLASS="Code">
&lt;realizes&gt;</EM>
 element references the <A NAME="marker-262315"></A>assembly’s <A NAME="marker-270613"></A>CORBA Component Descriptor, which describes the assembly’s implied IDL3 interface. The <EM CLASS="Code">
&lt;referencedImplementation&gt;</EM>
 element references the assembly’s <A NAME="marker-270760"></A>Component Implementation Descriptor, which describes the assembly’s implementation in terms of its subcomponents.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-175786"></A>Messenger Assembly - Summary</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-186644"></A>The Messenger <A NAME="marker-262334"></A>Assembly’s descriptors files describe the Messenger Assembly’ <A NAME="marker-269748"></A>composition in terms of its subcomponent instances the connections between them. The table summarizes the Messenger Assembly descriptor files.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-176380"></A>Messenger Assembly Descriptor Files</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-176384"></A>File</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-176386"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-176400"></A>MessengerAssembly.ccd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-176402"></A><A NAME="marker-270628"></A>CORBA Component Descriptor for the Messenger Assembly’s implied IDL3 interface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-176404"></A>MessengerAssembly.cid</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-176406"></A><A NAME="marker-270775"></A>Component Implementation Descriptor describing the Messenger Assembly’s implementation in terms of its subcomponent instances and connections</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-176408"></A>MessengerAssembly.cpd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-176410"></A><A NAME="marker-270907"></A>Component Package Descriptor packaging the Messenger Assembly component into one deployable package.</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-173604"></A>Application Descriptors</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-176777"></A>The application’s <A NAME="marker-261631"></A>deployment descriptors describe how the <A NAME="marker-262358"></A>assembly’s component instances are deployed onto logical nodes and how each logical node is mapped to a physical <A NAME="marker-263997"></A>component container.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-231347"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231345"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-30.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-231342"></A>The application’s UML Deployment Diagram illustrates the <A NAME="marker-261647"></A>deployment.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-176785"></A> Deployment of the Messenger Application</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-176783"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-31.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-176786"></A>The Application’s <A NAME="marker-261655"></A>deployment is described by five descriptor files: a <A NAME="marker-270937"></A>Package Configuration Descriptor that wraps the Messenger <A NAME="marker-262374"></A>Assembly’s package descriptor; a <A NAME="marker-271010"></A>Top-level Package Descriptor that represents the entire application; a <A NAME="marker-271076"></A>Component Deployment Plan descriptor that maps the Message Assembly’s subcomponent instances to logical <A NAME="marker-261663"></A>deployment nodes; a <A NAME="marker-271142"></A>Component Domain Descriptor that describes each of the logical nodes; and a <A NAME="marker-269992"></A>node map that maps logical deployment nodes to physical <A NAME="marker-264134"></A>component server processes.</LI>
<LI CLASS="Body">
<A NAME="pgfId-177455"></A>The <A NAME="marker-270944"></A>Package Configuration Descriptor describes one possible configuration of a component package by indicating <A NAME="marker-261671"></A>deployment requirements and/or configuration properties of the component package.</LI>
<LI CLASS="Body">
<A NAME="pgfId-177459"></A>The <A NAME="marker-271017"></A>Top-level Package Descriptor references the <A NAME="marker-270951"></A>Package Configuration Descriptor that is the root of the deployed application. It always has the name <EM CLASS="Code">
package.tpd</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-177466"></A>The <A NAME="marker-271083"></A>Component Deployment Plan contains the bulk of the application’s <A NAME="marker-261680"></A>deployment information. It maps each component instance onto a logical deployment node, achieving a separation of concerns between the <A NAME="marker-270782"></A>Component Implementation Descriptor’s instance connections and the <A NAME="marker-271090"></A>Component Deployment Plan’s <A NAME="marker-269999"></A>node mappings.</LI>
<LI CLASS="Body">
<A NAME="pgfId-177467"></A>The <A NAME="marker-271149"></A>Component Domain Descriptor describes the target <A NAME="marker-261689"></A>deployment environment in terms of its nodes, interconnects, and bridges.</LI>
<LI CLASS="Body">
<A NAME="pgfId-177486"></A>The <A NAME="marker-270006"></A>Node Map maps each logical node onto a physical <A NAME="marker-264141"></A>component server process.</LI>
<LI CLASS="Body">
<A NAME="pgfId-177454"></A>The relationships between the application descriptor files are illustrated in the diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-166326"></A> The Application’s Deployment Descriptors</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-166324"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-32.gif">
</DIV>
</TD>
</TR>
</TABLE>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-166489"></A>Application - Package Configuration Descriptor</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-186675"></A>The <A NAME="marker-270959"></A>Package Configuration Descriptor describes one configuration of a deployable component package. It may define <A NAME="marker-261697"></A>deployment requirements or configure <A NAME="marker-275622"></A>attribute values. Our <A NAME="marker-270966"></A>Package Configuration Descriptor references the Messenger <A NAME="marker-262380"></A>Assembly’s <A NAME="marker-270914"></A>Component Package Descriptor and configures a default value for the Messenger Assembly’s exposed <EM CLASS="Code">
subject</EM>
 attribute. The descriptor is as follows, with comments interspersed:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-176951"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-176988"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176952"></A>&lt;Deployment:PackageConfiguration</P>
<P CLASS="Code">
<A NAME="pgfId-176953"></A>xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-176954"></A>xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-176955"></A>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-176956"></A>xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176957"></A>  &lt;label&gt;Messenger Application Configuration&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176958"></A>  &lt;basePackage href=&quot;MessengerAssembly.cpd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176959"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-176991"></A>The <EM CLASS="Code">
&lt;basePackage&gt;</EM>
 element references the Messenger <A NAME="marker-262395"></A>Assembly’s <A NAME="marker-270921"></A>Component Package Descriptor. Either a <EM CLASS="Code">
&lt;basePackage&gt;</EM>
 element or a <EM CLASS="Code">
&lt;specializedConfig&gt;</EM>
 element is mandatory. A <EM CLASS="Code">
&lt;specializedConfig&gt;</EM>
 element can reference another <A NAME="marker-270973"></A>Package Configuration Descriptor and override its requirements and/or configuration values.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-176992"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-176961"></A>  &lt;configProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176962"></A>    &lt;name&gt;subject&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176963"></A>    &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176964"></A>      &lt;type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176965"></A>        &lt;kind&gt;tk_string&lt;/kind&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176966"></A>      &lt;/type&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176967"></A>      &lt;value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176968"></A>        &lt;string&gt;Typewriter practice&lt;/string&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176969"></A>      &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176970"></A>    &lt;/value&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176971"></A>  &lt;/configProperty&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176995"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-176996"></A>The <EM CLASS="Code">
&lt;configProperty&gt;</EM>
 element defines a default value for the Messenger <A NAME="marker-262390"></A>Assembly’s <EM CLASS="Code">
subject</EM>
 <A NAME="marker-275628"></A>attribute.</LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-244995"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-245035"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
CIAO does not yet support the setting of a default <A NAME="marker-275634"></A>attribute value through a <EM CLASS="Code">
&lt;configProperty&gt;</EM>
 element, so this value is currently ignored.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<P CLASS="Code">
<A NAME="pgfId-176997"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-176972"></A>&lt;/Deployment:PackageConfiguration&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-176987"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-177067"></A>A <A NAME="marker-270980"></A>Package Configuration Descriptor may also contain <EM CLASS="Code">
&lt;selectRequirement&gt;</EM>
 requirement elements. In future implementations of CIAO, these elements would be matched against <EM CLASS="Code">
&lt;capability&gt;</EM>
 elements in the Component Implementation Description.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-166545"></A>Application - Top-level Package Descriptor</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-166546"></A>Each application has exactly one <A NAME="marker-271025"></A>Top-level Package Descriptor. It is always named <EM CLASS="Code">
package.tpd</EM>
, and it points to the application’s <A NAME="marker-270987"></A>Package Configuration Descriptor file. The <A NAME="marker-271032"></A>Top-level Package Descriptor for our application is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-177079"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-177096"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177093"></A>&lt;Deployment:TopLevelPackageDescription</P>
<P CLASS="Code">
<A NAME="pgfId-177081"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177082"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177083"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177084"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177085"></A>  &lt;package href=&quot;Application.pcd&quot;/&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177086"></A>&lt;/Deployment:TopLevelPackageDescription&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177097"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-177077"></A>A <A NAME="marker-271039"></A>Top-level Package Descriptor has exactly one <EM CLASS="Code">
&lt;package&gt;</EM>
 element that points to the application’s <A NAME="marker-270994"></A>Package Configuration Descriptor.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-166565"></A>Application - Component Deployment Plan</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-177130"></A>The application’s <A NAME="marker-262410"></A>Component Deployment Plan describes how the Messenger <A NAME="marker-262403"></A>Assembly’s component instances are deployed onto logical processing nodes. Through this descriptor, the application deployer can vary the component instance-to-<A NAME="marker-270013"></A>node mapping independently from the connections between component instances.</LI>
<LI CLASS="Body">
<A NAME="pgfId-177147"></A>The <A NAME="marker-271099"></A>Component Deployment Plan for our application is as follows, with comments interspersed:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-177150"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-177220"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177151"></A>&lt;Deployment:DeploymentPlan</P>
<P CLASS="Code">
<A NAME="pgfId-177152"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177153"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177154"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177155"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177156"></A>  &lt;label&gt;Messenger Deployment Plan&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177157"></A>  &lt;instance xmi:id=&quot;Messenger_Instance_ID&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177158"></A>    &lt;name&gt;Messenger_Instance&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177159"></A>    &lt;node&gt;Messenger_Node&lt;/node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177160"></A>  &lt;/instance&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177161"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-177221"></A>This <EM CLASS="Code">
&lt;instance&gt;</EM>
 element indicates that the <EM CLASS="Code">
Messenger_Instance</EM>
 is deployed onto the <EM CLASS="Code">
Messenger_Node</EM>
. The value of the <EM CLASS="Code">
&lt;name&gt;</EM>
 element must match the Messenger instance’s <EM CLASS="Code">
&lt;name&gt;</EM>
 element in the Messenger <A NAME="marker-262417"></A>Assembly’s <A NAME="marker-270789"></A>Component Implementation Descriptor file.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-177222"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-177223"></A>  &lt;instance xmi:id=&quot;First_Receiver_Instance_ID&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177162"></A>    &lt;name&gt;First_Receiver_Instance&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177163"></A>    &lt;node&gt;First_Receiver_Node&lt;/node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177164"></A>  &lt;/instance&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177165"></A>  &lt;instance xmi:id=&quot;Second_Receiver_Instance_ID&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177166"></A>    &lt;name&gt;Second_Receiver_Instance&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177167"></A>    &lt;node&gt;Second_Receiver_Node&lt;/node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177168"></A>  &lt;/instance&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177169"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-177239"></A>These two <EM CLASS="Code">
&lt;instance&gt;</EM>
 elements indicate that each of the two Receiver instances is deployed on its own logical node. Again, the value of each <EM CLASS="Code">
&lt;name&gt;</EM>
 element must match the Receiver instances’ <EM CLASS="Code">
&lt;name&gt;</EM>
 elements in the Messenger <A NAME="marker-262424"></A>Assembly’s <A NAME="marker-270796"></A>Component Implementation Descriptor file.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-177228"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-177229"></A>  &lt;instance xmi:id=&quot;Administrator_Instance_ID&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177170"></A>    &lt;name&gt;Administrator_Instance&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177171"></A>    &lt;node&gt;Administrator_Node&lt;/node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177172"></A>  &lt;/instance&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177173"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-177261"></A>This <EM CLASS="Code">
&lt;instance&gt;</EM>
 element indicates that the Administrator instance is deployed onto the <EM CLASS="Code">
Administrator_Node</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-177258"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-177259"></A>&lt;/Deployment:DeploymentPlan&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177276"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-186747"></A>In summary, the <A NAME="marker-271106"></A>Component Deployment Plan maps each component instance onto a logical processing node. Each instance name must match an instance name in the <A NAME="marker-262431"></A>assembly’s <A NAME="marker-270803"></A>Component Implementation Descriptor.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-186754"></A>Application - Component Domain Descriptor</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-166623"></A>The <A NAME="marker-271157"></A>Component Domain Descriptor describes the target environment in terms of its nodes, interconnects, and bridges. The Messenger application’s <A NAME="marker-271164"></A>Component Domain Descriptor is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-177344"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-177418"></A>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177345"></A>&lt;Deployment:Domain</P>
<P CLASS="Code">
<A NAME="pgfId-177346"></A> xmlns:Deployment=&quot;http://www.omg.org/Deployment&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177347"></A> xmlns:xmi=&quot;http://www.omg.org/XMI&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177348"></A> xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</P>
<P CLASS="Code">
<A NAME="pgfId-177349"></A> xsi:schemaLocation=&quot;http://www.omg.org/Deployment Deployment.xsd&quot;&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177350"></A>  &lt;label&gt;Messenger Application Domain&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177351"></A>  &lt;node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177352"></A>    &lt;name&gt;Messenger_Node&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177353"></A>    &lt;label&gt;Messenger's Node&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177354"></A>  &lt;/node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177355"></A>  &lt;node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177356"></A>    &lt;name&gt;First_Receiver_Node&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177357"></A>    &lt;label&gt;First Receiver's Node&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177358"></A>  &lt;/node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177359"></A>  &lt;node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177360"></A>    &lt;name&gt;Second_Receiver_Node&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177361"></A>    &lt;label&gt;Second Receiver's Node&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177362"></A>  &lt;/node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177363"></A>  &lt;node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177364"></A>    &lt;name&gt;Administrator_Node&lt;/name&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177365"></A>    &lt;label&gt;Administrator's Node&lt;/label&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177366"></A>  &lt;/node&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177342"></A>&lt;/Deployment:Domain&gt;</P>
<P CLASS="Code">
<A NAME="pgfId-177412"></A>&nbsp;</P>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-177340"></A>This <A NAME="marker-271190"></A>Component Domain Descriptor describes the four nodes of the Messenger application. The <EM CLASS="Code">
&lt;name&gt;</EM>
 of each <EM CLASS="Code">
&lt;node&gt;</EM>
 matches the node name in the <A NAME="marker-271113"></A>Component <A NAME="marker-261745"></A>Deployment Plan. The <EM CLASS="Code">
&lt;label&gt;</EM>
, as always, is optional and may be used for display purposes by a tool. Our sample application doesn’t use this descriptor, but we define it for completeness.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-166655"></A>Node Map</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-177495"></A>The <A NAME="marker-270020"></A>node map is a text file that maps each of the <A NAME="marker-271119"></A>Component Deployment Plan’s logical nodes onto a physical <A NAME="marker-264148"></A>component server process by mapping each logical node to a <EM CLASS="Code">
NodeManager</EM>
<A NAME="marker-271950"></A> object reference. The <A NAME="marker-270027"></A>node map for the Messenger application is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-166661"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-177532"></A>Administrator_Node   corbaloc:iiop:localhost:10000/NodeManager</P>
<P CLASS="Code">
<A NAME="pgfId-166662"></A>First_Receiver_Node  corbaloc:iiop:localhost:20000/NodeManager</P>
<P CLASS="Code">
<A NAME="pgfId-166663"></A>Second_Receiver_Node corbaloc:iiop:localhost:30000/NodeManager</P>
<P CLASS="Code">
<A NAME="pgfId-166664"></A>Messenger_Node       corbaloc:iiop:localhost:40000/NodeManager</P>
<P CLASS="Code">
<A NAME="pgfId-177539"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-166665"></A>The contents of this file determine where each component executes. Our <A NAME="marker-261753"></A>deployment environment consists of four <EM CLASS="Code">
NodeManager</EM>
<A NAME="marker-271958"></A> processes running on the <EM CLASS="Code">
localhost</EM>
, each listening on a different <A NAME="marker-263449"></A>port. Each <EM CLASS="Code">
NodeManager</EM>
 is a <A NAME="marker-264155"></A>component server, capable of dynamically loading a component’s libraries and making connections between components. The <EM CLASS="Code">
NodeManager</EM>
 is documented in <A HREF="CIAO.htm#21954" CLASS="XRef">See Running the Messenger Application</A> and <A HREF="CIAO.htm#47222" CLASS="XRef">See DAnCE Executable Reference</A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-186818"></A>The <A NAME="marker-270034"></A>node map enables a great deal of <A NAME="marker-261760"></A>deployment flexibility. We could deploy the Messenger application across a network simply by running our <EM CLASS="Code">
</EM>
<A NAME="marker-271967"></A>NodeManager processes across the network and changing our node map’s <EM CLASS="Code">
NodeManager</EM>
 object references to reflect that.</LI>
<LI CLASS="Body">
<A NAME="pgfId-177607"></A>We could also deploy several component instances on one <A NAME="marker-264162"></A>component server simply by mapping several logical nodes to the same <EM CLASS="Code">
NodeManager</EM>
<A NAME="marker-271975"></A> object reference.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-186821"></A>Messenger Application - Summary</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-177920"></A>The Messenger Application’s descriptors describe how each subcomponent instance is deployed onto a physical <A NAME="marker-264169"></A>component server process. The table summarizes the Messenger application’s descriptor files.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-177923"></A>Messenger Application Descriptor Files</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-177927"></A>File</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-177929"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-177931"></A>Application.pcd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-177933"></A><A NAME="marker-271001"></A>Package Configuration Descriptor that configures the top-level component’s <A NAME="marker-261768"></A>deployment <A NAME="marker-275640"></A>attributes.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-177935"></A>package.tpd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-177937"></A><A NAME="marker-271046"></A>Top-level Package Descriptor that represents the application.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-177967"></A>Application.cdp</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-177969"></A><A NAME="marker-271126"></A>Component Deployment Plan that maps component instances to logical nodes.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-177971"></A>Domain.cdd</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-177973"></A><A NAME="marker-271171"></A>Component Domain Descriptor that describes the target <A NAME="marker-261779"></A>deployment environment.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-177939"></A>ApplicationNodeMap.dat</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-177941"></A>Text file that maps each logical node to a physical <A NAME="marker-264176"></A>component server object.</P>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-231458"></A>The following sections discusses the execution of the Messenger application.</LI>
</UL>
</DIV>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-231459"></A><A NAME="66494"></A>Building the Messenger Application</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-231482"></A>The Messenger application consists of three component types: Messenger, Receiver, and Administrator. Each component type is composed of three libraries: a stub library, a servant library, and an <A NAME="marker-267039"></A>executor library. We manage these libraries with three Make Project Creator (MPC) files, one file for each component type.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-231508"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231506"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-33.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-242439"></A>The example’s source code, build files, and XML descriptor files ares in the <EM CLASS="Code">
$CIAO_ROOT/examples/DevGuideExamples/Messenger</EM>
 directory.</LI>
</UL>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-241864"></A><A NAME="47823"></A>Setting Up Your Environment</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-241996"></A>There are several environment variables used by ACE, TAO, and CIAO during both the compilation and execution of applications. Information about ACE and TAO environment variables is available at <A HREF="GettingStarted.htm#72285" CLASS="XRef"></A>. CIAO’s environment variables are described below. Syntax for Windows is shown in parentheses.</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-241874"></A><EM CLASS="Code">
CIAO_ROOT</EM>
<A NAME="marker-271660"></A></LI>
</UL>
<P CLASS="Indent1">
<A NAME="pgfId-241878"></A>The base path for all CIAO-related code, normally <EM CLASS="Code">
$TAO_ROOT/CIAO</EM>
 (<EM CLASS="Code">
%TAO_ROOT%\CIAO</EM>
).</P>
<UL>
<LI CLASS="Bullet1">
<A NAME="pgfId-241880"></A><EM CLASS="Code">
XERCESCROOT</EM>
<A NAME="marker-271337"></A></LI>
</UL>
<P CLASS="Indent1">
<A NAME="pgfId-242086"></A>The base directory of the Xerces C++ installation. See <A HREF="CIAO.htm#99979" CLASS="XRef">See Building CIAO with Visual C++</A> <A HREF="CIAO.htm#87312" CLASS="XRef">See Obtain and Build the Xerces C++ Library</A>and <A HREF="CIAO.htm#27149" CLASS="XRef">See Building CIAO on UNIX with GNU Make and gcc</A> for more information on Xerces C++.</P>
<UL>
<LI CLASS="Bullet1">
<A NAME="pgfId-242040"></A>Library Path</LI>
</UL>
<P CLASS="Indent1">
<A NAME="pgfId-241881"></A>The library path must include the directory containing the Xerces C++ dynamic libraries, <EM CLASS="Code">
$XERCESCROOT/bin</EM>
<A NAME="marker-271344"></A> (<EM CLASS="Code">
%XERCESCROOT%\bin</EM>
<A NAME="marker-271829"></A>). You should add this location to your <EM CLASS="Code">
LD_LIBRARY_PATH</EM>
<A NAME="marker-271833"></A> environment variable or its equivalent. (On Windows, add this directory to your <EM CLASS="Code">
PATH</EM>
<A NAME="marker-271852"></A> so DLLs can be located at run time.)</P>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-242245"></A>Creating the Messenger’s MPC File</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-221699"></A>The CIAO source tree contains a <EM CLASS="Code">
generate_component_mpc.pl</EM>
 script to generate the beginning of a component’s MPC file.</LI>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-221702"></A><A NAME="marker-221700"></A><A NAME="marker-221701"></A>UNIX and UNIX-like Systems</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-221706"></A>The script is <EM CLASS="Code">
$CIAO_ROOT/bin/generate_component_mpc.pl</EM>
<A NAME="marker-221703"></A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-221707"></A>Windows Systems</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-221710"></A>The script is <EM CLASS="Code">
%CIAO_ROOT%\bin\generate_component_mpc.pl.</EM>
<A NAME="marker-221708"></A><A NAME="marker-221709"></A> </LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-221711"></A>General Usage</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-221712"></A>The general usage of the <EM CLASS="Code">
generate_component_mpc.pl</EM>
 script is as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-221719"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-241208"></A>$CIAO_ROOT/bin/generate_component_mpc.pl &lt;component name&gt;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-221720"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221727"></A>For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-221728"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-241444"></A>$CIAO_ROOT/bin/generate_component_mpc.pl Messenger</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-221732"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221733"></A>creates an MPC file called <EM CLASS="Code">
Messenger.mpc</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-221734"></A>The script also prints the following text to indicate that it generated the export header file for each Messenger library:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-310598"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-310599"></A>The following commands have been executed:                                                                                                                                        </P>
<P CLASS="Code-Line3">
<A NAME="pgfId-310600"></A>generate_export_file.pl MESSENGER_STUB &gt; Messenger_stub_export.h</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-221738"></A>generate_export_file.pl MESSENGER_SVNT &gt; Messenger_svnt_export.h</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-221739"></A>generate_export_file.pl MESSENGER_EXEC &gt; Messenger_exec_export.h</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-221740"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221741"></A>We deploy our component executors in dynamic libraries. On Windows platforms, classes exported from a dynamic library must define an export macro. On UNIX-like platforms, the export macros define to nothing. However, the 4.x versions of the <EM CLASS="Code">
gcc</EM>
 compiler support the C++ <EM CLASS="Code">
export</EM>
 keyword, which may reduce code size by reducing the number of exported symbols. In either case, the export macros enable cross-platform development.</LI>
<LI CLASS="Body">
<A NAME="pgfId-241825"></A>See <A HREF="IDL_Complr.htm#21046" CLASS="XRef"></A> for more information on the <EM CLASS="Code">
generate_export_file.pl</EM>
 script.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-241826"></A>The Messenger’s MPC File</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-221759"></A>The generated MPC file is as follows:</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221760"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-258933"></A>project(Messenger_stub): ccm_stub {</P>
<P CLASS="Code">
<A NAME="pgfId-221761"></A>  </P>
<P CLASS="Code">
<A NAME="pgfId-221762"></A>  sharedname = Messenger_stub</P>
<P CLASS="Code">
<A NAME="pgfId-221763"></A>  idlflags += -Wb,stub_export_macro=MESSENGER_STUB_Export</P>
<P CLASS="Code">
<A NAME="pgfId-221764"></A>  idlflags += -Wb,stub_export_include=Messenger_stub_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221765"></A>  idlflags += -Wb,skel_export_macro=MESSENGER_SVNT_Export</P>
<P CLASS="Code">
<A NAME="pgfId-221766"></A>  idlflags += -Wb,skel_export_include=Messenger_svnt_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221767"></A>  dynamicflags   = MESSENGER_STUB_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-221768"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221769"></A>  IDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221770"></A>    Messenger.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221771"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221772"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221773"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221774"></A>    MessengerC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221775"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221776"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-221777"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221778"></A>project(Messenger_svnt) : ciao_servant {</P>
<P CLASS="Code">
<A NAME="pgfId-221779"></A>  after +=  Messenger_stub</P>
<P CLASS="Code">
<A NAME="pgfId-221780"></A>  sharedname  = Messenger_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221781"></A>  libs    += Messenger_stub </P>
<P CLASS="Code">
<A NAME="pgfId-221782"></A>  idlflags +=  -Wb,export_macro=MESSENGER_SVNT_Export</P>
<P CLASS="Code">
<A NAME="pgfId-221783"></A>  idlflags +=  -Wb,export_include=Messenger_svnt_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221784"></A>  dynamicflags = MESSENGER_SVNT_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-221785"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221786"></A>  CIDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221787"></A>    Messenger.cidl</P>
<P CLASS="Code">
<A NAME="pgfId-221788"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221789"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221790"></A>  IDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221791"></A>    MessengerE.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221792"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221793"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221794"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221795"></A>    MessengerEC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221796"></A>    MessengerS.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221797"></A>    Messenger_svnt.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221798"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221799"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-221800"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221801"></A>project(Messenger_exec) : ciao_executor {</P>
<P CLASS="Code">
<A NAME="pgfId-221802"></A>  after   += Messenger_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221803"></A>  sharedname = Messenger_exec</P>
<P CLASS="Code">
<A NAME="pgfId-221804"></A>  libs      += Messenger_stub Messenger_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221805"></A>  idlflags +=  -Wb,export_macro=MESSENGER_EXEC_Export</P>
<P CLASS="Code">
<A NAME="pgfId-221806"></A>  idlflags +=  -Wb,export_include=Messenger_exec_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221807"></A>  dynamicflags   = MESSENGER_EXEC_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-221808"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221809"></A>  IDL_Files {    </P>
<P CLASS="Code">
<A NAME="pgfId-221810"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221811"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221812"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221813"></A>    Messenger_exec.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221814"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221815"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-221816"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221817"></A>That’s a reasonable start towards our final <EM CLASS="Code">
Messenger.mpc</EM>
 file. We edit the file as follows, with comments interspersed. First, we discuss the project for the Messenger’s stub library, <EM CLASS="Code">
Messenger_stub</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221818"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221819"></A>project(Messenger_stub): ccm_stub {</P>
<P CLASS="Code">
<A NAME="pgfId-221820"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221821"></A>Because we deploy the application using the <A NAME="marker-269803"></A>DAnCE facility, we change the <EM CLASS="Code">
ciao_client</EM>
 base project dependency to <EM CLASS="Code">
ciao_client_dnc</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221822"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221823"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-273785"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221824"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221825"></A>&nbsp;</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221826"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221827"></A>  sharedname  = Messenger_stub</P>
<P CLASS="Code">
<A NAME="pgfId-221828"></A>  idlflags += -Wb,stub_export_macro=MESSENGER_STUB_Export </P>
<P CLASS="Code">
<A NAME="pgfId-221829"></A>  idlflags += -Wb,stub_export_include=Messenger_stub_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221830"></A>  idlflags += -Wb,skel_export_macro=MESSENGER_SVNT_Export</P>
<P CLASS="Code">
<A NAME="pgfId-221831"></A>  idlflags += -Wb,skel_export_include=Messenger_svnt_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221832"></A>  dynamicflags = MESSENGER_STUB_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-221833"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221834"></A>We make no changes to the <EM CLASS="Code">
sharedname</EM>
, <EM CLASS="Code">
idlflags</EM>
, or <EM CLASS="Code">
dynamicflags</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221835"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221836"></A>  IDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221837"></A>    Runnable.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221838"></A>    Publication.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221839"></A>    Message.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221840"></A>    History.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221841"></A>    Messenger.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221842"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221843"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221844"></A>The Messenger component’s interfaces, <A NAME="marker-265905"></A>event types, and component declaration are spread across five IDL files. The <EM CLASS="Code">
generate_component_mpc.pl</EM>
 script does not know this. Thus, we add four IDL files to the <EM CLASS="Code">
IDL_Files</EM>
 section.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221845"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221846"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221847"></A>    RunnableC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221848"></A>    PublicationC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221849"></A>    MessageC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221850"></A>    HistoryC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221851"></A>    MessengerC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221852"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221853"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221854"></A>We add stub source code files for each of the Messenger component’s IDL files.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-258995"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-258996"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-258997"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221858"></A>Next, we discuss the project for the Messenger’s servant library, <EM CLASS="Code">
Messenger_svnt</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221859"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221860"></A>project(Messenger_svnt): ciao_servant_dnc {</P>
<P CLASS="Code">
<A NAME="pgfId-221861"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221862"></A>Again, because we deploy the application using the <A NAME="marker-269810"></A>DAnCE facility, we change the <EM CLASS="Code">
ciao_servant</EM>
 base project dependency to <EM CLASS="Code">
ciao_servant_dnc</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-310437"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-310439"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-310440"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221866"></A>&nbsp;</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221867"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221868"></A>  after += Messenger_stub</P>
<P CLASS="Code">
<A NAME="pgfId-221869"></A>  sharedname  = Messenger_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221870"></A>  libs += Messenger_stub</P>
<P CLASS="Code">
<A NAME="pgfId-221871"></A>  idlflags += -Wb,export_macro=MESSENGER_SVNT_Export </P>
<P CLASS="Code">
<A NAME="pgfId-221872"></A>  idlflags += -Wb,export_include=Messenger_svnt_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221873"></A>  dynamicflags = MESSENGER_SVNT_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-221874"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221875"></A>We make no changes to the <EM CLASS="Code">
after</EM>
, <EM CLASS="Code">
sharedname</EM>
, <EM CLASS="Code">
libs</EM>
, <EM CLASS="Code">
idlflags</EM>
, or <EM CLASS="Code">
dynamicflags</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221876"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221884"></A>&nbsp;</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221885"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221886"></A>  // project must be a ciao_servant or ciao_server to use CIDL files</P>
<P CLASS="Code">
<A NAME="pgfId-221887"></A>  CIDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221888"></A>    Messenger.cidl</P>
<P CLASS="Code">
<A NAME="pgfId-221889"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221890"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221891"></A>  IDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221892"></A>    MessengerE.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221893"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221894"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221895"></A>We make no changes to the <EM CLASS="Code">
CIDL_Files</EM>
 or the <EM CLASS="Code">
IDL_Files</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221896"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221897"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221898"></A>    RunnableS.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221899"></A>    PublicationS.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221900"></A>    MessageS.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221901"></A>    HistoryS.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221902"></A>    MessengerS.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221903"></A>    MessengerEC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221904"></A>    Messenger_svnt.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221905"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221906"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221907"></A>We add skeleton source code files for the Messenger component’s IDL files.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221908"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221909"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-221910"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221911"></A>Finally, we discuss the project for the Messenger’s <A NAME="marker-267046"></A>executor library, <EM CLASS="Code">
Messenger_exec</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221912"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221913"></A>project(Messenger_exec): ciao_component_dnc {</P>
<P CLASS="Code">
<A NAME="pgfId-221914"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221915"></A>Once more, because we deploy the application using the <A NAME="marker-269817"></A>DAnCE facility, we change the <EM CLASS="Code">
ciao_component</EM>
 base project dependency to <EM CLASS="Code">
ciao_component_dnc</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221916"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221917"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-273846"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221918"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221919"></A>&nbsp;</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221920"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221921"></A>  after += Messenger_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221922"></A>  sharedname  = Messenger_exec</P>
<P CLASS="Code">
<A NAME="pgfId-221923"></A>  libs     += Messenger_stub Messenger_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221924"></A>  idlflags += -Wb,export_macro=MESSENGER_EXEC_Export</P>
<P CLASS="Code">
<A NAME="pgfId-221925"></A>  idlflags += -Wb,export_include=Messenger_exec_export.h </P>
<P CLASS="Code">
<A NAME="pgfId-221926"></A>  dynamicflags = MESSENGER_EXEC_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-221927"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221928"></A>We make no changes to the <EM CLASS="Code">
after</EM>
, <EM CLASS="Code">
sharedname</EM>
, <EM CLASS="Code">
libs</EM>
, <EM CLASS="Code">
idlflags</EM>
, or <EM CLASS="Code">
dynamicflags</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221929"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221930"></A>  IDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221931"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221932"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221933"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221934"></A>    MessengerES.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221935"></A>    Messenger_exec_i.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221936"></A>    Publication_exec_i.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221937"></A>    History_exec_i.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221938"></A>    Runnable_exec_i.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221939"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221940"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-234955"></A>We make quite a few changes to the <A NAME="marker-267053"></A>executor library’s <EM CLASS="Code">
Source_Files</EM>
 section. First, we add <EM CLASS="Code">
MessengerES.cpp</EM>
, the Messenger executor’s skeleton file. Then we change <EM CLASS="Code">
Messenger_exec.cpp</EM>
 to <EM CLASS="Code">
Messenger_exec_i.cpp</EM>
 to reflect the fact that we’ve renamed the CIDL-generated executor implementation file as described in <A HREF="CIAO.htm#19107" CLASS="XRef">See Compiling the IDL and CIDL</A>. Finally, we add the <A NAME="marker-263190"></A>facet executor implementation files.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221942"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221943"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-259019"></A>&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-221944"></A>Creating the Administrator’s and Receiver’s MPC Files</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-221945"></A>The Receiver’s and Administrator’s MPC files are similar to the Messenger’s. We generate each file using the generate_component_mpc.pl script. </LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-221946"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-221949"></A>generate_component_mpc.pl Receiver</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-221952"></A>generate_component_mpc.pl Administrator</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-221953"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221954"></A>We modify the generated MPC files by hand, just as we did for the Messenger. We’ll examine the modified <EM CLASS="Code">
Receiver.mpc</EM>
 file and highlight significant differences between <EM CLASS="Code">
Receiver.mpc</EM>
 and <EM CLASS="Code">
Messenger.mpc</EM>
. Comments are interspersed. First, we discuss the project for the Receiver’s stub library, <EM CLASS="Code">
Receiver_stub</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221955"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221956"></A>project(Receiver_stub): ccm_stub {</P>
<P CLASS="Code">
<A NAME="pgfId-221958"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221959"></A>  after += Messenger_stub</P>
<P CLASS="Code">
<A NAME="pgfId-221960"></A>  sharedname  = Receiver_stub</P>
<P CLASS="Code">
<A NAME="pgfId-221961"></A>  libs += Messenger_stub</P>
<P CLASS="Code">
<A NAME="pgfId-221962"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221963"></A>The Receiver’s stub library is dependent on the Messenger’s stub library and must be built after the Messenger’s stub library.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221964"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221965"></A>  idlflags += -Wb,stub_export_macro=RECEIVER_STUB_Export</P>
<P CLASS="Code">
<A NAME="pgfId-221966"></A>  idlflags += -Wb,stub_export_include=Receiver_stub_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221967"></A>  idlflags += -Wb,skel_export_macro=RECEIVER_SVNT_Export</P>
<P CLASS="Code">
<A NAME="pgfId-221968"></A>  idlflags += -Wb,skel_export_include=Receiver_svnt_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221969"></A>  dynamicflags = RECEIVER_STUB_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-221970"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221971"></A>  IDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221972"></A>    Receiver.idl</P>
<P CLASS="Code">
<A NAME="pgfId-221973"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221974"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221975"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-221976"></A>    ReceiverC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-221977"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-221978"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-221979"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221980"></A>Next, we discuss the project for the Receiver’s servant library, <EM CLASS="Code">
Receiver_svnt</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221981"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221982"></A>project(Receiver_svnt): ciao_servant_dnc {</P>
<P CLASS="Code">
<A NAME="pgfId-273874"></A> &nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221984"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221985"></A>  after += Receiver_stub Messenger_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221986"></A>  sharedname  = Receiver_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221987"></A>  libs += Receiver_stub Messenger_stub Messenger_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-221988"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-221989"></A>The Receiver’s servant library is dependent on the Messenger’s stub and servant libraries and must be built after the Messenger’s servant library.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-221990"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-221991"></A>  idlflags += -Wb,export_macro=RECEIVER_SVNT_Export </P>
<P CLASS="Code">
<A NAME="pgfId-221992"></A>  idlflags += -Wb,export_include=Receiver_svnt_export.h</P>
<P CLASS="Code">
<A NAME="pgfId-221993"></A>  dynamicflags = RECEIVER_SVNT_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-221994"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222002"></A>  CIDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-222003"></A>    Receiver.cidl</P>
<P CLASS="Code">
<A NAME="pgfId-222004"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-222005"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222006"></A>  IDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-222007"></A>    ReceiverE.idl</P>
<P CLASS="Code">
<A NAME="pgfId-222008"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-222009"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222010"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-222011"></A>    ReceiverS.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-222012"></A>    ReceiverEC.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-222013"></A>    Receiver_svnt.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-222014"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-222015"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-222016"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-222017"></A>Finally, we discuss the project for the Receiver’s <A NAME="marker-267071"></A>executor library, <EM CLASS="Code">
Receiver_exec</EM>
.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-222018"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222019"></A>project(Receiver_exec): ciao_component_dnc {</P>
<P CLASS="Code">
<A NAME="pgfId-273886"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222021"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222022"></A>  after += Receiver_svnt</P>
<P CLASS="Code">
<A NAME="pgfId-222023"></A>  sharedname  = Receiver_exec</P>
<P CLASS="Code">
<A NAME="pgfId-222024"></A>  libs += Receiver_stub Receiver_svnt Messenger_stub</P>
<P CLASS="Code">
<A NAME="pgfId-222025"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-222026"></A>The Receiver’s <A NAME="marker-267078"></A>executor library is dependent on the Messenger’s stub library.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-222027"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222028"></A>  idlflags += -Wb,export_macro=RECEIVER_EXEC_Export</P>
<P CLASS="Code">
<A NAME="pgfId-222029"></A>  idlflags += -Wb,export_include=Receiver_exec_export.h </P>
<P CLASS="Code">
<A NAME="pgfId-222030"></A>  dynamicflags = RECEIVER_EXEC_BUILD_DLL</P>
<P CLASS="Code">
<A NAME="pgfId-222031"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222032"></A>  IDL_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-222033"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-222034"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222035"></A>  Source_Files {</P>
<P CLASS="Code">
<A NAME="pgfId-222036"></A>    ReceiverES.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-222037"></A>    Receiver_exec_i.cpp</P>
<P CLASS="Code">
<A NAME="pgfId-222038"></A>  }</P>
<P CLASS="Code">
<A NAME="pgfId-222039"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-222040"></A>The Receiver’s <A NAME="marker-267085"></A>executor library has just one executor implementation file.</LI>
</UL>
<P CLASS="Code">
<A NAME="pgfId-222041"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-222042"></A>}</P>
<P CLASS="Code">
<A NAME="pgfId-222043"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-222044"></A>The modified <EM CLASS="Code">
Administrator.mpc</EM>
 file is similar. The primary difference between the Administrator component and the Receiver component is that the Administrator is not an <A NAME="marker-266038"></A>event consumer, and thus the Administrator’s servant library does not depend on the Messenger’s servant library.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-222045"></A>Running MPC</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-222046"></A>Execute the Make Project Creator to generate the Messenger’s build files for your platform. For example:</LI>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-222047"></A>UNIX and UNIX-like Systems</H6>
<P CLASS="Code-Line2">
<A NAME="pgfId-222048"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-241803"></A>cd $CIAO_ROOT/examples/DevGuideExamples/Messenger</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-243138"></A>$ACE_ROOT/bin/mwc.pl -type gnuace</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-259073"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-222049"></A>Windows Systems</H6>
<P CLASS="Code-Line2">
<A NAME="pgfId-222050"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-243148"></A>cd %CIAO_ROOT%\examples\DevGuideExamples\Messenger</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-241804"></A>perl %ACE_ROOT%\bin\mwc.pl -type vc71</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-222051"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-222052"></A>See <A HREF="MakeProjectCreator.htm#62540" CLASS="XRef"></A> for more information on MPC.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-235519"></A>Building</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-235520"></A>Build the Messenger application using the target build environment.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-200794"></A><A NAME="21954"></A>Running the Messenger Application</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-231607"></A>Finally, we can execute the application.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-231612"></A> Road Map</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231610"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-34.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-207529"></A>Recall that we deploy the Messenger application on four nodes as illustrated in the diagram.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-201076"></A> Messenger Deployment</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-201074"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-35.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-201071"></A>Each component type -- the Messenger, Receiver, and Administrator -- consists of a set of dynamic libraries. We have not created any executables. Deployment descriptor files, as described in <A HREF="CIAO.htm#66043" CLASS="XRef">See Deploying the Messenger Application</A>, define how the component instances are created and connected together and how those component libraries are deployed onto physical nodes.</LI>
</UL>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-241848"></A>Setting Up Your Environment</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-241849"></A>Please see <A HREF="CIAO.htm#47823" CLASS="XRef">See Setting Up Your Environment</A> for information on setting up the environment variables required to execute a CIAO application.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-241808"></A>DAnCE Executables</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-203410"></A>CIAO’s <A NAME="marker-269833"></A>Deployment And Configuration Engine (DAnCE), which implements the OMG “Deployment and Configuration of Component-based Distributed Applications” specification (<A NAME="marker-261797"></A>OMG Document ptc/03-07-08), contains a set of executables to dynamically load component libraries, create component instances, and make connections between them. The table summarizes the DAnCE executables that we’ll use to deploy the application. The executables are described in more detail in <A HREF="CIAO.htm#47222" CLASS="XRef">See DAnCE Executable Reference</A>.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-202928"></A>DAnCE Executables</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-202932"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-202934"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-202936"></A>dance_node_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-202938"></A>A daemon process that launches component servers</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-202942"></A>ciao_componentserver</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-202944"></A>The <A NAME="marker-264183"></A>component server</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-202948"></A>dance_execution_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-202950"></A>A process that maps component instances to component servers</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-202954"></A>dance_repository_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-202956"></A>A process that parses a set of <A NAME="marker-261813"></A>deployment descriptors and sends deployment information to the <A NAME="marker-272226"></A>ExecutionManager</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-203423"></A>Deploying the Messenger with <A NAME="marker-269846"></A>DAnCE</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-261790"></A>First, we run four dance_node_manager daemon processes. In our example, each Node Manager process executes on the <EM CLASS="Code">
localhost</EM>
. The four processes listen on ports 10000, 20000, 30000, and 40000, respectively. Each Node Manager launches a Node Application process when an application is deployed upon it.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-205711"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-243361"></A>$DANCE_ROOT/bin/dance_node_manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-205712"></A>-ORBListenEndpoints iiop://localhost:10000 \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-205713"></A>-s &quot;$CIAO_ROOT/bin/ciao_componentserver&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-205714"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-205757"></A>$DANCE_ROOT/bin/dance_node_manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-205758"></A>-ORBListenEndpoints iiop://localhost:20000 \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-205759"></A>-s &quot;$CIAO_ROOT/bin/ciao_componentserver&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-205760"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-205781"></A>$DANCE_ROOT/bin/dance_node_manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-205782"></A>-ORBListenEndpoints iiop://localhost:30000 \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-205783"></A>-s &quot;$CIAO_ROOT/bin/ciao_componentserver&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-205784"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-205788"></A>$DANCE_ROOT/bin/dance_node_manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-205789"></A>-ORBListenEndpoints iiop://localhost:40000 \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-205790"></A>-s &quot;$CIAO_ROOT/bin/ciao_componentserver&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-203498"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-203506"></A>Then, we start an Execution Manager that reads the <A NAME="marker-270042"></A>node map file <EM CLASS="Code">
ApplicationNodeMap.dat</EM>
 and writes its own object reference to a file called <EM CLASS="Code">
em.ior</EM>
. The Execution Manager executable must be run in the directory containing the application’s <A NAME="marker-261824"></A>deployment descriptors.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-205884"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206027"></A>cd $CIAO_ROOT/examples/DevGuideExamples/Messenger/descriptors</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-239732"></A>$DANCE_ROOT/bin/dance_execution_manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-207352"></A>-o em.ior -i ApplicationNodeMap.dat</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206128"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-239758"></A>Finally, we start a Repository Manager that connects to the Execution Manager and reads the application’s <A NAME="marker-271053"></A>Top-level Package Descriptor and its <A NAME="marker-271133"></A>Component Deployment Plan. The Repository Manager executable must also be run in the directory containing the application’s <A NAME="marker-261833"></A>deployment descriptors.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-240362"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-243539"></A>cd $CIAO_ROOT/examples/DevGuideExamples/Messenger/descriptors</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206204"></A>$DANCE_ROOT/bin/dance_repository_manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-206205"></A>-p package.tpd -d Application.cdp -k file://em.ior</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206214"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-203478"></A>The Execution Manager deploys a component instance in each of the Node Manager windows.</LI>
<LI CLASS="Body">
<A NAME="pgfId-206562"></A>The Messenger does not begin <A NAME="marker-265224"></A>publishing automatically. One of the Node Manager windows contains the Administrator component instance. That window displays the following menu:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-206564"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206595"></A>What do you want to do to the Messenger(s)?</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206565"></A>1.  Start</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206566"></A>2.  Stop</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206567"></A>3.  Change Publication Period</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206568"></A>4.  Change Publication Text</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206514"></A>Please enter a selection:</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206596"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-206561"></A>Use the menu to start and stop publishing and change <A NAME="marker-275646"></A>attributes of the publication. A more industrial-strength application might launch a GUI of some kind. The Administrator’s menu illustrates that a component implementation can contain user interface elements.</LI>
</UL>
</DIV>
<DIV>
<H5 CLASS="Head4">
<A NAME="pgfId-201471"></A>Debugging</H5>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-206824"></A>It can be a challenge to debug a component <A NAME="marker-267102"></A>executor implementation. Thorough unit testing uncovers many problems before the component is tested in <A NAME="marker-261839"></A>deployment. However, it may be necessary to debug a component in its <A NAME="marker-264190"></A>component server process.</LI>
<LI CLASS="Body">
<A NAME="pgfId-206851"></A>We launch a component <A NAME="marker-267109"></A>executor in the debugger by changing the Node Manager’s launch command for its Node Application. It is easiest to illustrate with an example.</LI>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-206876"></A>UNIX and UNIX-like Systems</H6>
<P CLASS="Code">
<A NAME="pgfId-207120"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-207271"></A>$DANCE_ROOT/bin/dance_node_manager</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-207121"></A>-ORBListenEndpoints iiop://localhost:10000 </P>
<P CLASS="Code-Line2">
<A NAME="pgfId-207122"></A>-d 180 </P>
<P CLASS="Code-Line2">
<A NAME="pgfId-207123"></A>-s &quot;gdb --args $CIAO_ROOT/bin/ciao_componentserver&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-259230"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-206877"></A>Windows Systems</H6>
<P CLASS="Code">
<A NAME="pgfId-206848"></A>&nbsp;</P>
<P CLASS="Code">
<A NAME="pgfId-207026"></A>%DANCE_ROOT%\bin\dance_node_manager.exe</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-206956"></A>-ORBListenEndpoints iiop://localhost:10000 </P>
<P CLASS="Code-Line2">
<A NAME="pgfId-293322"></A>-d 180 </P>
<P CLASS="Code-Line2">
<A NAME="pgfId-293323"></A>-s &quot;devenv /debugexe %CIAO_ROOT%\bin\ciao_componentserver.exe&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-293324"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-206830"></A>The <A NAME="marker-272145"></A>Node Manager’s launch command launches the component server process in the debugger. The <EM CLASS="Code">
-d</EM>
 <EM CLASS="Code">
180</EM>
 command-line option delays the launching of the <A NAME="marker-272129"></A>NodeApplication process by 180 seconds, or three minutes. In that three minutes you must set a breakpoint in your component <A NAME="marker-267116"></A>executor to stop program execution. Once a breakpoint is reached you may debug as usual.</LI>
</UL>
</DIV>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Head2">
<A NAME="pgfId-166693"></A>Building CIAO<DIV>
<IMG SRC="CIAO-1.gif">
</DIV>
</H3>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-274916"></A>Before building <A NAME="marker-274915"></A>CIAO, build the ACE and TAO libraries as described in <A HREF="BuildingACE+TAO.htm#26824" CLASS="XRef"></A> and <A HREF="ConfiguringBuilds.htm#79013" CLASS="XRef"></A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-274923"></A>CIAO requires three external libraries: <A NAME="marker-274920"></A>Xerces C++; <A NAME="marker-274921"></A>Boost; and <A NAME="marker-274922"></A>Utility. The <A NAME="marker-274924"></A>DAnCE <A NAME="marker-274925"></A>deployment framework requires <A NAME="marker-274926"></A>Xerces C++. The <A NAME="marker-274927"></A>CIDL compiler requires <A NAME="marker-274928"></A>Boost and <A NAME="marker-274929"></A>Utility. These build instructions describe how to obtain and build those libraries. For more information, see <EM CLASS="Code">
$CIAO_ROOT/CIAO-INSTALL.html</EM>
<A NAME="marker-274930"></A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-210723"></A>Building CIAO entails several steps:</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-194290"></A>Build ACE and TAO, including the following targets:</LI>
</UL>
<P CLASS="Code-Line3">
<A NAME="pgfId-259345"></A>&nbsp;</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259627"></A>ACE</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259372"></A>ACEXML_Parser</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259373"></A>TAO_IDL</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259374"></A>TAO</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259375"></A>IFR_Client</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259376"></A>IORInterceptor</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259377"></A>IORTable</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259378"></A>Naming_Service</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259381"></A>RTCORBA</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259382"></A>RTPortableServer</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259383"></A>Valuetype</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259384"></A>Security</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259385"></A>Utils</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-259624"></A>&nbsp;</P>
<OL>
<LI CLASS="Numbered">
<A NAME="pgfId-233350"></A>Obtain and build the Xerces C++ library</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-235615"></A>Obtain and build the Boost library</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-235616"></A>Obtain the <A NAME="marker-271612"></A>Utility library</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-209689"></A>Set up the build environment</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-209690"></A>Enable the <A NAME="marker-269000"></A>CIDL compiler in MPC’s global features file.</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-209691"></A>Generate build files with MPC</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-209692"></A>Build CIAO’s <A NAME="marker-269003"></A>CIDL compiler</LI>
<LI CLASS="Numbered">
<A NAME="pgfId-235646"></A>Build CIAO’s libraries and <A NAME="marker-269877"></A>DAnCE executables</LI>
</OL>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-235649"></A><A NAME="99979"></A>Building CIAO with Visual C++</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-293380"></A>The CIAO libraries and <A NAME="marker-293379"></A>DAnCE executables can be built with either Visual C++ 7.1/8/9. However, the <A NAME="marker-293381"></A>CIDL compiler can only be built with Visual C++ 7.1. This section contain directions for building CIAO and the CIDL compiler with Visual C++ 7.1.</LI>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-194398"></A><A NAME="87312"></A>Obtain and Build the Xerces C++ Library</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-194408"></A>The source code for <A NAME="marker-271264"></A>Xerces C++ can be obtained from &lt;<EM CLASS="URL">
http://xml.apache.org/xerces-c</EM>
&gt;. At publication time, the latest version of Xerces C++ was version 2.6. Download and unzip the Xerces C++ 2.6 source code. The remainder of this section assumes that Xerces C++ is installed in a directory called <EM CLASS="Code">
C:\xerces-c-src-2_6_0</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-235711"></A>The <A NAME="marker-271268"></A>Xerces C++ site also contains many prebuilt distributions of the Xerces C++ library. If you find a binary distribution that matches your platform and compiler then you can avoid building Xerces C++.</LI>
<LI CLASS="Body">
<A NAME="pgfId-235780"></A>Set the <EM CLASS="Code">
XERCESCROOT</EM>
<A NAME="marker-271269"></A> environment variable to your root <A NAME="marker-271270"></A>Xerces C++ directory, as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-235871"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-235878"></A>set XERCESCROOT=C:\xerces-c-src_2_6_0</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-235879"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-235684"></A>Open the Visual Studio solution file called <EM CLASS="Code">
xerces-all.sln</EM>
 in the  <EM CLASS="Code">
%XERCESCROOT%\Projects\Win32\VC7\xerces-all</EM>
<A NAME="marker-271276"></A> directory. If Visual Studio asks if you want to convert the projects to the current version of Visual Studio, answer “<EM CLASS="Code">
yes</EM>
”. If there is a Visual Studio solution file for Visual Studio .NET (Visual C++ 7.1), use it instead. Build the <EM CLASS="Code">
XercesLib</EM>
 target.</LI>
<LI CLASS="Body">
<A NAME="pgfId-235928"></A>The <A NAME="marker-271351"></A>Xerces C++ project does not install its include files and libraries in the directories where CIAO is expecting them. We manually rectify this. First, we copy the Xerces C++ source files to an <EM CLASS="Code">
include</EM>
 directory. This copies both header and source files, but that is not a problem.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-236117"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236131"></A>cd %XERCESCROOT%</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236118"></A>xcopy /E /I  src include</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236095"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-236115"></A>Then, we create directories for the <A NAME="marker-271352"></A>Xerces C++ libraries.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-235963"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-235974"></A>mkdir %XERCESCROOT%\lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236002"></A>mkdir %XERCESCROOT%\bin</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238618"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-238619"></A>Finally, we copy the <A NAME="marker-271358"></A>Xerces C++ libraries to the appropriate directories</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-238620"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236170"></A>cd %XERCESCROOT%\lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236171"></A>copy ..\Build\Win32\VC7\Debug\xerces-c_2D.lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236172"></A>copy xerces-c_2D.lib xerces-cd.lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236173"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236174"></A>cd %XERCESCROOT%\bin</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236175"></A>copy ..\Build\Win32\VC7\Debug\xerces-c_2_6D.dll</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236227"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-194399"></A>Obtain and Build the Boost library</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-194342"></A>CIAO’s <A NAME="marker-269010"></A>CIDL compiler uses the <A NAME="marker-271463"></A>Boost <EM CLASS="Code">
regex</EM>
 and <EM CLASS="Code">
filesystem</EM>
 libraries and the <EM CLASS="Code">
spirit</EM>
 parser framework. The <EM CLASS="Code">
spirit</EM>
 parser framework consists only of header files.</LI>
<LI CLASS="Body">
<A NAME="pgfId-238627"></A>CIAO’s Windows build requires <A NAME="marker-271464"></A>Boost version 1.30.2. The Boost 1.30.2 source tree and the latest version of the <A NAME="marker-271475"></A>Boost Jam build system can be downloaded from the Boost web site, &lt;<EM CLASS="URL">
http://www.boost.org</EM>
&gt;.</LI>
<LI CLASS="Body">
<A NAME="pgfId-207375"></A>Install <A NAME="marker-271480"></A>Boost 1.30.2 and the latest <A NAME="marker-271470"></A>Boost Jam in the directories of your choice. For this example, we assume that Boost 1.30.2 is installed in <EM CLASS="Code">
C:\Boost-1.30.2</EM>
 and Boost Jam is installed in <EM CLASS="Code">
C:\Boost-Jam</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-233266"></A>You can edit the <A NAME="marker-271494"></A>Boost Jamfile in <EM CLASS="Code">
C:\Boost-1.30.2\Jamfile</EM>
 to limit the build to the <EM CLASS="Code">
filesystem</EM>
 and <EM CLASS="Code">
regex</EM>
 libraries. For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-233295"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233343"></A># Boost Jamfile</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233338"></A>project-root ;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233297"></A># please order by name to ease maintenance</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233298"></A>#subinclude libs/date_time/build ;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233299"></A>subinclude libs/filesystem/build ;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233300"></A>#subinclude libs/python/build ;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233301"></A>subinclude libs/regex/build ;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233302"></A>#subinclude libs/signals/build ;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233303"></A>#subinclude libs/test/build ;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233304"></A>#subinclude libs/thread/build ;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233339"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-208196"></A>Build the <A NAME="marker-271500"></A>Boost 1.30.2 <EM CLASS="Code">
regex</EM>
 and <EM CLASS="Code">
filesystem</EM>
 libraries with Boost Jam as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-207505"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-207617"></A>cd C:\Boost-1.30.2</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-207618"></A>vsvars32.bat</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-207619"></A>C:\Boost-Jam\bjam.exe &quot;-sTOOLS=vc7.1&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208150"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-208206"></A>Create a directory called <EM CLASS="Code">
C:\Boost-1.30.2\lib</EM>
. Copy the <EM CLASS="Code">
regex</EM>
 and <EM CLASS="Code">
filesystem</EM>
 library files to <EM CLASS="Code">
C:\Boost-1.30.2\lib</EM>
 and rename them so CIAO’s build can find them.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-208197"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208156"></A>mkdir C:\Boost-1.30.2\lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208163"></A>cd C:\Boost-1.30.2\lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208164"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208211"></A>copy C:\Boost-1.30.2\libs\regex\build\bin\libboost_regex.lib\vc7.1\debug\runtime-link-dynamic\libboost_regex_debug.lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208166"></A>copy C:\Boost-1.30.2\libs\filesystem\build\bin\libboost_filesystem.lib\vc7.1\debug\runtime-link-dynamic\libboost_filesystem.lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208167"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208168"></A>rename libboost_regex_debug.lib boost_regex_debug.lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208169"></A>rename libboost_filesystem.lib boost_filesystem_debug.lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-208217"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-207654"></A>Obtain the Utility Library</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-194364"></A>CIAO’s <A NAME="marker-269013"></A>CIDL compiler uses the <A NAME="marker-271620"></A>Utility library. Download the Utility 1.2.2 library from the following location:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-207455"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-207480"></A>http://www.dre.vanderbilt.edu/cidlc/prerequisites/Utility-1.2.2.tar.bz2</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-207485"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-207464"></A>There is nothing to build. The remaining instructions assume that the <A NAME="marker-271629"></A>Utility library has been unzipped into a directory called <EM CLASS="Code">
C:\Utility-1.2.2</EM>
.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-194316"></A>Set Up the Build Environment</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-194243"></A>Set <EM CLASS="Code">
CIAO_ROOT</EM>
<A NAME="marker-271689"></A>, <EM CLASS="Code">
XERCESCROOT</EM>
<A NAME="marker-271288"></A>, and <EM CLASS="Code">
UTILITY_ROOT</EM>
<A NAME="marker-271904"></A> environment variables and update your <EM CLASS="Code">
PATH</EM>
<A NAME="marker-271858"></A>. Setting <EM CLASS="Code">
CIAO_ROOT</EM>
 is not strictly necessary on Windows, but it makes using CIAO more convenient. Setting <EM CLASS="Code">
XERCESCROOT</EM>
<A NAME="marker-271295"></A> and <EM CLASS="Code">
UTILITY_ROOT</EM>
<A NAME="marker-271908"></A> is necessary.</LI>
<LI CLASS="Body">
<A NAME="pgfId-193810"></A>For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-193811"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-193812"></A>set CIAO_ROOT=%TAO_ROOT%\CIAO</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-193813"></A>set XERCESCROOT=C:\xerces-c-src_2_6_0</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-193816"></A>set UTILITY_ROOT=C:\Utility-1.2.2</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233706"></A>set PATH=%PATH%;%XERCESCROOT%\bin;%CIAO_ROOT%\bin</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-193817"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-193818"></A>The <EM CLASS="Code">
%XERCESCROOT%\bin</EM>
<A NAME="marker-271304"></A> directory contains the Xerces DLLs. The <EM CLASS="Code">
%CIAO_ROOT%\bin</EM>
<A NAME="marker-271699"></A> directory contains the CIAO <A NAME="marker-269016"></A>CIDL compiler.</LI>
<LI CLASS="Body">
<A NAME="pgfId-236607"></A>Update the include and library directories in Visual Studio. Add the <A NAME="marker-271524"></A>Boost root directory to Visual Studio’s include directories:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-236608"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236609"></A>C:\Boost-1.30.2</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236610"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-236611"></A>Add the <A NAME="marker-271532"></A>Boost <EM CLASS="Code">
lib</EM>
 directory that we created to Visual Studio’s library directories:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-236612"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236613"></A>C:\Boost-1.30.2\lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-236614"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-193850"></A>Enable CIAO and the <A NAME="marker-269019"></A>CIDL Compiler in MPC’s Default Features File</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-209781"></A>Create or edit the <EM CLASS="Code">
%ACE_ROOT%\bin\MakeProjectCreator\config\default.features</EM>
<A NAME="marker-275426"></A><A NAME="marker-275803"></A> file and enable CIAO and the CIDL compiler.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-209884"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-257501"></A>ciao          = 1</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-209895"></A>cidl          = 1</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-209902"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-209717"></A>Generate Build Files with MPC</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-193851"></A>Generate CIAO’s Visual Studio project files with MPC:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-209547"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-209548"></A>cd %CIAO_ROOT%</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-209549"></A>perl %ACE_ROOT%\bin\mwc.pl -recurse -type vc71</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-209550"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-193856"></A>This command generates a Visual Studio solution file for each MPC workspace file found in the build tree.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-209910"></A>Build CIAO’s <A NAME="marker-269023"></A>CIDL Compiler</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-233476"></A>Build CIAO’s CIDL compiler by using the Visual Studio workspace <EM CLASS="Code">
%CIAO_ROOT%\CIDLC\CIDLC.sln</EM>
<A NAME="marker-271707"></A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-233477"></A>You may use the Batch Build command in Visual Studio to build the <A NAME="marker-269027"></A>CIDL compiler’s libraries and executables. Alternatively, you may find that it is easier to build the libraries and executables from the command line, as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-233478"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238699"></A>cd %CIAO_ROOT%\CIDLC</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-233479"></A>devenv CIDLC.sln /build debug</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-269895"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-269898"></A><A NAME="marker-269896"></A><A NAME="marker-269897"></A>Build CIAO’s Libraries and DAnCE Executables</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-269899"></A>Build CIAO’s libraries and <A NAME="marker-269905"></A>DAnCE executables by using the Visual Studio workspace <EM CLASS="Code">
%CIAO_ROOT%\CIAO.sln</EM>
<A NAME="marker-271715"></A>.</LI>
<LI CLASS="Body">
<A NAME="pgfId-209972"></A>You may use the Batch Build command in Visual Studio to build the libraries and configurations in which you are interested. Alternatively, you may find that it is easier to build just the configurations in which you are interested from the command line. For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-209973"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-210038"></A>cd %CIAO_ROOT%</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238689"></A>devenv CIAO.sln /build debug</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-209975"></A>&nbsp;</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-193766"></A><A NAME="27149"></A>Building CIAO on UNIX with GNU Make and gcc</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-237719"></A>CIAO may be built with <EM CLASS="Code">
gcc</EM>
 versions 3.3 and later.</LI>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-237119"></A>Obtain and Build the Xerces C++ Library</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-238608"></A>The source code for <A NAME="marker-271381"></A>Xerces C++ can be obtained from &lt;<EM CLASS="URL">
http://xml.apache.org/xerces-c</EM>
&gt;. At publication time, the latest version of Xerces C++ is version 2.6. Download and unzip the Xerces C++ 2.6 source code. The remainder of this section assumes that Xerces C++ is installed in a directory called <EM CLASS="Code">
$HOME/xerces-c-src-2_6_0</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-237121"></A>The <A NAME="marker-271418"></A>Xerces C++ site also contains many prebuilt distributions of the Xerces C++ library. If you find a binary distribution that matches your platform and compiler then you can avoid building Xerces C++.</LI>
<LI CLASS="Body">
<A NAME="pgfId-237122"></A>Set the <EM CLASS="Code">
XERCESCROOT</EM>
<A NAME="marker-271311"></A> environment variable to your root <A NAME="marker-271428"></A>Xerces C++ directory, as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-237123"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237124"></A>export XERCESCROOT=$HOME/xerces-c-src_2_6_0</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237125"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-237126"></A>Build the <A NAME="marker-271437"></A>Xerces C++ libraries as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-237505"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237656"></A>cd $XERCESCROOT/src/xercesc</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237506"></A>autoconf</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237507"></A>./runConfigure -plinux -cgcc -xg++ -minmem -nsocket -tnative -rpthread </P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237495"></A>make</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237665"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-237494"></A>This execution of the <A NAME="marker-271446"></A>Xerces C++ <EM CLASS="Code">
runConfigure</EM>
 script command uses the <EM CLASS="Code">
gcc</EM>
 compiler, targets the <EM CLASS="Code">
linux</EM>
 platform, and builds with <EM CLASS="Code">
pthreads</EM>
. For more information, type enter the following at the command line:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-238715"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238726"></A>./runConfigure -help</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238775"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-239297"></A>The <A NAME="marker-271453"></A>Xerces C++ project does not install its include files in the directories where CIAO is expecting them. We manually rectify this by creating a symbolic link to an <EM CLASS="Code">
include</EM>
 directory.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-239358"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-239299"></A>cd $XERCESCROOT</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-239352"></A>ln -s src include</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-260112"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-237146"></A>Obtain and Build the Boost library</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-237147"></A>CIAO’s <A NAME="marker-269030"></A>CIDL compiler uses the <A NAME="marker-271540"></A>Boost <EM CLASS="Code">
regex</EM>
 and <EM CLASS="Code">
filesystem</EM>
 libraries and the <EM CLASS="Code">
spirit</EM>
 parser framework. The <EM CLASS="Code">
spirit</EM>
 parser framework consists only of header files.</LI>
<LI CLASS="Body">
<A NAME="pgfId-238628"></A>CIAO’s UNIX versions can use the latest version of <A NAME="marker-271544"></A>Boost, which is version 1.32 at publication time. Using a later version of Boost allows more flexibility in the choice of compiler version. The Boost source tree and the latest version of the <A NAME="marker-271553"></A>Boost Jam build system can be downloaded from the Boost web site, &lt;<EM CLASS="URL">
http://www.boost.org</EM>
&gt;.</LI>
<LI CLASS="Body">
<A NAME="pgfId-237151"></A>Install <A NAME="marker-271559"></A>Boost 1.32 and the latest <A NAME="marker-271565"></A>Boost Jam in the directories of your choice. For this example, we assume that <A NAME="marker-271569"></A>Boost 1.32 is installed in <EM CLASS="Code">
$HOME/boost_1_32_0</EM>
 and Boost Jam is installed in <EM CLASS="Code">
$HOME/boost-jam</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-238050"></A>Build the <A NAME="marker-271579"></A>Boost 1.32 libraries with <A NAME="marker-271586"></A>Boost Jam as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-237166"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237167"></A>cd $HOME/boost_1_32_0</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237169"></A>$HOME/boost-jam/bjam -sTOOLS=gcc</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237170"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-237182"></A>Obtain the Utility Library</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-237183"></A>CIAO’s <A NAME="marker-269033"></A>CIDL compiler uses the <A NAME="marker-271639"></A>Utility library. Download the Utility 1.2.2 library from the following location:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-237184"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237185"></A>http://www.dre.vanderbilt.edu/cidlc/prerequisites/Utility-1.2.2.tar.bz2</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237186"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-237187"></A>There is nothing to build. The remaining instructions assume that the <A NAME="marker-271648"></A>Utility library has been unzipped into a directory called <EM CLASS="Code">
$HOME/Utility-1.2.2</EM>
.</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-237188"></A>Set Up the Build Environment</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-237189"></A>Set <EM CLASS="Code">
CIAO_ROOT</EM>
<A NAME="marker-271723"></A>, <EM CLASS="Code">
XERCESCROOT</EM>
<A NAME="marker-271321"></A>, <EM CLASS="Code">
UTILITY_ROOT</EM>
<A NAME="marker-271916"></A>, <EM CLASS="Code">
BOOST_ROOT</EM>
<A NAME="marker-271933"></A>, <EM CLASS="Code">
BOOST_INCLUDE</EM>
<A NAME="marker-271935"></A>, and <EM CLASS="Code">
BOOST_LIB</EM>
<A NAME="marker-271940"></A> environment variables and update your <EM CLASS="Code">
PATH</EM>
<A NAME="marker-271874"></A>. Setting <EM CLASS="Code">
CIAO_ROOT</EM>
<A NAME="marker-271730"></A> is not strictly necessary on Windows, but it makes using CIAO more convenient. Setting <EM CLASS="Code">
XERCESCROOT</EM>
<A NAME="marker-271328"></A>, <EM CLASS="Code">
UTILITY_ROOT</EM>
<A NAME="marker-271923"></A>, and the <A NAME="marker-271595"></A>Boost environment variables is necessary.</LI>
<LI CLASS="Body">
<A NAME="pgfId-237191"></A>For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-237192"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237193"></A>export CIAO_ROOT=$TAO_ROOT/CIAO</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237194"></A>export XERCESCROOT=$HOME/xerces-c-src_2_6_0</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237195"></A>export UTILITY_ROOT=$HOME/Utility-1.2.2</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238207"></A>export BOOST_ROOT=$HOME/boost_1_32_0</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238208"></A>export BOOST_INCLUDE=$BOOST_ROOT</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238209"></A>export BOOST_LIB=$BOOST_ROOT/libs</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238201"></A>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$XERCESCROOT/lib</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-260140"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-237209"></A>Enable CIAO and the <A NAME="marker-269036"></A>CIDL Compiler in MPC’s Default Features File</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-237210"></A>Create or edit the <EM CLASS="Code">
$ACE_ROOT/bin/MakeProjectCreator/config/default.features </EM>
<A NAME="marker-271945"></A><A NAME="marker-275810"></A>file and enable CIAO and the CIDL compiler.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-237211"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-257483"></A>ciao          = 1</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237212"></A>cidl          = 1</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237213"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-237214"></A>Generate Build Files with MPC</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-237215"></A>Generate CIAO’s GNU Makefiles with MPC:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-237216"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238359"></A>cd $CIAO_ROOT</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237217"></A>$ACE_ROOT/bin/mwc.pl -recurse -type gnuace</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237219"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-237221"></A>Build CIAO’s <A NAME="marker-269041"></A>CIDL Compiler</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-237222"></A>Build CIAO’s CIDL compiler by executing <EM CLASS="Code">
make</EM>
 in the <EM CLASS="Code">
$CIAO_ROOT/CIDLC</EM>
<A NAME="marker-271739"></A> directory.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-237224"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238430"></A>cd $CIAO_ROOT/CIDLC</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237225"></A>make ciao=1 cidl=1</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-237226"></A>&nbsp;</P>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-237229"></A><A NAME="marker-237227"></A><A NAME="marker-237228"></A>Build CIAO’s Libraries and DAnCE Executables</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-238498"></A>Build CIAO’s libraries and <A NAME="marker-269913"></A>DAnCE executables by executing <EM CLASS="Code">
make</EM>
 in the <EM CLASS="Code">
$CIAO_ROOT/ccm, $CIAO_ROOT/ciao,</EM>
<A NAME="marker-271747"></A> and <EM CLASS="Code">
$CIAO_ROOT/ciao</EM>
<A NAME="marker-271754"></A> directories.</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-238499"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-304170"></A>cd $CIAO_ROOT/ccm</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-304171"></A>make ciao=1 cidl=1</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-304172"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238500"></A>cd $CIAO_ROOT/ciao</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238501"></A>make ciao=1 cidl=1</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238524"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238534"></A>cd $CIAO_ROOT/DAnCE</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-238549"></A>make ciao=1 cidl=1</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-260156"></A><A NAME="marker-271197"></A>&nbsp;</P>
</DIV>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Head2">
<A NAME="pgfId-177638"></A><A NAME="47222"></A>DAnCE <A NAME="marker-271201"></A>Executable Reference<DIV>
<IMG SRC="CIAO-1.gif">
</DIV>
</H3>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-260160"></A>CIAO’s <A NAME="marker-269921"></A>Deployment And Configuration Engine (DAnCE), which implements the OMG “Deployment and Configuration of Component-based Distributed Applications” specification (<A NAME="marker-261858"></A>OMG Document ptc/03-07-08), contains a set of executables to dynamically load component libraries, create component instances, and make connections between them.</LI>
<LI CLASS="Body">
<A NAME="pgfId-231622"></A>The <A NAME="marker-269928"></A>DAnCE executables are described in the following subsections.</LI>
</UL>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-231872"></A>Overview</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-241183"></A>The <A NAME="marker-269935"></A>DAnCE executables are as follows:</LI>
</UL>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-231623"></A>UNIX and UNIX-like Systems</H6>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-231626"></A><A NAME="marker-269942"></A>DAnCE Executables</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231630"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231632"></A>Path</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231634"></A>dance_node_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231636"></A>$DANCE_ROOT/bin/dance_node_manager</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231638"></A>ciao_componentserver</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-303735"></A>$CIAO_ROOT/bin/ciao_componentserver</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231642"></A>dance_execution_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231644"></A>$DANCE_ROOT/bin/dance_execution_manager</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231646"></A>dance_repository_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231648"></A>$DANCE_ROOT/bin/dance_repository_manager</P>
</TD>
</TR>
</TABLE>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-231650"></A>Windows Systems</H6>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-231653"></A><A NAME="marker-269956"></A>DAnCE Executables</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231657"></A>Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231659"></A>Path</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231661"></A><A NAME="marker-272009"></A>dance_node_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231663"></A>%DANCE_ROOT%\bin\dance_node_manager</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231665"></A>ciao_componentserver</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231667"></A>%CIAO_ROOT%\bin\ciao_componentserver</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231669"></A>dance_execution_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231671"></A>%DANCE_ROOT%\bin\dance_execution_manager</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231673"></A>dance_repository_manager</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231675"></A>%DANCE_ROOT%\bin\dance_repository_manager</P>
</TD>
</TR>
</TABLE>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-231677"></A>Node Manager and Node Application</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-231678"></A>The <EM CLASS="Code">
dance_node_manager</EM>
 is a daemon process that launches <EM CLASS="Code">
ciao_componentserver</EM>
 processes as directed by the <EM CLASS="Code">
dance_execution_manager</EM>
. Each object reference in the Messenger’s <EM CLASS="Code">
ApplicationNodeMap.dat</EM>
 configuration file refers to a <EM CLASS="Code">
NodeManager</EM>
 object in the <EM CLASS="Code">
NodeManager</EM>
 daemon process. Recall that the Messenger’s <EM CLASS="Code">
ApplicationNodeMap.dat</EM>
 file is as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-231679"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-231680"></A>Administrator_Node   corbaloc:iiop:localhost:10000/NodeManager</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-231681"></A>First_Receiver_Node  corbaloc:iiop:localhost:20000/NodeManager</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-231682"></A>Second_Receiver_Node corbaloc:iiop:localhost:30000/NodeManager</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-231683"></A>Messenger_Node       corbaloc:iiop:localhost:40000/NodeManager</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-231684"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-231685"></A>The <A NAME="marker-270049"></A>node map file expects to find four different <EM CLASS="Code">
NodeManager</EM>
<A NAME="marker-272033"></A> objects on the <EM CLASS="Code">
localhost</EM>
, each in an ORB listening on a different <A NAME="marker-263456"></A>port. Presumably, each <EM CLASS="Code">
NodeManager</EM>
 object lives in a different process. Each <EM CLASS="Code">
NodeManager</EM>
 launches a <EM CLASS="Code">
ciao_compontnserver</EM>
 process as a container for the component instance or instances mapped to it. For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-232065"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-232066"></A>$DANCE_ROOT/bin/dance_node_manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-303990"></A>-ORBListenEndpoints iiop://localhost:10000 \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-303991"></A>-s &quot;$CIAO_ROOT/bin/ciao_componentserver&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-303992"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-231686"></A>The <EM CLASS="Code">
dance_node_manager</EM>
 executable recognizes the following command-line options</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-231689"></A>dance_node_manager Command-Line Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231695"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231697"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231699"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231701"></A>-s server_executable</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231703"></A><EM CLASS="TableCode">
Componentserver</EM>
 executable to be launched.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231705"></A>REQUIRED</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231707"></A>-o ior_file</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231709"></A>Export the <A NAME="marker-272052"></A><EM CLASS="TableCode">
NodeManager</EM>
 IOR to a file. Supersedes registration with Naming Service.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231711"></A>off</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231713"></A>-d spawn_delay</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231715"></A>Delay spawning of the <A NAME="marker-272206"></A><EM CLASS="TableCode">
NodeApplication</EM>
 by spawn_delay seconds. This can be helpful for debugging.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231717"></A>0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231719"></A>-n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231721"></A>Register the <A NAME="marker-272057"></A><EM CLASS="Code">
NodeManager</EM>
 with the Naming Service in the root naming context with the name retrieved by calling <EM CLASS="TableCode">
ACE_OS::hostname()</EM>
. Superseded by export of IOR file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231723"></A>off</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231725"></A>-?</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231727"></A>Display usage information.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231729"></A>n/a</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-231987"></A>Execution Manager</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-231988"></A>The <EM CLASS="Code">
dance_execution_manager</EM>
 reads the <A NAME="marker-270056"></A>node map file and maps each component instance to the <EM CLASS="Code">
dance_node_manager</EM>
 responsible for it. For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-232085"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-232089"></A>$DANCE_ROOT/bin/dance_execution_Manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-232086"></A>-o em.ior -i ApplicationNodeMap.dat</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-232090"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-232083"></A>The <EM CLASS="Code">
dance_execution_manager</EM>
 executable recognizes the following command-line options</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-231991"></A>Execution Manager Command-Line Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231997"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231999"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-232001"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-232003"></A>-i node_map_file</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-232005"></A>Path of the <A NAME="marker-270063"></A>node map file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-232007"></A>deployment.dat</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-232009"></A>-o ior_file</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-232011"></A>Export the <A NAME="marker-272278"></A><EM CLASS="TableCode">
ExecutionManager</EM>
 IOR to a file. Supersedes registration with Naming Service.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-232013"></A>off</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-232015"></A>-n</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-232017"></A>Register the <A NAME="marker-272291"></A><EM CLASS="TableCode">
ExecutionManager</EM>
 with the Naming Service in the root naming context with the name <EM CLASS="TableCode">
ExecutionManager</EM>
. Superseded by export of IOR file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-232019"></A>off</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-232021"></A>-?</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-232023"></A>Display usage information.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-232025"></A>n/a</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-231769"></A>Repository Manager</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-231770"></A>The <A NAME="marker-272345"></A><EM CLASS="Code">
RepositoryManager</EM>
 parses the XML Deployment and Configuration files and passes the relevant <A NAME="marker-261871"></A>deployment information to the <EM CLASS="Code">
dance_execution_manager</EM>
. For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-232167"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-232168"></A>$DANCE_ROOT/bin/dance_repository_manager \</P>
<P CLASS="Code-Line3">
<A NAME="pgfId-232169"></A>-p package.tpd -d Application.cdp -k file://em.ior</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-232176"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-232149"></A>The <A NAME="marker-272356"></A><EM CLASS="Code">
RepositoryManager</EM>
 executable recognizes the following command-line options</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-231773"></A>Repository Manager Command-Line Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231779"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231781"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-231783"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231785"></A>-k execution_manager_ior</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231787"></A>The Execution Manager’s IOR.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231789"></A>file://exec_mgr.ior</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231791"></A>-p package_url</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231793"></A>The <A NAME="marker-271067"></A>Top-level Package Descriptor’s URL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231795"></A>REQUIRED</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-231797"></A>-d plan_url</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231799"></A>The Component Deployment Descriptor’s URL</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-231801"></A>REQUIRED<A NAME="marker-271203"></A></P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Head2">
<A NAME="pgfId-231616"></A><A NAME="68030"></A>CIDL <A NAME="marker-271220"></A>Compiler Reference<DIV>
<IMG SRC="CIAO-1.gif">
</DIV>
</H3>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-269082"></A>A <A NAME="marker-268526"></A>CIDL <A NAME="marker-269763"></A><EM CLASS="Code">
composition</EM>
 embedded in a <A NAME="marker-268531"></A>CIDL file describes a component implementation. CIAO includes a <A NAME="marker-271218"></A>CIDL compiler, <A NAME="marker-269145"></A><EM CLASS="Code">
cidlc</EM>
, that generates local IDL interfaces for component <A NAME="marker-267920"></A>homes and executors and C++ classes for servants and default <A NAME="marker-267126"></A>executor implementations.</LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-178212"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-178213"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
The generated C++ code is only usable by CIAO. The C++ output from <A NAME="marker-269170"></A>CIDL compilers cannot be interchanged among CORBA implementations. However, the code generated by CIAO’s CIDL compiler is platform-independent, making it possible to use CIAO in cross-compilation environments.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-178215"></A>CIAO’s <A NAME="marker-269174"></A>CIDL compiler maps CIDL files to equivalent IDL and C++ according to the CORBA Component Model specification.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-187020"></A>CIDL Executables</H4>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-178227"></A><A NAME="marker-178225"></A><A NAME="marker-178226"></A>UNIX and UNIX-like Systems</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-178231"></A>The <A NAME="marker-269179"></A>CIDL compiler executable is <EM CLASS="Code">
$CIAO_ROOT/bin/</EM>
<A NAME="marker-178228"></A><A NAME="marker-269097"></A><EM CLASS="Code">
cidlc.</EM>
</LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-178232"></A>Windows Systems</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-178237"></A>The <A NAME="marker-269180"></A>CIDL compiler executable is <EM CLASS="Code">
%CIAO_ROOT%\bin\</EM>
<A NAME="marker-265236"></A><A NAME="marker-269103"></A><EM CLASS="Code">
cidlc.exe.</EM>
 </LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-178238"></A>General Usage</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-178239"></A>The general usage of the CIAO <A NAME="marker-269183"></A>CIDL compiler is as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-178240"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-178243"></A><A NAME="marker-269109"></A>cidlc &lt;options&gt; -- CIDL-file</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-178244"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-178245"></A>The CIDL file name must be listed after the &quot;--&quot;, which is listed after the options. For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-178246"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-179845"></A><A NAME="marker-269118"></A>cidlc -I . -I $CIAO_ROOT/ccm -I $CIAO_ROOT/ciao -I $TAO_ROOT \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-188228"></A>      -I $TAO_ROOT/tao -I $TAO_ROOT/orbsvcs -- Messenger.cidl</P>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-178251"></A>Output Files Generated</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-178255"></A>The <A NAME="marker-269186"></A>CIDL compiler generates three files for each <A NAME="marker-268558"></A>CIDL file. One of these files is an IDL2 file containing the component <A NAME="marker-267133"></A>executor’s local IDL2 interfaces. The component developer compiles that file with the TAO IDL compiler. The remaining two files are C++ files containing the component servant’s class definition and implementation. The generation of these files ensures that the generated code is portable and optimized for a wide variety of C++ compilers. The diagram illustrates the generated files.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-187074"></A>: Compiling a CIDL File</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-187072"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-36.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-178257"></A>For a <A NAME="marker-268568"></A>CIDL file named <EM CLASS="Code">
Messenger.cidl</EM>
<A NAME="marker-178256"></A>, running the command</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-178258"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-180007"></A><A NAME="marker-269127"></A>cidlc -I . -I $CIAO_ROOT/ccm -I $CIAO_ROOT/ciao -I $TAO_ROOT \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-188251"></A>      -I $TAO_ROOT/tao -I $TAO_ROOT/orbsvcs -- Messenger.cidl</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-178262"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-178320"></A>generates the following files (we show how to customize these names later):</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-178265"></A>IDL and C++ Files Generated</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-178269"></A>File Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-178271"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-178273"></A>MessengerE.idl</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-178275"></A>IDL2 for the component <A NAME="marker-267140"></A>executor, to be run through the <EM CLASS="TableCode">
tao_idl</EM>
 compiler.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-178284"></A>Messenger_svnt.h</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-178286"></A>Component and <A NAME="marker-263205"></A>facet servant class definition.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-178288"></A>Messenger_svnt.cpp</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-178290"></A>Component and facet servant class implementations.</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-178335"></A>Using <A NAME="marker-178334"></A>CIDL Compiler Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-178339"></A>We discuss <A NAME="marker-269189"></A>CIDL compiler command line options in <A HREF="CIAO.htm#92488" CLASS="XRef">See Preprocessing Options</A> through <A HREF="CIAO.htm#35224" CLASS="XRef">See Descriptor File Options</A>. To see a complete list of the CIDL compiler’s options, enter the following:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-178343"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-178346"></A><A NAME="marker-269136"></A>cidlc --help</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-178347"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-180640"></A>In addition to the CIDL compiler options listed by the <EM CLASS="Code">
--help</EM>
 argument, the CIDL compiler also recognizes the <EM CLASS="Code">
-I</EM>
 <A NAME="marker-269202"></A>preprocessor argument for specifying an element of the include path.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-178360"></A><A NAME="marker-178357"></A><A NAME="92488"></A><A NAME="marker-178359"></A>Preprocessing Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-260242"></A>The CIDL compiler does not run the full C <A NAME="marker-269197"></A>preprocessor. It recognizes only the <EM CLASS="Code">
-I include_path</EM>
 preprocessor command-line option and the <EM CLASS="Code">
#include</EM>
 preprocessor directive. All other preprocessor directives are ignored.</LI>
<LI CLASS="Body">
<A NAME="pgfId-260299"></A>Each <A NAME="marker-268589"></A>CIDL file must be compiled with, at a minimum, the following <A NAME="marker-269208"></A>include path:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-187845"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-187846"></A>-I $CIAO_ROOT/ccm -I $CIAO_ROOT/ciao -I $TAO_ROOT -I $TAO_ROOT/tao -I $TAO_ROOT/orbsvcs</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-187848"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-187993"></A>Each <A NAME="marker-268596"></A>CIDL file indirectly includes a standard IDL file called <EM CLASS="Code">
Components.idl</EM>
, which in turn includes several other IDL files.</LI>
<LI CLASS="Body">
<A NAME="pgfId-178369"></A>The table provides details of the <A NAME="marker-269210"></A>preprocessing options.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-178376"></A><A NAME="13666"></A>Preprocessing Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-178382"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-178384"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-178386"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-178388"></A>---<A NAME="marker-269273"></A>preprocess-only</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-178390"></A>Run the preprocessor on the IDL file, but do not generate any IDL or C++ code.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-178394"></A>generate IDL and C++ code</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-178414"></A>-I include-path</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-178416"></A>Add <EM CLASS="TableCode">
include_path</EM>
 to the list of paths searched for include files.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-188321"></A>none</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-180467"></A><A NAME="24356"></A>General Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-193629"></A>The <A NAME="marker-193628"></A>CIDL compiler has an option that allows you to turn on a verbose mode that displays detailed information about the <A NAME="marker-268604"></A>CIDL file compilation steps. There are also two options for displaying usage information. The options are summarized in the table.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-193632"></A>General CIDLC Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-193636"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-193638"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-218811"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193640"></A>--<A NAME="marker-269214"></A>trace-semantic-actions</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193642"></A>Turn on verbose mode.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-218813"></A>off</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193644"></A>--<A NAME="marker-269219"></A>help</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193646"></A>Output usage information to <EM CLASS="TableCode">
stderr</EM>
.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-218815"></A>n/a</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193648"></A>--<A NAME="marker-269224"></A>help-html</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193650"></A>Output usage information in HTML format to <EM CLASS="TableCode">
stderr</EM>
<A NAME="marker-193651"></A><A NAME="marker-193652"></A><A NAME="marker-193653"></A>.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-218817"></A>n/a</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-193656"></A>Servant File Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-193098"></A>The CIDL compiler generates a complete servant class implementation for each component and each <A NAME="marker-263216"></A>facet. The component developer has some control over the servant’s usage of <A NAME="marker-265912"></A>event type factories and the names of the generated files.</LI>
<LI CLASS="Body">
<A NAME="pgfId-193148"></A>The table summarizes the servant-related CIDL compiler options.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-193101"></A>Servant File Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-193107"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-193109"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-193111"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193484"></A>--<A NAME="marker-269235"></A>suppress-register-factory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193486"></A>Suppress automatic registration of a value type factory for each <A NAME="marker-265919"></A>event type. By default, a value type factory is automatically registered for each event type. If <A NAME="marker-265946"></A>factory registration is suppressed, then the developer must manually register a value type factory for each event type.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193488"></A>off, meaning a value type factory is automatically registered for each event type</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193113"></A>--<A NAME="marker-269275"></A>svnt-hdr-file-suffix suffix</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193115"></A>Use this suffix instead of the default to construct the name of the servant’s header file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193117"></A><EM CLASS="TableCode">
_svnt.h</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193119"></A>--<A NAME="marker-269249"></A>svnt-hdr-file-regex regex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193121"></A>Use this regular expression to construct the name of the servant’s header file</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193123"></A>n/a</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193125"></A>--<A NAME="marker-269254"></A>svnt-src-file-suffix suffix</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193127"></A>Use this suffix instead of the default to construct the name of the servant’s source file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193129"></A><EM CLASS="TableCode">
_svnt.cpp</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193131"></A>--<A NAME="marker-269259"></A>svnt-src-file-regex regex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193133"></A>Use this regular expression to construct the name of the servant’s source file</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193135"></A>n/a</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193137"></A>--<A NAME="marker-269264"></A>svnt-export-macro macro</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193139"></A>Replace the servant’s default export macro with this export macro</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193141"></A>see below</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193143"></A>--<A NAME="marker-269269"></A>svnt-export-include file</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193145"></A>Replace the servant’s default export include file with this file</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193147"></A>see below</P>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-221494"></A>The CIDL compiler assumes that the servant is part of a dynamic library. On Windows platforms, classes exported from dynamic libraries must define an export macro. On UNIX-like platforms, the export macros define to nothing. However, future versions of the <EM CLASS="Code">
gcc</EM>
 compiler support the C++ <EM CLASS="Code">
export</EM>
 keyword, which may reduce code size by reducing the number of exported symbols. In either case, the export macros enable cross-platform development.</LI>
<LI CLASS="Body">
<A NAME="pgfId-193150"></A>The CIDL compiler assumes that a component servant’s export macro is called <EM CLASS="Code">
&lt;COMPONENT&gt;_SVNT_Export</EM>
 and that the macro is defined in a header file called <EM CLASS="Code">
&lt;Component&gt;_svnt_export.h</EM>
. For example, the Messenger component’s servant export macro is assumed to be</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-193151"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-193152"></A>MESSENGER_SVNT_Export</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-193153"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-193154"></A>and it is assumed to be defined in a C++ header file called</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-193155"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-193156"></A>Messenger_svnt_export.h</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-193157"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-193158"></A>If that is not the case, then use the <EM CLASS="Code">
--svnt-export-macro</EM>
 command-line argument to indicate the correct name of the export macro and the <EM CLASS="Code">
--svnt-export-include</EM>
 command-line argument to indicate the correct name of the export header file.</LI>
<LI CLASS="Body">
<A NAME="pgfId-193159"></A>See <A HREF="CIAO.htm#66494" CLASS="XRef">See Building the Messenger Application</A> for more information on component export macros.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-193392"></A>Local Executor File Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-193393"></A>The <A NAME="marker-269279"></A>CIDL compiler generates an IDL file containing the component implementation’s local <A NAME="marker-267153"></A>executor interfaces. The component developer implements the component and its <A NAME="marker-263224"></A>facets by implementing these local executor interfaces.</LI>
<LI CLASS="Body">
<A NAME="pgfId-193425"></A>The table summarizes the <A NAME="marker-267165"></A>executor-related CIDL compiler options.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-193396"></A>Local Executor File Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-193402"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-193404"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-193406"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193408"></A>--<A NAME="marker-269280"></A>lem-file-suffix suffix</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193410"></A>Suffix for the generated <A NAME="marker-267174"></A>executor IDL file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193412"></A><EM CLASS="TableCode">
E</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193414"></A>--<A NAME="marker-269282"></A>lem-file-regex regex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193416"></A>Regular expression to use when constructing the name of the local <A NAME="marker-267184"></A>executor IDL file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193418"></A>n/a</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-193420"></A>--<A NAME="marker-269287"></A>lem-force-all</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193422"></A>Force generation of local <A NAME="marker-267194"></A>executor mapping for all IDL types, whether used by the <A NAME="marker-269770"></A>composition or not. By default, the CIDL compiler generates local executor interfaces only for those components used by the composition.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-193424"></A>off</P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-193160"></A>Starter Executor Implementation File Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-193161"></A>The <A NAME="marker-269291"></A>CIDL compiler can generate a default <A NAME="marker-267206"></A>executor implementation for each component and <A NAME="marker-263235"></A>facet. These default executor implementation files contain empty C++ member function definitions that you fill in with your implementation code. This can be a great time saver.</LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-191370"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-218772"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
Running the <A NAME="marker-269292"></A>CIDL compiler with the starter implementation options overwrites any existing implementation files of the same names. Any modifications will be lost unless you rename the starter implementation files after they are generated (recommended).<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-191030"></A>The table summarizes the implementation-related CIDL compiler options.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-190982"></A>Executor Implementation File Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-190988"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-190990"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-190992"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-191988"></A>--<A NAME="marker-269293"></A>gen-exec-impl</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191990"></A>Generate a default <A NAME="marker-267215"></A>executor implementation class for each component and <A NAME="marker-263242"></A>facet.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191992"></A>off</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-190994"></A>--<A NAME="marker-269295"></A>exec-hdr-file-suffix suffix</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-190996"></A>Use this suffix instead of the default to construct the name of the default <A NAME="marker-267225"></A>executor implementation’s header file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-190998"></A><EM CLASS="TableCode">
_exec.h</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-191000"></A>--<A NAME="marker-269300"></A>exec-hdr-file-regex regex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191002"></A>Use this regular expression to construct the name of the default <A NAME="marker-267235"></A>executor implementation’s header file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191004"></A>n/a</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-191006"></A>--<A NAME="marker-269305"></A>exec-src-file-suffix suffix</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191008"></A>Use this suffix instead of the default to construct the name of the default <A NAME="marker-267245"></A>executor implementation’s source file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-191011"></A><EM CLASS="TableCode">
_exec.cpp</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-191013"></A>--<A NAME="marker-269310"></A>exec-src-file-regex regex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191015"></A>Use this regular expression to construct the name of the default <A NAME="marker-267255"></A>executor implementation’s source file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191017"></A>n/a</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-191019"></A>--<A NAME="marker-269315"></A>exec-export-macro <EM CLASS="Emphasis">
macro</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191021"></A>Replace the default <A NAME="marker-267262"></A>executor implementation’s default export macro with this export macro.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191023"></A>see below</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-191025"></A>--<A NAME="marker-269320"></A>exec-export-include <EM CLASS="Emphasis">
file</EM>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191027"></A>Replace the default <A NAME="marker-267279"></A>executor implementation’s default export include file this file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-191029"></A>see below</P>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-190480"></A>You are strongly advised to rename the generated default <A NAME="marker-267289"></A>executor implementation files before modifying them. Otherwise, the CIDL compiler will likely overwrite your changes. For example, rename <EM CLASS="Code">
Messenger_exec.h</EM>
 and <EM CLASS="Code">
Messenger_exec.cpp</EM>
 to <EM CLASS="Code">
Messenger_exec_i.h</EM>
 and <EM CLASS="Code">
Messenger_exec_i.cpp</EM>
.</LI>
<LI CLASS="Body">
<A NAME="pgfId-192087"></A>The CIDL compiler assumes that the <A NAME="marker-267296"></A>executor implementation is part of a dynamic library. On Windows platforms, classes exported from a dynamic library must define an export macro.</LI>
<LI CLASS="Body">
<A NAME="pgfId-190481"></A>The CIDL compiler assumes that a component <A NAME="marker-267303"></A>executor’s export macro is called <EM CLASS="Code">
&lt;COMPONENT&gt;_EXEC_Export</EM>
 and that the macro is defined in a header file called <EM CLASS="Code">
&lt;Component&gt;_exec_export.h</EM>
. For example, the Messenger component’s executor export macro is assumed to be</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-190482"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-190483"></A>MESSENGER_EXEC_Export</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-190484"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-190485"></A>and it is assumed to be defined in a C++ header file called</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-190486"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-190487"></A>Messenger_exec_export.h</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-190488"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-190489"></A>If that is not the case, then use the <EM CLASS="Code">
--exec-export-macro</EM>
 command-line argument to indicate the correct name of the export macro and the <EM CLASS="Code">
--exec-export-include</EM>
 command-line argument to indicate the correct name of the export header file.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-192139"></A><A NAME="35224"></A>Descriptor File Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-192385"></A>The <A NAME="marker-269330"></A>CIDL compiler generates a <A NAME="marker-270635"></A>CORBA Component Descriptor for each component. However, the generated descriptor file is not usable to deploy a CCM application using CIAO’s <A NAME="marker-269974"></A>DAnCE facility. The generated descriptor file is formatted in accordance with the deprecated “Packaging and Deployment” chapter of the OMG CORBA Component Model specification (<A NAME="marker-261901"></A>OMG Document formal/02-06-65) rather than the updated OMG “Deployment and Configuration of Component-based Distributed Applications” specification (<A NAME="marker-261910"></A>OMG Document ptc/03-07-08). Thus, we ignore the generated <A NAME="marker-270642"></A>CORBA Component Descriptor files in our <A NAME="marker-261934"></A>deployment.<A NAME="marker-265392"></A></LI>
<LI CLASS="Body">
<A NAME="pgfId-261886"></A>The table summarizes the descriptor-related CIDL compiler options:</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-192143"></A>Descriptor File Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-192149"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-192151"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-192153"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-192155"></A>--<A NAME="marker-269331"></A>desc-file-suffix suffix</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-192157"></A>Use this suffix instead of the default to construct the name of the descriptor file.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-192159"></A><EM CLASS="TableCode">
.ccd</EM>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-192161"></A>--<A NAME="marker-269333"></A>desc-file-regex regex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-192163"></A>Use this regular expression to construct the name of the descriptor file</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-192165"></A>n/a<A NAME="marker-271228"></A></P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Head2">
<A NAME="pgfId-245304"></A>IDL3-to-IDL2 <A NAME="marker-271236"></A>Compiler Reference<DIV>
<IMG SRC="CIAO-1.gif">
</DIV>
</H3>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-260372"></A>CIAO includes an <A NAME="marker-269376"></A>IDL3-to-IDL2 compiler that generates IDL2-compatible interfaces for ORB implementations that do not recognize IDL3 keywords such as “<EM CLASS="Code">
component</EM>
” and “<EM CLASS="Code">
provides</EM>
”. This enables a client developed with a non-CCM-aware ORB to communicate with a CCM component. For example, a Java client built with an ORB such as JacORB can use CIAO’s IDL3-to-IDL2 output files as its interface to the Messenger component. Simply compile the Messenger’s IDL3 files with CIAO’s IDL3-to-IDL2 compiler, and then compile the IDL2 output with JacORB’s IDL compiler.</LI>
</UL>
<DIV>
<H6 CLASS="SideNote">
<A NAME="pgfId-245306"></A>&nbsp;</H6>
<UL>
<LI CLASS="NoteBody">
<A NAME="pgfId-245307"></A></LI>
<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
The generated IDL2 code is usable by any ORB.<DIV>
<IMG SRC="CIAO-8.gif">
</DIV>
</UL>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-245309"></A>CIAO’s <A NAME="marker-269409"></A>IDL3-to-IDL2 compiler maps IDL3 files to equivalent IDL2 according to the Equivalent IDL sections of the CORBA Component Model specification. </LI>
<LI CLASS="Body">
<A NAME="pgfId-248710"></A>For an example of using the IDL3-to-IDL2 compiler, please see the <EM CLASS="Code">
Administrator_Client_IDL2.mpc</EM>
 project in the <EM CLASS="Code">
$CIAO_ROOT/examples/DevGuideExamples/Messenger</EM>
 directory.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-245789"></A>IDL3-to-IDL2 Source Code</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-245795"></A>The source code for the <A NAME="marker-269408"></A>IDL3-to-IDL2 compiler is in the <EM CLASS="Code">
$CIAO_ROOT/tools/IDL3_to_IDL2</EM>
<A NAME="marker-271780"></A> directory. Build the code in that directory to create the <EM CLASS="Code">
tao_idl3_to_idl2</EM>
<A NAME="marker-265325"></A> executable.</LI>
</UL>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-245310"></A>IDL3-to-IDL2 Executable</H4>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-245828"></A><A NAME="marker-245826"></A><A NAME="marker-245827"></A>UNIX and UNIX-like Systems</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-245832"></A>The <A NAME="marker-269413"></A>IDL3-to-IDL2 compiler executable is <EM CLASS="Code">
$CIAO_ROOT/bin/tao_idl3_to_idl2.</EM>
<A NAME="marker-245829"></A><A NAME="marker-265290"></A></LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-245833"></A>Windows Systems</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-245323"></A>The <A NAME="marker-269414"></A>IDL3-to-IDL2 compiler executable is <EM CLASS="Code">
%CIAO_ROOT%\bin\tao_idl3_to_idl2.exe.</EM>
<A NAME="marker-265276"></A><A NAME="marker-265292"></A> </LI>
</UL>
</DIV>
<DIV>
<H6 CLASS="Head5">
<A NAME="pgfId-245324"></A>General Usage</H6>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-245325"></A>The general usage of the CIAO <A NAME="marker-269415"></A>IDL3-to-IDL2 compiler is as follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-245326"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248822"></A><A NAME="marker-265301"></A>tao_idl3_to_idl2 -I $CIAO_ROOT -I $CIAO_ROOT/ciao -I $CIAO_ROOT/ciao -I $TAO_ROOT \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248823"></A>      -I $TAO_ROOT/tao -I $TAO_ROOT/orbsvcs \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248836"></A>      &lt;options&gt; &lt;idl3 files&gt;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-245330"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-245331"></A>For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-245332"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248832"></A><A NAME="marker-265310"></A>tao_idl3_to_idl2 -I $CIAO_ROOT -I $CIAO_ROOT/ciao -I $CIAO_ROOT/ciao -I $TAO_ROOT \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-245333"></A>      -I $TAO_ROOT/tao -I $TAO_ROOT/orbsvcs \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248837"></A>      -I . Messenger.idl</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248811"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-248815"></A>The lengthy include path is necessary to enable the <A NAME="marker-269401"></A>IDL3-to-IDL2 compiler to find CIAO’s CCM-related IDL files.</LI>
</UL>
</DIV>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-249996"></A>Output Files Generated</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-245336"></A>The IDL3-to-IDL2 compiler generates one IDL2 <A NAME="marker-269384"></A>output file for each <A NAME="marker-269393"></A>input file. A developer typically compiles that output file with another ORB’s IDL compiler. The diagram illustrates the generated files.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="FigTitle">
<A NAME="pgfId-245344"></A>: Compiling an IDL File with IDL3-to-IDL2</H6>
</CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-245342"></A>&nbsp;</P>
<DIV>
<IMG SRC="CIAO-37.gif">
</DIV>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-245346"></A>For an IDL3 file named <EM CLASS="Code">
Messenger.idl</EM>
<A NAME="marker-245345"></A>, running the command</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-245347"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248893"></A><A NAME="marker-265345"></A>tao_idl3_to_idl2 -I $CIAO_ROOT -I $CIAO_ROOT/ciao -I $CIAO_ROOT/ciao -I $TAO_ROOT \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248894"></A>      -I $TAO_ROOT/tao -I $TAO_ROOT/orbsvcs \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-245349"></A>      -I . Messenger.idl</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-246405"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-246427"></A>generates the following file:</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-260491"></A>IDL and C++ Files Generated</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-260495"></A>File Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-260497"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-260499"></A>Messenger_IDL2.idl</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-260501"></A>Equivalent IDL2 for Messenger’s IDL3 file, to be run through another ORB’s IDL compiler.</P>
</TD>
</TR>
</TABLE>
<LI CLASS="Body">
<A NAME="pgfId-246429"></A>The generated <EM CLASS="Code">
Messenger_IDL2.idl</EM>
 file includes CIAO’s <EM CLASS="Code">
Components.idl</EM>
 file, which contains IDL2 CCM declarations. When compiling the <EM CLASS="Code">
Messenger_IDL2.idl</EM>
 file with a non-CCM-aware ORB’s IDL compiler, the <EM CLASS="Code">
Components.idl</EM>
 file and the files it includes must be in the include path of that ORB’s IDL compiler.</LI>
<LI CLASS="Body">
<A NAME="pgfId-250240"></A>In our example, we compile the IDL3 file <EM CLASS="Code">
Messenger.idl</EM>
, which follows:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-250241"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250340"></A>// file Messenger.idl</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250242"></A>#include &lt;Components.idl&gt;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250243"></A>#include &lt;Runnable.idl&gt;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250244"></A>#include &lt;Publication.idl&gt;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250245"></A>#include &lt;Message.idl&gt;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250246"></A>#include &lt;History.idl&gt;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250247"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250248"></A>component Messenger {	</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250249"></A>  attribute string subject;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250250"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250251"></A>  provides Runnable control;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250252"></A>  provides Publication content;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250253"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250254"></A>  publishes Message message_publisher;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250255"></A>  provides History message_history;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250256"></A>};</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250257"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250258"></A>home MessengerHome manages Messenger {};</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250259"></A>&nbsp;</P>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-250322"></A>Note that you must also compile the included IDL3 files <EM CLASS="Code">
Runnable.idl</EM>
, <EM CLASS="Code">
Publication.idl</EM>
, <EM CLASS="Code">
Message.idl</EM>
, and <EM CLASS="Code">
History.idl</EM>
 with the <A NAME="marker-269407"></A>IDL3-to-IDL2 compiler.</LI>
<LI CLASS="Body">
<A NAME="pgfId-250260"></A>The compiler generates the IDL2 file <EM CLASS="Code">
Messenger_IDL2.idl</EM>
:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-250261"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250262"></A>// file Messegner_IDL2.idl</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250346"></A>#include &quot;Components.idl&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250263"></A>#include &quot;Runnable_IDL2.idl&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250264"></A>#include &quot;Publication_IDL2.idl&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250265"></A>#include &quot;Message_IDL2.idl&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250266"></A>#include &quot;History_IDL2.idl&quot;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250267"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250268"></A>interface Messenger : Components::CCMObject</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250269"></A>{</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250270"></A>  </P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250271"></A>  attribute string subject;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250272"></A>  Runnable provide_control ();</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250273"></A>  Publication provide_content ();</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250274"></A>  History provide_message_history ();</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250275"></A>  </P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250276"></A>  Components::Cookie subscribe_message_publisher (</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250277"></A>    in MessageConsumer consumer)</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250278"></A>    raises (Components::ExceededConnectionLimit);</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250279"></A>  </P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250280"></A>  MessageConsumer unsubscribe_message_publisher (in Components::Cookie ck)</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250281"></A>    raises (Components::InvalidConnection);</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250282"></A>};</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250283"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250284"></A>interface MessengerHomeExplicit : Components::CCMHome</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250285"></A>{</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250286"></A>};</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250287"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250288"></A>interface MessengerHomeImplicit : Components::KeylessCCMHome</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250289"></A>{</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250290"></A>  Messenger create ()</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250291"></A>    raises (Components::CreateFailure);</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250292"></A>};</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250293"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250294"></A>interface MessengerHome : MessengerHomeExplicit, MessengerHomeImplicit</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250295"></A>{</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250296"></A>};</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-250297"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-249611"></A>IDL3-to-IDL2 Compiler Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-246436"></A>We discuss <A NAME="marker-269404"></A>IDL3-to-IDL2 compiler command line options in <A HREF="CIAO.htm#92715" CLASS="XRef">See Preprocessing Options</A> through <A HREF="CIAO.htm#88048" CLASS="XRef">See General Options</A>. To see a complete list of the IDL3-to-IDL2 compiler’s options, enter the following:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-245382"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-245385"></A><A NAME="marker-265353"></A>tao_idl3_to_idl2 -u</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-245386"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-246552"></A><A NAME="marker-246550"></A><A NAME="marker-246551"></A><A NAME="92715"></A>Preprocessing Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-246638"></A>The <A NAME="marker-269406"></A>IDL3-to-IDL2 compiler uses the same preprocessor as the <EM CLASS="Code">
tao_idl</EM>
<A NAME="marker-265365"></A> compiler. For more information on the preprocessor options and directives, please see <A HREF="IDL_Complr.htm#92488" CLASS="XRef"></A>. The most commonly used of these options is the <EM CLASS="Code">
-I</EM>
 option, which specifies a directory for the include path. For example:</LI>
</UL>
<P CLASS="Code-Line2">
<A NAME="pgfId-246648"></A>&nbsp;</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248903"></A><A NAME="marker-265370"></A>tao_idl3_to_idl2 -I $CIAO_ROOT -I $CIAO_ROOT/ciao -I $CIAO_ROOT/ciao -I $TAO_ROOT \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-248904"></A>      -I $TAO_ROOT/tao -I $TAO_ROOT/orbsvcs \</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-246650"></A>      -I . Messenger.idl</P>
<P CLASS="Code-Line2">
<A NAME="pgfId-246651"></A>&nbsp;</P>
</DIV>
<DIV>
<H4 CLASS="Head3">
<A NAME="pgfId-246643"></A><A NAME="88048"></A>General Options</H4>
<UL>
<LI CLASS="BodyNoLead">
<A NAME="pgfId-245429"></A>The <A NAME="marker-269416"></A>IDL3-to-IDL2 compiler’s other remaining options are summarized below. Each option’s function is identical to its matching option of the IDL compiler.</LI>
<TABLE BORDER="1">
<CAPTION>
<H6 CLASS="NumberedTableTitle">
<A NAME="pgfId-245432"></A>General IDL3-to-IDL2 Options</H6>
</CAPTION>
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-245438"></A>Option</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-245440"></A>Description</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Heading">
<A NAME="pgfId-245442"></A>Default</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-246822"></A>-<A NAME="marker-269494"></A>o output-directory</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246824"></A>Subdirectory in which to place the generated stub and skeleton files.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246826"></A>Current directory</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-246801"></A>-<A NAME="marker-269499"></A>t dir</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246803"></A>Directory used by the IDL compiler for temporary files.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246807"></A>In <A NAME="marker-246805"></A><A NAME="marker-246806"></A>UNIX, uses the value of the <EM CLASS="TableCode">
TMPDIR</EM>
 environment variable, if set, or <EM CLASS="TableCode">
/tmp</EM>
 by default. In <A NAME="marker-246808"></A>Windows, uses the value of the <EM CLASS="TableCode">
TMP</EM>
 environment variable, if set, or the <EM CLASS="TableCode">
TEMP</EM>
 environment variable, if set, or the <EM CLASS="TableCode">
WINNT</EM>
 directory (on NT).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-246810"></A>-<A NAME="marker-269504"></A>v</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246812"></A>Verbose flag. IDL compiler will print progress messages after completing major phases.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246814"></A>No progress messages displayed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-246816"></A>-<A NAME="marker-269509"></A>d</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246818"></A>Print the Abstract Syntax Tree (AST) to <EM CLASS="TableCode">
stdout</EM>
.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246820"></A>AST is not displayed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-249030"></A>-<A NAME="marker-269514"></A>w</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-249032"></A>Suppress warnings.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-249034"></A>All warnings displayed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-249052"></A>-<A NAME="marker-269519"></A>V</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-249054"></A>Print version information for front end and back end.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-249056"></A>No version information displayed.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-249046"></A>-<A NAME="marker-269524"></A>Cw</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-249048"></A>Output a warning if two identifiers in the same scope differ in spelling only by case.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-249050"></A>Error output is default.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-249040"></A>-<A NAME="marker-269529"></A>Ce</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-249042"></A>Output an error if two indentifiers in the same scope differ in spelling only by case.</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-249044"></A>Error output is default.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TblCode">
<A NAME="pgfId-246680"></A>-<A NAME="marker-269534"></A>g gperf-path</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246682"></A>Specify a path for the <EM CLASS="TableCode">
gperf</EM>
<A NAME="marker-275437"></A> program</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="Tbl-Body">
<A NAME="pgfId-246684"></A><EM CLASS="TableCode">
$ACE_ROOT/bin/</EM>
<A NAME="marker-265379"></A><EM CLASS="TableCode">
gperf</EM>
<A NAME="marker-271244"></A></P>
</TD>
</TR>
</TABLE>
</UL>
</DIV>
</DIV>
<DIV>
<H3 CLASS="Head2">
<A NAME="pgfId-166747"></A>Future Topics<DIV>
<IMG SRC="CIAO-1.gif">
</DIV>
</H3>
<UL>
<LI CLASS="Body">
<A NAME="pgfId-166748"></A>Several CCM and CIAO-related topics are beyond the scope of this chapter. They include the following:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235332"></A>Component navigation</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235442"></A>Keyed component <A NAME="marker-267935"></A>homes</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235340"></A><A NAME="marker-267944"></A>Home finders</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235350"></A>Life cycle categories s<EM CLASS="Code">
ervice</EM>
, <EM CLASS="Code">
process</EM>
, and <EM CLASS="Code">
entity</EM>
</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235397"></A>The IDL3 <A NAME="marker-272503"></A><EM CLASS="Code">
supports</EM>
 keyword</LI>
<LI CLASS="Body">
<A NAME="pgfId-235398"></A>In addition, there are several capabilities that are expected to be addressed in future versions of CIAO. These include the following:</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235399"></A>Static application <A NAME="marker-261941"></A>deployment</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235413"></A><A NAME="marker-261948"></A>Deployment of real-time applications</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235387"></A>Container-managed persistent using the Persistent State Service (PSS) and Persistent State Definition Language (PSDL) (<A NAME="marker-264014"></A>OMG Document formal/02-09-06)</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235405"></A>Integration with Enterprise Java Beans</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235432"></A>Using the Real-Time Event Service or OMG Notification Service as the event delivery infrastructure</LI>
<LI CLASS="Bullet1">
<A NAME="pgfId-235433"></A>Quality-of-Service</LI>
<LI CLASS="Body">
<A NAME="pgfId-260547"></A><A NAME="marker-260552"></A>&nbsp;</LI>
</UL>
</DIV>
</DIV>
</BODY>
</HTML>
