<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; I; Linux 2.0.32 i486) [Netscape]">
   <META NAME="Author" CONTENT="James CE Johnson">
   <META NAME="Description" CONTENT="A first step towards using ACE productively">
   <TITLE>ACE Tutorial 001</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#000FFF" VLINK="#FF0F0F">

<CENTER><B><FONT SIZE=+2>ACE Tutorial 001</FONT></B></CENTER>

<CENTER><B><FONT SIZE=+2>A Beginners Guide to Using the ACE Toolkit</FONT></B></CENTER>


<P>
<HR WIDTH="100%">

<P>From here, we to move on to the main program loop. In a way, we're
starting at the final product when we do this, but it is a very simple
piece of code and a good place to start.

<P>The <A HREF="server.cpp">main</A>
program is really quite simple. The real work is done in the ACE derived
classes.

<P>
Kirthika Parameswaran offers this abstract of Tutorial 1:
<UL>
<P>
This is a simple logging server example.
The Reactor is used to handle more than one client request using a
single thread of execution instead of one thread per client. The Reactor
reactes to events and demultiplexes the events to the appropriate
Event_Handler registered with it, using the "callback" technique. The
reactor runs in an infinte event loop handling all the incoming events.
<P>
The Logging_Acceptor listens at a SERVER PORT address and passively
waits for requests to arrive. The Acceptor is also an Event_Handler and
is registered with the Reactor. This way it is simply yet another
Event_Handler for the Reactor and hence no special processing is needed
for it.
<P>
Once a connection request occurs, the Acceptor accepts it and
a connection is established. The reactor instance is passed to the
handler so that it can register with the Reactor. It does so with an
ACE_Event_Handler::ACCEPT_MASK.
<P>
The Logging_Client is another Event_Handler which actually handles the
client requests in its handle_input() method. It is also registered
with the Reactor with the ACE_Event_Handler::READ_MASK.
<P>
The Event_Handlers can be unregistered from the Reactor using
handle_close() methods 
or explicitly calling the remove_handler() methods. 
<P>
This server application builds and executes succesfully waiting for
client requests to arrive.
<P>
</UL>
FYI (from Doug):
<UL>
The ACCEPT_MASK is defined in the ACE_Event_Handler class.  It's used
to inform the Reactor that you want to register an event handler to
"accept" a connection passively.  Not surprisingly, the ACE_Acceptor
component uses this.
<P>
The READ_MASK is also defined in the ACE_Event_Handler class.  It's
used to inform the Reactor that you want to register an event handler
to "read" data from an established connection.
</UL>
<HR WIDTH="100%">
<PRE>/*
&nbsp; Include the header file where our client acceptor is defined.
&nbsp;*/
#include "ace/Reactor.h"

/*&nbsp;&nbsp;
&nbsp; For simplicity, we create our reactor in the global address space.
&nbsp; In later tutorials we will do something more clever and appropriate. However,
&nbsp; the purpose of this tutorial is to introduce a connection acceptance and
&nbsp; handling, not the full capabilities of a reactor.
*/
ACE_Reactor * g_reactor;

/*
&nbsp; Include the header where we define our acceptor object.&nbsp; An acceptor is
&nbsp; an abstraction that allows a server to "accept" connections from clients.
*/
#include "acceptor.h"

/*
&nbsp; A TCP/IP server can listen to only one port for connection requests.
&nbsp; Well-known services can always be found at the same address. Lesser-known
&nbsp; services are generally told where to listen by a configuration file or
&nbsp; command-line parameter. For this example, we're satisfied with simply hard-coding
&nbsp; a random but known value.
*/
static const u_short PORT = ACE_DEFAULT_SERVER_PORT;

int main (int, char **)
{
&nbsp; /*
&nbsp;&nbsp;&nbsp; Create a Reactor instance.&nbsp; Again, a global pointer isn't exactly the
&nbsp;&nbsp;&nbsp; best way to handle this but for the simple example here, it will be OK.
&nbsp;&nbsp;&nbsp; We'll get cute with it later.
&nbsp; */
&nbsp; g_reactor = new ACE_Reactor;

&nbsp; /*
&nbsp;&nbsp;&nbsp; Like the Reactor, I'm skimming over the details of the ADDR
&nbsp;&nbsp;&nbsp; object. What it provides is an abstraction for addressing services in the
&nbsp;&nbsp;&nbsp; network. All we need to know at this point is that we are creating an address
&nbsp;&nbsp;&nbsp; object which specifies the TCP/IP port on which the server
&nbsp;&nbsp;&nbsp; will listen for new connection requests.
&nbsp; */
&nbsp; ACE_INET_Addr addr (PORT);

&nbsp; /*
&nbsp;&nbsp;&nbsp; We now create an acceptor object.&nbsp; No connections will
&nbsp;&nbsp;&nbsp; yet be established because the object isn't "open for business"
&nbsp;&nbsp;&nbsp; at this time. Which brings us to the next line...
&nbsp; */
&nbsp; Logging_Acceptor * peer_acceptor = new Logging_Acceptor();

&nbsp; /*
&nbsp;&nbsp;&nbsp; where the acceptor object is opened.&nbsp; You'll find that most ACE
&nbsp;&nbsp;&nbsp; objects have to be open()ed before they're of any use to you.
&nbsp;&nbsp;&nbsp; On this open() call, we're telling the acceptor where to listen
&nbsp;&nbsp;&nbsp; for connections via the 'addr' object.&nbsp; We're also telling it
&nbsp;&nbsp;&nbsp; that we want it to be registered with our 'g_reactor' instance.
&nbsp;&nbsp; */
&nbsp; if (peer_acceptor->open(addr,g_reactor) == -1 )
&nbsp;&nbsp;&nbsp; ACE_ERROR_RETURN ((LM_ERROR, "Opening Acceptor\n"), -1);

&nbsp; ACE_DEBUG ((LM_DEBUG, "(%P|%t) starting up server logging daemon\n"));

&nbsp; /*
&nbsp;&nbsp;&nbsp; The reactor's handle_events member function is responsible for looking at
&nbsp;&nbsp;&nbsp; all registered objects and invoking an appropriate member function when
&nbsp;&nbsp;&nbsp; anything of interest occurs. When an event is processed, the handle_events
&nbsp;&nbsp;&nbsp; function returns. In order to get all events, we embed this in an infinite
&nbsp;&nbsp;&nbsp; loop.

&nbsp;&nbsp;&nbsp; Since we put ourselves into an infinite loop, you'll need to CTRL-C
&nbsp;&nbsp;&nbsp; to exit the program.
&nbsp; */
&nbsp; while (1)
&nbsp;&nbsp;&nbsp;&nbsp; g_reactor-> handle_events ();

&nbsp; return 0;
}</PRE>

<HR WIDTH="100%">

<P>As I said, the main program is really quite simple:
<UL>
<LI>
Create an address for the <I>port</I> we want to listen to</LI>

<LI>
Create an acceptor which listens on that address</LI>

<LI>
Register the acceptor with a reactor to respond to the connection requests</LI>

<LI>
Enter an infinite loop to let the reactor handle the events</LI>
</UL>
On the next page, we will take a look at the acceptor and how it responds
to new connection requests.

<P>
<HR WIDTH="100%">
<CENTER>[<A HREF="..">Tutorial
Index</A>] [<A HREF="page01.html">Previous
Page</A>] [<A HREF="page03.html">Continue
This Tutorial</A>]</CENTER>

</BODY>
</HTML>
