<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="James CE Johnson">
   <TITLE>ACE Tutorial 013</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#000FFF" VLINK="#FF0F0F">

<CENTER><B><FONT SIZE=+2>ACE Tutorial 013</FONT></B></CENTER>

<CENTER><B><FONT SIZE=+2>Multiple thread pools</FONT></B></CENTER>


<P>
<HR WIDTH="100%">
<P>
I did eventually create that ACE_Data_Block derivative that I wanted.
My purpose in doing so was to use the reference-counting
that is provided by ACE_Data_Block and ACE_Message_Block interactions.
  When you're working with an object in a single
thread, it's generally not so difficult to manage it's lifetime.
That is, it doesn't tend to go out of scope or get destroyed unless
you do it on purpose.
<P>
On the other hand, if you're passing data between several threads, it
is easy to loose track of who "owns" the data at any one time.  All
too frequently, data will be deleted by one thread while another is
still using it.  Reference counting can prevent that.  The rule of
thumb is that you increment the reference count of the object when you 
hand it off to a new thread.  You then decrement the count when you're 
done with the object and let the object delete itself when there are
no more references.
<P>
To prove that all of that works correctly in the tutorial, I've
created a cheap Memory Leak Detector object.  All mld instances
reference a thread-safe counter that is incremented when the mld is
constructed and decremented when destructed.  I then insert an mld
into each of my dynamically created objects.  If I get to the end of
main() and the counter isn't zero then I either didn't delete enough
or I deleted too many times.
<P>
Simple, cheap, effective.
<P>
<HR WIDTH="100%">
<PRE>
#ifndef MLD_H
#define MLD_H

#include "ace/Synch.h"
#include "ace/Singleton.h"

/*
  This is a cheap memory leak detector.  Each class I want to watch
  over contains an mld object.  The mld object's ctor increments a
  global counter while the dtor decrements it.  If the counter is
  non-zero when the program is ready to exit then there may be a leak.
*/

class mld
{
public:
    mld(void);
    ~mld(void);
};

/*
  The mld_counter will be made into a singleton so that all of the mld 
  objects can access it easily.
*/

class mld_counter
{
public:
        // Return the value of the counter
    static int value(void);
    
protected:
    friend class mld;

        // Use ACE_Atomic_Op to make the counter thread-safe
    static ACE_Atomic_Op<ACE_Mutex,int> counter_;
};

typedef ACE_Singleton<mld_counter,ACE_Mutex>    MLD_Counter;

//================================================

/*
  A couple of handy macros to make things easier to remember.  Just
  drop 'MLD' anywhere in your class definition.
  
  Use 'MLD_COUNTER->value()' in main() to see if things are OK.  We
  don't really need a singleton since the counter itself is static and 
  thread safe but it makes the interface to mld simpler.
 */
#define MLD            mld mld_
#define MLD_COUNTER    MLD_Counter::instance()

//================================================

#endif
</PRE>
<HR WIDTH="100%">
<P>
<P>
<HR WIDTH="100%">
<CENTER>[<A HREF="..">Tutorial Index</A>] [<A HREF="page04.html">Continue
This Tutorial</A>]</CENTER>

</BODY>
</HTML>
