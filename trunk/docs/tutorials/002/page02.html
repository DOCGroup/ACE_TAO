<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.04 [en] (X11; I; Linux 2.0.32 i486) [Netscape]">
   <META NAME="Author" CONTENT="James CE Johnson">
   <META NAME="Description" CONTENT="A first step towards using ACE productively">
   <TITLE>ACE Tutorial 002</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#000FFF" VLINK="#FF0F0F">

<CENTER><B><FONT SIZE=+2>ACE Tutorial 002</FONT></B></CENTER>

<CENTER><B><FONT SIZE=+2>Creating a Better Server</FONT></B></CENTER>


<P>
<HR WIDTH="100%">

<P>Like Tutorial 1, this is also a rather small program.&nbsp; I'm going
to add a couple of new ideas along the way but to make up for it I'm also
going to simplify the acceptor a great deal.

<P>
Kirthika's Abstract:
<UL>
This is a server example made simpler due to the use of off-the-shelf 
components and classes from ACE.
<P>
Here, the Logging_Acceptor is an ACE_Acceptor class which is associated
with the Logging_Handler and the ACE_SOCK_ACCEPTOR. This will now
accept connection requests from the clients on being opened with the
reactor instance passed to it.
<P>
We also implement a signal to capture CTRL-C [ which generates SIGINT ] using ACE_SigAction and
ACE_SignalHandler. This signal can now be used to stop the reactor
from handling events.
<P>
Then, the reactor is allowed to loop infintely until it is shut down
using a ^C, after which both the reactor as well as the acceptor are
destroyed.
<P>
The Logging_Handler derives from the ACE_Svc_Handler instead of the
Event_Handler since the Svc_Handler has inbuilt SOCK_Stream and
provides all the calls needed by the reactor. The Svc_Handler has the
ability to react to events and communicate to remote tasks using the
underlying data stream passed to it.
<P>
A timer is scheduled in the reactor which does nothing but simply
display how it could be used to provide periodic processing when
needed. The ACE_TimeValue is used to set the time period. 
<P>
Also, optimisations have been  made in the form of a separate function
for 
destroying the objects used.
<P>
Thus a simpler server has now been built which successfully
demonstrates how simple a task, writing a server can become on using
the various ACE components judiciously.
</UL>
<P>We begin by looking at the <A HREF="server.cpp">main (server.cpp)</A> portion program:

<P>
<HR WIDTH="100%">
<PRE>
/*
&nbsp; As before, we need a few ACE objects as well as our Logging_Handler declaration.
&nbsp;*/
#include "ace/Acceptor.h"
#include "ace/SOCK_Acceptor.h"
#include "ace/Reactor.h"
#include "handler.h"

/*
&nbsp; We'll still use the global reactor pointer.&nbsp; There's a snappy way around this
&nbsp; that shows up in later server tutorials.
&nbsp;*/
ACE_Reactor * g_reactor;

/*
&nbsp; This was hinted at in Tutorial 1.&nbsp; Remember the hand-coded acceptor that we
&nbsp; created there?&nbsp; This template does all of that and more and better.&nbsp; If you
&nbsp; find yourself creating code that doesn't feel like a part of your application,
&nbsp; there's a good chance that ACE has a template or framework component to do
&nbsp; it for you.
&nbsp;*/
typedef ACE_Acceptor &lt; Logging_Handler, ACE_SOCK_ACCEPTOR > Logging_Acceptor;

/*
&nbsp; One of the new things will be a signal handler so that we can exit the application
&nbsp; somewhat cleanly.&nbsp; The 'finished' flag is used instead of the previous infninite
&nbsp; loop and the 'handler' will set that flag in respose to SIGINT (CTRL-C).
&nbsp;*/
static sig_atomic_t finished = 0;
extern "C" void handler (int)
{
&nbsp; finished = 1;
}

static const u_short PORT = ACE_DEFAULT_SERVER_PORT;

int main (int, char **)
{
&nbsp; // Create the reactor we'll register our event handler derivatives with.
&nbsp; g_reactor = new ACE_Reactor;

&nbsp; // Create the acceptor that will listen for client connetions
&nbsp; Logging_Acceptor peer_acceptor;

&nbsp; /*
&nbsp;&nbsp;&nbsp; Notice how similar this is to the open() call in Tutorial 1.&nbsp; I read
&nbsp;&nbsp;&nbsp; ahead when I created that one so that it would come out this way...
&nbsp;&nbsp; */
&nbsp; if (peer_acceptor.open (ACE_INET_Addr (PORT), g_reactor) == -1)
&nbsp;&nbsp;&nbsp; ACE_ERROR_RETURN ((LM_ERROR, "%p\n", "open"), -1);

&nbsp; /*
&nbsp;&nbsp;&nbsp; Here's the easiest way to respond to signals in your application.&nbsp; Simply
&nbsp;&nbsp;&nbsp; construct an ACE_Sig_Action object with a "C" function and the signal you
&nbsp;&nbsp;&nbsp; want to capture.&nbsp; As you might expect, there is also a way to register
&nbsp;&nbsp;&nbsp; signal handlers with a reactor but we take the easy-out here.
&nbsp;&nbsp; */
&nbsp; ACE_Sig_Action sa ((ACE_SignalHandler) handler, SIGINT);

&nbsp; ACE_DEBUG ((LM_DEBUG, "(%P|%t) starting up server logging daemon\n"));

&nbsp; // Perform logging service until the signal handler receives SIGINT.
&nbsp; while (!finished)
&nbsp;&nbsp;&nbsp; g_reactor->handle_events ();

&nbsp; // Close the acceptor so that no more clients will be taken in.
&nbsp; peer_acceptor.close();

&nbsp; // Free up the memory allocated for the reactor.
&nbsp; delete g_reactor;

&nbsp; ACE_DEBUG ((LM_DEBUG, "(%P|%t) shutting down server logging daemon\n"));

&nbsp; return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
template class ACE_Acceptor &lt;Logging_Handler, ACE_SOCK_ACCEPTOR>;
template class ACE_Svc_Handler&lt;ACE_SOCK_STREAM, ACE_NULL_SYNCH>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate ACE_Acceptor &lt;Logging_Handler, ACE_SOCK_ACCEPTOR>
#pragma instantiate ACE_Svc_Handler&lt;ACE_SOCK_STREAM, ACE_NULL_SYNCH>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

</PRE>


<P>
<HR WIDTH="100%">
<CENTER></CENTER>

<CENTER>[<A HREF="..">Tutorial
Index</A>] [<A HREF="page01.html">Previous
Page</A>] [<A HREF="page03.html">Continue
This Tutorial</A>]</CENTER>

</BODY>
</HTML>
