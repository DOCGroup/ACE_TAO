

class ADS_Thread_Reactor : public ACE_Reactor {
private:
	ThreadSafeList<ADS_Connection_Handler> connectionList;
	ThreadSafeList<ADS_Connection_Handler> pendingConnectionList;
	uint svcHandlerCount;
	statistics-information-variables;
public:
	ADS_Thread_Reactor(void);
	Boolean ConnectionListIsEmpty(void);		// return TRUE if connectionList has no entries
	ADS_Thread_Reactor * LocateIdleReactor(void);	// locate a reactor that isn't too busy for another connection
	void RegisterNewConnections(void);		// call register_handler on everything in pendingConnectionList
	reactor.AdjustStatistics( ulong, Time );	// accumulate some kind of "busy" indication statistics
};

ADS_Thread_Reactor(void) : () {
	svcHandlerCount = 0;
	connectionList.MakeEmpty();
}

typedef ACE_Singleton<ADS_Thread_Reactor> ADS_ReactorSingleton;		// Added 1/18

ADS_Connection_Handler is very similar to Doug's soultion but with additions.

/*
 * The open method is called by the Acceptor when a new connection is accepted.
 * It needs access to the reactor which is handling the acceptor.  That may be a problem.
 * It tries to locate a thread-pool reactor to handle the new connection (itself).
 * If none can be found, it will activate itself to become a new thread-pool reactor loop.
 * If one is found, the connection places itself in that thread-pool reactor's list of pending connections.
 */
open(...) {
	// ADS_Thread_Reactor * r = this->reactor();					// Replaced 1/18
	ADS_Thread_Reactor * r = ADS_ReactorSingleton::instance();	// Added 1/18
	ADS_Thread_Reactor * tr;

	if( r->ConnectionListIsEmpty() || !(tr = r->LocateIdleReactor()) ) {
		this->activate();
	} else {
		/*
		 * Tell the acceptor's reactor to add us to the list of connection_handlers
		 * which are executing a reactor loop and willing to handle more connections.
 		 */
		r->AddToConnectionList(this);
		tr->Enque(this);
	}
}



svc(...) {
	ADS_Thread_Reactor		reactor;
	/*
	 * We have to create a new connection object to handle the actual connection
	 * because we are going to become the reactor's event loop.  If we were to
	 * register ourselves with the reactor then we would delete ourself when the
	 * connection ended.  That would be very bad because when the thread invoking
	 * svc() exits, it will call the svc() object's close() method (us, in other words).  Now
	 * you're calling a member function of a deleted object.  Very bad.
	 * 	
	 * To avoid all of that, we create a new connection object initialized with ourselves
	 * and feed it to the reactor to deal with the data stream.  It can safely delete itself
	 * when the connection closes and we can delete ourself when the thread exits and
	 * all will be just fine.
 	 */
	ADS_Connection_Handler	connection(this);
	
	ulong loopCount = 0;
	
	reactor.register_handler( connection, ... );
	
	while( reactor.HandleCount() > 0 )
	{
		Time tStart = now();		// Get the current time
		
		reactor.handle_events( some-timeout? );	// typical reactor loop stuff
		
		reactor.RegisterNewConnections();
		
		reactor.AdjustStatistics( loopCount++, now - tStart );
	}
}



Q:  Does a Svc_Handler have access to the reactor it's handler is registered with?

How about using a reactor singleton for the acceptor.  Then, the other threads have 
access to it by using ADS_ReactorSingleton::instance().  When the acceptor object is
created it would be registered with the singleton.  We need a wrapper class that hides
the details of acceptor creation, configuration and registration anyway.  (On the 
client side, we need a wrapper for connection creation, etc... as well.)



When examining the ThreadSafeList<> objects, we should use a ReadersWriter
lock to speed things up.  We only need a mutex when writting new data to them.


