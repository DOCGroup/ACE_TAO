<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (WinNT; I) [Netscape]">
   <title>ACE Software Development Guidelines</title>
<!-- $Id$ -->
<link rev=made href="mailto:levine@cs.wustl.edu">
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#000FFF" vlink="#FF0F0F">

<hr>
<h3>
ACE Software Development Guidelines</h3>

<ul>
<li>
<b>General</b></li>

<br>&nbsp;
<p>&nbsp;
<ul>
<li>
Every text file must end with a newline.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Use spaces instead of tabs, except in Makefiles. Emacs users can add this
to their <b>.emacs</b>:</li>

<pre>(setq-default indent-tabs-mode nil)</pre>
Microsoft Visual C++ users should do the following:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Choose:&nbsp; Tools -- Options -- Tabs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Then Set:&nbsp; "Tab size" to 8 and "Indent size" to 2, and
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; indent using spaces.
</pre>

<li>
If you add a comment to code that is directed to, or requires the attention
of, a particular individual: <b>SEND EMAIL TO THAT INDIVIDUAL!</b>.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Every program should have a ``usage'' message. It should be printed out
if erroneous command line arguments, or a <b><tt>-?</tt></b> command line
argument, are provided to the program.</li>

<br>&nbsp;
<p>&nbsp;
<li>
The program <b><tt>main</tt></b> function must always be declared with
arguments, <i>e.g.</i>,</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main (int argc, char *argv[])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [...]

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre>
If you don't use the <tt>argc</tt> and/or <tt>argv</tt> arguments, don't
declare them, <i>e.g.</i>,
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; main (int, char *[])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [...]

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre>
Please declare the second argument as <tt>char *[]</tt> instead of <tt>char
**</tt>. Ancient versions of MSC complained about <tt>char **</tt>; I've
never seen a C++ compiler complain about <tt>char *[]</tt>.
<p>&nbsp;<tt>main</tt> must also return 0 on successful termination, and
non-zero otherwise.
<br>&nbsp;
<br>&nbsp;
<li>
Avoid use of floating point types (float and double) and operations unless
absolutely necessary. Not all ACE platforms support them. Therefore, wherever
they are used, ACE_LACKS_FLOATING_POINT conditional code must be also be
used.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<li>
<b>Code Documentation</b></li>

<br>&nbsp;
<p>&nbsp;
<ul>
<li>
Use comments and whitespace (:-) liberally. Comments should consist of
complete sentences, <i>i.e.</i>, start with a capital letter and end with
a period.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Insert a CVS/RCS keyword string at the top of every source file, Makefile,
config file, <i>etc</i>. For C++ files, it is:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // $<!-- -->Id$
</pre>
It is not necessary to fill in the fields of the keyword string, or modify
them when you edit a file that already has one. CVS does that automatically
when you checkout or update the file.
<p>&nbsp;To insert that string at the top of a file:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; perl -pi -e \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'if (! $o) {printf "// \$<!-- -->Id\$\n\n";}; $o = 1;' <i>file
</i></pre>

<li>
Comments, especially in header files, must follow the <a href="http://www.dscpl.com.au">OSE</a>
Tools format requirements. Please see the ``Classinfo Tools'' section of
the <a href="http://www.dscpl.com.au">OSE</a> ``Tools Manual'' for these
requirements.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<li>
<b>Preprocessor</b></li>

<br>&nbsp;
<p>&nbsp;
<ul>
<li>
Never #include standard headers directly, except in a few specific ACE
files, <i>e.g.</i>, OS.h and stdcpp.h. Let those files #include the correct
headers. If you do not do this, your code will not compile with the Standard
C++ Library.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Always follow a preprocessor <b><tt>#endif</tt></b>with a <b><tt>/* */</tt></b>
C-style comment. It should correspond to the condition in the matching
<b><tt>#if</tt></b> directive. For example,</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if defined (ACE_HAS_THREADS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # if defined (ACE_HAS_STHREADS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; include /**/ &lt;synch.h>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; include /**/ &lt;thread.h>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; define ACE_SCOPE_PROCESS P_PID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; define ACE_SCOPE_LWP P_LWPID
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; define ACE_SCOPE_THREAD (ACE_SCOPE_LWP + 1)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; define ACE_SCOPE_PROCESS 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; define ACE_SCOPE_LWP 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp; define ACE_SCOPE_THREAD 2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # endif /* ACE_HAS_STHREADS */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* ACE_HAS_THREADS */
</pre>

<li>
Always insert a <b><tt>/**/</tt></b> between an <b><tt>#include</tt></b>
and <b><tt>filename</tt></b>, as shown in the above example. This avoids
dependency problems with Visual C++.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Be very careful with names of macros and enum values. It's always best
to prefix them with something like <tt>ACE_</tt> or <tt>TAO_</tt>. There
are too many system headers out there that #define <tt>OK</tt>, <tt>SUCCESS</tt>,
<tt>ERROR</tt>, and so on.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Try to centralize <tt>#ifdefs</tt> with <tt>typedefs</tt> and <tt>#defines</tt>.
For example, use this:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if defined(ACE_PSOS)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef long ACE_NETIF_TYPE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # define ACE_DEFAULT_NETIF 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #else&nbsp; /* ! ACE_PSOS */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; typedef const ASYS_TCHAR* ACE_NETIF_TYPE;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # define ACE_DEFAULT_NETIF ASYS_TEXT("le0")
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* ! ACE_PSOS */
</pre>
instead of:
<p>#if defined (ACE_PSOS) // pSOS supports numbers, not names for network
interfaces long net_if, #else /* ! ACE_PSOS */ const ASYS_TCHAR *net_if,
#endif /* ! ACE_PSOS */
<li>
Protect header files against multiple inclusion with this construct:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #ifndef FOO_H
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FOO_H

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [contents of header file]

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* FOO_H */
</pre>
This exact construct (note the <tt>#ifndef</tt>) is optimized by many compilers
such they only open the file once per compilation unit. Thanks to Eric
C. Newton &lt;ecn@smart.net> for pointing that out.
<p>&nbsp;If the header <tt>#includes</tt> an ACE library header, then it's
a good idea to include the <tt>#pragma once</tt> directive:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #ifndef FOO_H
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FOO_H

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "ace/ACE.h"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if !defined (ACE_LACKS_PRAGMA_ONCE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # pragma once
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* ACE_LACKS_PRAGMA_ONCE */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [contents of header file]

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* FOO_H */
</pre>
<tt>#pragma once</tt> must be protected, because some compilers complain
about it. The protection depends on <tt>ACE_LACKS_PRAGMA_ONCE</tt>, which
is defined in some ACE config headers. Therefore, the protected <tt>#pragma
once</tt> construct should only be used after an <tt>#include</tt> of an
ACE library header. Note that many compilers enable the optimization if
the <tt>#ifndef</tt> protection construct is used, so for them, <tt>#pragma
once</tt> is superfluous.
<p>&nbsp;<b>No</b> code can appear after the final <tt>#endif</tt> for
the optimization to be effective and correct.
<br>&nbsp;
<br>&nbsp;
<p>Files that contain parametric classes should follow this style:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #ifndef FOO_T_H
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FOO_T_H

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "ace/ACE.h"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if !defined (ACE_LACKS_PRAGMA_ONCE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # pragma once
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* ACE_LACKS_PRAGMA_ONCE */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Put your template declarations here...

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if defined (__ACE_INLINE__)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "Foo_T.i"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* __ACE_INLINE__ */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if defined (ACE_TEMPLATES_REQUIRE_SOURCE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "Foo_T.cpp"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* ACE_TEMPLATES_REQUIRE_SOURCE */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if defined (ACE_TEMPLATES_REQUIRE_PRAGMA)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #pragma implementation "Foo_T.cpp"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* ACE_TEMPLATES_REQUIRE_PRAGMA */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* FOO_T_H */</pre>
Notice that some compilers need to see the code of the template, hence
the <tt>.cpp</tt> file must be included from the header file.
<p>To avoid multiple inclusions of the <tt>.cpp</tt> file it should also
be protected as in:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #ifndef FOO_T_C
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FOO_T_C

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "Foo_T.h"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if !defined (ACE_LACKS_PRAGMA_ONCE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # pragma once
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* ACE_LACKS_PRAGMA_ONCE */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if !defined (__ACE_INLINE__)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "ace/Active_Map_Manager_T.i"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* __ACE_INLINE__ */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_RCSID(lib, Foo_T, "$<!-- -->Id$")

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // put your template code here

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* FOO_T_H */</pre>
Finally you may want to include the template header file from a non-template
header file (check <tt>$ACE_ROOT/ace/Synch.h</tt>); in such a case the
template header should be included <b>after</b> the inline function definitions,
as in:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #ifndef FOO_H
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define FOO_H

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "ace/ACE.h"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if !defined (ACE_LACKS_PRAGMA_ONCE)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # pragma once
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* ACE_LACKS_PRAGMA_ONCE */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Put your non-template declarations here...

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if defined (__ACE_INLINE__)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "Foo.i"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* __ACE_INLINE__ */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "Foo_T.h"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* FOO_H */</pre>
</ul>

<li>
<b>C++ Syntax and Constructs</b></li>

<br>&nbsp;
<p>&nbsp;
<ul>
<li>
<b><tt>for</tt></b> loops should look like:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; Options::instance ()->spawn_count (); ++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; spawn ();
</pre>
Though, I prefer to always wrap the body of the loop in braces, to avoid
surprises when other code or debugging statements are added, and to maintain
sanity when the body consists of a macro, such as an ACE_ASSERT without
a trailing semicolon:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t i = 0; i &lt; Options::instance ()->spawn_count (); ++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_ASSERT (spawn () == 0;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre>
Similarly, <b><tt>if</tt></b> statements should have a space after the
``<b>if</b>'', and no spaces just after the opening parenthesis and just
before the closing parenthesis.
<br>&nbsp;
<br>&nbsp;
<li>
If a loop index is used after the body of the loop, it <b>must</b> be declared
before the loop. For example,</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t i = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (size_t j = 0; file_name [j] != '\0'; ++i, ++j)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (file_name [j] == '\\' &amp;&amp; file_name [j + 1] == '\\')
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++j;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name [i] = file_name [j];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Terminate this string.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; file_name [i] = '\0';
</pre>

<li>
Prefix operators are sometimes more efficient than postfix operators. Therefore,
they are preferred over their postfix counterparts where the expression
value is not used.</li>

<p><br>&nbsp;Therefore, use this idiom for iterators, with prefix operator
on the loop index:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_Ordered_MultiSet&lt;int> set;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_Ordered_MultiSet_Iterator&lt;int> iter(set);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = -10; i &lt; 10; ++i)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set.insert (2 * i + 1);

</pre>
rather than the postfix operator:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = -10; i &lt; 10; i++)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set.insert (2 * i + 1);
</pre>

<li>
When a class provides operator==, it must also provide operator!=. Also,
both these operators must be const.</li>

<li>
Avoid unnecessary parenthesis. We're not writing Lisp :-)</li>

<br>&nbsp;
<p>&nbsp;
<li>
Put inline member functions in a <b><tt>.i</tt></b> file. That file is
conditionally included by both the <b><tt>.h</tt></b> file, for example:</li>

<br>&nbsp;
<p>&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ACE_Export ACE_High_Res_Timer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [...]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if defined (__ACE_INLINE__)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "ace/High_Res_Timer.i"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* __ACE_INLINE__ */
</pre>
and <b><tt>.cpp</tt></b> file:
<br>&nbsp;
<br>&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #define ACE_BUILD_DLL
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "ace/High_Res_Timer.h"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #if !defined (__ACE_INLINE__)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "ace/High_Res_Timer.i"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #endif /* __ACE_INLINE__ */

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_ALLOC_HOOK_DEFINE(ACE_High_Res_Timer)
</pre>
<b>NOTE:</b> It is very important to ensure than an inline function will
not be used before its definition is seen. Therefore, the inline functions
in the .i file should be arranged properly. Some compilers, such as <tt>g++</tt>
with the <tt>-Wall</tt> option, will issue warnings for violations.
<br>&nbsp;
<br>&nbsp;
<li>
<tt>ACE_Export</tt> must be inserted between the <tt>class</tt> keyword
and class name for all classes that are exported from libraries, as shown
in the example above. <b>However</b>, do <b>not</b> use <tt>ACE_Export</tt>
for template classes!</li>

<br>&nbsp;
<p>&nbsp;
<li>
Mutators and accessors should be of this form:</li>

<br>&nbsp;
<p>&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void object_addr (const ACE_INET_Addr &amp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Sets &lt;object_addr_> cache from &lt;host> and &lt;port>.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_INET_Addr &amp;object_addr (void);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Returns the &lt;ACE_INET_Addr> for this profile.
</pre>
instead of the ``set_'' and ``get_'' form.
<br>&nbsp;
<br>&nbsp;
<li>
Never use <b><tt>delete</tt></b> to deallocate memory that was allocated
with <b><tt>malloc</tt></b>. Similarly, never associate <b><tt>free</tt></b>
with <b><tt>new</tt></b>. <b><tt>ACE_NEW</tt></b> or <b><tt>ACE_NEW_RETURN</tt></b>
should be used to allocate memory, and <b><tt>delete</tt></b> should be
used to deallocate it. And be careful to use the correct form, <b><tt>delete</tt></b>
or <b><tt>delete []</tt></b> to correspond to the allocation.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Don't check for a pointer being 0 before deleting it. It's always safe
to delete a 0 pointer. If the pointer is visible outside the local scope,
it's often a good idea to 0 it _after_ deleting it. Note, the same argument
applies to free().</li>

<br>&nbsp;
<p>&nbsp;
<li>
Always use <b><tt>ACE_NEW</tt></b> or <b><tt>ACE_NEW_RETURN</tt></b> to
allocate memory, because they check for successful allocation and set errno
appropriately if it fails.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Never compare or assign a pointer value with <b>NULL</b>; use <b>0</b>
instead. The language allows any pointer to be compared or assigned with
<b>0</b>. The definition of <b>NULL</b> is implementation dependent, so
it is difficult to use portably without casting.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Never cast a pointer to or from an <b><tt>int</tt></b>. On all currently
supported ACE platforms, it is safe to cast a pointer to or from a <b><tt>long</tt></b>.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Be very careful when selecting an integer type that must be a certain size,
<i>e.g.</i>, 4 bytes. <b>long</b> is not 4 bytes on all platforms; it is
8 bytes on many 64-bit machines. ACE_UINT32 is always 4 bytes, and ACE_UINT64
is always 8 bytes.</li>

<br>&nbsp;
<p>&nbsp;
<li>
If a class has any virtual functions, and its destructor is declared explicitly
in the class, then the destructor should <b>always</b> be virtual as well.
And to support compiler activities such as generation of virtual tables
and, in some cases, template instantiation, the virtual destructor should
<b>not be inline</b>. (Actually, any non-pure virtual function could be
made non-inline for this purpose. But, for convenience, if its performance
is not critical, it is usually easiest just to make the virtual destructor
non-inline.)</li>

<br>&nbsp;
<p>&nbsp;
<li>
Constructor initializers must appear in the same order as the data members
are declared in the class header. This avoids subtle errors, because initialization
takes place in the order of member declaration.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Initialization is usually cleaner than assignment, especially in a conditional.
So, instead of writing code like this:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssize_t n_bytes;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Send multicast of one byte, enough to wake up server.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((n_bytes = multicast.send ((char *) &amp;reply_port,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof reply_port)) == -1)
</pre>
Write it like this:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ssize_t n_bytes = multicast.send ((char *) &amp;reply_port,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sizeof reply_port)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Send multicast of one byte, enough to wake up server.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (n_bytes == -1)
</pre>
But, beware if the initialization is of a static variable. A static variable
is only initialized the first time its declaration is seen. Of course,
we should avoid using static variables at all.
<br>&nbsp;
<br>&nbsp;
<li>
It is usually clearer to write conditionals that have both branches without
a negated condition. For example,</li>

<br>&nbsp;
<p>&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (test)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true branch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // false branch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre>
is preferred over:
<br>&nbsp;
<br>&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (! test)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // false test branch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // true test branch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre>

<li>
If a cast is necessary, avoid use of function-style casts, <i>e.g.</i>,
<tt>int (foo)</tt>. Instead, use one of the ACE cast macros:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return ACE_static_cast(size_t, this->count_) > that->size_;
</pre>
The general usage guidelines for the four styles of casts are:
<br>&nbsp;
<br>&nbsp;
<ul>
<li>
<b>ACE_const_cast</b>: use to cast away constness, or volatile-ness.</li>

<br>&nbsp;
<p>&nbsp;
<li>
<b>ACE_static_cast</b>: use to cast between compatible types, such as downcasting
a pointer or narrowing an integer.</li>

<br>&nbsp;
<p>&nbsp;
<li>
<b>ACE_reinterpret_cast</b>: use only when ACE_static_cast is not suitable.</li>

<br>&nbsp;
<p>&nbsp;
<li>
<b>ACE_dynamic_cast</b>: avoid, unless you really want to type check at
run-time.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<li>
In general, if instances of a class should not be copied, then a private
copy constructor and assignment operator should be declared for the class,
but not implemented. For example:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Disallow copying by not implementing the following . . .
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_Object_Manager (const ACE_Object_Manager &amp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_Object_Manager &amp;operator= (const ACE_Object_Manager &amp;);
</pre>
If the class is a template class, then the <tt>ACE_UNIMPLEMENTED_FUNC</tt>
macro should be used:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // = Disallow copying...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_UNIMPLEMENTED_FUNC (ACE_TSS (const ACE_TSS&lt;TYPE> &amp;))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_UNIMPLEMENTED_FUNC (void operator= (const ACE_TSS&lt;TYPE> &amp;))
</pre>
<tt>ACE_UNIMPLEMENTED_FUNC</tt> can be used with non-template classes as
well. Though for consistency and maximum safety, it should be avoided for
non-template classes.
<br>&nbsp;
<br>&nbsp;
<li>
Never use <tt>bool</tt>, <tt>BOOL</tt>, or similar types. (CORBA::Boolean
is acceptable). Use <tt>int</tt> or <tt>u_int</tt> instead for boolean
types.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Functions should always return -1 to indicate failure, and 0 or greater
to indicate success.</li>

<br>&nbsp;
<p>&nbsp;
<br>&nbsp;
<p>Separate the code of your templates from the code for non-parametric
classes: some compilers get confused when template and non-template code
is mixed in the same file.</ul>

<li>
<b>I/O</b></li>

<br>&nbsp;
<p>&nbsp;
<ul>
<li>
Use <b><tt>ACE_DEBUG</tt></b> for printouts, and <b><tt>ACE_OS::scanf/fprintf
()</tt></b> for file I/O. Avoid using iostreams because of implementation
differences across platforms.</li>

<br>&nbsp;
<p>&nbsp;
<li>
After attempting to open an existing file, always check for success. Take
appropriate action if the open failed.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<li>
<b>UNICODE conformity</b></li>

<br>&nbsp;
<p>&nbsp;
<ul>
<li>
Define strings as <b><tt>ASYS_TCHAR</tt></b> if they need to be passed
into system API. It expands to <tt>wchar_t</tt> only when <tt>ACE_HAS_MOSTLY_UNICODE_APIS</tt>
is defined.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Use <b><tt>ASYS_TEXT</tt></b> and <b><tt>ASYS_WIDE_STRING</tt></b> for
format strings and other string arguments passed to <tt>ACE_DEBUG</tt>
or <tt>ACE_ERROR</tt>. For example,</li>

<br>&nbsp;
<p>&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_FOO::ace_bar (int err, ASYS_TCHAR *astr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_TRACE ("ACE_FOO::ace_bar");

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_DEBUG ((LM_DEBUG, ASYS_TEXT ("From ACE_FOO::ace_bar")));

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (err)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_ERROR ((LM_ERROR,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ASYS_TEXT ("(%P) Printing this string %s\n"),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; astr));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre>
This is because ACE also support platforms which use UNICODE in most of
their APIs. On these platforms, ACE also uses UNICODE as its system string
type.
<br>&nbsp;
<br>&nbsp;
<li>
<b><tt>ACE_TRACE</tt></b> handles conversion between char strings and UNICODE
strings automatically.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Other helper macros include <b><tt>ASYS_MULTIBYTE_STRING</tt></b> and <b><tt>ASYS_ONLY_MULTIBYTE_STRING</tt></b>.
See the end of <a href="../ace/OS.h">OS.h</a> for more details.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<li>
<b>Exceptions</b></li>

<br>&nbsp;
<p>&nbsp;
<ul>
<li>
There are many ways of throwing and catching exceptions. The code below
gives several examples. Note that each method has different semantics and
costs. Whenever possible, use the first approach.</li>

<br>&nbsp;
<p>&nbsp;
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include "iostream.h"

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class exe_foo
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exe_foo (int data) : data_ (data)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { cerr &lt;&lt; "constructor of exception called" &lt;&lt; endl; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ~exe_foo ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { cerr &lt;&lt; "destructor of exception called" &lt;&lt; endl; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exe_foo (const exe_foo&amp; foo) : data_ (foo.data_)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { cerr &lt;&lt; "copy constructor of exception called" &lt;&lt; endl; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int data_;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; good (int a)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw exe_foo (a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bad (int a)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exe_foo foo (a);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw foo;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int main ()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "First exception" &lt;&lt; endl &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; good (0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (exe_foo &amp;foo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "exception caught: " &lt;&lt; foo.data_ &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Second exception" &lt;&lt; endl &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; good (0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (exe_foo foo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "exception caught: " &lt;&lt; foo.data_ &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Third exception" &lt;&lt; endl &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bad (1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (exe_foo &amp;foo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "exception caught: " &lt;&lt; foo.data_ &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; endl &lt;&lt; "Fourth exception" &lt;&lt; endl &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bad (1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; catch (exe_foo foo)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cerr &lt;&lt; "exception caught: " &lt;&lt; foo.data_ &lt;&lt; endl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre>
Output is:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; First exception

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception caught: 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destructor of exception called

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Second exception

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy constructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception caught: 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destructor of exception called

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Third exception

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy constructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception caught: 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destructor of exception called

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Fourth exception

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; constructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy constructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; copy constructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exception caught: 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destructor of exception called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; destructor of exception called

</pre>
</ul>
</ul>

<hr>
<h3>
<a href="http://www.cs.wustl.edu/~schmidt/ACE-overview.html">ACE</a> Usage
Guidelines</h3>

<ul>
<li>
Always use <b><tt>ACE_OS</tt></b> (static) member functions instead of
bare OS system calls.</li>

<br>&nbsp;
<p>&nbsp;
<li>
As a general rule, the only functions that should go into the <b><tt>ACE_OS</tt></b>
class are ones that have direct equivalents on some OS platform. Functions
that are extensions should go in the <b><tt>ACE</tt></b> class.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Use the <b><tt>ACE_SYNCH_MUTEX</tt></b> macro, instead of using one of
the specific mutexes, such as <b><tt>ACE_Thread_Mutex</tt></b>. This provides
portability between threaded and non-threaded platforms.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Avoid creating a static instance of user-defined (class) type. Instead,
either create it as an <b><tt>ACE_Singleton</tt></b>, <b><tt>ACE_TSS_Singleton</tt></b>,
or as an <b><tt>ACE_Cleanup</tt></b> object. See the <b>ACE</b> <tt><a href="../ace/Singleton.h">Singleton.h</a></tt>,
<tt><a href="../ace/Object_Manager.h">Object_Manager.h</a></tt>, and <tt><a href="../ace/Managed_Object.h">Managed_Object.h</a></tt>
header files for more information.</li>

<p><br>&nbsp;Static instances of built-in types, such as <b><tt>int</tt></b>
or any pointer type, are fine.
<p>&nbsp;Construction of static instance of a user-defined type should
<i>never</i> spawn threads. Because order of construction of statics across
files is not defined by the language, it is usually assumed that only one
thread exists during static construction. This allows statics suchs as
locks to be safely created. We do not want to violate this assumption.
<br>&nbsp;
<br>&nbsp;
<li>
Do not use run-time type identification (RTTI). Some platforms do not support
it.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Do not use C++ exception handling directly. Some platforms do not support
it. And, it can impose an execution speed penalty. Instead use the TAO/ACE
try/catch macros.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Because ACE does not use exception handling, dealing with failures requires
a bit of care. This is especially true in constructors. Consider the following
approach:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_NEW_RETURN (this->name_space_, LOCAL_NAME_SPACE, -1);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (ACE_LOG_MSG->op_status () != 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ....
</pre>
This snip of code is from <tt><a href="../ace/Naming_Context.cpp">ACE_Naming_Context</a></tt>.
All failed constructors in ACE (should) call ACE_ERROR. This sets the thread
specific <b>op_status</b>, which can be checked by the caller. This mechanism
allows the caller to check for a failed constructor without the requiring
the constructor to throw exceptions.
<br>&nbsp;
<br>&nbsp;
<li>
Avoid using the C++ Standard Template Library (STL) in our applications.
Some platforms do not support it yet.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Be <i>very</i> careful with <tt>ACE_ASSERT</tt>. It must only be used to
check values; it may never be used to wrap a function call, or contain
any other side effect. That's because the statement will disappear when
ACE_NDEBUG is enabled. For example, this code is BAD:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_ASSERT (this->next (retv) != 0);&nbsp; // BAD CODE!
</pre>
Instead, the above should be coded this way:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result = this->next (retv);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_ASSERT (result != 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_UNUSED_ARG (result);
</pre>

<li>
Never put side effects in <tt>ACE_DEBUG</tt> code:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_DEBUG ((LM_DEBUG,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "handling signal: %d iterations left\n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; --this->iterations_));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // BAD CODE!
</pre>
Note that this won't work correctly if <tt>ACE_NDEBUG</tt> is defined,
for the same reason that having side-effects in <tt>ACE_ASSERT</tt>s won't
work either, <i>i.e.</i>, because the code is removed.
<br>&nbsp;
<br>&nbsp;
<li>
Immediately after opening a temporary file, unlink it. For example:</li>

<pre>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_HANDLE h = open the file (filename);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ACE_OS::unlink (filename);
</tt></pre>
This avoids leaving the temporary file even if the program crashes.
<br>&nbsp;
<br>&nbsp;</ul>

<hr>
<h3>
<a href="http://www.cs.wustl.edu/~schmidt/ACE-overview.html">Other ACE</a>
and <a href="http://www.cs.wustl.edu/~schmidt/TAO-overview.html">TAO</a>
Guidelines</h3>

<ul>
<li>
Never add copyrighted, confidential, or otherwise restricted code to the
ACE or TAO distributions without written permission from the owner.</li>

<li>
A source code filename should never be a (case-insenstitive) duplicate
of another, even if it is in a different directory (or project). Some compilers
will break if this is so.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<hr>
<h3>
<a href="http://www.cs.wustl.edu/~levine/CVS.html">CVS</a> Usage Guidelines</h3>

<ul>
<li>
Always make sure that a change builds and executes correctly on at least
one platform before checking it into the CVS repository.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<hr>
<h3>
Script Guidelines</h3>

<ul>
<li>
In general, it's best to write scripts in Perl. It's OK to use Bourne shell.
Never, never, never use csh, ksh, bash, or any other kind of shell.</li>

<br>&nbsp;
<p>&nbsp;
<li>
Follow the Perl style guide guide as closely as possible. <tt>man perlstyle</tt>
to view it.</li>

<li>
Don't specify a hard-coded path to Perl itself. Use the following code
at the top of the script to pick up perl from the users <tt>PATH</tt>:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eval '(exit $?0)' &amp;&amp; eval 'exec perl -S $0 ${1+"$@"}'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp; eval 'exec perl -S $0 $argv:q'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if 0;
</pre>

<li>
Never, never, never start the first line of a script with ``#'', unless
the first line is ``#! /bin/sh''. With just ``#'', t/csh users will spawn
a new shell. That will cause their <tt>.[t]cshrc</tt> to be processed,
possibly clobbering a necessary part of their environment.</li>

<br>&nbsp;
<p>&nbsp;
<li>
If your Perl script relies on features only available in newer versions
of Perl, include the a statement similar to the following:</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; require 5.003;
</pre>

<li>
Don't depend on <b><tt>.</tt></b> being in the user's path. If the script
spawns another executable that is supposed to be in the current directory,
be sure the prefix its filename with <b><tt>.</tt></b>.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<hr>
<h3>
Software Engineering Guidelines</h3>

<ul>
<li>
<b>Advise</b>: Keep other developers informed of problems and progress.</li>

<br>&nbsp;
<p>&nbsp;
<li>
<b>Authorize</b>: We have contractual obligations to not unilaterally change
interfaces. If you need to change or remove an interface, get an OK.</li>

<br>&nbsp;
<p>&nbsp;
<li>
<b>Minimize</b> risk: Test all changes. Solicit review of changes.</li>

<br>&nbsp;
<p>&nbsp;
<li>
<b>Revise</b> only when necessary: Every change has risk, so avoid making
any change unless there is a good reason for it.</li>

<br>&nbsp;
<p>&nbsp;
<li>
<b>Normalize</b>: Factor out commonality. For example, maintain a data
value in only one place.</li>

<br>&nbsp;
<p>&nbsp;
<li>
<b>Synthesize</b>: Build stubs and scaffolding early to simulate the complete
system. Maintain a checked-in version of the system that cleanly builds
and tests at all times.</li>

<br>&nbsp;
<p>&nbsp;</ul>

<hr>
<h3>
<a href="http://www.cs.wustl.edu/~schmidt/rules.html">ACE Design Rules</a></h3>

<hr>
<p><font size=-1>Last modified&nbsp;<!--#echo var="LAST_MODIFIED" -->.</font>
<br>&nbsp;
<br>&nbsp;
</body>
</html>
