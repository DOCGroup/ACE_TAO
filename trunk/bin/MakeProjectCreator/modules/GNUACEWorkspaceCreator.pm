package GNUACEWorkspaceCreator;

# ************************************************************
# Description   : A GNU Workspace (GNUmakefile) creator for ACE
# Author        : Chad Elliott
# Create Date   : 5/13/2002
# ************************************************************

# ************************************************************
# Pragmas
# ************************************************************

use strict;
use File::Basename;

use GNUACEProjectCreator;
use WorkspaceCreator;

use vars qw(@ISA);
@ISA = qw(WorkspaceCreator);

# ************************************************************
# Data Section
# ************************************************************

my(@targets)  = ('install', 'deinstall', 'clean', 'realclean',
                 'depend', 'idl_stubs',
                );

# ************************************************************
# Subroutine Section
# ************************************************************

sub generate_implicit_project_dependencies {
  #my($self) = shift;
  return 1;
}


sub workspace_file_name {
  my($self) = shift;
  return $self->get_modified_workspace_name('GNUmakefile', '');
}


sub workspace_per_project {
  #my($self) = shift;
  return 1;
}


sub pre_workspace {
  my($self) = shift;
  my($fh)   = shift;
  my($crlf) = $self->crlf();

  print $fh "#----------------------------------------------------------------------------$crlf" .
            "#       GNU ACE Workspace$crlf" .
            "#$crlf" .
            "# \@file GNUmakefile$crlf" .
            "#$crlf" .
            "# \$Id\$$crlf" .
            "#$crlf" .
            "# This file was automatically generated by MPC.  Any changes made directly to$crlf" .
            "# this file will be lost the next time it is generated.$crlf" .
            "#$crlf" .
            "#----------------------------------------------------------------------------$crlf" .
            $crlf;
}


sub write_comps {
  my($self)     = shift;
  my($fh)       = shift;
  my($crlf)     = $self->crlf();
  my($projects) = $self->get_projects();
  my(%targnum)  = ();
  my($pjs)      = $self->get_project_info();
  my(@list)     = $self->number_target_deps($projects, $pjs, \%targnum);

  ## Print out the info for using -k
  print $fh $crlf .
            "MAKE_OPTIONS=\$(shell echo \$(MAKEFLAGS) | sed 's/--unix *//; s/ .*//')$crlf" .
            "ifeq (\$(findstring k,\$(MAKE_OPTIONS)),k)$crlf" .
            "  KEEP_GOING = 1$crlf" .
            "else$crlf" .
            "  KEEP_GOING = 0$crlf" .
            "endif$crlf";

  ## Print out the "all" target
  print $fh $crlf . 'all:';
  foreach my $project (@list) {
    print $fh " $$pjs{$project}->[0]";
  }

  ## Print out all other targets here
  print $fh "$crlf$crlf@targets:$crlf";
  foreach my $project (@list) {
    print $fh "\t-\@\$(MAKE) -f " . basename($project) . ' -C ' .
              dirname($project) . " \$(\@);$crlf";
  }

  ## Print out each target separately
  foreach my $project (@list) {
    print $fh $crlf . $$pjs{$project}->[0] . ':';
    if (defined $targnum{$project}) {
      foreach my $number (@{$targnum{$project}}) {
        print $fh " $$pjs{$list[$number]}->[0]";
      }
    }
    my($cmd) = "\@\$(MAKE) -f " . basename($project) . ' -C ' . dirname($project) . $crlf;
    print $fh $crlf .
              "ifeq (\$(KEEP_GOING),1)$crlf" .
              "\t-$cmd" .
              "else$crlf" .
              "\t$cmd" .
              "endif$crlf";
  }

  ## Print out the reverseclean target
  {
    print $fh $crlf . 'reverseclean:' . $crlf;
    
    foreach my $project (reverse @list) {
      print $fh "\t-\@\$(MAKE) -f " . basename($project) . ' -C ' .
                dirname($project) . " realclean$crlf";
    }
  }

  ## Print out the project_name_list target
  print $fh $crlf . "project_name_list:$crlf";
  foreach my $project (sort @list) {
    print $fh "\t\@echo $$pjs{$project}->[0]$crlf";
  }
}



1;
