// $Id$

// ============================================================================
//
// = LIBRARY
//    TAO/utils/IOR-parser
//
// = FILENAME
//    ior-handler.h
//
// = DESCRIPTION
//    Provides the definition of a class that parses real (valid) IORs.
//
// = AUTHORS
//    Priya Narasimhan <priya@lambda.ece.ucsb.edu>
//
// ============================================================================

#if !defined (__IORPARSER_H__)
#define __IORPARSER_H__

#include "ace/OS.h"

// @@ Priya, are these still required?
// Maximum length of either the type_id, the ProfileBody or the
// object_key fields. Tentatively assigned.
#define MAX_IOR_FIELD_LEN   200
#define MAX_TYPE_ID_LEN     100

// These are CDR-encoded sequences of hexChars (note, not octets) that
// are useful in creating IORs.
#define NULL_HEXCHARS       "00000000"
#define NUM_TAG_PROFS       "0001"
#define IIOP_VERSION        "0001"

struct IOR
{
  // = TITLE
  //     This is the useful information obtained from parsing an IOR.
  //
  // = DESCRIPTION
  //     This structure assumes that the profile_id is
  //     TAG_INTERNET_IOP and that there is only one TaggedProfile in 
  //     the IOR.
  u_long typeIdLen;
  // The length of the type_id field of the IOR.

  char typeId[MAX_TYPE_ID_LEN];
  // The string in the type_id field of the IOR.

  char idlInterface[MAX_TYPE_ID_LEN];
  // The IDL interface of the server that published the IOR (can be
  // extracted from the type_id field).

  u_long profileBodyLen;
  // The lenght of the body of the profile field of the IOR.

  u_long hostLen;
  // The length of the hostname embedded in the IOR.

  char HostName[MAXHOSTNAMELEN];
  // The server's hostname embedded in the IOR.

  u_long portNum;
  // The server's port number embedded in the IOR.

  u_long objectKeyLen;
  // The length of the object_key field of the IOR.

  // @@ Priya, can you please change this so that it's not a magic
  // number?!
  char objectKey[100];
  // The object_key field of the IOR.
};

class IorHandler
{
  // = TITLE 
  //     This is the class that takes in a real (valid) IOR and
  //     parses it.
  //
  // = DESCRIPTION
  //     This class prints out the useful information in the
  //     IORs generated by VisiBroker, Orbix and TAO   
public:
  IorHandler (void);
  // Constructor.

  void prettyPrintIOR (IOR thisIor);
  // Prints out additional detailed information in the IOR.

  void interpretIor (char *thisIor, IOR *thisIorInfo);
  // The main parsing routine.

  char *getIdlInterface (char *typeId);
  // Obtains the IDL interface part of the type_id field in the IOR.

  void readIorFromFile (char *filename);
  // Reads in the IOR from a specified file.

  int cutAndPasteHere;

  // @@ Priya, can you please change this so that it's not a magic
  // number?!
  char stringRealIOR[400];
  IOR parsedRealIOR;
  char parsedStr[MAX_IOR_FIELD_LEN];
  char idlInterface[MAX_TYPE_ID_LEN];

private:
  u_long getOctet8Field (char *readPtr, int *hexCharsRead);
  // Interpret the next 8 octets into an unsigned long

  u_long getOctet4Field (char *readPtr, int *hexCharsRead);
  // Interpret the next 4 octets into an unsigned long

  u_long getOctet2Field (char *readPtr, int *hexCharsRead);
  // Interpret the next 2 octets into an unsigned long

  void skipNullOctets (char *readPtr, int *hexCharsRead);
  // Skip the null octets encountered while parsing the IOR

  char *getString (char *readPtr, int givenLen);
  // Extract a character string of a given length from the IOR
};

#endif /* __IORPARSER_H__ */
