<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Real-time Event Channel Configuration</title>
    <!-- $Id$ -->
  </head>

  <body>
    <CENTER>
    <h1>Real-time Event Channel Configuration</h1>
    </CENTER>

    <H3>Overview</H3>

    <P>The new implementation of the real-time event channel uses a
      factory to build all the objects and strategies it requires.
      The factory can be dynamically loaded using ACE Service
      Configurator, this is extremely convenient because the factory
      can also parse options in the Service Configurator script file.
    </P>

    <P>The current implementation provides a default implementation
      for this Factory, this document describes the options used by
      this default implementation.
    </P>

    <H3>The configuration file</H3>

    <P>The real-time event channel uses the same service configurator
      file that the ORB uses, the default name for this file is
      <CODE>svc.conf</CODE>, but the ORB option
      <CODE>-ORBSvcConf</CODE> can be used to override this.
      The format of the file is described in detail in
      the service configurator documentation, but the relevant section
      for the event channel looks like this:
    </P>

<PRE>
# Comments go here...
# More comments if you want to...
static EC_Factory "-ECFiltering basic ....."
</PRE>

    <P>All the event service factory options start with
      <CODE>-EC</CODE></P>


    <H3>The options</H3>

    <P><TABLE BORDER="2" CELLSPACING="2" CELLPADDING="0">
        <TR>
          <TH>Option</TH>
          <TH>Description</TH>
        </TR>
        <!-- <TR NAME="ECDispatching"> -->
        <TR>
          <TD><CODE>-ECDispatching</CODE>
            <EM>dispatching_strategy</EM>
          </TD>
          <TD>Select the dispatching strategy used by the real-time
            event service. A <EM>reactive</EM> strategy will use the
            same thread that received the event from the supplier to
            push the event to all the consumers,
            the <EM>priority</EM> strategy will use a prioritized pool
            of threads and will query the scheduling service to select
            the thread that will dispatch each event;
            the <EM>mt</EM> strategy will also use a pool of threads,
            but the thread to dispatch is randomly selected.
          </TD>
        </TR>

        <!-- <TR NAME="ECDispatchingThreads"> -->
        <TR>
          <TD><CODE>-ECDispatchingThreads</CODE>
            <EM>number_of_threads</EM>
          </TD>
          <TD>Select the number of threads used bythe <EM>mt</EM>
            dispatching strategy.
          </TD>
        </TR>

        <!-- <TR NAME="ECFiltering"> -->
        <TR>
          <TD><CODE>-ECFiltering</CODE>
            <EM>consumer_filtering_strategy</EM>
          </TD>
          <TD>Select the filtering strategy used by the consumers.
            The <EM>null</EM> filtering strategy will build trivial
            filters for all consumers.
            The <EM>basic</EM> filtering strategy supports
            disjunction, conjunctions and timeouts based on the
            subscriptions passed by the consumer during the connect
            call.
            The <EM>priority</EM> filtering strategy supports the same
            features, but it also collaborates with the scheduling
            service to build the dependency graph.
          </TD>
        </TR>

        <!-- <TR NAME="ECSupplierFiltering"> -->
        <TR>
          <TD><CODE>-ECSupplierFiltering</CODE>
            <EM>supplier_filtering_strategy</EM>
          </TD>
          <TD>The event channel can also perform some filtering close
            to the suppliers by minimizing the number of consumers
            that are tested for given event.
            If the strategy is <EM>null</EM> then a global collection
            of consumers is maintained and each event is filtered by
            each consumer.
            If the strategy is <EM>per-supplier</EM> then the EC uses
            the supplier publications and the consumer subscriptions
            to determine which consumers could potentially be
            interested in events for each supplier.
            This set of consumers is usually smaller than the complete
            set and it is thus faster to traverse it, but keeping more
            collections of consumers increases the connection and
            disconnection time as well as the memory requirements.
          </TD>
        </TR>

        <!-- <TR NAME="ECTimeout"> -->
        <TR>
          <TD><CODE>-ECTimeout</CODE>
            <EM>timeout_strategy</EM>
          </TD>
          <TD>A consumer can request that the event channel generate
            periodic or oneshot timeout events.
            This option controls the strategy to generate the
            timeouts,
            using <EM>reactive</EM> the same reactor used for the ORB
            is used by the event service.
            The <EM>priority</EM> strategy uses a prioritized group of
            threads, timeouts with higher rate are generated by
            threads of higher priority.
            <BR><B>NOTE: The <EM>priority</EM> strategy is not
              implemented</B>
          </TD>
        </TR>

        <!-- <TR NAME="ECObserver"> -->
        <TR>
          <TD><CODE>-ECObserver</CODE>
            <EM>observer</EM>
          </TD>
          <TD>The event channel uses the Observer pattern to report
            changes in the subscriptions and publications of its
            suppliers and consumers; this is specially useful in the
            implementation of event channel gateways.
            The user can disable this feature by selecting the
            <EM>null</EM> strategy;
            whereas the <EM>basic</EM> strategy provides a simple, yet
            efficient implementation.
          </TD>
        </TR>

        <!-- <TR NAME="ECScheduling"> -->
        <TR>
          <TD><CODE>-ECScheduling</CODE>
            <EM>scheduling_strategy</EM>
          </TD>
          <TD>The event channel can collaborate with the scheduling
            service to build the dependency list between the consumers
            and the suppliers.
            If the <EM>null</EM> scheduling strategy is selected this
            feature is disabled,
            the <EM>priority</EM> strategy enables this feature.
            <BR><B>NOTE:<B> The default is to have the feature disabled.
          </TD>
        </TR>

        <!-- <TR NAME="ECProxyConsumerLock"> -->
        <TR>
          <TD><CODE>-ECProxyConsumerLock</CODE>
            <EM>lock_type</EM>
          </TD>
          <TD>Select the lock type (<EM>null</EM>, <EM>thread</EM> or
            <EM>recursive</EM>) to synchronize access to the
            ProxyPushConsumer state.
          </TD>
        </TR>

        <!-- <TR NAME="ECProxySupplierLock"> -->
        <TR>
          <TD><CODE>-ECProxySupplierLock</CODE>
            <EM>lock_type</EM>
          </TD>
          <TD>Select the lock type (<EM>null</EM>, <EM>thread</EM> or
            <EM>recursive</EM>) to synchronize access to the
            ProxyPushSupplier state.
          </TD>
        </TR>

        <!-- <TR NAME="ECORBId"> -->
        <TR>
          <TD><CODE>-ECORBId</CODE>
            <EM>orbid</EM>
          </TD>
          <TD>Set the name of the ORB used by the event service, only
	    useful in applications that create multiple ORBs and
	    activate the event service in one of them.
          </TD>
        </TR>

        <!-- <TR NAME="ECConsumerControl"> -->
        <TR>
          <TD><CODE>-ECConsumerControl</CODE>
            <EM>policy</EM>
          </TD>
          <TD>Select the consumer control policy (<EM>null</EM> or
	    <EM>reactive</EM>) to detect and discard broken consumer
	    proxies.
          </TD>
        </TR>

        <!-- <TR NAME="ECSupplierControl"> -->
        <TR>
          <TD><CODE>-ECSupplierControl</CODE>
            <EM>policy</EM>
          </TD>
          <TD>Select the supplier control policy (<EM>null</EM> or
	    <EM>reactive</EM>) to detect and discard broken supplier
	    proxies.
          </TD>
        </TR>

        <!-- <TR NAME="ECConsumerPeriod"> -->
        <TR>
          <TD><CODE>-ECConsumerPeriod</CODE>
            <EM>period</EM>
          </TD>
          <TD>Set the period (in microseconds) used by the reactive
	    consumer control policy to poll the state of the
	    consumer proxies.
          </TD>
        </TR>

        <!-- <TR NAME="ECSupplierPeriod"> -->
        <TR>
          <TD><CODE>-ECSupplierPeriod</CODE>
            <EM>period</EM>
          </TD>
          <TD>Set the period (in microseconds) used by the reactive
	    supplier control policy to poll the state of the
	    supplier proxies.
          </TD>
        </TR>

        <!-- <TR NAME="ECProxyPushConsumerCollection"> -->
        <TR>
          <TD><CODE>-ECProxyPushConsumerCollection</CODE>
	    <EM>flag[:flags]</EM>
          </TD>
          <TD><P>Configure the data structure and strategies used to
	      implement collections of
	      <CODE>ProxyPushConsumers</CODE>.
	      The argument is a colon separated list of flags, with
	      the following semantics:
	      <TABLE>
	      <TR><TH>Flag</TH><TH>Description</TH><
	      </TR>
	      <TR>
		<TD>MT</TD>
		<TD>Use regular mutexes and/or condition
		  variables for serialization.
		</TD>
		<TD>ST</TD>
		<TD>Use null mutexes and/or condition
		  variables for serialization.
		</TD>
		<TD>LIST</TD>
		<TD>Implement the collection using an ordered list,
		  fast for iteration (i.e. during event dispatching),
		  but slow for insertion and removal (i.e. when
		  clients connect and disconnect from the EC).
		</TD>
		<TD>RB_TREE</TD>
		<TD>Implement the collection using a Red-Black tree,
		  slow for iteration (i.e. during event dispatching),
		  but fast for insertion and removal (i.e. when
		  clients connect and disconnect from the EC).
		</TD>
		<TD>IMMEDIATE</TD>
		<TD>Threads block until they can execute a change on
		  the data structure, the system must use other
		  approaches to guarantee that the iterators are not
		  invalidated during event dispatching.  For example,
		  use a separate dispatching thread.
		</TD>
		<TD>COPY_ON_READ</TD>
		<TD>Before initiating an iteration to dispatch events
		  (or similar tasks) a copy of the complete collection
		  is performed.
		  This solves most of the synchronization problems,
		  but introduces a significant source of overhead and
		  priority inversions on the critical path.
		</TD>
		<TD>COPY_ON_WRITE <STRONG>UNIMPLEMENTED</STRONG></TD>
		<TD>Similar to the previous one, but the copy is only
		  performed when needed.
		</TD>
		<TD>DELAYED</TD>
		<TD>Threads that need to change the collection can
		  detect if that change will invalidate iterators used
		  by other threads.
		  If so, the thread posts the change on a queue that
		  is executed once the collection is no longer in
		  use.
		</TD>
	      </TR>
	      </TABLE>
	    </P>
          </TD>
        </TR>

        <!-- <TR NAME="ECPushSupplierSet"> -->
        <TR>
          <TD><CODE>-ECPushSupplierSet</CODE>
          </TD>
          <TD><P>Obsolete option, ignored.
	    </P>
          </TD>
        </TR>

        <!-- <TR NAME="ECConsumerAdminLock"> -->
        <TR>
          <TD><CODE>-ECConsumerAdminLock</CODE>
          </TD>
          <TD>Obsolete option, ignored in the current version.
          </TD>
        </TR>

        <!-- <TR NAME="ECSupplierAdminLock"> -->
        <TR>
          <TD><CODE>-ECSupplierAdminLock</CODE>
          </TD>
          <TD>Obsolete option, ignored in the current version.
          </TD>
        </TR>

      </TABLE>
    </P>

    <H3>The constructor</H3>

    <P>The <CODE>TAO_EC_Event_Channel</CODE> class implements the
      <CODE>RtecEventChannelAdmin::EventChannel</CODE> interface;
      this class takes one mandatory and two optional parameters in
      its constructor:
    </P>

<PRE>
  TAO_EC_Event_Channel (const TAO_EC_Event_Channel_Attributes& attributes,
                        TAO_EC_Factory* factory = 0,
                        int own_factory = 0);
</PRE>

    <P>The <CODE>factory</CODE> is an optional parameter to override
      the default strategy factory used by the event channel,
      the event channel will destroy the factory if the
      <CODE>own_factory</CODE> argument is true.
    </P>

    <P>The <CODE>attributes</CODE> parameter can be used to fine tune
      some of the algorithms and strategies used by the event channel,
      the default values are probably OK for most applications.
      Notice that the attributes include the POA used to activate the
      ConsumerAdmin, SupplierAdmin, ProxyPushConsumer and
      ProxyPushSupplier objects;
      this POAs must have the <CODE>IMPLICIT_ACTIVATION</CODE> and the
      <CODE>SYSTEM_ID</CODE> policies (as the RootPOA does).
    </P>

    <P><TABLE BORDER="2" CELLSPACING="2" CELLPADDING="0">
        <TR><TH>Attribute</TH><TH>Description</TH></TR>

        <TR><TD><CODE>consumer_reconnect</CODE></TD>
          <TD>If the attribute is not zero then the same consumer can
            call <CODE>connect_push_consumer</CODE> on its
            ProxyPushSupplier multiple times to change its
            subscriptions;
            this is usually more efficient that disconnecting and
            connecting again.
          </TD>
        </TR>

        <TR><TD><CODE>supplier_reconnect</CODE></TD>
          <TD>If the attribute is not zero then the same supplier can
            call <CODE>connect_push_supplier</CODE> on its
            ProxyPushConsumer multiple times to change its
            publications;
            this is usually more efficient that disconnecting and
            connecting again.
          </TD>
        </TR>

        <TR><TD><CODE>busy_hwm</CODE></TD>
          <TD>When using the delayed strategy to update
            ProxyPushSupplier sets this flag controls the maximum
            number of thread that can simultaneously iterate over the
            set before blocking.
            It can be used to avoid starvation in delayed updates on
            the set.
          </TD>
        </TR>

        <TR><TD><CODE>max_write_delay</CODE></TD>
          <TD>When using the delayed strategy to update
            ProxyPushSupplier sets this flag controls the maximum
            number of threads that will initiate dispatching
            <B>after</B> a change has been posted.
            Any thread after that is blocked until the operations are
            performed.
            It can be used to completely stop starvation of delayed
            updates on the set.
          </TD>
        </TR>

        <TR><TD><CODE>scheduler</CODE></TD>
          <TD>Most configurations of the real-time event channel do
            not require an scheduler.
            If any of the strategies that require an scheduling
            service is selected then this attribute should be set
            appropiately.
          </TD>
        </TR>
      </TABLE>
    </P>

    <P><HR><P>

      Back to the TAO <A HREF="index.html">components documentation</A>.

      <!--#include virtual="/~schmidt/cgi-sig.html" -->

    <address><a href="mailto:coryan@cs.wustl.edu">Carlos O'Ryan</a></address>
<!-- Created: Thu Jul  1 21:44:28 CDT 1999 -->
<!-- hhmts start -->
Last modified: Fri Jan 28 15:59:23 PST 2000
<!-- hhmts end -->
  </body>
</html>
