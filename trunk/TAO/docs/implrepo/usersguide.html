<html>
<!-- $Id$ -->

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<title>Implementation Repository User's Guide</title>
</head>

<body bgcolor="#FFFFFF">

<hr>

<h3>Implementation Repository User's Guide</h3>

<p>In order for a server to make use of the Implementation Repository, it must communicate
with the IMR to keep it up to date on such things as the server's running status. These 
functions now are contained within the POA, so when a Persistent POA is used on a server
that has -ORBUseIMR specified, it will communicate with an Implementation Repository, if
one is available.</p>

<hr>

<h4>How is the IMR used?</h4>

<p>The main steps for the lifetime of a server that uses the IMR are generally the
following:

<ol>
  <li>Register name and startup commands with the IMR using <b>tao_imr<br>
    </b><em>Example:<code>  </code> </em><code> tao_imr -ORBInitRef ImplRepoService=file://implrepo.ior add plane -c
    &quot;airplane_server -i -ORBInitRef ImplRepoService=file://implrepo.ior&quot;<br>
    <br>
    </code>Note that the name used to register the server is the name of the POA
    which the objects are created in. So in this example, the
    airplane_server creates a POA called &quot;plane&quot; and activates its
    servants under it.<code> <br>
    </code></li>
  <li>Start the server once to generate an IMR-ified IOR<br>
  </li>
  <li>Start clients and pass them the above IOR<br>
  </li>
  <li>Clients will use the IOR, which will automatically go through the IMR<br>
  </li>
  <li>The IMR will start the server if it is not already running<br>
  </li>
  <li>At any time when the server is not currently in use by a client, it can be shut down
    using <strong>tao_imr<br>
    </strong><em>Example:</em><code> tao_imr -ORBInitRef ImplRepoService=file://implrepo.ior shutdown
    plane<br>
    </code></li>
  <li>After the server isn't needed anymore, it can be removed from the IMR database using <strong>tao_imr<br>
    </strong><em>Example:<code> </em>tao_imr -ORBInitRef ImplRepoService=file://implrepo.ior remove plane</code></li>
</ol>

<hr>

<h4>So what does the server need to do? </h4>

<p>As of TAO 1.0.9, the Implementation Repository support on the server-side has
been integrated into the POA. Previously, the IR_Helper class needed to be
used explicitly. Now only the &quot;-ORBUseIMR 1&quot; command line
argument needs to be used. </p>

<p>There are a couple of restrictions on the server though. Only objects
within a persistent POA will be supported by the IMR. Also the
Implementation repository will key its entries on POA name. What this
means for the server is that each server must have unique persistent POA names. </p>

<hr>

<h4>What are activation modes</h4>

<p>Each server can have one of three different types of activation modes:</p>
<ul>
  <li>NORMAL is the default.  The server can be started via tao_imr, the command line, and
      with client requests. </li>
  <li>MANUAL specifies that the server shouldn't be  activated with a client request but can 
      be activated through tao_imr or via the command line.  </li>
  <li>PER_CLIENT specifies that each request to the ImplRepo will result in a new server 
      process started up.  Because clients cache the forwarded reference, there is one server 
      per client (more or less).  There are some exceptions, such as if the original IOR
      is used in different threads (each thread would get a different server).  <b>Note:</b>
      The Implementation Repository doesn't store any information about the started servers
      in this mode, so it cannot be used to shut down the servers.  So the servers must 
      have an alternative way of shutting down. </li>
  <li>AUTO_START specifies that a server should be activated when the Implementation Repository
      is started.  tao_imr also has an autostart command to activate all servers marked 
      AUTO_START</li>
</ul>

<hr>

<h4>Using the tao_imr ior command</h4>

<p>First, some background.</p>

<p>For the longest time, there was no way with TAO's Implementation Repository to register a 
server and then start using the client immediately.  The server had to be started once just
for the purpose of creating an IOR for the client to use.  The problem was that it was very 
difficult to create an IOR without running the server.</p>

<p>It would be nice to be able to  generate a valid IOR without requiring the program
to be run. A valid IOR in this case requires two major things.  First it requires the endpoint
of the IMR. This is relatively easy to get, since it is encoded in the IMR's IOR.  Second it
also requires an object key.  At the least, this involves both the POA hierarchy and the object
name.</p>

<p>So if we knew the POA and object names, then we should be able to create an IOR for the 
server. One possibility would be to have tao_imr ask for both the POA and the object, and then
create the POA hierarchy to generate an IOR.  Doing the generation is this manner (letting the
POA create the reference) shields us from changes in the IOR generation schemes.  Since we are 
using the same code that the server would use, our IORs would be up to date.</p>

<p>It ends up there is an easier way to do this.  The Interoperable Naming Service is intended
to be used in situations where an IOR could be created by hand.  Using the same information as
above, it is not difficult to take the endpoint information from the IMR and attach the POA 
name.  For example, let's say that we are running the IMR on ringil.ece.uci.edu at port 5000.  
The endpoint would be &quot;iioploc://1.1@ringil.ece.uci.edu:5000&quot;.  If we are creating
an IOR for the nestea server, we'd just need to attach &quot;/nestea_server&quot; to the end
of the endpoint.  Now we have an IOR.</p>

<p>So what does this mean for the server?</p>

<p>The main issue here is that the server must be changed to support the simplified name. The
code to do this is just one line:</p>

<p><code>this->orb_->_tao_add_to_IOR_table (poa_name, server_obj.in ());</code></p>

<p> This line, as taken from the nestea_server example, just uses the same poa_name as 
registered with the IMR and associates it with the server_obj object in the IOR table.  Because
the IMR will be able to handle the simplified name (if it uses the POA name scheme) then this
IOR will work.</p>

<p>Just one more thing, each object that needs an IOR needs to be registered with the IOR table.
But this raises the problem of uniqueness; they all can't have the same name.  The IMR will 
actually only look at the name part of the simplified IOR up to the first &quot;/&quot;.  So
both &quot;iioploc://1.1@ringil:5000/nestea_server/foo&quot; and 
&quot;iioploc://1.1@ringil:5000/nestea_server/bar&quot; will be treated by the IMR as objects
in the &quot;nestea_server&quot; server.</p>

<hr>

<h4>Persistent Implementation Repository</h4>

<p>Tao's Implementation Repository can be made persistent by doing two things:</p>

<ul>
<li>
Always start up the Implementation Repository on the same port. This ensures that
the Implementation Repository will not have to re-IMR-ify the IORs of every server
registered to it each time it starts up. The way to accomplish this is to add<br>
<blockquote>
-ORBEndpoint iiop://(hostname):(portnumber)<br>
</blockquote>
 to the IMR's startup command line. The host
name can be obtained portably in C++ code with the lines<br>
<blockquote>
	ACE_INET_addr ad;<br>
	char *hostname = ad.get_host_name ();<br>
</blockquote>
or in a Perl script by adding<br>
<blockquote>
	use Sys::Hostname;<br>
	$hostname = hostname();<br>
</blockquote>
There are even specific port numbers, assigned to the OMG by the IANA, which can be used for
this purpose. They are 683 (for IIOP) and 684 (for IIOP SSL). For more information about this,
see <a href="http://www.iana.org/">http://www.iana.org/</a> and <a href="http://www.isi.edu/in-notes/iana/assignments/port-numbers">
http://www.isi.edu/in-notes/iana/assignments/port-numbers</a>.
</li>
<br><br>
<li>
Pass the IMR a filename to use for the backing store, specified by the command line option<br>
<blockquote>
-p (filename)<br>
</blockquote>
This option must be used the first and every subsequent time the persistent IMR is started up.
</li>
</ul>

<hr>

<h4>How to run the Implementation Repository as an NT service</h4>

<p>These conditions must be met:</p>

<ul>
<li>
The user must be logged in as administrator, or have administrative priveleges 
(in order to register an NT service).
</li>
<li>
ACE_ROOT must be set to the ACE_wrappers directory in the system environment.
</li>
<li>
ACE_ROOT/bin must be in the system path.
</li>
</ul>

To set the options for the TAO NT ImplRepo Sevice, go to the Services icon
in the Settings group under the start menu (start menu -> settings ->
services). There, highlight "TAO NT ImplRepo Service", which is the name
used by the ImplRepo Service when it is registered. After it's
highlighted, you should see at the bottom of the dialog box an area to
specify options for ImplRepo_Service.exe. Just enter the options you wish in 
that edit box and everything should just work. However, some options, such as
-ORBDebugLevel, won't work since an NT service can't write output to
standard out.

<br><br>

<ul>
<li>
Syntax<br>
<blockquote>
        % NT_ImplRepo_Service&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[-i value]
<blockquote><blockquote><blockquote><blockquote><blockquote>
                              [-r]<br>
                              [-s]<br>
                              [-k]<br>
                              [-t n]<br>
                              [-d]<br>
</blockquote></blockquote></blockquote></blockquote></blockquote>
</blockquote>
</li>

<li>
Optional Command-line Arguments<br>
<br>
<ul>
<li>
        -i value<br>
                Install this program as an NT service, with specified startup<br>
</li>
<li>
        -r<br>
                Remove this program from the Service Manager<br>
</li>
<li>
        -s<br>
                Start the service<br>
</li>
<li>
        -k<br>
                Kill the service<br>
</li>
<li>
        -t value<br>
                Set startup for an existing service<br>
</li>
<li>
        -d<br>
                Debug; run as a regular application<br>
</li>
</ul>
</li>
<br>
<li>Usage<br>
<blockquote>
        To see different stages of an NT service application, you have<br>
        to run the program several times, with different options.<br>
        Please note: run with only one option at a time.<br>
<br>
<ul>
<li>
        First, you must initialize the service in the NT Service Control<br>
	Manager database.  Run NT_ImplRepo_Service with -in, where n is<br>
	one of the following startup options:<br>
<br>
        // Start Type (from WinNT.h)<br>
        //<br>
        #define SERVICE_SYSTEM_START    0x00000001<br>
        #define SERVICE_AUTO_START      0x00000002<br>
        #define SERVICE_DEMAND_START    0x00000003<br>
        #define SERVICE_DISABLED        0x00000004<br>

        If only -i is specified, SERVICE_DEMAND_START is default option.<br>
<br>
</li>
<li>
        Now you are ready to run the actual service. Run<br>
        NT_ImplRepo_Service again, this time with -s option. If the<br>
        service starts successfully, it will ring the system<br>
        bell every second or so until the service is stopped.<br>
<br>
</li>
<li>
        To stop service execution, run NT_ImplRepo_Service with the<br>
        -k option.<br>
<br>
</li>
<li>
        To remove the service from the Service Control Manager<br>
        database, run NT_ImplRepo_Service with -r.<br>
<br>
</li>
</ul>
        In addition, once you have initialized this service (by using<br>
        the -i option) you can change its startup type to one of the<br>
        other values above.  To do this, run NT_ImplRepo_Service with<br>
        -tn option. n is as explained above for -i.<br>
<br>
        In order to debug the service's execution itself, use the -d<br>
        option.<br>
</blockquote>
</li>
</ul>
<br>

<hr>

<p>Last update to this document: $Date$</p>

<p>Back to <a href="index.html">Implementation Repository</a></p>
</body>
</html>
