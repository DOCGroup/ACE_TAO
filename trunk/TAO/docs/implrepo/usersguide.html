<html>
<!-- $Id$ -->

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<title>Implementation Repository User's Guide</title>
</head>

<body bgcolor="#FFFFFF">

<hr>

<h3>Implementation Repository User's Guide</h3>

<p>In order for a server to make use of the Implementation Repository, it must communicate
with the IMR to keep it up to date on such things as the server's running status. These 
functions now are contained within the POA, so when a Persistent POA is used on a server
that has -ORBUseIMR specified, it will communicate with an Implementation Repository, if
one is available.</p>

<hr>

<h4>How is the IMR used?</h4>

<p>The main steps for the lifetime of a server that uses the IMR are generally the
following:

<ol>
  <li>Register name and startup commands with the IMR using <b>tao_imr<br>
    </b><em>Example:<code>  </code> </em><code> tao_imr -ORBInitRef ImplRepoService=file://implrepo.ior add plane -c
    &quot;airplane_server -i -ORBInitRef ImplRepoService=file://implrepo.ior&quot;<br>
    <br>
    </code>Note that the name used to register the server is the name of the POA
    which the objects are created in. So in this example, the
    airplane_server creates a POA called &quot;plane&quot; and activates its
    servants under it.<code> <br>
    </code></li>
  <li>Start the server once to generate an IMR-ified IOR<br>
  </li>
  <li>Start clients and pass them the above IOR<br>
  </li>
  <li>Clients will use the IOR, which will automatically go through the IMR<br>
  </li>
  <li>The IMR will start the server if it is not already running<br>
  </li>
  <li>At any time when the server is not currently in use by a client, it can be shut down
    using <strong>tao_imr<br>
    </strong><em>Example:</em><code> tao_imr -ORBInitRef ImplRepoService=file://implrepo.ior shutdown
    plane<br>
    </code></li>
  <li>After the server isn't needed anymore, it can be removed from the IMR database using <strong>tao_imr<br>
    </strong><em>Example:<code> </em>tao_imr -ORBInitRef ImplRepoService=file://implrepo.ior remove plane</code></li>
</ol>

<hr>

<h4>So what does the server need to do? </h4>

<p>As of TAO 1.0.9, the Implementation Repository support on the server-side has
been integrated into the POA. Previously, the IR_Helper class needed to be
used explicitly. Now only the &quot;-ORBUseIMR 1&quot; command line
argument needs to be used. </p>

<p>There are a couple of restrictions on the server though. Only objects
within a persistent POA will be supported by the IMR. Also the
Implementation repository will key its entries on POA name. What this
means for the server is that each server must have unique persistent POA names. </p>

<hr>

<h4>What are activation modes</h4>

<p>Each server can have one of three different types of activation modes:</p>
<ul>
  <li>NORMAL is the default.  The server can be started via tao_imr, the command line, and
      with client requests. </li>
  <li>MANUAL specifies that the server shouldn't be  activated with a client request but can 
      be activated through tao_imr or via the command line.  </li>
  <li>PER_CLIENT specifies that each request to the ImplRepo will result in a new server 
      process started up.  Because clients cache the forwarded reference, there is one server 
      per client (more or less).  There are some exceptions, such as if the original IOR
      is used in different threads (each thread would get a different server).  <b>Note:</b>
      The Implementation Repository doesn't store any information about the started servers
      in this mode, so it cannot be used to shut down the servers.  So the servers must 
      have an alternative way of shutting down. </li>
  <li>AUTO_START specifies that a server should be activated when the Implementation Repository
      is started.  tao_imr also has an autostart command to activate all servers marked 
      AUTO_START</li>
</ul>

<hr>

<h4>Using the tao_imr ior command</h4>

<p>First, some background.</p>

<p>For the longest time, there was no way with TAO's Implementation Repository to register a 
server and then start using the client immediately.  The server had to be started once just
for the purpose of creating an IOR for the client to use.  The problem was that it was very 
difficult to create an IOR without running the server.</p>

<p>It would be nice to be able to  generate a valid IOR without requiring the program
to be run. A valid IOR in this case requires two major things.  First it requires the endpoint
of the IMR. This is relatively easy to get, since it is encoded in the IMR's IOR.  Second it
also requires an object key.  At the least, this involves both the POA hierarchy and the object
name.</p>

<p>So if we knew the POA and object names, then we should be able to create an IOR for the 
server. One possibility would be to have tao_imr ask for both the POA and the object, and then
create the POA hierarchy to generate an IOR.  Doing the generation is this manner (letting the
POA create the reference) shields us from changes in the IOR generation schemes.  Since we are 
using the same code that the server would use, our IORs would be up to date.</p>

<p>It ends up there is an easier way to do this.  The Interoperable Naming Service is intended
to be used in situations where an IOR could be created by hand.  Using the same information as
above, it is not difficult to take the endpoint information from the IMR and attach the POA 
name.  For example, let's say that we are running the IMR on ringil.ece.uci.edu at port 5000.  
The endpoint would be &quot;iioploc://1.1@ringil.ece.uci.edu:5000&quot;.  If we are creating
an IOR for the nestea server, we'd just need to attach &quot;/nestea_server&quot; to the end
of the endpoint.  Now we have an IOR.</p>

<p>So what does this mean for the server?</p>

<p>The main issue here is that the server must be changed to support the simplified name. The
code to do this is just one line:</p>

<p><code>this->orb_->_tao_add_to_IOR_table (poa_name, server_obj.in ());</code></p>

<p> This line, as taken from the nestea_server example, just uses the same poa_name as 
registered with the IMR and associates it with the server_obj object in the IOR table.  Because
the IMR will be able to handle the simplified name (if it uses the POA name scheme) then this
IOR will work.</p>

<p>Just one more thing, each object that needs an IOR needs to be registered with the IOR table.
But this raises the problem of uniqueness; they all can't have the same name.  The IMR will 
actually only look at the name part of the simplified IOR up to the first &quot;/&quot;.  So
both &quot;iioploc://1.1@ringil:5000/nestea_server/foo&quot; and 
&quot;iioploc://1.1@ringil:5000/nestea_server/bar&quot; will be treated by the IMR as objects
in the &quot;nestea_server&quot; server.</p>

<hr>

<p>Last update to this document: $Date$</p>

<p>Back to <a href="index.html">Implementation Repository</a></p>
</body>
</html>
