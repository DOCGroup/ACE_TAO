<!-- $Id$-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<TITLE>Smart Proxies</TITLE>
<BODY>
<CENTER><H1>Smart Proxies</H1></CENTER>

<BODY text = "#000000"
link="#000fff"
vlink="#ff0f0f"
bgcolor="#ffffff">

<h3><a name="toc">Table of Contents</a></h3>
<ul>
  <li><a href="#Introduction">Introduction</a>
  <li><a href="#Design Issues">Design Issues</a>
  <li><a href="#Design Overview">Design Overview</a>
  <li><a href="#Acknowledgements">Acknowledgements</a>
  <li><a href="#ref">References</a>
</ul>

<h2><a name="Introduction">Introduction</a></h2>

<P>Smart Proxies (or Smart Stubs) are basically proxy classes which are
user defined.
<P>By default, the IDL compiler generates proxy classes for IDL interfaces.
The proxy is an exact image of the target object on whom the
invocations are to be made by the client. A proxy packadges the
request along with its Service Context which gets marshalled and sent
to the target object.</p>
<P>The user may wish to manually change the proxy code for the following
reasons:
<P>
<h3><a name="Examples">Examples</a></h3>

<P>1) Cache information about the rempote object locally to save the
expense of going across the wire for every request.
<P>2) Batch updates/accesses to the remote object.
<p>For instance:<br>
Consider a remote Database which has an api which can update 10
records at one shot. To leverage performance, one would want to use
this method.</p>

<P> So on an update method on the smart stub, instead of an remote
invocation per record, the record-info will be cached and then after
10 such records to be updated are obtained, the actual remote
invocation could be made.</p>

<P> It is not certain whether this usecase might not induce extra
overhead and whether the proxy can be smart enough to deduce the use
of this kind of batch processing. Also, this scheme wont work for
two-way calls.The "cached-oneways" feature might make more sense in
this scenario.</p>

<P>3) The client can make a single request which results in a sequence
of invocations.
<p> For instance:<br>
The smart stub has some private methods (since this is user specific
this should be possible) which do validation of the request to be
made. The remote call could result in another call wherein the
validation occurs before it is shoved over the wire.</p>

<P>4) Quality of Service features like load-balancing can be considered
by the smart proxy before making the invocation on the appropriate
target object.</p>

<h2><a name="Design Issues">Design Issues</a></h2>

<P>1) How will the smart proxy be created?
<P>2) Who will create the smart proxy?
<P>3) It has to be done before the invocations on the target object are
done, so when will it get created?
<P>4) What about collocation? Will those stubs fall under this category?</p>

<h3>Design Needs and discussion points</h3>

<P>A ProxyFactory is needed which will create the stubs (either default
or smart). This factory should be able to create different kinds of
proxies.</p>

<P>The <code>unchecked_narrow</code> method needs to return the
appropriate stub.</p>

<P>Collacated stubs need to be handled too.</p>

<P>An existing function for creating stubs has to replaced by a class
which will handle all cases viz. default stubs, smart stubs (proxies),
collcated stubs.</p>

<h2><a name="Design Overview">Design Overview</a></h2>

<P>At a glance:</p>

<P>Classses to be generated by TAO_IDL in addition to the Default
Stub:</p>

<P>1. StubFactoryAdaptor
<p>The singleton which has the different stub factories
registered with it.</p>

<P>2. DefaultStubFactory
<p>The stub factory which will replace the factory function
currently generated by TAO_IDL to create default stubs.</p>

<P>3. DefaultSmartStub.
<p>The smart stub interface which makes it easier for the
user to simply implement only the methods he wishes to change and also
provides and <br>common interface to address remote as well as collocated
stubs.</p>

<P>Classes to be defined by the user:</p>

<P>1. SmartFactory.
<p>The factory which will create the smart stub which the
user wants.Its necessary that an object of this class is created.</p>

<P>2. SmartStub.
<p>The stub which has the user desired extra functionality.</p>

<P>*Note: Names are as they are to make it easier to comprehend the
concept.</p>

<h3>In more detail</h3>

<pre>
// To be generated by TAO_IDL.
class StubFactoryAdaptor
{
 // DESCRIPTION:
 // Behaves like a singleton and contains the
 // factory object which is used to create the
 // default/smart stubs.
public:

 static StubFactoryAdaptor *instance (void)
  {
    if (StubFactoryAdaptor::factory_ == 0)
    {
      Perform Double-Checked Locking Optimisation...
      this->factory = new DefaultFactory;
    }
  }

 // Register the factory with the Adaptor.
 static register (DefaultFactory *df)
 {
   Perform Double-Checked Locking Optimisation...

   // If there is a factory already existing, replace it.

   if (StubFactoryAdaptor::factory_ != 0)
     delete this->factory_;
   this->factory_ = df;
 }

 // Remove the factory.
 static unregister (void)
 {
   Perform Double-Checked Locking Optimisation...
   delete this->factory_;
 }

 // Delegation of the stub creation to the factory
 static interface_ptr create_stub (void)
 {
   return this->factory_->create_stub ();
 }

protected:
 StubFactoryAdaptor (void);

 static DefaultFactory *factory_;

};

// This class will also be generated by TAO_IDL.
class DefaultFactory
{
 // DESCRIPTION:
 // This class creates default stubs and is the parent
 // for the different stub factories.
public:
 DefaultFactory (void)
 {
   if (this->open () == error)
     print error;
 }

 ~DefaultFactory (void)
 {
   this->close ();
 }

 // The default stub is created.
 interface_ptr create_stub (void)
 {
   return new DefaultStub;
 }

 // Whenever the factory object is created, automatically it
 // gets registered with the StubFactoryAdaptor.
 int open (void)
 {
   StubFactorydaptor::instance ()->register(this);
   If above fails, return error else 0.
 }

 // Job done, unregisteration is done.
 int close (void)
 {
   StubFactorydaptor::instance ()->unregister(this);
   If above fails, return error else 0.
 }

};

// This has to be implemented by the user
class SmartFactory : public DefaultFactory
{
 // DESCRIPTION:
 // An object of this class has to be defined by the user
 // which will cause it to be registered with the
 // StubFactoryAdaptor.
public:
 Smartinterface_ptr create_stub (void)
 {
   return new SmartStub;
 }
};

// This class will be generated by the TAO_IDL.
class DefaultSmartStub : public virtual DefaultStub
{
 // DESCRIPTION:
 // This class is the class from which the user will inherit
 // and simply override the methods he requires. This extra
 // level of indirection is necessary to be able to provide
 // the smartstub interface for even collcated stubs.
public:
 DefaultSmartStub (void);
 int method ();
 ...

protected:
 // This pointer denotes the kind of proxy used:
 // collacated-thru_poa, collocated-direct, or remote.
 // This is decided by the collocated strategy used along
 // with the smart stubs. Note: the collocated stubs
 // themselves are smart proxies.
 DefaultStub *stub;
};

// This class will be implemented by the user.
class VerySmartStub : public DefaultSmartStub
{
 // DESCRIPTION:
 // This is the smart stub will is defined by the user
 // to suit his needs.
 int method ()
 {
   print "Yahoo, I am so smart"
   this->stub->method ();
 }

}
</pre>

<h2><a name="Acknowledgements">Acknowledgements</a></h2>

<P><a href="mailto:nanbor@cs.wustl.edu">Nanbor Wang</a> and <a
href="mailto:schmidt@cs.wustl.edu">Dr.Schmidt</a> for their help in
designing and discussing this feature.

<h2><a name="ref">References</a></h2>

<p> CORBA Distributed Objects using Orbix - Sean Baker </p>
<p> Visigenic Documentation </p>


<p><h2>Completed On</h2></p>

<p> Date: 19thSept99</p>
<p> By: <a href="mailto:kirthika@cs.wustl.edu">Kirthika Parameswaran</a></p>

</BODY>
</HTML>
