<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>

   <title>TAO Release Information and TODO List</title>
</head>
<body text="#000000" bgcolor="#FFFFFF">
<!-- $Id$ -->
<center>
<hr></center>

<center>
<h3>
Release Information for The ACE ORB (TAO)</h3></center>
This document contains information on the following topics related to the <a href="http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/VERSION">current
release</a> of <a href="http://www.cs.wustl.edu/~schmidt/TAO.html">TAO</a>:

<TABLE cellpadding=10 cellspacing=0 border=0>

<TD>
<ul>
<li>
<a href="#idl">IDL Compiler</a></li>

<li>
<a href="orbcore.html">ORB Core</a></li>

<li>
<a href="#pp">Pluggable Protocols</a></li>

<li>
<a href="RTCorba.html">Real-Time CORBA</a></li>

<li>
<a href="#poa">Portable Object Adapter (POA)</a></li>

<li>
<a HREF="../poa_migration.html">POA Migration Notes</a></li>

<li>
<a href="#ami">Asynchronous Method Invocation (AMI)</a></li>

<li>
<a href="#interceptor">Portable Interceptors</a></li>

<li>
<a href="../Smart_Proxies.html">Smart Proxies</a></li>

<li>
<a href="../implrepo/index.html">Implementation Repository</a></li>

<li>
<a href="#interfrepo">Interface Repository</a></li>

<li>
<a href="OBV.html">Object-by-Value</a></li>

<li><a href="#CORBA2.3.1">CORBA 2.3.1 Conformance</a></li>

</UL>
</TD>
<TD>
<UL>

<li>
<a href="#nservices">CORBA Naming Service </a>

<li>
<a href="#tservices">CORBA Trading Service</a></li>

<li>
<a href="#pservices">CORBA Property Service</a></li>

<li>
<a href="#cservices">CORBA Concurrency Service</a></li>

<li>
<a href="#av">CORBA Audio/Video Streaming Service</a></li>

<li>
<a href="#ts">CORBA Time Service</a></li>

<li>
<a href="#ec">CORBA Event Service</a></li>

<li>
<a href="#log">CORBA Telecom Log Service</a></li>

<li>
<a href="#notify">CORBA Notification Service</a></li>

<li>
<a href="#security">CORBA Security Service</a></li>

<li>
<a href="ec.html">TAO's Real-time Event Service</a></li>


<li>
<a href="#scheduling">TAO's Scheduling Service</a></li>

<li>
<a href="#logging">TAO's Logging Service</a></li>

<li><a href="#loadbalancer">TAO's Load Balancer</a></li>

</UL>
</TD>
<TD>
<UL>

<li>
<a href="#apps">Regression Tests</a></li>

<li>
<a href="#ace">ORB-related ACE Changes</a></li>

<li>
<a href="#dove">The DOVE Demo</a></li>

<li>
<a href="#forwarding">Location Forwarding</a></li>

<li>
<a href="#leader">Global Resources and Leader-Follower Model</a></li>

<li>
<a href="#locate">Locate requests</a></li>

<li><a href="#localobject">Local Interfaces</a></li>

<li>
<a href="TODO.html">Our TODO list</a></li>

</TABLE>

A complete list of all modifications to TAO is available in the <a href="http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/ChangeLog">ChangeLog</a>.
<p>
<hr>

<h3>
<a NAME="idl"></a>IDL Compiler</h3>
Point of contact: <a href="mailto:parsons@cs.wustl.edu">
Jeff Parsons</a>
<p>Current status: (As of August 23, 2000.)
<ul>
<li>
Generated code closely follows the C++ Mapping specified in the latest
C++ mapping for CORBA 2.3 (Document ptc/98-09-03).</li>

<li>
IDL compiler is now able to generate code that support native C++
exceptions on the stubs and skeletons. With this strict mapping, the
CORBA::Environment parameter is no longer generated.
The default behavior is to generate code without the extra parameter
	on plaforms with native exceptions and with the extra
	parameter in platforms without native exceptions.
	Use the -Ge flag to override the defaults.
</li>

<li>
We are now able to handle shared case labels and default label in
unions. In addition, whenever appropriate, we are also able to
generate the "default ()" operation.
</li>

<li>
We are now able to handle recursive types. We are also able to
generate optimized typecodes.
</li>

<li>
Struct members of type strings and arrays of strings now use the managed
type instead of the _var type. This change was necessary to conform to
the IDL->C++ mapping.</li>

<li>
Fixed a large number of problems with anonymous arrays and sequences inside
structs and unions. The name of anonymous sequence needs to be fixed as
per latest C++ mapping spec.</li>

<li>
Compile problems with sequence of forward declared interfaces is fixed.
In addition, problems with sequence of CORBA::Objects is fixed. In this
specific case, we were not generating the _downcast and _upcast methods.</li>

<li>
Some more problems with the front-end have been fixed. In particular, oneway
operations with a "raises" clause or having an "inout", "out", or "return"
mode is flagged as an error.</li>

<li>
For platforms that support namespaces, we now allow reopening modules.</li>

<li>
Support for generating compiled marshaling code is added. Use the -Gc option.
However, this needs thorough testing before we can claim success. Unions
are still a problme with compiled marshaling.</li>

<li>
The problem of "#include"ing the relative path of the header files rather
than the paths of their corresponding IDL files has been fixed. tao_idl
now generates #include path names that are derived from the IDL files that
are #include'd in the main idl file.</li>

<li>
Added options to IDL compiler to specify file name endings for the IDL-generated
stubs, skeletons and the various header files. Please refer to the <a href="http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/docs/compiler.html">IDL
compiler options</a> for details.</li>

<li>
Verified support for the "long long" and "unsigned long long" datatypes.
On platforms that do not support 64 bit longs we provided <i>partial</i>
emulation through ACE_U_LongLong.</li>

<li> Perfect Hashed Operation Lookup Strategy has been added to the
IDL Compiler.  -P flag to <code>tao_idl</code> enables the perfect
hased lookup strategy.  This strategy uses <a
href="http://www.cs.wustl.edu/~schmidt/gperf.ps.gz">GPERF</a>, the
GNU's Perfect Hash Function Generator written by Dr.Douglas
C. Schmidt.  Right now, GPERF works only on Solaris. Any work on
porting GPERF to other platforms will be highly
appreciated.</L1></li>

<li>
The &lt;&lt;= and >>= operators for user-defined types are now generated.</li>

<li> Completely redesigned the IDL compiler using the Visitor
patterns. Many incomplete issues have been resolved. These include
support for "sequence of typecodes", passing object references as in,
inout, and out parameters.  Code generation for sequences is also
properly handled i.e., for a named sequence such as <CODE>typedef
sequence&lt;char&gt;CharSeq;</CODE>, we now generate a new class (and
hence a type) called "class CharSeq". Arrays are still being worked
out and will be done soon. An important difference in the generated
code is that the skeletons now use a table driven approach very
similar to the stubs.</li>

<li>
Support for the "native" keyword added.</li>

<li>
The problem of incorrect code generation for typedefs defined in an imported
file is resolved.</li>

<li>
Problems when interfaces use single or multiple inheritance solved. The
problem was with the demultiplexing code, the generated operation tables,
and the dispatching mechanism. We are currently testing this with the Event
Channel code.</li>

<li>
The problems arising due to public virtual inheritance when casting from
an interface class to CORBA::Object_ptr has been solved. We do this casting
inside the stubs/skeletons rather than first converting an interface class
pointer to a void*, storing it in an Any, and casting it to CORBA::Object_ptr
in the encode/decode methods. The casting inside the stubs/skeletons work
because the compiler has knowledge of both types.</li>

<li>
Include files are handled properly. So are the definitions used inside
the include files that are used in the currently parsed files.</li>

<li>
Generates C++ stubs and skeletons that use TAO's <a href="http://www.cs.wustl.edu/~schmidt/HICSS-97.ps.gz">interpretive
IIOP protocol engine</a>.</li>

<li>
Support dynamic libraries on NT, i.e., marking classes for DLL export was
added. Two backend options control the name of the export macro, and the
name of an extra include file were the macro is defined; the options are
<tt>-Wp,export_macro=MACRO_NAME-Wp,export_include=INCLUDE_NAME</tt>.</li>

<li>
The IDL compiler generates now source code for sequences. The user has
now the option to use these generated sequence classes or to use, as up
to now, the template instatiation. If TAO_LACKS_TEMPLATE_SPECIALIZATION
is defined, then template instantiation will be used, else not. The reason
for this was, that some C++ compilers did not support template instantiation
properly and sequences were based on templates. The generated source code
is mainly contained in the generated header file directly in the class
declaration.</li>

<li>
The IDL Compiler generates templates for servant implementations. The options
are -GI [ h | s | b | e | c ]</li>

<li>
The IDL compiler generates source code for the management and (de)marshaling
of wide characters and wide strings, enabling the sending and receiving of
Unicode over the wire. However, wide character and wide string literals are
not yet portable to Unix platforms (see entry under Future Work below).</li>

<li>
Since the CORBA spec requires that all enums be 32 bits, and some compilers
will try to use less space if the enum values are small enough, the IDL
compiler now appends <enum name>_TAO_ENUM_32BIT_ENFORCER = 0xFFFFFFFF to
every enum. This appended enum value is not part of the IDL compiler's
internal representation of the enum, so unions that use the enum as a
discriminator will not have incorrect _default() code generated for them.</li>

<li>
The IDL compiler generates a C++ ostream operator for IDL exceptions. So
far only the repository ID is output, but this may be enhanced when
requirements and/or desires become clearer.</li>

<li>
The IDL compiler now has limited support for valuetypes (see release notes
for valuetypes for details). If the TAO library is built with
TAO_HAS_VALUETYPE defined, and IDL_HAS_VALUETYPE is also defined, then
the IDL compiler will enable OBV support with the command line option
-Gv, and disable it with the option -Sv (the default).</li>

<li>
As part of the implementation of interceptors, the TAO IDL compiler
now generates interception points in the client and server, as well
as the prepare_header method in the stubs.</li>

<li>
Scoping and name resolution rules have changed in CORBA with version
2.3. The IDL compiler now conforms to these new rules. </li>

<li>
IDL compiler now supports the CORBA AMI callback model, generating code
for reply handlers and reply stubs if the -GC command line option is
used. The TAO library must be compiled with TAO_HAS_CORBA_MESSAGING = 1.
If this is done, TAO_HAS_AMI_CALLBACK will automatically be defined to
1 as well. IDL_HAS_VALUETYPE is defined to 1 by default. </li>

<li>
New command line option -So added to suppress generation of ostream
operators for exceptions. </li>

<li>
New command line option -Sc added to suppress generation of tie classes
and *S_T.* files. The default is still to generate them. </li>

<li>
IDL compiler now handles escaped identifiers (CORBA 2.3.1). An identifier
appearing in an IDL file with a leading underscore will appear in
generated code without the underscore. This enables the use of identifiers
in generated code identical to IDL keywords, as specified in CORBA 2.3.1.
If the resulting identifier matches a C++ keyword, "_cxx_"
will be prepended in generated code as before. </li>

<li>
The -St option to suppress generation of typecodes now also suppresses the
generation of the Any insertion and extraction operators. The extraction
operators require the associated typecode, so the generated code for those
operators would not compile when the -St option was used. </li>

<li>
Option -Ge 2 added which generates 'throw' instead of ACE_THROW_SPEC, ACE_THROW,
and ACE_RETHROW. Since the expansion of ACE_THROW_RETURN is platform-dependent,
it was left as is. Same for TAO_INTERCEPTOR_THROW, since it sometimes
expands to ACE_THROW_RETURN. Of course ACE_HAS_EXCEPTIONS must be defined for
this option to work.</li>

<li>
Removed generation of ostream operators for user exceptions, along with the
command line option to suppress this generation. The ostream operator
defined in the base class CORBA::Exception works fine and produces the same
output.</li>

<li>
The TAO IDL compiler is no longer monolithic. It is composed of a top-level
executable, a front end library and a back end library. This will enable
different back ends to be plugged in for code generation in different
languages, and for IfR administration. Different back ends may require
a few changes to the executable (described below), but the front end
library can remain unchanged. The chain of dependencies is as follows:
<blockquote>
FE : ACE<br>
BE : FE<br>
EXE : FE, BE<br>
</blockquote>
Executing the Makefile (or the TAO_IDL Compiler project in the MSVC 'tao_idl'
workspace) will build whatever is required in the proper order, as before.
Back end files, classes and functions required by the executable are as follows:
<blockquote>
be.h - file containing #includes of the major BE file headers.<br>
TAO_Codegen - class, holds output stream references for the various generated files.<br>
TAO_CODEGEN - ACE_Singleton typedef of the above class.<br>
tao_cg - pointer to instance of TAO_CODEGEN.<br>
be_generator - class, inherits from AST_Generator in FE and generates AST nodes.<br>
void BE_produce (void) - global function, starts AST traversal for code generation.<br>
BE_GlobalData - class, holds default/command line arg settings specific to BE.<br>
be_global - pointer to instance of above class.<br>
</blockquote>
All the code in the executable that may need to be modified for different back
ends in contained in the file drv_args.cpp. Code in this file processes the
command line arguments, outputs a usage message, and performs other miscellaneous
BE initiialization.</li>
</ul>

<p><br>Known bugs/unimplemented constructs:
<ul>
<LI>At this point there are no known problems with the IDL compiler
</LI>
</ul>
Future work:
<ul>

<p>Goal is to measure the code size of the interpretive stubs generated
by TAO IDL compiler <i>vs</i> code size of compiled stubs. Then compare
the performance of each. We want to prove the thesis that TAO IDL compiler
generated interpretive stubs have a small code size, yet are comparable
in performance (or slightly less) than compiled stubs. Hence, it will be
useful for small distributed equipment such as handsets, PDAs, etc.
<p>In doing the above, improvements to the IIOP protocol engine in terms
of size/performance/determinism will be made.
<li>
Tweak the IDL compiler to generate code that's more easily integrated back
into the ORB Core, e.g., POA, etc. This will depend largely on our ability
to generalize the changes necessary to generated code.</li>

<li>
The generated sequence classes should not be generated per sequence, but
per type and parent scope. Which means, that the overhead of having the
source code generated serveral times should be reduced. To do this, an
extra pass over the internal representation of the IDL file has to be done.</li>

<li>
Unix's native wchar_t type is not compatible with Unicode. CORBA wide string
implementations are required to support Unicode, but are not restricted to
it, so the IDL compiler should ultimately support Unix's wchar_t as well.
</ul>



<br><!--#include virtual="orbcore.html" -->
<hr>

<h3>
<a NAME="pp"></a>Pluggable Protocols</h3>
Point of contact: <a href="mailto:ossama@uci.edu">Ossama Othman</a>
<p>The goal of the pluggable protocol effort is to (1) identify logical
communication layers in the ORB, (2) abstract out common features, (3)
define general interfaces, and (4) provide necessary mechanisms for
implementing different concrete ORB and transport protocols. TAO's pluggable
protocol framework will allow disparate communication mechanisms to be
supported transparently, each with its own set of requirements and strategies.
<p>For example, if the ORB is communicating over a system bus, such as
PCI or VME, and not all the features of GIOP/IIOP are necessary and a simpler,
optimized ORB and transport protocol can be defined and implemented. Similarly,
it should be straightforward to add support for new transport protocols
that use native ATM or shared memory as the underlying communication mechanism.
In all cases the ORB's interface to the application will remain compliant
with the OMG CORBA standard.
<p>There will be several stages of the development process: (1) basic
pluggable transport protocols framework, (2) support for multiple profiles,
(4) add example transport protocols, such as ATM and VME, and refine/optimize
the transport protocols framework, and (4) add support for pluggable ORB
protocols, e.g., replacements for GIOP. Each of these steps is outlined
below:
<ul>
<li>
<b>Basic pluggable transport protocols framework</b>: We have added
several Bridge classes that decouple the transport-specific details from
the rest of TAO's ORB Core. This allows us to isolate the details of how
messages are communicated at the transport layer in a few classes. This
design resulted in the restructuring of the ORB Core and how requests are
handled.  For instance, there is now the concept of communication layers:
Objects (e.g., references, method invocations, etc.), ORB Messaging, Transport,
and Network. The Object layer is just the usual stubs and skeletons.</li>

<p>The common interfaces have been defined in the new abstract classes
that form the core of TAO's pluggable protocol framework, e.g.,
<tt>TAO_Connector</tt>,
<tt>TAO_Acceptor</tt>,
<tt>TAO_Profile</tt>
and <tt>TAO_Transport</tt>. Two new mechanisms for keeping track of supported
transport protocols are the
<tt>TAO_Connector_Registry</tt> and
<tt>TAO_Acceptor_Registry</tt>,
which are essentially Abstract Factories that produce the right types of
connector, acceptors, and transports. <p>
<li>
<b>Multiple Profile</b> - Support for more than one profile per object.
This is important since there may be several different ways to access an
object. Each profile for an object may encode information pertaining to
QoS, network and transport protocols, addresses or routes.<p>

<li>
<b>Example Transport protocols</b> - Aside from IIOP, three additional
transport protocols are distributed with TAO:
<ol>
<P><li>UIOP: GIOP over local IPC (UNIX domain sockets)</li>
<P><li>SHMIOP: GIOP over shared memory</li>
<P><li>SSLIOP: IIOP over SSL (Secure Socket Layer).
</ol>

<P>
Other interesting transport protocols could be for ATM, Buses (VME or
PCI), TP4, GSMP, and UDP/IP.  TAO users have also created their own
pluggable transport protocols, such as a ScramNet pluggable protocol.

</li>


<P><li>
<b>Pluggable ORB protocols</b> - This step will add support for ORB protocols
besides GIOP. In particular, we will explore lightweight protocols using
shared memory and system buses like PCI or VME.</li>
</ul>
Current Status:
<ul>
<li>

The basic framework to support pluggable transport protocols has been
completed.  The standard TAO regression tests <tt>MT_Cubit</tt>,
<tt>Multiple_Inheritance</tt>, <tt>CDR</tt> and <tt>EC_Throughput</tt>
can be used to verify performance using the new framework.</li>

<P><li>
            Multiple endpoint support in the ORB has been added.  A
            list of TAO_Acceptors is kept in the Acceptor
            Registry. When the ORB needs to create an IOR it iterates
            over all the acceptors to do so. Using either multiple
            <a href="../ORBEndpoint.html"><code>-ORBEndpoint</code></a>
            options or several endpoints separated by semi-colons ';',
            the user can specify what addresses the ORB should use.
            Each endpoint is specified in URL format (ex:
            <code>iiop://foo.bar.com:0</code>), this format can be
            extended to support different protocols.
</li>

<P><li>
            If the user does not specify a list of endpoints then the
            ORB creates a default endpoint for each protocol
            configured, unless the pluggable protocol explicitly
	    prevents that in an effort to prevent resource leaks.
</li>

<P><li>
            Added support for multiple Connectors in the ORB, the ORB
            finds the correct connector based on the tag for the
            profile.
</li>

<P><li>
	    Added support for multiple profiles in the IORs, when the
            ORB demarshals an IOR it queries the Connector Registry to
            create the right kind of profile for the known protocols.
            If one of the protocols is unknown we create a special
            profile class that can only be used for marshaling and
            demarshaling, not communication.
</li>

<P><li>
	    Enabled the UIOP protocol.  This protocol uses local IPC
            (aka UNIX domain sockets) as the transport mechanism.  The
            protocol is loaded by default.

</li>

<P><li>
	    Enabled the SHMIOP protocol.  This protocol uses shared
	    memory as the transport mechanism.  The protocol is loaded
	    by default.
</li>

<P><li>
	    An IIOP over SSL pluggable protocol called "SSLIOP" has
	    been implemented.  It provides secure communication
	    between hosts that support IIOP over SSL, and is meant to
	    be a drop-in replacement for the IIOP pluggable protocol.
	    TAO's SSLIOP pluggable protocol implementation supports
	    both the standard IIOP transport protocol and the secure
	    IIOP over SSL transport protocol.

	    <P>
	      No changes were made to the core TAO sources to provide
              to this SSL support, nor does TAO contain any security
              related hooks.  TAO's SSLIOP implementation is
              completely self-contained.  This ensures that the core
              TAO sources remains free of export restrictions.
</li>

<P><li>
	    Protocols can be dynamically loaded into the ORB: The
            default resource factory reads the protocol "names" from
            its list of arguments.  These protocol names are used to
            load an abstract factory via the service configurator.
            This factory can create acceptors or connectors on demand.
            By default only IIOP is loaded.
</li>

<P><li>

The service configurator is now used to load protocol factories.

</li>

<P><li>
	    Support for the <code>-ORBHost</code> and
            <code>-ORBPort</code> has been removed. The new
            <a href="../ORBEndpoint.html"><code>-ORBEndpoint</code></a>
            option supersedes them, and provides the same
            functionality in a protocol-neutral way.  If the
            deprecated options are used, the ORB exits with a 
            <code>CORBA::BAD_PARAM</code> exception, indicating an
            unknown <code>-ORB</code> option.
</li>

<P><li>
            The <code>-ORBPreconnect</code> ORB option has been
            deprecated in favor of the standard
            <code>validate_connection</code> run-time feature.
            Support for this option will be removed from future
            releases.
</li>

<P><li>
            The URL style object reference format has been updated to
            conform with the format that <code>corbaloc</code>
            uses. The BNF specification for <code>corbaloc</code> is:

<blockquote><code>

&lt;corbaloc&gt; = "corbaloc:/"[&lt;obj_addr_list&gt;]["/"&lt;key_string&gt;]<br>
&lt;obj_addr_list&gt;= [&lt;obj_addr&gt; ","]* &lt;obj_addr&gt;<br>
&lt;obj_addr&gt;= &lt;prot_addr&gt; | &lt;future_prot_addr&gt;<br>
&lt;prot_addr&gt;= &lt;rir_prot_addr&gt; | &lt;iiop_prot_addr&gt;<br>
&lt;rir_prot_addr&gt;= &lt;rir_prot_token&gt;":"<br>
&lt;iiop_prot_addr&gt;= &lt;iiop_id&gt;&lt;iiop_addr&gt;<br>
&lt;iiop_id&gt;= ":" | &lt;iiop_prot_token&gt;":"<br>
&lt;iiop_prot_token&gt; = "iiop"<br>
&lt;iiop_add&gt; = [&lt;version&gt; &lt;host&gt; [":" &lt;port&gt;]]<br>
&lt;host&gt; = DNS-style Host Name | ip_address<br>
&lt;version&gt; = &lt;major&gt; "." &lt;minor&gt; "@" | empty_string<br>
&lt;port&gt; = number<br>
&lt;major&gt; = number<br>
&lt;minor&gt; = number<br>
&lt;future_prot_addr&gt;    = &lt;future_prot_id>&lt;future_prot_addr&gt;
&lt;future_prot_id&gt;    = &lt;future_prot_token&gt;":"
&lt;future_prot_token&gt; = possible examples: "atm" | "dce"
&lt;future_prot_addr&gt;    = protocol specific address 
&lt;key_string&gt; = &lt;string&gt; | empty_string<br>
</code></blockquote>

            The <code>uiop</code> URL style object references syntax
            is:

<blockquote><code>
&lt;uioploc&gt; = "uioploc://"[&lt;addr_list&gt;]["|"&lt;key_string&gt;]<br>
&lt;addr_list&gt;= [&lt;address&gt; ","]* &lt;address&gt;<br>
&lt;address&gt; = [&lt;version&gt; &lt;rendezvous point&gt;]<br>
&lt;rendezvous point&gt; = Valid Filesystem Path<br>
&lt;version&gt; = &lt;major&gt; "." &lt;minor&gt; "@" |
                empty_string<br>
&lt;major&gt; = number<br>
&lt;minor&gt; = number<br>
&lt;key_string&gt; = &lt;string&gt; | empty_string<br>
</code></blockquote>

            Note that the key string delimiter for <b><code>uiop</code></b>
            is a vertical bar `<b><code>|</code></b>' (the command line
            "pipe" symbol) not a forward slash
            `<code>/</code>'.  A delimiter other than a
            forward slash is needed to prevent ambiguities of
            where the rendezvous point ends and where the key
            string begins since both may contain forward
            slashes in them.  The new <code>corbaloc:uiop</code> URL
            format may also be used.
	    <p>
            It should be noted that these formats have been superseded
            by the new <code>corbaloc</code>
            <a href="../INS.html">Interoperable Naming Service</a>
            support.
</li>

<P><li>
            The <i>rendezvous point</i> for <code>uiop</code> is
            any valid path and filename that the ORB has permission to
            read and write to.  However, UIOP rendezvous points have
            the same restrictions that local IPC has.  The following
            are some guidelines that will help ensure successful use
            TAO's UIOP pluggable transport protocol:
                <blockquote><li>
                  To guarantee portability, local IPC rendezvous
                  points (including the path and filename) should not
                  be longer than 99 characters long. Some platforms
                  may support longer rendezvous points, usually 108
                  characters including the null terminator, but
                  Posix.1g only requires that local IPC rendezvous
                  point arrays contain a maximum of <b>at least</b>
                  100 characters, including the null terminator.<P>

                  If an endpoint is longer than what the platform
                  supports then it will be truncated so that it fits,
                  and a warning will be issued.
                </li>
                <P><li>
                  Avoid using <em>relative</em> paths in your UIOP endpoints.
                  If possible, use <b><em>absolute</em></b> paths
                  instead.  Imagine that the server is given an
                  endpoint to create using <code>-ORBEndpoint
                  uiop://foobar</code>.  A local IPC rendezvous
                  point called <code>foobar</code> will be created
                  in the current  working directory.  If the client
                  is not started in the directory where the
                  <code>foobar</code> rendezvous point exists then
                  the client will not be able to communicate with
                  the server since its point of communication, the
                  rendezvous point, was not found. On the other
                  hand, if an absolute path was used, the client
                  would know exactly where to find the rendezvous
                  point.
                  <P>
                  It is up to the user to make sure that a given UIOP
                  endpoint is accessible by both the server and
                  the client.
                </li>
                <P><li>
                  It is important to be consistent in the use of
                  absolute paths and relative paths for rendezvous
                  points.  The two types of paths should not be used
                  for the same endpoint.  For example, if
                  <code>uiop:///tmp/foo</code> is specified as the
                  server endpoint and <code>uiop://foo</code> as a
                  preconnect for a client in <code>/tmp</code>, then
                  the preconnection may be established but it is
                  likely it won't be used since the endpoint and
                  preconnect are interpreted as different strings,
                  i.e. <code>/tmp/foo</code> and <code>foo</code> are
                  not the same, lexicographically.  On the other
                  hand, if both the endpoint and the preconnect are
                  the same string then a preconnection will be
                  established and used successfully.<P>
                </li></blockquote>

            The <a href="../ORBEndpoint.html"><code>-ORBEndpoint</code></a>
            option uses a syntax similar to that of the URL style
            object reference shown above.  The only difference is that
            the object key delimiter and the object key string are not
            specified. 
</li>

<P><li>
	    Added documentation that describes how to implement
	    pluggable transport protocols for TAO.  The document is
	    available
	    <A HREF="../pluggable_protocols/index.html">here</A>.
</li>

<P><li>
	    TAO's IIOP pluggable protocol now supports automatic
	    creation of profiles for endpoints created on a host with
	    multiple network interfaces.  It should no longer be
	    necessary to manually specify an endpoint for each network
	    interface.
	    <P>
	      This means that server IORs will contain profiles for
	      all of the default endpoints created on each network
	      interface the server is listening on, if no explicit
	      endpoints were specified.
</li>

</ul>

<P>
Known Issues:

<ul>
<li>
</ul>
Critical Work:

<ul>
<li>
None.
</li>

<p><p>
</ul>
Future Work:
<ul>
<li>
Complete support for multiple ORB messaging protocols.

<li>
Long term work will include adding support for pluggable ORB protocols,
as well as transport protocols. This way we can develop optimal messaging
and transport protocols for a given platform.</li>

</ul>

<p>
<hr>


<h3>
<a NAME="poa"></a>Portable Object Adapter (POA)</h3>
Point of contact: <a href="mailto:irfan@cs.wustl.edu">Irfan Pyarali</a>
<P>
The POA associates servants with the ORB and demultiplexes incoming
requests to servants. <P>

<p>Current Status:
<ul>
<li>
TAO supports the POA spec. This section will carry updates as available.</li>
</ul>
Known issues:

<ul>

</UL>

Future work:
<ul>

</ul>

Recently completed work:<P>

<ul>

<li> ORB::shutdown now properly deactives all the POA
Managers. </li><P>

<li>

POA Managers in TAO were previously ignored in the request processing
path on the server. This is now fixed such that their state is checked
before dispatching the client request to the servant. Only if the
state is <CODE>ACTIVE</CODE>, is the request dispatched to the
servant.  Otherwise, the request is rejected. Since POA Managers start
off in <CODE>HOLDING</CODE> state, make sure to
<CODE>activate()</CODE> them before falling into the event loop.

</li><P>

<li> TAO's POA now properly supports both the threading policies:
SINGLE_THREAD_MODEL and ORB_CTRL_MODEL. </li><P>

<li>The synchronization in the POA is now very optimal. For example,
the locks are not held across the invocation on the servant. The locks
are also not held across the invocation on the AdapterActivator and
ServantManagers. This allows us to use regular locks instead of
recursive locks inside the POA. This also allows multiple threads to
dispatch requests on the same POA simultaneous.</li><P>

<li>TAO now supports reference counting between POA and servants,
including the new RefCountServantBase and ServantBase_var
classes. RefCountServantBase is a reference counted base class that
was added to the CORBA specification to avoid race conditions for
servant deletion in threaded servers. <a
href="ftp://ftp.omg.org/pub/docs/orbos/98-07-12.pdf">ftp://ftp.omg.org/pub/docs/orbos/98-07-12.pdf</a>
contains the relevant text. Check <a
href="../poa_migration.html#Reference counting Servants">here</a> on
some hints to avoid trouble.</li><P>

<li> The POA now supports active demultiplexing of servants in the
SYSTEM_ID and the USER_ID policy. This should make the POA faster and
more predictable since there is no hashing involved and the index of
the slot where the servant is registered is in the Object Key.</li>
<P>

<li> Previously, the complete POA name was used as the POA
identity. This scheme was inefficient in many ways including: (a) the
complete POA name can be significantly large in size, and therefore,
ineffient to pass with every method call from the client to the
server; (b) it is varible in size, and therefore, does not lend itself
to smart and effective parsing; (c) the searching based on the
complete POA name is very ineffient.</li>

<p> The new solution is to use an active demux table, and flatten the
POA hierarchy. This will help in the searching since active demuxing
is fast and predictable. This will also help in the parsing since the
demux key will be fixed size.

<p> Note that for persistent ids, we have to pass the complete POA
name in addition to the demux key in order to handle POA creation on
demand.<P>

<li> There were some POA objects in a typical server that are not
freed up properly, resulting in a memory leak. This has now been
fixed.</li> <P>

<li> Timestamps in persistent IORs were not required and have been
removed.</li> <P>

<li> POA exceptions are not not system exceptions and have been
removed from the list of system exceptions.</li> <P>

<li> Vastly improved the ability of the POA to deal with user
exceptions, memory allocation failures, and constructor failures.</li>
<P>

<li> We now support a minimum POA for the minimum CORBA specification.
Recently, this feature was enchanced such that the minimum CORBA
footprint was further reduced.  In addition, minimum POA can be
enabled/disable irrespective of the minimum CORBA setting.</li> <P>

<li> We have decided not to support active demuxing for method name
lookup. The benefit of this optimization was questionable since the
current perfect hashing scheme provide very good and predictable
behavior.</li> <P>

Also, note that this optimization will require many changes. We would
have to use the help of the IDL compiler to modify the object key that
is passed for every method call differently. Note that this scheme
doesn't work in the case of multiple inheritance or when the client
stubs are not TAO.<P>

<li> Improved the parsing of object keys belonging to the
RootPOA. Since this is the default POA and is commonly used, we have
given it a reserved byte in the object key in order to quickly
identify it. With the reserved bit, the active demux key for the
RootPOA is not used, and no map lookups are required.</li> <P>

<li> POA name separator was changed from '/' to '\0'.  Since POA names
are strings, this makes a better choice since there is no chance of a
conflict with the string specified by the user. </li> <P>

<li> We have support for reactivating servants with system generated
ids.  </li> <P>

<li> The TAO specific synchronization POA policy has been
removed. </li> <P>

<li> New examples have been added to show how servants can be
dynamically loaded from DLLs on demand. </li> <P>

<li> Support for collocation should be much better now because the POA
can tell if we created the object reference.</li><P>

<li> After Nanbor's recent changes for collocation, we support the
full semantics of remote objects on a collocated object. The spec
mandates that collocated object should behave <i>exactly</i> like
remote objects, which includes going through the POA, running the
Servant Managers, running the interceptors, and expecting the
reference counting behavior provided by the POA.  Note that the old
scheme of direct call through to the servant is also still
available. </li><P>

</UL>
<hr>

<h3>
<a NAME="interfrepo"></a>Interface Repository</h3>
Point of contact: <a href="mailto:parsons@cs.wustl.edu">Jeff Parsons</a><P>

The Interface Repository provides run-time information about IDL
interfaces.  Using this information, it is possible for a program to
encounter an object whose interface was not known when the program was
compiled, yet, be able to determine what operations are valid on the
object and make invocations on it using the DII.

<p>Current Status (as of August 27, 2000):
<ul>

<LI><P>First pass implementing the new Dynamic Any interfaces.
  </P>
</LI>

<li> Implementation of Interface.idl completed, for types fully supported
by TAO. This excludes valuetypes and all types related to components. </li><p>

<li> TypeCodeFactory methods completed except for the types mentioned above
and for recursive types.</li><p>

<li> Test code for Interface.idl methods and for
resolve_initial_references ("InterfaceRespository") completed.</li><p>

<li> Multicast discovery of IFR service debugged and tested.</li><p>

<li> Read/write locking option added.</li><p>

<li> Persistent IFR tested.</li><p>

</ul>

<p>Known Issues:
<ul>
<li> With the chosen design, calling move() on a Contained IR object will
invalidate the object reference, since the object ID is based on the path
to the object in the database. This is not expected to be a serious problem
in the forthcoming implementation of automatic IFR administration, but users
should be aware of this, if they attempt to write their own IFR administration
code.</li><p>

</ul>

<p>Recent Work:
<ul>
<li> The Interface Repository Service has been added to TAO, in
ACE_wrappers/TAO/orbsvcs/IFR_Service. The implementation follows the
expanded IDL found in CORBA Components vol. III. The database used to store
IR objects is an ACE tool called ACE_Configuration, written by
<a href="mailto:chafey@stentorsoft.com">Chris Hafey</a>. This
class represents its contents to the user as a tree of hash maps.
By specifying a disk file to read from at startup, the storage may
be made persistent. There is also an option to use a win32 registry
to store the data, although persistence is not available with this
option.</li><p>

<li> The create_*_tc functions have been moved from the ORB (CORBA 2.x) to
a new class TypeCodeFactory (CORBA 3.0). The TypeCodeFactory is built as
a separate DLL, and can be dynamically loaded into a running TAO ORB
by calling resolve_initial_references ("TypeCodeFactory").</li><p>

<li> Several methods have been added to class TypeCodeFactory, including
create_exception_tc, create_alias_tc, create_native_tc, create_wstring_tc,
create_value_box_tc, and create_union_tc. Union typecodes with both
multiple and default case labels have been tested.</li><p>

<li> Test code for the IFR service has been added in the directory
ACE_wrappers/TAO/orbsvcs/tests/InterfaceRepo/IFR_Test.</li><p>

<li> Code to support multicast discovery of the Interface Repository
IOR has been added to TAO. Testing has been done using loopback on NT,
loopback on Solaris, and remotely between these two platforms in both
directions.</li><p>

<li> Read/write locking option added to IFR service. This option should be
used if the IFR service is started using a service config file that
chooses the thread-per-request threading model.</li><p>

<li> A test of the persistence option for the IFR added in the directory
ACE_wrappers/TAO/orbsvcs/tests/InterfaceRepo/Persistence_Test.</li><p>

</ul>

<p>Future Work:
<ul>
<li> Implement administration of the IFR. The current plan is to modify the
IDL compiler to generate an XML file in a special directory for each IDL
file processed. Then these XML files can be parsed and the IFR populated
with their contents at any time.</li><p>

<li> Implement the CORBA::Object methods get_interface_def (CORBA 3.0) and
get_interface (CORBA 2.x), the latter for backward compatibility.</li><p>

<li> Add support for recursive structs and unions to the IFR, and for
their typecodes to the TypeCodeFactory.</li><p>

<li> When Object By Value is fully supported in TAO (support is rudimentary at
present), implement methods for classes ValueDef and ValueMemberDef in the IFR,
and implement create_value_tc in TypeCodeFactory.</li><p>

<li> When component support is added to TAO, implement methods for ComponentDef,
ComponentRepository and related classes in the IFR, and create_component_tc and
create_home_tc in TypeCodeFactory.</li><p>

<li> Add pluggability for commonly used OTS databases.</li><p>

</ul>

<p>

<hr>

<br><!--#include virtual="OBV.html" -->

<h3>
<a NAME="nservices"></a>CORBA Naming Service and Interoperable Naming Service</h3>
Points of contact: <a href="mailto:marina@cs.wustl.edu">Marina
Spivak</a> and <a href="mailto:vishal@cs.wustl.edu">Vishal Kachroo</a>
<p>

OMG defined CORBA Naming Service (spec <a
href="ftp://www.omg.org/pub/docs/formal/97-07-12.pdf">here</a>) to
provide a basic service location mechanism for CORBA systems.  Naming
Service manages a hierarchy of name to object reference mappings.
Servers register themselves with the Naming Service by providing their
name and object reference.  Clients can then use the Naming Service to
obtain an object reference for the service of interest based on its
name.
<p>

More recently, CORBA Naming Service was subsumed/extended by the CORBA
Interoperable Naming Service, a.k.a. INS (spec <A
HREF="ftp://ftp.omg.org/pub/docs/orbos/98-10-11.pdf">here</A>).  INS
inherits all the functionality from the original Naming Service
specification in addition to addressing some its shortcomings.  In
particular, INS defines a standard way for clients and servers to
locate the Naming Service itself.  It also allows the ORB to be
administratively configured for bootstrapping to services not set up
with the orb at install time. <a href="../INS.html">This page</a>
provides a brief description of additional features INS provides, and
how they are implemented in TAO.  <P>

<p>Current status (as of 30th Apr 2000):
<ul>
<li>
Implementation of the CORBA Naming Service spec is completed.  TAO's
Naming Service provides an optional persistence capability.</li>
</ul>
Recently completed work:
<ul>
<li>
Added support for Persistence (using memory-mapped files).  Persistence
feature is optional, and is controlled by the command line argument.</li>

<li>
Updated the implementation of the Naming Service to use new ACE
exception macros.</li>
<li>
Added support for the InterOperable Naming Service, which enables the
ORB to support IORs in user-friendly <CODE>corbaloc</CODE> format.
These features allow the ORB to be configured to return arbitrary object
references from <CODE>CORBA::ORB::resolve_initial_references</CODE>
for non-locality-constrained objects. Two options -ORBInitRef and
-ORBDefaultInitRef have been added to the orb for bootstrapping to
arbitrary services.
</li>

<li>Added support for the Naming service to act like an agent: to understand IIOP
request messages from clients and respond with reply messages with a
LOCATION_FORWARD/OBJECT_NOT_EXIST status. The Naming Service can be
configured through ORB options to register arbitrary services given
the URL-format IOR for the service. The resolve_initial_references ()
resolves a service in the following order :
<br>1. -ORBInitRef
<br>2. -ORBDefaultInitRef
<br>3. Multicast to service.
</li>
<li>
Added a test for the InterOperable Naming Service that works in
conjunction with the current TAO examples.
</li>
<li>
Implementation of the CORBA INS spec is completed.  The
following features are now supported:
  <ul>
  <li> corbaname format </li>
  <li> NamingServiceExt interface</li>
  </ul>
</li>

</ul>

Future work:
<ul>
<li>
Support for a load balancing feature similar to the one present in ORBIX.
It will be possible to bind a group of objects under a single name, and when a client attempts to resolve the name in question, a preset policy (e.g., random, round robin, etc.) will determine which one of the object references from the group will be returned.
</li>
<li>
Support for the Naming Service to handle the IIOP
LocateRequest messages and respond with LocateReply messages with a
LOCATION_FORWARD/OBJECT_NOT_EXIST status.
</li>
</ul>

<p>
<hr>

<h3>
<a NAME="tservices"></a>CORBA Trading Service</h3>
Point of contact: <a href="mailto:sbw1@cs.wustl.edu">Seth Widoff</a>

<p>The <a href="http://www.omg.org/corba/sectrans.htm#trader"> Trading
Service</a> is an implementation of the COS Trading Service
speficiation that meets the Linked Trader conformance criteria --- it
implements the <tt>Lookup</tt>, <tt>Register</tt>, <tt>Admin</tt>, and
<tt>Link</tt> interfaces, but not the <tt>Proxy</tt>
interface. Notably, the TAO trader supports the following features:<P>
<ul> <li> Multithreaded operation;</li>

<li>
Trader federations and distributed queries;</li>

<li>
Dynamic properties;</li>

<li>
Modifiable properties;</li>

<li>
All policies described in the specification;</li>

<li>
Preference sorting;</li>

<li>
Service type inheritance hierarchies and subtype searching.</li>
</ul>
<a href="trader.html">Trading Service documentation</a> is also available.
<p>Future Work:
<ul>
<li>
The Proxy Interface.</li>

<li>
Persistent storage of service types and offers.</li>
</ul>
<p>
<hr>

<h3>
<a NAME="pservices"></a>CORBA Property Service</h3>
Point of contact: <a href="mailto:alex@cs.wustl.edu">Alexander Babu
Arulanthu</a>

<p>Current status (as of Mar 9th, 1999): All the interfaces of this
service have been implemented.  Please
go through the test examples at $TAO/orbsvcs/tests/CosPropertyService.
Property Service is has been used by the TAO's <a href="#av">Audio Video Streaming
Service</a>developed for TAO. For general documentation of the
Property Service, please read <a
href="http://www.omg.org/corba/sectrans.html#prop">The Property Service
Specification.</a>

<P>Recent Work:
<ul>
 <li>
     Changed the PropertyException from Exception to struct, according
     to the OMG's changes.
 </li>
 <li>
     Changed the implementation to allocate storage for the Sequence
     out parameters, eventhough their length is 0. This is according
     to the CORBA specification.
 </li>
</ul>

<p>
<hr>

<h3>
<a NAME="cservices"></a>CORBA Concurrency Service</h3>
Point of contact: <a href="mailto:tworm@cs.wustl.edu">Torben Worm</a>
<p>Current status (as of May 3rd):

The <a href="http://www.omg.org/corba/sectrans.htm#concur">
Concurrency Service</a> provides a mechanism that allows clients to
acquire and release various types of locks in a distributed system.<P>

<ul>
<li>
A simple version of the Concurrency Service has been implemented, i.e.
a version without transactions. It is currently being tested.</li>
</ul>
Future Work:
<ul>
<li>
Implementation of the Concurrency Service with transactions</li>
</ul><P>
<hr WIDTH="100%">
<h3><a NAME="av"></a>CORBA Audio/Video Streaming Service</h3>
Point of contact: <a href="mailto:naga@cs.wustl.edu">Nagarajan
Surendran</a> and <a href="mailto:yamuna@cs.wustl.edu">Yamuna Krishnamurthy</a>
<p>This is an implementation of the OMG spec addressing the <a href="http://www.cs.wustl.edu/~sumedh/research/corbaav.pdf">Control
and Management of Audio/Video Streams</a>.For more documentation on
TAO's A/V Service please have a look <A HREF="http://www.cs.wustl.edu/~schmidt/av.html">here</A>.

<p><h4>Current Status:</h4> (as of Sep 1st 1999)
<p>
<ul>
  <li>
      The audio/video streaming service has been implemented in the full
      profile. The current implementation support all the flow related
      components like flowEndpoint,FDev,FlowConnection,..,etc.
  </li>
  <li>
      Point-to_Point and Point-to-MultiPoint streams have been
      implemented.
  </li>
  <li>
      A Pluggable protocols framework has been implemented to flexibly
      add new flow protocols like SFP, RTP and new transports like
      ATM. The current implementation has protoocol implementations
      for SFP, RTP over UDP and Multicast UDP. Please look at this<A
      HREF="http://www.cs.wustl.edu/~naga/pluggable_av.ps.gz"> paper
      </A> for more documentation about the implementation.
  </li>
  <li>
      A Videoconferencing application based on Vic, a MBONE tool, has
      been implemented using the AV components. Please contact <A
      HREF="mailto:yamuna@cs.wustl.edu"> yamuna</a> or <A
      HREF="mailto:naga@cs.wustl.edu"> Naga </A> if you're interested.
  </li>
  <li>
      An MPEG-1 application which streams mpeg-1 video and mpeg-1 audio
      separately has been developed using the service. The client side
      of the mpeg player requires X windows support.Its available in
      the release at $TAO_ROOT/orbsvcs/tests/AVStreams/mpeg/source.
  </li>
  <li>
      An Integrated Video-on-demand application has been developed
      using the Trading Service and the A/V Service. The demo uses a
      Java FrontEnd and JNI to talk to the TAO C++ trader client. The
      demo is available in the release at
      $TAO_ROOT/orbsvcs/tests/AVStreams/server_discovery.
  </li>
</ul>
<p>Work in progress:
<ul>
  <li>
      Adding more features to the VideoConferencing application
      eg. porting vat, the audio counterpart of vic to use AV components.
  </li>
  <li>
      Adding ATM AAL5 protocol support.
  </li>
  <li>
      Adding QoS implementation.
  </li>
</ul>

<hr>

<p><a NAME="ts"></a><b>CORBA Time Service</b>
<p>Point of contact: <a href="mailto:vishal@cs.wustl.edu">Vishal Kachroo</a>

<p> The <a href="ftp://ftp.omg.org/pub/docs/formal/97-02-22.pdf">Time Service</a>
 allows clients to connect to Time Service Clerks and obtain globally
synchronized time. This time is calculated from the time obtained from
one or more Time Servers running on multiple machines in the
network. The service uses the TAO Implementation Repository to
activate the time servers on demand.

<p>Current status (as of 10th Jan 1999):
<ul>
<li>
Implementation of a Distributed CORBA Time Service is complete.</li>
</ul>
Future work:
<ul>
<li>
Currently the average of the time obtained from the various servers is
considered the global notion of time. A better distributed time synchronization
algorithm can be used in the future.</li>

<li>
Implementation of the Timer Event Service.</li>
</ul>
<p>

<hr WIDTH="100%">
<h3>
<a NAME="ec"></a>CORBA Event Service</h3>

<h4>
Last updated: Fri Mar  5 20:38:26 CST 1999</h4>
Point of contact: <a href="mailto:pradeep@cs.wustl.edu">Pradeep Gore</a>
<p>The COS compliant Event Service implements the Event Service Specification:
<a href="http://www.omg.org/docs/formal/97-12-11.pdf">(.pdf)</a>,
<a href="http://www.omg.org/docs/formal/97-12-11.ps">(.ps)</a>
<br>This implementation is based on the Real Time Event service.
<h3>
Features in this release:</h3>

<ul>
      <li><P>There is a new implementation of the COS Event Service
	  available.
	  This new implementation supports both the Push and Pull
	  styles for event communication, and it does not require the
	  Real-time Event Service to work.
	</P>
      </LI>

      <LI><P>A new testsuite for the COS Event Service has been
	  started, they are available at:
	  <CODE>$TAO_ROOT/orbsvcs/tests/CosEvent/</CODE>
	</P>
      </LI>

      <LI><P>A new example for the COS Event Service is provided in
	  <CODE>$TAO_ROOT/orbsvcs/examples/CosEC/Simple/</CODE>
	</P>
      </LI>

      <LI><P>A new binary to run the native COS Event Service was
	  added, it is compiled in:
	  <CODE>$TAO_ROOT/orbsvcs/CosEvent_Service/CosEvent_Service_Native</CODE>
	</P>
      </LI>

<li>
A simple test (<tt>$TAO_ROOT/orbsvcs/tests/CosEC_Basic</tt>) demonstrates
how to create and use the event channel.</li>

<li>
Event Service (<tt>$TAO_ROOT/orbsvcs/CosEvent_Service</tt>)The Event Service
creates a COS compliant event channel and registers it with the naming
service with the default name "CosEventChannel".</li>

<br>Please read the associated README for more details.

<li>
CosEC_Multiple: <tt>($TAO_ROOT/orbsvcs/tests/CosEC_Multiple)</tt>:
This test demonstrates how multiple CosEC's connect to one RtEC and how
multiple consumers and producers exchange events in this configuration.</li>
</ul>
<h3>
Known bugs:</h3>
<ul>
<li>
CosEC_Multiple: <tt>($TAO_ROOT/orbsvcs/tests/CosEC_Multiple)</tt>:
Once the tests are done, the control doesn't return to the shell,
you have to say CTRL-C to get back to the prompt.
</li>
</ul>

<hr WIDTH="100%">
<h3><a NAME="log"></a>CORBA Telecom Log Service </h3>

<h4> Last updated: Sat Feb 19 16:58:42 CDT 2000 </h4>
Point of contact: <a href="mailto:krish@cs.wustl.edu">Krishnakumar Elakkara Pathayapura</a>
<p>The CORBA <a href="http://www.omg.org/cgi-bin/doc?telecom/99-05-01"> Telecom Log Service </a> prototype was released in TAO version 1.0.6.

<br>
<h3> Features supported in the first version:</h3>

<ul>
  <li>
      The Log Service implementation under <tt>$TAO_ROOT/orbsvcs/orbsvcs/Log</tt>
      implements the <tt>DsLogAdmin </tt>module.
      <br>
  </li>

  <li>
      The Logging_Service (<tt>$TAO_ROOT/orbsvcs/Logging_Service</tt>) starts the Log
      Service and registers the Log Service Factory with the Naming Service
      as "BasicLogFactory".
      <br>
  </li>
  <li>
      The test <tt>$TAO_ROOT/orbsvcs/examples/Log/Client</tt> demonstrates
      a simple use of the Log Service.
      <br>
      A thorough test <tt>$TAO_ROOT/orbsvcs/examples/Log/test/client</tt> tests
      most of the features of the logging service.
  </li>
  <li>
      The Query Language supported at present is "TCL".
	  The Log record id and Log record time are treated as properties
	  of the log and can be referenced in a query as "id" and "time"
	  respectively.
      <br>
  </li>
</ul>

<h3> Things to be done: </h3>
<ul>
  <li>
      Implement a few remaining methods - <br>
      For the <tt>Log</tt> interface: copy.<br>
      For the <tt>LogMgr</tt> interface: list_logs_by_id
      <br>
  </li>
</ul>

<h3> Future work and enhancements: </h3>
<ul>
  <li>
      Support the <tt>DsEventLogAdmin </tt> module, which uses
      the <a href= "#ec">COS Event Service </a>
      <br>
  </li>
  <li>
      Support the <tt>DsLogNotification </tt> module after the
      <tt>CORBA Notification Service</tt> is complete.
      <br>
  </li>
  <li>
      Currently all Log records are stored in memory, later we could add
      support for persistant storage.
      <br>
  </li>
  <li>
      Support "Extended TCL" as the Query Language.
      <br>
	  Support the record attributes as name-value pair properties.
	  <br>
  </li>
  <li>
	Use Red-Black trees to optimize lookup on frequently used query keys -
	namely record id's and time.
	<br>
  </li>
</ul>

<hr WIDTH="100%">
<h3><a NAME="notify"></a>CORBA Notification Service </h3>

<h4> Last updated: Wed Jul 19 16:49:50 CDT 2000 </h4>
Point of contact: <a href="mailto:pradeep@cs.wustl.edu">Pradeep Gore</a>
<p>
Work is in progress to implement the CORBA <a href="ftp://ftp.omg.org/pub/docs/telecom/99-07-01.pdf"> Notification Service </a>.
The implementation released in TAO 1.1 consists of the following
(see the associated README's for more information):
<ul>
	<li>
            The implementation of the interfaces in the Notification Service
            spec is in <tt>$TAO_ROOT/orbsvcs/orbsvcs/Notify</tt>.
	</li>

	<li>
            The service executable is implemented in
            <tt>$TAO_ROOT/orbsvcs/Notify_Service</tt>.
        </li>

        <li>
            The example in <tt>$TAO_ROOT/orbsvcs/examples/Notify/Filter</tt>
            shows a basic example of using filters.
	</li>

        <li>
            The example in <tt>$TAO_ROOT/orbsvcs/examples/Notify/Subscribe
            </tt> shows a basic example of how to use subscriptions.
        </li>

        <li>
            There is on-going work to add tests in
            <tt>$TAO_ROOT/orbsvcs/tests/Notify/
            </tt>
        </li>
</ul>

<h3> Features supported thus far:</h3>
The Notification Service supports all the interfaces defined in the spec
*except* Qos Properties, Pull interfaces and Typed Event style communication.
<br>
Please note the following:
<ul>
  <li>
      All features implemented so far are *code* complete and we are
      currently testing them.
  </li>

  <li>
      All Proxy objects support the <tt>Subscribe</tt> and <tt>Publish</tt>
      interface methods and will inform connected clients about
      <tt>subscription_change</tt> and <tt>offer_change</tt>.
  </li>

  <li>
      Assignment of ID's: All object factories assign ID's to objects created.
      The ID's are recycled when the objects are destroyed.
  </li>

  <li>
      For now, the SequenceProxyPushSupplier does not <tt>push</tt> to
      consumers.
      This will be done once we support the <tt>Maximum Batch Size</tt> QoS
      property.
  </li>

  <li>
      There are helper classes TAO_Notify_StructuredPushConsumer,
      TAO_Notify_StructuredPushSupplier and TAO_Notify_PushConsumer,
      TAO_Notify_PushSupplier to write client consumers and suppliers
      in <tt> $TAO_ROOT/orbsvcs/tests/Notify/lib</tt>.
  </li>

  <li>
      The EventChannel's default Filter Factory can be used to create filters.
      For now we support the "TCL" grammer from the Trading Service.
  </li>

  <li>
      This implementation is backward compatible with the <a href="#ec">
      CORBA Event Service</a>.
  </li>

  <li>
      A runnning theme in this project is to isolate the patterns identified
      in the implementation of the <a href="ec.html"> RTEC </a> and reuse them.
      We hope to come up with a collection of C++ template classes that
      capture these patterns so that they might be used in other similar
      event communication senarios.
  </li>

  <li>
      Concurrency:
      <ul>
        <li>
            The service is thread safe.
        </li>

        <li> MT dispatching of events to consumers - The EventChannel
            will deliver the event in another thread, different from the thread
            that evaluated (checking subscriptions and filters) it.
        </li>

        <li> MT evaluation of events - Events delivered to the
            ProxySuppliers will be evaluated in another thread, different
            from the delivering thread.
        </li>

        <li>
            MT dispatching of updates - subscription/offer_change
            updates are delivered on another thread.
        </li>

      </ul>
  </li>


  <li>
      Memory Management
      <ul>
        <li>
            (almost) All memory allocations are via factory interfaces.
        </li>

        <li>
            Uses service configurator to load resource factories and
            supply strartup options to the service.
        </li>

      </ul>
  </li>

</ul>

<h3> Project Schedule </h3>
The TODO list runs like this:
<ul>

  <li>
      Implement the QoS properties - Priority, Expiry times, Earliest
      delivery times, maximun events per consumer, order policy,
      discard policy, maximum batch size, pacing interval.
  </li>

  <li>
      Filters:
      <ul>
        <li>
            Intergrate the parser engine for the <tt>Extended TCL</tt>
            grammer in <tt> orbsvcs/orbsvcs/ETCL </tt> with Notify and
            remove dependency on the <tt>Trader </tt>.
        </li>

        <li>
            Implement CosNotifyFilter::MappingFilter.
        </li>

        <li>
            (Wish list) Add a "filter cache" to cache the expression tree for frequently
            used constraint expressions.
        </li>

      </ul>
  </li>

  <li>
      Come up with a rigorous test suite for this service to measure its
      performance.
  </li>

  <li>
      Implement Pull interfaces.
  </li>

  <li>
      Support policies to remove dead or unresponsive consumers and
      suppliers in the Notification Service.
  </li>

</ul>

<!-- BEGIN: CORBA Security Service Release Notes -->
<HR WIDTH="100%">
<H3><A NAME="security"></A>CORBA Security Service </H3>
Point of contact: <A HREF="mailto:ossama@uci.edu">Ossama Othman</A>

<P>
For up-to-date information, see the project web site
<A HREF="http://doc.ece.uci.edu/TAO/Security/">here</A>.

<P>
Implemented Features:
<UL>
  <LI>
    IIOP over SSL integration via TAO's
    <A HREF="http://doc.ece.uci.edu/TAO/Security/SSLIOP.html">SSLIOP pluggable protocol</A>.
  </LI>
</UL>

Current Status:
<UL>
  <LI>
    The level 1 authentication mechanisms detailed in the CORBA
    Security Service specification are currently under development.
  </LI>
</UL>

Schedule:
<UL>
  <LI>
    Security Level 1 completion by Winter 2000.
  </LI>
  <LI>
    Security Level 2 completion by <FONT COLOR=RED><STRONG>TBD</STRONG></FONT>.
  </LI>
</UL>

<!-- END: CORBA Security Service Release Notes -->

<!--#include virtual="ec.html" -->
<p>
<hr>

<h3>
<a NAME="scheduling"></a>TAO's Scheduling Service</h3>
Point of contact: <a href="mailto:cdgill@cs.wustl.edu">Chris Gill</a>
and <a href="mailto:levine@cs.wustl.edu">David Levine</a>
<p>Currently Implemented Features:
<ul>
<li>
The scheduling service can be built to use either a null implementation
or a strategized implementation of the configuration scheduler.</li>

<li>
The null scheduler implementation, which is built by default, allows the
configuration scheduler to be used with applications that require a scheduling
service interface, but do not (at least in the current stage of their development,
in certain configurations, etc.) make use of the real-time scheduling features
it provides.</li>

<li>
The strategized scheduler implementation can be built by #defining TAO_USES_STRATEGY_SCHEDULER,
and the appropriate scheduling strategy macro (TAO_USES_RMS_SCHEDULING,
TAO_USES_EDF_SCHEDULING, TAO_USES_MUF_SCHEDULING, or TAO_USES_MUF_SCHEDULING)
in $ACE_ROOT/ace/config.h. This allows the configuration scheduler to be
used with applications that require a specific scheduling strategy. Each
scheduling strategy will produce a set of static scheduling priorities,
which it will assign to operations based on their RT_Infos. For each static
priority, a strategy will also determine the run-time (dynamic) scheduling
strategy to use for that priority level.</li>
</ul>
Future work:
<ul>
<li>
Implement heap-based dispatching queues.</li>

<li>
Add support for additional configurability, especially in the type
of dispatching strategy (list vs. heap) that will be used to dispatch operations
at a given static priority level.</li>

<li>
Benchmark the various alternative strategies to obtain performance
profiles across different operation loads and OS platforms.</li>

<li>
Add increased functionality. Requests and suggestions are welcome.</li>
</ul>

<hr>

<h3>
<a NAME="logging"></a>TAO's Logging Service</h3>
Point of contact: <a href="mailto:krish@cs.wustl.edu">Krishnakumar Elakkara Pathayapura</a>
<p>Current status (Jan 23 2000):
<ul>
<li>
The basic logging service has been implemented. It can log basic messages
from multiple clients. The log scheduling is currently being tested.</li>
</ul>
Future work:
<ul>
<li>
Add persistence and then to add event notification</li>
</ul>

<hr>

<h3><a NAME="loadbalancer"></a>TAO's Load Balancer</h3>

<p>
Point of contact: <a href="mailto:ossama@uci.edu">Ossama Othman</a>

<h4>Current Status:</h4>
<p>TAO's Load Balancer currently implements the following load
balancing algorithms:
<ul>
<li><FONT COLOR=BLUE>Round Robin</FONT>
  <ul>
  <li>Simply forwards requests to the next registered replica in a
      circular list.</li>
  </ul>
</li>
<li><FONT COLOR=BLUE>Minimum Dispersion</FONT>
  <ul>
  <li>Basically tries to keep the load on each registered replica
      close to the average.  If the load on a given server is much
      higher than the average load it is deemed too loaded, at which
      point the load balancer informs the replica of this condition,
      which in turn causes it to stop accepting requests until its
      load is close to the average.</li>
  </ul>
</li>
</ul>

<h4>Known Issues:</h4>
<ul>
<li>Factory must be implemented to allow applications to create load
balancers at run-time, rather than at application start up time.</li>
</ul>

<h4>Recent Work:</h4>
<ul>
<li>Replaced use of DSI for forwarding requests in favor of a
    ServantLocator.  The ServantLocator implementation provides a more
    robust way of forwarding requests.  The DSI implementation was a
    bit of a hack since ForwardRequest exceptions are only supposed to
    be thrown from ServantManagers, such as ServantLocators.</li>
<li>All code is now thread-safe and exception-safe.</li>
</ul>

<h4>Future Work:</h4>
<ul>
<li>Implement a load balancing algorithm strategy factory.</li>
<li>Implement load balancing via Interceptors.</li>
<li>Implement cooperative load balancing support.</li>
<li>Implement additional load balancing strategies:
  <ul>
  <li>load based on power consumption</li>
  <li>load based on the number of requests currently serviced
      (maybe)</li>
  <li>adaptive load balancing strategy that utilizes load history to
      attempt to predict future load conditions</li>
  </ul>
</li>
<li>Active load balancing:
  <ul>
  <li>Actively poll replicas for current load, as opposed to the
      currently implemented passive load balancing where the load
      balancer listens for load reports from the replicas.
  </ul>
</li>
</ul>

<hr>


<h3>
<a NAME="apps"></a>Test &amp; Performance Tests</h3>
Point of contact: <a href="mailto:naga@cs.wustl.edu">Nagarajan Surendran</a>
<p>Current Status:
<p>The TAO IDL_Cubit test application makes use of the Naming Service and
the server holds a TAO_Naming_Server component.Just running server and
client is enough to test the application.
<p>The various tests in the tests/POA test the different features of the
Portable Object Adapter interface like Explicit Activation, On Demand Activation,etc..
<p>MT_Cubit:
<p>Current status:
<p>The TAO MT_Cubit test application is meant to serve as a starting point
for real-time tests on the TAO system. It comprises the following parts:
<ul>
<li>
<i>Server.</i> The server creates multiple CORBA objects (servants), each
with different real-time priorities. This priority is implemented by using
real-time thread support provided by the operating system. Thus, requests
sent to a high-priority servant are handled by a high-priority real-time
thread, and those sent to a lower priority servant are handled by correspondingly
lower priority threads.</li>

<li>
<i>Client.</i> The client component binds to the servants, and sends a
stream of CORBA requests to the servants. It measures the response time,
i.e. the time taken for the request to complete successfully. In particular,
it measures the time taken for requests sent to the high priority servant
to complete. The volume of lower priority requests is configurable. The
client is thus able to measure the performance of the high-priority servant
in the presence of competition from several lower-priority servants.</li>
</ul>
Clearly, if the ORB endsystem handles the priorities of the various requests
correctly, increasing the volume of lower priority requests should not
affect the performance seen by the higher priority requests. The application
thus serves as a tool to measure and confirm this behavior.
<p>Future work:
<ul>
<li>
Study the impacts of scheduling &amp; concurrency strategies on performance.</li>

<li>
Evolve into a testbed for discovering sources of performance non-determinism
&amp; priority inversion.</li>
</ul>

<p>Pluggable:
<p>Current status:
<p>The TAO Pluggable test utilizes ACE Timeprobes to time the latency at
various points in the ORB, especially that incurred by the Pluggable Protocols
implementation. Comparisons can be made not only between different layers of the
ORB, but also between different protocols as they  become available.
<p>Future work:
<ul>
<li>
Add options to redirect the output to a file.</li>
<li>
Script or otherwise automate the piping of the output to a spreadsheet.</li>
</ul>

<hr>

<h3>
<a NAME="ace"></a>ORB-related ACE Changes</h3>
Points of contact: <a href="mailto:nanbor@cs.wustl.edu">Nanbor Wang</a>
and <a href="mailto:irfan@cs.wustl.edu">Irfan Pyrarli</a>
<p>Recently Completed Work:
<ul>
<li>
Added special declaration to OS.h for <tt>inet_ntoa</tt> and other functions
because VxWorks doesn't provide full argument prototypes for these library
functions.</li>

<li>
The current caching connector behaves properly in the face of a non-blocking
connect request. The "fix" is simply to not support non-blocking connects
through the cache. When the <tt>connect()</tt> fails with <tt>EWOULDBLOCK</tt>,
morph the error to -1 and clean up the request.</li>

<li>
Service handlers obtained from the caching connector are now cleaned up.
The application needs to be able to signal that it's not using it any longer,
and, when the application encounters an error, needs to effectively close
down that connection for good so that a new connection can be initiated.</li>

<br>Added the ability for a Svc_Handler to recycle itself. idle() can be
called when the Svc_Handler is done serving a particular connection and
can how be recycled. The Svc_Handler now also has a pointer to a recycler
that is responsible for managing the connections. The recycler is usually
a Cached_Connector.
<br>Added new class ACE_Recycling_Strategy. It defines the interface (and
default implementation) for specifying a recycling strategy for a Svc_Handler.
This strategy acts as a consular to the Svc_Handler, preparing it for the
tough times ahead when the Svc_Handler will be recycled.
<br>Added new class ACE_NOOP_Concurrency_Strategy. It implements a no-op
activation strategy in order to avoid calling open on a recycled svc_handler
multiple times.
<br>ACE_Cached_Connect_Strategy now implements the ACE_Connection_Recycling_Strategy
interface. This allows Svc_Handlers to cache themselves with ACE_Cached_Connect_Strategy
when they become idle. It also allows them to purge themselves from the
connection cache when the Svc_Handlers close down.
<br>Also added ~ACE_Cached_Connect_Strategy that will cleanup up the connection
cache.</ul>
Future work:
<blockquote><i>None currently scheduled.</i></blockquote>

<hr>
<h3>
<a NAME="dove"></a>The DOVE Demo</h3>
Points of contact: <a href="mailto:mk1@cs.wustl.edu">Michael Kircher</a>
and <a href="mailto:cdgill@cs.wustl.edu">Chris Gill</a>.
<p><a href="http://www.cs.wustl.edu/~schmidt/dove.html">DOVE</a> is documented
in detail <a href="http://www.cs.wustl.edu/~schmidt/Dove.ps.gz">online</a>.
This discussion focuses on the following goals:
<ul>
<li>
Have a DOVE Browser running using Java Beans as vizualization components.</li>

<li>
Have the Event Channel as DOVE Agent running with an Event Consumer in
the DOVE Browser.</li>

<li>
Having a DOVE Management Information Base (MIB), which dumps all events
transfered on the Event Channel into a file on persistent storage for later
reuse.</li>
</ul>
The DOVE Browser uses independent visualization components (Java Beans)
and the Event Channel as DOVE Agent. Connections can be established between
monitored metrics and the visualization components.
<p>We have three major components: Observables (monitored metrics), Observers
(a Java Bean for displaying the metric) and a DataHandler (for demultiplexing
the monitored metrics to the appropriate Observables). Each component inherits
from a base class, so that a certain behavior of the components can be
assured for each component. Relationships between components are based
on these base classes.
<p>The used Java Beans are required to conform to some standards, as they
have to support a function called "getProperty" which allows the DOVE Browser
to determine if the vizualization capabilities of a specific Java Bean
are sufficient to display the metric. A JavaBean is for example a Java
Panel which shows a Graph of the delivered doubles. So all metrics can
be displayed by this visualization component which can be expressed by
a single double.
<p>The DataHandler is connected to the Event Push Consumer (PUSH, because
we use the push concept of the Event Service). The Event Push Consumer
does not know what kind of data is transported. The only component knowing
all the details about the dependencies of the metrics is the DataHandler.
This separation allows easy extension and change of the demo.
<p><a href="http://students.cec.wustl.edu/~mk1/dove.html">Object Diagrams</a>
are available about this new concept.
<p>Event Service events are used as communication between DOVE Applications
and the DOVE Browser. The DOVE MIB analyses the event data field of all
events and stores this information into a file. The event data filed is
of type CORBA::Any and the DOVE MIB has no notion of what is conveyed in
this field. So the DOVE MIB has to discover the content via the embedded
type code information. Future work includes:
<ul>
<li>
Enhancing MIB functionality</li>

<li>
Monitoring the AV Streaming Service</li>
</ul>
For more information on the DOVE demo, please refer to: $TAO_ROOT/orbsvcs/tests/Simulator/README.<P>
<hr>

<h3>
<a NAME="forwarding"></a>Location Forwarding</h3>
Point of contact: <a href="mailto:irfan@cs.wustl.edu">Irfan Pyarali</a>,
<a href="mailto:mk1@mk1.wustl.edu">Michael
Kircher</a>.
<p>For more information see <a href="../forwarding.html">Location forwarding</a>
<p>
<hr>

<h3>
<a NAME="leader"></a>Global Resources and Leader-Follower Model</h3>
Point of contact: <a href="mailto:irfan@cs.wustl.edu">Irfan Pyarali</a>,
<a href="mailto:mk1@mk1.wustl.edu">Michael
Kircher</a>.
<p>For more information see <a href="../leader_follower.html">Leader-follower
model</a>
<p>
<hr>

<h3>
<a NAME="locate"></a>Implementation of locate request</h3>
Point of contact: <a href="mailto:irfan@cs.wustl.edu">Irfan Pyarali</a>,
<a href="mailto:mk1@mk1.wustl.edu">Michael
Kircher</a>.
<p>For more information see <a href="../locate_request.html">Locate request</a>
<p>
<hr>

<h3>
<a NAME="ami"></a>Asynchronous Method Invocation</h3>
Points of contact: <a href="mailto:alex@cs.wustl.edu">Alexander Arulanthu</a>
, <a href="mailto:Michael.Kircher@mchp.siemens.de">Michael Kircher</a> and
<a href="mailto:coryan@uci.edu">Carlos O'Ryan</a>
<p>Status:
<ul>

We've implemented the callback model of the <A
HREF="http://www.cs.wustl.edu/~schmidt/CORBA-docs/98-05-05.pdf.gz">Messaging
specification</a>.  To activate the AMI for TAO and the TAO IDL
compiler define <tt>TAO_HAS_CORBA_MESSAGING</tt>,
<tt>TAO_HAS_AMI_CALLBACK</tt> in your config.h file.  The TAO IDL
compiler can generate the AMI stubs, ReplyHandler und reply stubs
using the -GC switch.
<p>
For an example see <tt>$TAO_ROOT\tests\AMI</tt> and <tt>$TAO_ROOT\examples\AMI</tt>.

</ul>

<p> Finished work:
<ul>
<li> Redesign of the IDL compiler to make an addtional pass over
the AbstractSyntaxTree and generate the implied-IDL code in memory.
This reduced the amount of AMI specific IDL compiler code dramatically.</li>
<li>Support for exceptions</li>
<li>Support for attributes</li>
<li>Support for buffering and batching AMI calls. See <a
href="../../examples/Buffered_AMI">Buffered AMI</a> example for
details.</li>
<li>Support for deferred synchronous invocations.
<a href="mailto:parsons@cs.wustl.edu">Jeff Parsons</a></li>
</ul>
<p> Future Work:
<ul>
<li>Testing the current implementation</li>
<li>Implementation of the poller model.</li>
</ul>
<p>
<hr>

<h3> <a NAME="interceptor"></a>Portable Interceptors</h3>
Point of contact: <a href="mailto:nanbor@cs.wustl.edu">Nanbor Wang</a>,
<a href="mailto:kirthika@cs.wustl.edu">Kirthika Parameswaran</a>.
<p>For more information see <a href="../interceptors.html">Portable
Interceptors</a>
</p>
<hr>

<h3><a name="localobject"></a>Local Interfaces</h3>

<p>Point of contact: <a href="mailto:nanbor@cs.wustl.edu">Nanbor
Wang</a>.</p>

<p>Local interfaces are first defined in the CORBA Component Model
specification.  For more information on using the local interfaces,
please refers to Section 11.1.1 to 11.1.4 of the
<a href="http://www.omg.org/cgi-bin/doc?orbos/99-07-01/">spec</a> and
our short <a href="../LocalObject.html">guideline</a> on implementing
local objects.</p>

<HR><P>
<h3><a NAME="CORBA2.3.1">CORBA 2.3.1 Conformance</a></h3>
(updated 9 August 2000)<br>
Here is a summary of TAO's conformance issues with CORBA 2.3.1:<br>

2.3.1 and 2.3 differ in very little, if at all, check:<br>

<a href="http://ringil.ece.uci.edu/corba/CORBA2.3/99-10-07.pdf">http://ringil.ece.uci.edu/corba/CORBA2.3/99-10-07.pdf</a><br>

   and search for the change bars, meanwhile this can help:
<ul>

  <li>The full OBV (valueboxes, valuetypes in all sorts of things, value
   graphs, Anys and value types, abstract interfaces, etc. etc.)

  <li>The old (2.3.1) IfR interface (we support a 3.0 draft, which is
   non-backwards compatible, and it is going to be changed).

  <li>The IfR database cannot be populated (so it is less than fully
   operational ;-))

  <li>The old typecode factory methods (we support a much better
   alternative from a CORBA 3.0 draft)

  <li>Fixed data types (who cares)

  <li>GIOP fragments (1.1 and 1.2) are not completely tested.

  <li>There are several "optional" features like bi-dir GIOP that we
   don't support yet.

  <li>The old ServantManager interfaces (POA stuff)

  <li>Domain Managers (useful for security, but otherwise nobody seems to
   care)

  <li>I think our interpretation of codesets is compliant (we only
   support one codeset), but would have to check.
</ul>


<p>Future Work (aka. known problems):</p>
<ul>
  <li>Supposedly, any constructed types that contains local types
      become local automatically.  TAO_IDL currently doesn't handle
      the array type very well if one is defined outside the scope of
      a local interface.</li>
  <li>Need to test local object support more systematically and
      comprehensively. (Does TAO throw a MARSHAL exception when trying
      to marshal a local type?)
</ul>
<hr>

<p>Back to the TAO <a href="../index.html">documentation index</a>.<!--#include virtual="/~schmidt/cgi-sig.html" -->
</body>
</html>
