<HTML>
<TITLE>Portable Interceptors</TITLE>
<BODY>

<Hr><P>
<H3>Portable Interceptors</H3>

<BODY text = "#000000"
link="#000fff"
vlink="#ff0f0f"
bgcolor="#ffffff">

<p>We have revised TAO's interceptor implementation so that it
conforms to the <a
href="ftp://ftp.omg.org/pub/docs/orbos/99-12-02.pdf">Portable
Interceptor</A> specification.  The purpose of this document is to
provide a trasition guide for those who have used our old
interceptors.  The old interceptors will no longer be supported now
that we have the new mechanism in place.  A paper that describes TAO's
portable interceptors and <A HREF="Smart_Proxies.html">smart
proxies</A> is available <A
HREF="http://www.cs.wustl.edu/~schmidt/PDF/smart_proxies.pdf">online</A>.</p>

<Hr><P>
<h3><a name="toc">Table of Contents</a></h3>
<ul>
  <li><a href="#context">Context</a>
  <li><a href="#implement">TAO's Implementation</a>
  <li><a href="#api">Transition</a>
  <li><a href="#status">Current Status</a>
  <li><a href="#ref">References</a>
</ul>

<Hr><P>
<h2><a name="context">Context</a></h2>

<p>Interceptors allow you to interpose other CORBA services to the ORB
and extend the ORB's functionalities.  They are most commonly used in,
but not limited to, Security Service, Transaction Service.  They are
also for doing accounting and debugging distributed application.</p>

<p>Although both CORBA 2.2 and 2.3 define an interceptor interface,
the definitions are pretty much useless because it does not define how
the interceptor should interact with an ORB.  Therefore, OMG is
currently trying to define a "<a
href="http://www.omg.org/techprocess/meetings/schedule/Portable_Interceptors_RFP.html">
Portable Interceptor</a>" specification which will remedy the problems
and allow application users to use interceptos from different venders
with their ORBs. </p>

<Hr><P>
<h3><a name="implement">TAO's Implementation of "Portable
Interceptors"</a></h3>

<p>TAO's portable interceptor implementation was developped before
even a joint submission was available.  There were several proposed
standards which defined very different interfaces and capabilities.
The old interceptor implementation provides a minimum subset of
functionalities proposed in the initial submissions.  This approach
has allowed TAO users to explore various use cases of interceptors and
prevented users from adding code that depended on the interceptor
features which would not be supported when the spec gets
finalized.</p>

<p>We have modifed TAO's interceptor interface to conform with the
proposed spec.  The current version of interceptors consists of support
for the Dynamic Module as well as the canonical interception points
including (1) send_request, (2) receive_request, (3) send_reply, (4)
receive_reply (5) send_exception, and (6) receive_exception.  Only
Request Interceptors have been implemented as of now.  Every operation
now has a RequestInfo object which encapsulates the details of the
operation like arguments, etc.  The registeration of the client-side
and server-side interceptors remians the same.</p>

<p>
Details of this implementation along with benchmarking is available in
the paper on <a
href="http://www.cs.wustl.edu/~schmidt/PDF/COOTS-00.pdf">Meta-programming
mechanisms.</a>
</p>

<p> Examples on this new version of Portable Interceptors is available
at $TAO_ROOT/tests/Portable_Interceptors. </p>

<Hr><P>
<h3><a name="api">Transitting from TAO's Old "Portable"
Interceptor APIs to the Standard Portable Interceptor APIs</a></h3>

<p>Please refer to the working draft for details on the proposed
Portable Interceptor interfaces. Below is the old but now obsolete
interceptor version in TAO.</p>

<pre>
// -*- IDL -*- $Id$

// This file contains the interface definitions for "Portable"
// Interceptor support.

// **********************************************************
//   Notice that the Portable Interceptor specification
//   is still under discussion in OMG and both the IDL
//   and the implementation details in TAO will eventually
//   change to conform with the PI spec in the future.
//
//   @@ Now that a working draft of the Portable Interceptors
//      is available, we will provide a compliant implementation
//      shortly.
//
//      Please see the annotation marked with "@@" in this file
//      for hints on transitting from the temporary
//      implementation to new APIs.
//
//      See $TAO_ROOT/docs/interceptors.html for more info.
// **********************************************************

// Author (currently): Nanbor Wang <nanbor@cs.wustl.edu>
// @@ I will no longer be the author of this IDL file. ;-)

#include <corba.pidl>
#include <IOP.pidl>

#pragma prefix "TAO"
// The prefix should be changed to "omg.org" once the spec. gets
// finallized.
// @@ The prefix will be changed to "omg.org".

module PortableInterceptor
{
  interface Cookie
    {
      // Cookie's are used to pass information among interceptors
      // within a invocation or an upcall.
      //
      // @@ Cookie will no longer be available.
      string myname ();
    };

  typedef sequence<Cookie>  Cookies;
  // Collections of Cookie's become Cookies'es.
  //
  // @@ Cookies will no longer be available.

  interface Interceptor
    {
      // Base interface for Interceptors.
      //
      // @@ This interface will not change.
      readonly attribute string name;
    };

  interface ServerRequestInterceptor : Interceptor
    {
      // Server side request interceptor definition.
      //
      // @@ The name of the interface will not change.

      void preinvoke (in unsigned long request_id,
                      in boolean response_expected,
                      in CORBA::Object objref,
                      in string operation_name,
                      inout IOP::ServiceContextList sc,
                      inout NVList arguments,
                      inout Cookies ck);
      // Interception pointer before invoking the servant method.
      // Currently, we don't pass NVList into the interceptor because
      // I haven't figured out how to best optimize this stuff.
      // In the future, NVList will contain all in and inout arguments
      // of the operation.
      //
      // @@ This operation will map to either
      // &lt;receive_request_service_contexts&gt; or &lt;receive_request&gt; of
      // the standard APIs.  If you are not sure, use
      // &lt;receive_request&gt;.
      //
      // void receive_request_service_contexts (in ServerRequestInfo ri) raises (ForwardRequest);
      // void receive_request (in ServerRequestInfo ri) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ServerRequestInfo&gt; interface.

      void postinvoke (in unsigned long request_id,
                       in boolean response_expected,
                       in CORBA::Object objref,
                       in string operation_name,
                       inout IOP::ServiceContextList sc,
                       inout NVList arguments,
                       inout Cookies ck);
      // Interception pointer after invoking the servant method.
      // Currently, we don't pass NVList into the interceptor because
      // I haven't figured out how to best optimize this stuff.
      // In the future, NVList will contain all out, inout arguments
      // and the return value of the operation.
      //
      // @@ This operation will map to &lt;send_reply&gt;.
      // It is not clear whether oneway call will invoke &lt;send_other&gt;
      // operation or not.
      //
      // void send_reply (in ServerRequestInfo ri);
      // void send_other (in ServerRequestInfo ri) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ServerRequestInfo&gt; interface.

      void exception_occurred (in unsigned long request_id,
                               in boolean response_expected,
                               in CORBA::Object objref,
                               in string operation_name,
                               inout Cookies ck);
      // Exception interception point.
      //
      // @@ This method will map to &lt;send_exception&gt; method.
      //
      // void send_exception (in ServerRequestInfo ri) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ServerRequestInfo&gt; interface.
    };

  interface ClientRequestInterceptor : Interceptor
    {
      // Client side interceptor.
      //
      // @@ The name of the interface will not change.

      void preinvoke (in unsigned long request_id,
                      in boolean response_expected,
                      in CORBA::Object objref,
                      in string operation_name,
                      inout IOP::ServiceContextList sc,
                      inout NVList arguments,
                      inout Cookies ck);
      // Before remote invocation.
      // Currently, we don't pass NVList into the interceptor because
      // I haven't figured out how to best optimize this stuff.
      // In the future, NVList will contain all in and inout arguments
      // of the operation.
      //
      // @@ This operation will map to &lt;send_request&gt; of the standard
      // APIs.
      //
      // void send_request (in ClientRequestInfo) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ClientRequestInfo&gt; interface.

      void postinvoke (in unsigned long request_id,
                       in boolean response_expected,
                       in CORBA::Object objref,
                       in string operation_name,
                       inout IOP::ServiceContextList sc,
                       inout NVList arguments,
                       inout Cookies ck);
      // After returned from remote invocation.
      // Currently, we don't pass NVList into the interceptor because
      // I haven't figured out how to best optimize this stuff.
      // In the future, NVList will contain all out, inout arguments
      // and the return value of the operation.
      //
      // @@ This operation will map to either &lt;receive_reply&gt; or
      // &lt;receive_other&gt; in the standard APIs depending on whether the
      // operation is oneway or not.
      //
      // void receive_reply (in ClientRequestInfo ri);
      // void receive_other (in ClientRequestInfo ri);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ClientRequestInfo&gt; interface.

      void exception_occurred (in unsigned long request_id,
                               in boolean response_expected,
                               in CORBA::Object objref,
                               in string operation_name,
                               inout Cookies ck);
      // Exception occurred.
      //
      // @@ This method will map to &lt;receive_exception&gt; method as:
      //
      //    void receive_exception (in ClientRequestInfo ri) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ClientRequestInfo&gt; interface.
    };
};

#pragma prefix ""
</pre>

<Hr><P>
<h3><a name="status">Current Status</a></h3>
<ul>
  <li>The basic infrastructure is in place as well as the canonical
      points:  send_request, receive_request, send_exception,
      receive_exception, send_reply, and receive reply.  The other
      points are mostly for specific applications like AMI, FT, etc.
      which will implemented as and when needed.
  <li>We will change the temporary interceptor implementation to
      conform with the proposed spec. shortly.
  <li>The current implementation does not go through the interceptor chain
      when using collocation optimizations such as "direct" or "ThruPOA".
</ul>

<Hr><P>
<h2><a name="future">Future Work</a></h2>
<ol>
  <li>Add support for the interceptor chain to "ThruPOA" collocation
      optimization; the "Direct" collocation optimization will not go
      through the interceptor chain.
  <li>The IOR interceptor is provides interception at object creation
      time and can be used influence the existing policies used by the
      POA at IOR creation.
  <li>Multiple interceptors which will handled according to a flow
      stack model.
  <li>Making the registeration of interceptors conformant to the spec
      which uses the ORBInitInfo class.
            
</ol>

<Hr><P>
<H3><a name="ref">References</a></H3>
<UL>
  <LI><p><a href="ftp://ftp.omg.org/pub/docs/orbos/99-12-02.pdf">
      99-12-02</a> Portable Interceptors -- Joint Revised
      Submission.</p>
  <LI><p><a href="ftp://ftp.omg.org/pub/docs/orbos/99-12-14.zip">
      99-12-14</a> Portable Interceptors related IDL files (in zip
      format.) </p>
</UL>
</BODY>
