<HTML>
<TITLE>Portable Interceptors</TITLE>
<BODY>

<hr><P>
<H3>Portable Interceptors</H3>

<BODY text = "#000000"
link="#000fff"
vlink="#ff0f0f"
bgcolor="#ffffff">

<p>We have revised TAO's interceptor implementation so that it
conforms to the
<a href="ftp://ftp.omg.org/pub/docs/orbos/99-12-02.pdf">Portable
Interceptor</A> specification.  The purpose of this document is to
provide a transition guide for those who have used our old
interceptors.  The old interceptors will no longer be supported now
that we have the new mechanism in place.  A paper that describes TAO's
portable interceptors and <A HREF="Smart_Proxies.html">smart
proxies</A> is available <A
HREF="http://www.cs.wustl.edu/~schmidt/PDF/smart_proxies.pdf">online</A>.</p>

<hr><P>
<h3><a name="toc">Table of Contents</a></h3>
<ul>
  <li><a href="#context">Context</a>
  <li><a href="#implement">TAO's Implementation</a>
  <li><a href="#api">Transition</a>
  <li><a href="#status">Current Status</a>
  <li><a href="#future">Future Work</a>
  <li><a href="#issues">Known Issues</a>
  <li><a href="#ref">References</a>
</ul>

<hr><P>
<h2><a name="context">Context</a></h2>

<p>Interceptors allow you to interpose other CORBA services to the ORB
and extend the ORB's functionalities.  They are most commonly used in,
but not limited to, Security Service, Transaction Service.  They are
also for doing accounting and debugging distributed application.</p>

<p>Although both CORBA 2.2 and 2.3 define an interceptor interface,
the definitions are pretty much useless because it does not define how
the interceptor should interact with an ORB.  Therefore, OMG is
currently trying to define a "<a
href="http://www.omg.org/techprocess/meetings/schedule/Portable_Interceptors_RFP.html">
Portable Interceptor</a>" specification which will remedy the problems
and allow application users to use interceptos from different venders
with their ORBs. </p>

<hr><P>
<h3><a name="implement">TAO's Implementation of "Portable
Interceptors"</a></h3>

<p>TAO's portable interceptor implementation was developped before
even a joint submission was available.  There were several proposed
standards which defined very different interfaces and capabilities.
The old interceptor implementation provides a minimum subset of
functionalities proposed in the initial submissions.  This approach
has allowed TAO users to explore various use cases of interceptors and
prevented users from adding code that depended on the interceptor
features which would not be supported when the spec gets
finalized.</p>

<p>We have modifed TAO's interceptor interface to conform with the
proposed spec.  The current implementation of interceptors consists of
support for the <CODE>Dynamic</CODE> module as well as the canonical
interception points including
(1) <CODE>send_request</CODE>,
(2) <CODE>receive_reply</CODE>,
(3) <CODE>receive_exception</CODE>,
(4) <CODE>receive_other</CODE>,
(5) <CODE>receive_request_service_contexts</CODE>,
(6) <CODE>receive_request</CODE>,
(7) <CODE>send_reply</CODE>,
(8) <CODE>send_exception</CODE>,
(9) <CODE>send_other</CODE>, and
(10) <CODE>establish_components</CODE> (specific to
<CODE>IORInterceptor</CODE>s).  Each request interception point is
passed a <CODE>RequestInfo</CODE> object which encapsulates the
details of the operation like arguments, etc.  The IOR interception
point is passed an <CODE>IORInfo</CODE> object that encapsulates
operations for adding tagged components to profiles in an IOR.
Registration of all three types of interceptors (client and server
request interceptors, and IOR interceptors) is now done using the
interface provided by the standard <CODE>ORBInitInfo</CODE>
object.</p>

<p>
Details of this implementation along with benchmarking is available in
the paper on <a
href="http://www.cs.wustl.edu/~schmidt/PDF/COOTS-00.pdf">Meta-programming
mechanisms.</a>
</p>

<p> Examples on this new version of Portable Interceptors is available
at <CODE>$TAO_ROOT/tests/Portable_Interceptors</CODE>.</p>

<hr><P>
<h3><a name="api">Transitting from TAO's Old "Portable"
Interceptor APIs to the Standard Portable Interceptor APIs</a></h3>

<p>Please refer to the working draft for details on the proposed
Portable Interceptor interfaces. Below is the old but now obsolete
interceptor version in TAO.</p>

<pre>
// -*- IDL -*- $Id$

// This file contains the interface definitions for "Portable"
// Interceptor support.

// **********************************************************
//   Notice that the Portable Interceptor specification
//   is still under discussion in OMG and both the IDL
//   and the implementation details in TAO will eventually
//   change to conform with the PI spec in the future.
//
//   @@ Now that a working draft of the Portable Interceptors
//      is available, we will provide a compliant implementation
//      shortly.
//
//      Please see the annotation marked with "@@" in this file
//      for hints on transitting from the temporary
//      implementation to new APIs.
//
//      See $TAO_ROOT/docs/interceptors.html for more info.
// **********************************************************

// Author (currently): Nanbor Wang <nanbor@cs.wustl.edu>
// @@ I will no longer be the author of this IDL file. ;-)

#include <corba.pidl>
#include <IOP.pidl>

#pragma prefix "TAO"
// The prefix should be changed to "omg.org" once the spec. gets
// finallized.
// @@ The prefix will be changed to "omg.org".

module PortableInterceptor
{
  interface Cookie
    {
      // Cookie's are used to pass information among interceptors
      // within a invocation or an upcall.
      //
      // @@ Cookie will no longer be available.
      string myname ();
    };

  typedef sequence<Cookie>  Cookies;
  // Collections of Cookie's become Cookies'es.
  //
  // @@ Cookies will no longer be available.

  interface Interceptor
    {
      // Base interface for Interceptors.
      //
      // @@ This interface will not change.
      readonly attribute string name;
    };

  interface ServerRequestInterceptor : Interceptor
    {
      // Server side request interceptor definition.
      //
      // @@ The name of the interface will not change.

      void preinvoke (in unsigned long request_id,
                      in boolean response_expected,
                      in CORBA::Object objref,
                      in string operation_name,
                      inout IOP::ServiceContextList sc,
                      inout NVList arguments,
                      inout Cookies ck);
      // Interception pointer before invoking the servant method.
      // Currently, we don't pass NVList into the interceptor because
      // I haven't figured out how to best optimize this stuff.
      // In the future, NVList will contain all in and inout arguments
      // of the operation.
      //
      // @@ This operation will map to either
      // &lt;receive_request_service_contexts&gt; or &lt;receive_request&gt; of
      // the standard APIs.  If you are not sure, use
      // &lt;receive_request&gt;.
      //
      // void receive_request_service_contexts (in ServerRequestInfo ri) raises (ForwardRequest);
      // void receive_request (in ServerRequestInfo ri) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ServerRequestInfo&gt; interface.

      void postinvoke (in unsigned long request_id,
                       in boolean response_expected,
                       in CORBA::Object objref,
                       in string operation_name,
                       inout IOP::ServiceContextList sc,
                       inout NVList arguments,
                       inout Cookies ck);
      // Interception pointer after invoking the servant method.
      // Currently, we don't pass NVList into the interceptor because
      // I haven't figured out how to best optimize this stuff.
      // In the future, NVList will contain all out, inout arguments
      // and the return value of the operation.
      //
      // @@ This operation will map to &lt;send_reply&gt;.
      // It is not clear whether oneway call will invoke &lt;send_other&gt;
      // operation or not.
      //
      // void send_reply (in ServerRequestInfo ri);
      // void send_other (in ServerRequestInfo ri) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ServerRequestInfo&gt; interface.

      void exception_occurred (in unsigned long request_id,
                               in boolean response_expected,
                               in CORBA::Object objref,
                               in string operation_name,
                               inout Cookies ck);
      // Exception interception point.
      //
      // @@ This method will map to &lt;send_exception&gt; method.
      //
      // void send_exception (in ServerRequestInfo ri) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ServerRequestInfo&gt; interface.
    };

  interface ClientRequestInterceptor : Interceptor
    {
      // Client side interceptor.
      //
      // @@ The name of the interface will not change.

      void preinvoke (in unsigned long request_id,
                      in boolean response_expected,
                      in CORBA::Object objref,
                      in string operation_name,
                      inout IOP::ServiceContextList sc,
                      inout NVList arguments,
                      inout Cookies ck);
      // Before remote invocation.
      // Currently, we don't pass NVList into the interceptor because
      // I haven't figured out how to best optimize this stuff.
      // In the future, NVList will contain all in and inout arguments
      // of the operation.
      //
      // @@ This operation will map to &lt;send_request&gt; of the standard
      // APIs.
      //
      // void send_request (in ClientRequestInfo) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ClientRequestInfo&gt; interface.

      void postinvoke (in unsigned long request_id,
                       in boolean response_expected,
                       in CORBA::Object objref,
                       in string operation_name,
                       inout IOP::ServiceContextList sc,
                       inout NVList arguments,
                       inout Cookies ck);
      // After returned from remote invocation.
      // Currently, we don't pass NVList into the interceptor because
      // I haven't figured out how to best optimize this stuff.
      // In the future, NVList will contain all out, inout arguments
      // and the return value of the operation.
      //
      // @@ This operation will map to either &lt;receive_reply&gt; or
      // &lt;receive_other&gt; in the standard APIs depending on whether the
      // operation is oneway or not.
      //
      // void receive_reply (in ClientRequestInfo ri);
      // void receive_other (in ClientRequestInfo ri);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ClientRequestInfo&gt; interface.

      void exception_occurred (in unsigned long request_id,
                               in boolean response_expected,
                               in CORBA::Object objref,
                               in string operation_name,
                               inout Cookies ck);
      // Exception occurred.
      //
      // @@ This method will map to &lt;receive_exception&gt; method as:
      //
      //    void receive_exception (in ClientRequestInfo ri) raises (ForwardRequest);
      //
      // @@ Note that all arguments will be accessed thru
      // &lt;PortableInterceptor::ClientRequestInfo&gt; interface.
    };
};

#pragma prefix ""
</pre>

<hr><P>
<h3><a name="status">Current Status</a></h3>
<ul>
  <li>The core infrastructure is in place as well as the canonical
      request and IOR interception points:
      <CODE>send_request</CODE>,
      <CODE>receive_reply</CODE>,
      <CODE>receive_exception</CODE>,
      <CODE>receive_other</CODE>,
      <CODE>receive_request_service_contexts</CODE>,
      <CODE>receive_request</CODE>,
      <CODE>send_reply</CODE>,
      <CODE>send_exception</CODE>,
      <CODE>send_other</CODE>, and
      <CODE>establish_components</CODE>.
      The remaining client request interception point,
      <CODE>send_poll</CODE>, is <EM>time independent invocation</EM>
      specific.  Once TAO supports time independent invocations, the
      <CODE>send_poll</CODE> interception point will be implemented.
  <li><CODE>ORBInitializer</CODE> registration has been implemented,
      as per the spec.
  <li>Registration of interceptors is now conformant to the spec
      through the <CODE>ORBInitInfo</CODE> class.  Multiple
      interceptors may now be registered.
  <li>IOR interceptors have been implemented.  They allow an external
      service, for example, to add tagged components to profiles
      within IORs as they are being generated.
  <li>Policy factory registration, i.e.
      <CODE>ORBInitInfo::register_policy_factory</CODE>, has been
      implemented.  Corresponding policies can then be created using
      the <CODE>ORB::create_policy</CODE> method.
  <li>Initial reference registration, i.e.
      <CODE>ORBInitInfo::register_initial_reference</CODE>, has been
      implemented.  This is particularly useful for registering local
      objects with the ORB's <CODE>resolve_initial_references</CODE>
      mechanism since they can't be stringified and registered via
      <CODE>-ORBInitRef</CODE> ORB option.
  <li>Basically, all <CODE>ORBInitInfo</CODE> methods have been
      implemented except <CODE>allocate_slot_id</CODE> and
      <CODE>codec_factory</CODE>.
  <li>Implemented most of the remaining
      <CODE>ClientRequestInfo</CODE>, <CODE>ServerRequestInfo</CODE>
      and <CODE>IORInfo</CODE> methods.
  <li>Added support for the
      <CODE>PortableInterceptor::ForwardRequest</CODE>
      exception on both the client and server sides.
</ul>

<hr><P>
<h2><a name="future">Future Work</a></h2>
<ol>
  <li>Add support for the <CODE>ThruPOA</CODE> collocation
      optimization to the interceptor chain; the <CODE>direct</CODE>
      collocation optimization will not go through the interceptor
      chain.
  <li>Implement the <CODE>PortableInterceptor::Current</CODE>
      interface.  Useful for passing data between interceptors.
  <li>Implement the <CODE>CodecFactory</CODE> interface, and an
      accompanying CDR encapsulation <CODE>Codec</CODE>.
      Implementations of each are almost ready and should be available
      soon.  The CDR encapsulation <CODE>Codec</CODE> is useful for
      embedding data in an <CODE>octet</CODE> sequence that conforms
      to the CDR encapsulation rules.  For example, it could be used
      to create the <CODE>octet</CODE> sequence that is part of an
      <CODE>IOP::TaggedComponent</CODE>.  This means that it could
      compliment the IOR interceptor support.
  <li>Add interception points for AMI requests.
  <li>Add interception points for DII/DSI invocations.
  <li>The <CODE>send_poll</CODE> request interception point
      implementation will most likely be deferred until TII is
      supported in TAO.
</ol>

<hr><p>
<h3><a name="issues">Known Issues</a></h3>
<ul>
  <li>The current implementation does not go through the interceptor chain
      when using collocation optimizations such as <CODE>direct</CODE> or
      <CODE>ThruPOA</CODE>.
</ul>

<hr><P>
<H3><a name="ref">References</a></H3>
<UL>
  <LI><p><a href="ftp://ftp.omg.org/pub/docs/orbos/99-12-02.pdf">
      99-12-02</a> Portable Interceptors -- Joint Revised
      Submission.</p>
  <LI><p><a href="ftp://ftp.omg.org/pub/docs/orbos/99-12-14.zip">
      99-12-14</a> Portable Interceptors related IDL files (in zip
      format.) </p>
</UL>
<hr>

</BODY>
