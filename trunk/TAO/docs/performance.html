<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <!-- $Id$ -->
    <title>TAO Performance Tuning</title>
    <LINK href="tao.css" rel="stylesheet" type="text/css">
  </head>

  <body>
  <HR><P>
    <h3>TAO Performance Tuning</h3>

    <h3>Overview</h3>

    <p>
      TAO is increasingly being used to support high-performance
      distributed real-time and embedded (DRE) applications.  DRE
      applications constitute an important class of distributed
      systems where predictability and efficiency are essential for
      success.  This document describes how to configure <a href
      ="index.html">TAO</a> to enhance its throughput, scalability,
      and latency for a variety of applications. </p>

     <p>
      As with most applications, including compilers, enabling
      optimizations can often introduce side-effects that may not be
      desirable for all use-cases.  TAO's default configuration
      therefore emphasizes programming simplicity rather than top
      speed or scalability.  Our goal is to assure that CORBA
      applications work correctly ``out-of-the-box,'' while also
      enabling developers to further optimize their CORBA applications
      to meet stringent performance requirements. </P>
      
    <p>  
      TAO's performance tuning philosophy reflects the fact that there
      are trade-offs between speed, size, scalability, and programming
      simplicity.  For example, certain ORB configurations work well
      for a large number of clients, whereas others work better for a
      small number.  Likewise, certain configurations minimize
      internal ORB synchronization and memory allocation overhead by
      making assumptions about how applications are designed.
    </p>

    <!-- Ossama, can you please add a brief outline of what's
      described in the document below?! -->
      
    <P><HR><P>      
    <h3>Optimizing Throughput</h3>

    <p>
      In this context, ``throughput'' refers to the number of events
      occurring per unit time, where ``events'' can refer to
      ORB-mediated operation invocations, for example.  This section
      describes how to optimize client and server throughput.
    </p>

    <p>
      It is important to understand that enabling throughput
      optimizations for the client may not affect the server
      performance and vice versa.  In particular, the client and
      server ORBs may be designed by different ORB suppliers.
    </p>

    <h3>Optimizing Client Throughput</h3>

    <p>
      Client ORB throughput optimizations improve the rate at which
      CORBA requests (operation invocations) are sent to the target
      server.  Depending on the application, various techniques can be
      employed to improve the rate at which CORBA requests are sent
      and/or the amount of work the client can perform as requests are
      sent or replies received.  These techniques consist of:
    </p>
    <ul>
      <li>
	<b>Run-time features</b> offered by the ORB, such as
	Asynchronous Method Invocations (AMI)
        <!-- Ossama, are there other examples you can list here? -->
      </li>
      <li>
	<b>ORB configurations</b>, such as disabling synchronization
	of various parts of the ORB in a single-threaded application
      </li>
    </ul>
    We explore these techniques below.

    <h4>Run-time Client Optimizations</h4>

    <p>
      For two-way invocations, i.e., those that expect a reply
      (including ``<CODE>void</CODE>'' replies), Asynchronous method
      invocations (AMI) can be used to give the client the opportunity
      to perform other work as a CORBA request is sent to the target,
      handled by the target, and the reply is received.
    </p>

    <h4>Client Optimizations via ORB Configuration</h4>

    <p>
      A TAO client ORB can be optimized for various types of
      applications:
    </p>

    <ul>
      <li>
	<b>Single-Threaded</b>
	<ul>
	  <li>
	    <p>
	      A single-threaded client application may not require
	      the internal thread synchronization performed by TAO.
	      It may therefore be useful to add the following line to your
	      <code>svc.conf</code> file:
	    </p>

	    <blockquote>
	      <code>static <a href = "Options.html#DefaultClient">Client_Strategy_Factory</a> "<a href="Options.html#-ORBProfileLock">-ORBProfileLock</a> null"</code>
	    </blockquote>

	    <p>
	      If such an entry already exists in your
	      <code>svc.conf</code> file, then just add
	      <code>-ORBProfileLock null</code> to the list options
	      between the quotes found after
	      <code>Client_Strategy_Factory</code>.
	    </p>

	    <p>
	      Other options include disabling synchronization in the
	      components of TAO responsible for constructing and sending
	      requests to the target and for receiving replies.  These
	      components are called ``connection handlers.''  To disable
	      synchronization in the client connection handlers, simply
	      add:
	    <p>

	    <blockquote>
	      <code>
		<a href="Options.html#-ORBClientConnectionHandler">
		  -ORBClientConnectionHandler</a> ST
	      </code>
	    </blockquote>

	    <p>
	      to the list of <code>Client_Strategy_Factory</code>
	      options.  Other values for this option, such as
	      <code>RW</code>, are more appropriate for "pure"
	      clients.  See the <code>
		<a href="Options.html#-ORBClientConnectionHandler">
		  -ORBClientConnectionHandler</a></code> option
	      documentation for details.
	    </p>
	    
	  </li>
	</ul>
      </li>

      <li>
	<b>Low Client Scalability Requirements</b>
	<ul>
	  <li>
	    <p>
	      Clients with lower scalability requirements can dedicate a
	      connection to one request at a time, which means that no
              other requests or replies will be sent or received,
	      respectively, over that connection while a request is
              pending.  The connection is <i>exclusive</i> to a given
              request, thus reducing contention on a connection.
              However, that exclusivity 
	      comes at the cost of a smaller number of requests that
	      may be issued at a given point in time.  To enable this
	      behaviour, add the following option to the
	      <code>Client_Strategy_Factory</code> line of your
	      <code>svc.conf</code> file:

	    <blockquote>
	      <code>
		<a href="Options.html#-ORBTransportMuxStrategy">
		  -ORBTransportMuxStrategy</a> EXCLUSIVE
	      </code>
	    </blockquote>

	  </li>
	</ul>
      </li>
    </ul>

    <h3>Optimizing Server Throughput</h3>

    <p>
      FILL IN THE BLANK
    </p>

    <P><HR><P>            
    <h3>Optimizing Scalability</h3>

    <p>
      In this context, ``scalability'' refers to how well an ORB
      performs as the number of CORBA requests increases.  For
      example, a non-scalable configuration will perform poorly as the
      number of pending CORBA requests on the client increases from
      <code>10</code> to <code>1,000</code>, and similarly on the
      server.  ORB scalability is particular important on the server
      since it must often handle many requests from multiple clients.
    </p>

    <h3>Optimizing Client Scalability</h3>

    <p>
      FILL IN THE BLANK
    </p>

    <h3>Optimizing Server Scalability</h3>

    <p>
      FILL IN THE BLANK
    </p>

    <hr><P>
    <address><a href="mailto:ossama@uci.edu">Ossama Othman</a></address>
<!-- Created: Mon Nov 26 13:22:00 PST 2001 -->
<!-- hhmts start -->
Last modified: Sun Dec 16 11:36:28 CST 2001
<!-- hhmts end -->
  </body>
</html>
