<HTML>
  <HEAD>
    <META NAME="GENERATOR" CONTENT="Adobe PageMill 2.0 Mac">
    <TITLE>Configuring TAO's Components</TITLE>
  </HEAD>
<!-- $Id$ -->
<BODY text = "#000000"
link="#000fff"
vlink="#ff0f0f"
bgcolor="#ffffff">

<HR><P>

<H3 ALIGN=CENTER>Configuring TAO's Components</H3>

<H3>Overview</H3>

<p>As described in the <a href="Options.html">options</a>
documentation, various components in TAO can be customized by
specifying options for those components.  This document illustrates
how to combine these options in order to affect ORB behavior and
performance, particularly its <A
HREF="http://www.cs.wustl.edu/~schmidt/CACM-arch.ps.gz">concurrency
model</A>.</P>

<p>TAO configures itself using the ACE Service Configurator
framework.  Thus, options are specified in the familiar
<code>svc.conf</code> file (if you want to use a different file
name, use the <a
href="Options.html#svcfonf"><code>-ORBsvcconf</code></a>
option).</p>

<HR><P>

<H3>Roadmap</H3>

<blockquote>
<P>Details for the following configurations are provided.</P>

<UL> 
  <li><b><a href="#comp">Configurating key components</a>:</b>
      <ul>
        <li><a href="#concurrency">Server Concurrency Strategy.</a>
        <li><a href="#orb">ORB and other resources.</a>
        <li><a href="#poa">POA.</a>
        <li><a href="#coltbl">Collocation Table.</a>
      </ul>
  <li><b><a href="#examples">Configuration examples</a></b>
      <ul>
        <LI><A HREF="#reactive">Single-threaded, reactive model.</A>
        <LI><A HREF="#tpc">Multiple threads, thread-per-connection model.</A>
        <LI><A HREF="#multiorb">Multiple threads, ORB-per-Reactor-thread model.</A>
        <LI><A HREF="#multiorb-tpc">Multiple threads, ORB-per-thread,
            thread-per-connection model.</A>
        <li><a href="#tpool">Multiple threads, thread-pool model.</a>
            (Not yet implemented.)
        <li><a href="#multiorb-tpool">Multiple threads,
            ORB-per-thread, thread-pool model.</a> (Not yet implemented.)
        <li>Each configuration has the following information:</p>
            
            <table border=2 width="70%" cellspacing="2" cellpadding="0">
              <tr align=left>
                <th> Typical Use </th>
                <td> A brief description of the scenario and its typical use. </td>
              </tr>

              <tr align=left>
                <th>Number of Threads</th>
                <td>The number of threads used by ORB-related activities.</td>
              </tr>

              <tr align=left>
                <th>Thread Creator</th>
                <td>Identifies the creator of the threads discussed above.</td>
              </tr>

              <tr align=left>
                <th>Resource Location</th>
                <td>Where information on various resources is stored.</td>
              </tr>

              <tr align=left>
                <th>Thread task</th>
                <td>Describes what task is undertaken for each thread.</td>
              </tr>

              <tr align=left>
                <th>Options</th>
                <td>Specifies the options for each service in order to utilize this configuration.</td>
              </tr>
            </table>
      </ul>
</UL>


</blockquote>

<HR><P>
<h3>Configuring key components<a name="comp"></a></h3>

<ul>
  <li><a name="concurrency">Server concurrency strategy</a> specifies
      the concurrency strategy an ORB uses.  It says nothing about how
      many ORBs (or, threads) are there in a process.<p>
 
      <ul>
        <li><code>reactive</code>: The ORB handles requests
            reactively, i.e., the ORB runs in one thread and service
            multiple requests/connections simultaneously using
            "<code>select</code>" call.  You can have multiple ORBs
            accepting requests reactively and running in separate
            threads.<p> 

        <li><code>thread-per-connection</code>: The ORB handles new
            connections by spawning a new thread whose job is to
            service requests coming from the connection.  The new
            threads inherits all properties from the ORB threads (see
            below.) <p> 

        <li><code>thread-pool</code> (not yet implemented):  ... to be
            continued ... <p> 

      </ul><p>

  <li><a name="orb">ORB and other resources.</a><p>

      <ul>
        <li><code>global</code>: There's only one ORB process-wide.
            ORB_init () must be called only once.  Every thread
            accesses the same ORB.  <p>  

        <li><code>tss</code>: In this case, the programmer is
            responsible for spawning the ORB threads.  ORB_init must
            be called for each ORB threads.  Any ORB spawned thread
            shares the same resource the spawning ORB uses.<p>

      </ul><p>

  <li><a name="poa">POA.</a>
      <ul>
        <li><code>global</code>: All ORBs share the same POA.  The
            advantage of this setting is that once an object is
            registered under an ORB, it can be externalized from other
            ORB.<p>

        <li>per ORB (<code>tss</code>): Each ORB has its own POA,
            which means, the programmer must also instantiate the POA
            for each ORB (otherwise, a default RootPOA gets created,
            which might not be what you what and thus, is discouraged.)<p>

      </ul><p>

  <li><a name="coltbl">Collocation Table.</a>
      <ul>
        <li><code>global</code>:<p>

        <LI>per ORB (<code>tss</code>):<p>

      </ul><p>

</ul>



<HR><P>
<H3>Configuration Example<a name="examples"></a></H3>

<UL>
<LI>Single-threaded, reactive model.<A NAME="reactive"></A>

<p>
<table border=2 width="90%" cellspacing="2" cellpadding="0">
  <th align=left>Typical Use</th>
  <td>
    This is the default configuration of TAO, where one thread handles
    requests from multiple clients via a single Reactor.  It is
    appropriate when the requests (1) take a fixed, relatively uniform
    amount of time and (2) are largely compute bound.
  </td>
</tr>

<tr align=left>
  <th>Number of Threads</th>
  <td>1</td>
</tr>

<tr align=left>
  <th>Thread Creator</th>
  <td>OS or whomever creates the main ORB thread in a process.</td>
</tr>

<tr align=left>
  <th>Resource Location</th>
  <td>Resources are stored process-wide.</td>
</tr>

<tr align=left>
  <th>Thread task</th>
  <td>The single thread processes all connection requests and CORBA messages.</td>
</tr>

<tr align=left>
  <th>Options</th>
  <td>
    <code>TAO_Resource_Manager</code>: <code>-ORBresources global</code><br>
    <code>TAO_Server_Strategy_Factory</code>: <code>-ORBconcurrency reactive</code>
  </td>
</tr>
</table>
</p>

<LI>Multiple threads, thread-per-connection model.<A NAME="tpc"></A>

<p>
<table border=2 width="90%" cellspacing="2" cellpadding="0">
<tr align=left>
  <th>Typical Use</th>
  <td>This configuration spawns a new thread to serve requests
      from a new connection.  This approach works well when
      there are multiple connections active simultaneously and each
      request-per-connection may take a fair amount of time to
      execute. 
</tr>

<tr align=left>
  <th>Number of Threads</th>
  <td>1 plus the number of connections.</td>
</tr>

<tr align=left>
  <th>Thread Creator</th>
  <td>Programmer must set up the main thread which is
      responsible to create new threads for new connections.</td>
</tr>

<tr align=left>
  <th>Resource Location</th>
  <td>Process-wise.</td>
</tr>

<tr align=left>
  <th>Thread task</th>
  <td>The main thread handles new connections and spawns new
      threads for them.  Other threads handle requests for
      established connections.</td>
</tr>

<tr align=left>
  <th>Options</th>
  <td>
    <code>TAO_Resource_Manager</code>: <code>-ORBresources global</code><br>
    <code>TAO_Server_Strategy_Factory</code>: <code>-ORBconcurrency thread-per-connection</code>
  </td>
</tr>

</table>
</p>

<LI>Multiple threads, ORB-per-thread model.<A NAME="multiorb"></A>

<p>
<table border=2 width="90%" cellspacing="2" cellpadding="0">
<tr align=left>
  <th>Typical Use</th>
  <td>In this configuration, there multiple ORBs per process each
      running in its own thread.  Each thread handles requests
      reactively.  It's good for hard real-time applications that require 
      different thread priorities for the various ORBs.</td>
</tr>

<tr align=left>
  <th>Number of Threads</th>
  <td>The number of ORBs.</td>
</tr>

<tr align=left>
  <th>Thread Creator</th>
  <td>The main process (thread).</td>
</tr>

<tr align=left>
  <th>Resource Location</th>
  <td>Thread specific.</td>
</tr>

<tr align=left>
  <th>Thread task</th>
  <td>Service the requests from associating ORB.</td>
</tr>

 <tr align=left>
  <th>Options</th>
  <td>
    <code>TAO_Resource_Manager</code>: <code>-ORBresources tss</code><br>
    <code>TAO_Server_Strategy_Factory</code>: <code>-ORBconcurrency reactive</code>
  </td>
</tr>
</table>
</p>

<LI>Multiple threads, ORB-per-thread, thread-per-connection
model.<A NAME="multiorb-tpc"></A></H3>

<p>
<table border=2 width="90%" cellspacing="2" cellpadding="0">
<tr align=left>
  <th>Typical Use</th>
  <td>This approach provides a range of thread priorities plus connections
      that don't interfere with each others.</td>
</tr>

<tr align=left>
  <th>Number of Threads</th>
  <td>Number of ORBs plus number of connections.</td>
</tr>

<tr align=left>
  <th>Thread Creator</th>
  <td>Main threads creates threads running ORBs.  They, in
      turns, create connection handling threads.</td>
</tr>

<tr align=left>
  <th>Resource Location</th>
  <td>Thread specific.</td>
</tr>

<tr align=left>
  <th>Thread task</th>
  <td>There are ORB threads which handle connection requests
      and handler threads which service requests form
      establiched connections.</td>
</tr>

<tr align=left>
  <th>Options</th>
  <td>
    <code>TAO_Resource_Manager</code>: <code>-ORBresources tss</code><br>
    <code>TAO_Server_Strategy_Factory</code>: <code>-ORBconcurrency thread-per-connection</code>
  </td>
</tr>

</table>
</p>

<LI><A NAME="tpool">Multiple threads, thread-pool model.</A>
(Not yet implemented.)

<p>
<table border=2 width="90%" cellspacing="2" cellpadding="0">
<tr align=left>
  <th>Typical Use</th>
  <td>This model implements a highly optimized thread pool that
      minimizes context switching, synchronization, dynamic memory
      allocations, and data movement between threads.</td>
</tr>

<tr align=left>
  <th>Number of Threads</th>
  <td>The number of threads used by ORB-related activities.</td>
</tr>

<tr align=left>
  <th>Thread Creator</th>
  <td>Identifies the creator of the threads discussed above.</td>
</tr>

<tr align=left>
  <th>Resource Location</th>
  <td>Where information on various resources is stored.</td>
</tr>

<tr align=left>
  <th>Thread task</th>
  <td>Describes what task is undertaken for each thread.</td>
</tr>
</table>
</p>

<LI>Multiple threads, ORB-per-thread, thread-pool model.<A
NAME="multiorb-tpool"></A> (Not yet implemented.)

<p>
<table border=2 width="90%" cellspacing="2" cellpadding="0">
<tr align=left>
  <th>Typical Use</th>
  <td>A brief description of the scenario and its typical use.</td>
</tr>

<tr align=left>
  <th>Number of Threads</th>
  <td>The number of threads used by ORB-related activities.</td>
</tr>

<tr align=left>
  <th>Thread Creator</th>
  <td>Identifies the creator of the threads discussed above.</td>
</tr>

<tr align=left>
  <th>Resource Location</th>
  <td>Where information on various resources is stored.</td>
</tr>

<tr align=left>
  <th>Thread task</th>
  <td>Describes what task is undertaken for each thread.</td>
</tr>
</table>
</p>

</UL>
</blockquote>

<P><HR><P>
Back to the TAO <A HREF="components.html">components documentation</A>.

<!--#include virtual="/~schmidt/cgi-sig.html" -->
</BODY>
</HTML>
