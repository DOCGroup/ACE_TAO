<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Introduction - A very simple server</title>
    <!-- $Id$ -->
  </head>

  <body>
    <h1>Introduction - A very simple server</h1>

    <P>Now that we knwo how to implement a
      <A HREF="../Client/index.html">simple client</A> we need to
      implement a server to test it out.
      We have to provide implementations for both the <TT>Stock</TT>
      and <TT>Stock_Factory</TT> interfaces,
      and then create an executable that implements those interfaces.
    </P>

    <H2>Implementing the <TT>Stock</TT> interface</H2>

    <P>To keep things simple why don't we implement a <TT>Stock</TT>
      object with a fixed price, the constructor will receive all the
      parameters:
<PRE>
class Quoter_Stock_i : public POA_Quoter::Stock {
public:
  Quoter_Stock_i (const char *symbol,
                  const char *full_name,
                  CORBA::Double price);

private:
  std::string symbol_;
  std::string full_name_;
  CORBA::Double price_;
};
</PRE>
      Notice the name of the base class, TAO implements the CORBA 2.2
      specification, that includes the Portable Object Adapter (hence
      the POA prefix).  This new Object Adapter fixes many problems
      with the previous versions of the CORBA specification, where the
      so-called Basic Object Adapter was used.  Unfortunately the
      specification was ambiguous and lead to incompatible (yet
      compliant) specifications.
      Code based on the POA, and conforming to the CORBA 2.2
      specification is almost completely portable,
      the only incompatibilities araise from the names of the
      generated header files and and other minors things like that.
      Those problems can be easily wrapped in helper classes, and the
      file names can be controlled through IDL compiler options in
      most cases.
    </P>
    <P>We have to implement the operations and attributes:
<PRE>
class Quoter_Stock_i : public POA_Quoter::Stock {
public:
  // some details ommited
  char *symbol () throw (CORBA::SystemException);
  char *full_name () throw (CORBA::SystemException);
  CORBA::Double price () throw (CORBA::SystemException);
};

// In the .cpp file:
char *
Quoter_Stock_i::symbol () throw (CORBA::SystemException)
{
  return CORBA::string_dup (this->symbol_.c_str ());
}
</PRE>

    The other attributes and methods are similar, so we don't
    reproduce them here.
    </P>
    <P>The first question is what are those <TT>throw()</TT>
      specifications doing there?  Any CORBA operation or attribute
      can raise a <TT>CORBA::SystemException</TT> the IDL compiler
      must generate a throw specification that includes the CORBA
      system exceptions and any user exceptions listed in the
      <TT>raise</TT> clause.  In turn, the C++ specification requires
      that any derived classes cannot add exceptions to a throw
      specification, so you must have a throw specification in your
      methods, either including <TT>CORBA::SystemException</TT> or
      empty.
    </P>
    <P>It is important to copy the strings before returning them,
      because the ORB will use <TT>CORBA::string_free</TT> to release
      them. The rationale is that over the network the string must be
      copied anyway, hence, the client must be responsible for releasing
      the received string.  When both client and servers are in the same
      address space the ORB can optimize the path and invoke the server
      operation directly, without marshaling or demarshaling.  If the
      client is going to work with both local and remote servers it
      should always expect to own the string, in consequence the server
      implementation must always allocate a copy and return the copy,
      because the server-side must also work identically for local and
      remote clients.  The memory managment rules in CORBA are a bit
      subtle, but there are some simple rules to follow:
      <UL>
        <LI>You must make a copy of the memory that you return, the
          caller is going to release it.
        </LI>
        <LI>Conversely, you must release the memory returned to you, the
        callee made a copy.
        </LI>
        <LI>You don't own the memory that you receive as input
        arguments,
        you can only use it for the duration of the call.
        You must make a copy if you want to hold a reference to it
        after you return.
        </LI>
      </UL>
      The complete memory managment rules can be found in Henning and
      Vinoski book or the CORBA specification.
    </P>

    <P>Typing all this code seems tedious, can't the IDL compiler
      help with this? After all it seems like the method declarations
      are completely specified!  The answer is yes, TAO's IDL compiler
      can generate empty implementations that you can modify, simply
      use the <TT>-GI</TT> option:
<PRE>
$ $ACE_ROOT/TAO/TAO_IDL/tao_idl -GI Quoter.idl
</PRE>
      the empty implementations are generated in the
      <TT>QuoterI.h</TT> and <TT>QuoterI.cpp</TT> files.
      Be advised that the <TT>-GI</TT> option overwrites these files
      every time, so it is better to copy your implementation to
      another file.
    </P>

    <P>Our first implementation of the factory will serve only two
      stocks, "RHAT" and "MSFT":
<PRE>
class Quoter_Stock_Factory_i : public POA_Quoter::Stock_Factory
{
public:
  Quoter_Stock_Factory ();

  Quoter::Stock_ptr get_stock (const char *symbol)
    throw (Quoter::Invalid_Stock_Symbol);

private:
  Quoter_Stock_i rhat_;
  Quoter_Stock_i msft_;
};
    </P>

    <P>The implementation of the <TT>get_stock()</TT> method is
      simple, just compare the symbol name and return the appropriate
      object reference:
<PRE>
Quoter::Stock_ptr
Quoter_Stock_Factory_i::get_stock (const char *symbol)
    throw (Quoter::Invalid_Stock_Symbol)
{
  if (strcmp (symbol, "RHAT") == 0) {
    return this->rhat_._this ();
  } else if (strcmp (symbol, "MSFT") == 0) {
    return this->msft_._this ();
  }
  throw Quoter::Invalid_Stock_Symbol ();
}
</PRE>
    </P>

    <P>So what is that <TT>_this()</TT> method?  In the POA mapping
      the client-side stubs and server-side skeletons are not related
      through inheritance, you must either explicitly activate the
      servant (your implementation object) or use <TT>_this()</TT> to
      activate it with its default POA.  We will discuss more about
      explicit and implicit activation later, but at this point it is
      important to remove any thoughts about converting pointers to
      servants to object references or vice-versa, it just does not
      work that way.
    </P>

    <P>Now that we have all the helper classes in place we must create
      the server executable, we start with the ORB initialization:
<PRE>
int main (int argc, char* argv[])
{
  try {
    // First initialize the ORB, that will remove some arguments...
    CORBA::ORB_var orb =
      CORBA::ORB_init (argc, argv,
                       "" /* the ORB name, it can be anything! */);
</PRE>
    </P>

    <P>On startup the ORB starts the POA in the {\em holding state},
      where all requests received are not processed until the POA is
      activated.  Meanwhile the requests are stored to some
      implementation limit, TAO sets this limit to 0, because queueing
      is a severe source of overhead and unpredictability in real-time
      systems.
    </P>
    <P>What does this means for us? Well we have to activate the POA,
      the process is a bit tedious, first we gain access to the
      RootPOA:
<PRE>
    CORBA::Object_var poa_object =
      orb->resolve_initial_references ("RootPOA");
    PortableServer::POA_var poa =
      PortableServer::POA::_narrow (poa_object.in ());
</PRE>
      The <TT>resolve_initial_references()</TT> is used to bootstrap
      all kinds of services, like the Naming Service, the Trading
      Service, but it is also used to gain access to other ORB
      interfaces, such as the RootPOA, the Current objects and the
      Policy Managers.
    </P>
    <P>Now that we have gained access to the Root POA we must obtain
      its POA manager, the POA managers provide interfaces to activate
      and deactivate one or more POAs:
<PRE>
    PortableServer::POAManager_var poa_manager =
      poa->the_POAManager ();
</PRE>
       and now we activate the POA:
<PRE>
    poa_manager->activate ();
</PRE>
    </P>

    <P>The shutdown process is similar to the client side, but now we
      must also remember to destroy the POA, putting all the code
      above together we get:
<PRE>
int main (int argc, char* argv[])
{
  try {
    // First initialize the ORB, that will remove some arguments...
    CORBA::ORB_var orb =
      CORBA::ORB_init (argc, argv,
                       "" /* the ORB name, it can be anything! */);
    CORBA::Object_var poa_object =
      orb->resolve_initial_references ("RootPOA");
    PortableServer::POA_var poa =
      PortableServer::POA::_narrow (poa_object.in ());
    PortableServer::POAManager_var poa_manager =
      poa->the_POAManager ();
    poa_manager->activate ();

    // The application code goes here!

    // Destroy the POA, waiting until the destruction terminates
    poa->destroy (1, 1);
    orb->destroy ();
  }
  catch (CORBA::Exception &ex) {
    std::cerr << "CORBA exception raised!" << std::endl;
  }
  return 0;
}
</PRE>
    </P>

    <P>Now we create an instance of our stock factory implementation
      and activate it using <TT>_this()</TT>
<PRE>
    Quoter_Stock_Factory_i stock_factory_i;

    Quoter::Stock_Factory_var stock_factory =
      stock_factory_i._this ();
</PRE>
      next we convert the object reference into an IOR string, so it
      can be used by the client:
<PRE>
    CORBA::String_var ior = orb->object_to_string (stock_factory.in ());
    std::cerr << ior.in () << std::endl;
</PRE>
    </P>

    <P>There is only one final detail, we must run the ORB event loop
      to start processing requests from the client:
<PRE>
    orb->run ();
</PRE>
    </P>

    <P>There are many details that we have left out from this server,
      such as how to terminate the event loop, how to perform servant
      memory managment, orderly deactivation of servants and the fact
      is that it is not very flexible.  But we have covered a number
      of other things, and more importantly we can test the client
      now!
    </P>

    <H3>Exersice 1</H3>

    <P>Flesh out the implementation, you don't have to do it from
      scratch, we provide you with the following files:
      <A HREF="Stock_i.h">Stock_i.h</A>,
      <A HREF="Stock_i.cpp">Stock_i.cpp</A>,
      <A HREF="Stock_Factory_i.h">Stock_Factory_i.h</A>
      <A HREF="Stock_Factory_i.cpp">Stock_Factory_i.cpp</A>,
      <A HREF="Quoter.idl">Quoter.idl</A>
      and the always useful
      <A HREF="Makefile">Makefile</A>
    </P>

    <H4>Solution</H4>

    <P>Compare your solution with
      <A HREF="server.cpp">server.cpp</A>.
    </P>

    <H3>Testing</H3>

    <P>To test this application we need a
      <A HREF="../Client/index.html">client</A>.
      We just run both of them:
<PRE>
$ server > ior_file
$ client file://ior_file MSFT RHAT
</PRE>
      also test invalid symbols!
    </P>

    <hr>
    <address><a href="mailto:coryan@cs.wustl.edu">Carlos O'Ryan</a></address>
<!-- Created: Sat Nov 27 15:47:01 CST 1999 -->
<!-- hhmts start -->
Last modified: Sun Nov 28 11:40:09 CST 1999
<!-- hhmts end -->
  </body>
</html>
