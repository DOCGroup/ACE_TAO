<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Introduction - A very simple client</title>
    <!-- $Id$ -->
  </head>

<BODY text = "#000000"
link="#000fff"
vlink="#ff0f0f"
bgcolor="#ffffff">
    <h3>Introduction - A very simple client</h3>

    <P>We will start with a reasonably simple IDL interface, we want
      to build a stock quoter server, some interface to query the
      prices of stock.  To make a life interesting we will use a
      different CORBA object for each Stock, this may sound as an
      overkill, but it will motivate a number of elements that are
      interesting to learn on the start.
    </P>
    <P>So we have define an IDL interface:
<PRE>
    interface Stock {
      double price ();
    };
</PRE>
    but stocks usually have symbols and full names, so why not add a
    couple of attributes to query them:
<PRE>
    interface Stock {
      double price ();

      readonly attribute string symbol;
      readonly attribute string full_name;
    };
</PRE>
    </P>
    <P>We also need some interface to gain access to the
      <TT>Stock</TT> object references from their symbols,
      usually we call this kind of interface a <I>Factory</I>,
      and they look like this:
<PRE>
  interface Stock_Factory {
    Stock get_stock (in string stock_symbol);
  };
</PRE>
      Notice how arguments have a <I>direction</I>, they are qualified
      as <I>input only (<TT>in</TT>)</I>,
      <I>output only (<TT>out</TT>)</I>
      or <I>input-output (<TT>inout</TT>)</I> arguments.
      There is a problem though, what happens if the stock symbol is
      invalid?  The CORBA way is to raise an exception:
<PRE>
  exception Invalid_Stock_Symbol {};
</PRE>
      and then make the exception part of the
      <TT>Stock_Factory</TT> interface:
<PRE>
  interface Stock_Factory {
    Stock get_stock (in string stock_symbol)
      raises (Invalid_Stock_Symbol);
  };
</PRE>
    </P>

    <P>Finally we put all this IDL constructs in a module to avoid
      namespace pollution to obtain the
      <A HREF="../Quoter.idl">Quoter.idl</A> file.
    </P>

    <H3>The generated files</H3>

    <P>Let's take a minute to look at the generated code,
      you don't need to do this often, in fact you rarely have to do
      it at all.  But doing it once is educative and can demistify the
      role of the IDL compiler.
    </P>
    <P>To generate the code you must
      invoke the IDL compiler, like
      this:
<PRE>
$ $ACE_ROOT/TAO/TAO_IDL/tao_idl Quoter.idl
</PRE>
      The complete documentation of the IDL compiler and its options
      are include are in the
      <A HREF="../../../../compiler.html">compiler.html</A>,
      naturally this file included in the distribution.
    </P>

    <P>TAO generates 9 files for each IDL file,
      the <TT>QuoterC.h</TT>, <TT>QuoterC.i</TT>
      and <TT>QuoterC.cpp</TT> contain the client-side interfaces,
      notice that the inline functions are on a separate file so you
      can optionally compile them out-of-line for smaller code.
      Pure clients only need to link the object file
      generated from <TT>QuoterC.cpp</TT>.
    </P>
    <P>
      Similarly the <TT>QuoterS.h</TT>, <TT>QuoterS.i</TT>
      and <TT>QuoterS.cpp</TT> contain the server-side
      <I>skeletons</I>. Servers must link the object files generated
      from <TT>QuoterS.cpp</TT> <B>and</B> <TT>QuoterC.cpp</TT>.
    </P>
    <P>
      Finally <TT>QuoterS_T.h</TT>, <TT>QuoterS_T.i</TT>
      and <TT>QuoterS_T.cpp</TT> contain the <I>TIE</I> classes,
      this are the standard (after the CORBA 2.2 spec) skeletons based
      on composition instead of inheritance.
      They are on a separate file only because some compilers cannot
      handle mixed template and non-template code in the same source
      file, you <B>do not</B> need to compile these files in any
      platform.
      Also notice that if your platform does not support namespaces
      then you may be unable to use the TIE approach for some IDL
      interfaces.
    </P>

    <P>All the extensions and suffixes discussed above can be modified
      using options in the IDL compiler, check the documentation for
      more details.  Notice though that you should use consistent
      extensions across your project, otherwise you may have problems
      with some <TT>#include</TT> directives in your IDL source.
    </P>

    <H3>Building a simple client</H3>

    <P>With our simple IDL interface ready we want to start with a
      simple client.  The first thing to do in any CORBA client or
      server is initialize the ORB:
<PRE>
int main (int argc, char* argv[])
{
  try {
    // First initialize the ORB, that will remove some arguments...
    CORBA::ORB_var orb =
      CORBA::ORB_init (argc, argv,
                       "" /* the ORB name, it can be anything! */);
</PRE>
      since the ORB initialization can fail, and in fact, any CORBA
      operation can raise a <TT>CORBA::SystemExpception</TT> we use
      a <TT>try/catch</TT> block to check for any failures.
      Needless to say this is very naive, some failures can be
      temporary and we should have a better way to recover from
      errors, but this is enough for our example.
      In consequence, at the end of <TT>main()</TT> we catch all
      kinds of CORBA exceptions:
<PRE>
  }
  catch (CORBA::Exception &ex) {
    std::cerr << "CORBA exception raised!" << std::endl;
  }
  return 0;
}
</PRE>
      We must not forget that the ORB is a resource that must be
      released by the application, until CORBA 2.3 there was no
      standard way to do this. TAO has adopted the new specification,
      so our client should really look like this:
<PRE>
int main (int argc, char* argv[])
{
  try {
    // First initialize the ORB, that will remove some arguments...
    CORBA::ORB_var orb =
      CORBA::ORB_init (argc, argv,
                       "" /* the ORB name, it can be anything! */);

    // the real code goes here!

    orb->destroy ();
  }
  catch (CORBA::Exception &ex) {
    std::cerr << "CORBA exception raised!" << std::endl;
  }
  return 0;
}
</PRE>
    </P>

    <P>Just a few words about the ORB name, the spec requires the ORB
      to return the same ORB pointer if the same ORB id is used in
      <TT>CORBA::init</TT>,
      the implementation is free to return the same pointer even if
      different ids are used,
      usually this is not a problem as most applications instantiate a
      single ORB.  TAO is one of the few CORBA implementations that
      actually support multiple ORB pointers, this can be important
      for real-time applications where each ORB executes at different
      priority.
    </P>

    <P>Now that we have the ORB pointer we can start bootstrapping the
      application, normally we would use the Naming Service,
      Trading Service or the Interoperable Naming Service to locate
      the stock factory, but for simplicity let us use just an IOR
      string passed in the first argument.
    </P>
    <P>The easiest way is to use the first argument to get the string,
      and then use <TT>string_to_object()</TT> to conver it into an
      object reference:
<PRE>
    CORBA::Object_var factory_object =
      orb->string_to_object (argv[1]);

    Quoter::Stock_Factory_var factory =
      Quoter::Stock_Factory::_narrow (factory_object.in ());
</PRE>
      There are a few interesting things about TAO, first it supports
      the <TT>file:</TT> scheme for object references, so the first
      argument could be <TT>file://a_file_name</TT>, in that case
      the ORB will open the file named <TT>"a_file_name"</TT> and
      read the IOR from that file.
      TAO also supports the <TT>iioploc:</TT> scheme, for example
      <TT>iioploc://ace.cs.wustl.edu:12345/Stock_Factory</TT>.
      So using a string can be a very powerful bootstrapping protocol.
    </P>
    <P>Before we go any further, at this point we are using interfaces
      generated by the IDL compiler, so we must include the correct
      header file!
<PRE>
#include "QuoterC.h"
</PRE>
      notice that this is all you need to include, the IDL compiler
      generates code that includes all the required internal header
      files.
      When you use TAO services don't forget to include their
      corresponding header file too.
    </P>

    <P>Another interesting TAO feature is the support for
      <TT>_unchecked_narrow()</TT>,
      this is part of the CORBA Messaging specification and
      essentially performs the same work as <TT>_narrow()</TT>,
      but it does not check the types remotely,
      it you have compile time knowledge that ensures the correctness
      of the narrow operation, it is more efficient to use the
      unchecked version.
    </P>

    <P>Now we can use the rest of the arguments to obtain the stock
      objects:
<PRE>
    for (int i = 2; i != argc; ++i) {
      try {
        // Get the stock object
        Quoter::Stock_var stock =
          factory->get_stock (argv[i]);
</PRE>
    </P>

    <H3>Exercise 1</H3>

    <P>Complete the client implementation, it should be easy at this
      point, but it will give you a chance to setup your environment
      and become familiar with the basics of building a TAO
      application.
    </P>
    <P>You don't need to do everything,
      the <A HREF="../Quoter.idl">Quoter.idl</A> file and
      a <A HREF="Makefile">Makefile</A> are provided, just
      implement the <TT>client.cpp</TT> file.
      Cut & paste the ORB initialization code, and anything you find
      useful from above, you can even cheat and look at the soluition,
      but it is going to be some really boring 30 minutes if you do!
    </P>

    <H4>Solution</H4>
    <P>Look at the
      <A HREF="client.cpp">client.cpp</A> file, it should
      not be much different from yours.  Count the number of lines in
      your client, the idl file and the <TT>QuoterC.*</TT> files, do
      you want to write all that code ever again?
    </P>

    <H3>Testing</H3>

    <P>To test this application we need a server working, this is a
      good excuse to go to the next
      <A HREF="../Server/index.html">lesson</A> in the tutorial.
    </P>

    <hr>
    <address><a href="mailto:coryan@cs.wustl.edu">Carlos O'Ryan</a></address>
<!-- Created: Sat Nov 27 15:47:01 CST 1999 -->
<!-- hhmts start -->
Last modified: Sun Nov 28 14:19:15 CST 1999
<!-- hhmts end -->
  </body>
</html>
