<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.03 [en] (X11; I; Linux 2.0.30_SMP i686) [Netscape]">
   <TITLE>TAO Release Information and TODO List</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#000FFF" VLINK="#FF0F0F">
<!-- $Id$ -->
<CENTER>
<H2>
Release Information for The ACE ORB (TAO)</H2></CENTER>

<CENTER>
<H3>
Version 0.0.12</H3></CENTER>

<CENTER>
<H3>
17-October-1997</H3></CENTER>

<HR>
<H3>
Roadmap</H3>
Information is available on the following topics related to the current
release of <A HREF="TAO.html">TAO</A>:
<UL>
<LI>
<A HREF="#orb">ORB &amp; ORB Core</A></LI>

<LI>
<A HREF="#idl">IDL Compiler</A></LI>

<LI>
<A HREF="#eventchannel">Event Channel</A></LI>

<LI>
<A HREF="#apps">Test &amp; Example Applications</A></LI>

<LI>
<A HREF="#poa">Portable Object Adapter</A></LI>

<LI>
<A HREF="#services">CORBA Services</A></LI>

<LI>
<A HREF="#ace">ORB-related ACE Changes</A></LI>
</UL>

<HR>
<H3>
<A NAME="orb"></A>ORB &amp; ORB Core</H3>
Point of contact: <A HREF="mailto:cleeland@cs.wustl.edu">Chris Cleeland</A>
<BLOCKQUOTE>Current status:
<UL>
<LI>
Provides dynamically linked wholesale assignment of ORB strategies for
communication, concurrency, demultiplexing, scheduling, and dispatching
using the ACE Service Configurator framework.</LI>

<LI>
Supports several concurrency models out of the box: Reactive, Thread-per-Connection,
and ORB-per-thread. The ORB-per-thread design is optimized for real-time
I/O subsystems.</LI>
</UL>
      Recently Completed Work:
      <BLOCKQUOTE>
	<LI>Remove BOA and ROA names from the ORB.</LI>

	<LI>Change CORBA_ORB::open() to return an error status
	(first cut at this already there--needs to be checked
	out).</LI>
      </BLOCKQUOTE>

      Ongoing Work:
      <BLOCKQUOTE>
	<LI>Verify ACE_ & TAO on Linux.</LI>
	<LI>Use Purify to eliminate straggling problems.</LI>
      </BLOCKQUOTE>

      Critical Work:
      <BLOCKQUOTE>
	<LI>Use Purify to track down problems Brian has found.
	<em>Brian is checking out some suggestions, so this will be
	deferred pending his results.</em></LI>

	<LI>Add pre-cached connection on client side.  Clients will
	pass in a comma-separated list of <em>host:port</em>
	destinations using the <code>CORBA::ORB_init()</code>
	interface.</LI>

	<LI>Validate movement of Strategy Connector into ORB&nbsp;Core.</LI>

	<LI>The lock used in <code>giop.cpp:626</code> originally
	appeared in the IIOP-1.4 code base.  Its purpose was to
	protect access to the <code>fwd_profile</code> data member.
	We're not using the forward feature right now, so we could
	eliminate it entirely.  The smarter move is probably to fold
	the lock into <code>IIOP_Object</code> and only make it
	available through an accessor method.  This translates into
	the following TODO:</LI>
	<BLOCKQUOTE>
	  <ul>
	    <LI>Move <code>lock_</code> member from <code>TAO_GIOP_Invocation</code> into <code>IIOP_Object</code>.</li>
	    <li>Make <code>IIOP_Object::fwd_profile</code> private.</li>
	    <li>Create accessors for <code>IIOP_Object::fwd_profile</code>.</li>
	    <li>Make all references to <code>IIOP_Object::fwd_profile</code> through the accessors.</li>
	  </ul>
	</BLOCKQUOTE>

	<LI>
	  Verify that, in the ORB-per-thread concurrency model, it's
	  possible to have a factory in each thread that creates a
	  client and returns an object reference to that client within
	  that thread.  This is different from the model that Sumedh
	  originally had where the factory was trying to turn out a
	  client in a separate thread/ORB combination.
	  <p>
	  There is no application which attempts this at the moment,
	  so both a client and a server will need to be manufactured.
	  Using existing Cubit-like examples (that poor app is so
	  weary) should reduce development time to a couple of hours.
	</LI>

	<LI>Implement <code>CORBA_ORB::shutdown()</code> as a manner
	in which a thread of control can request that
	<code>CORBA_ORB::run()</code> should return and no longer
	service requests.</li>

	<LI>Rename following files:&nbsp;Orb_Core.*&nbsp;->orb_core.*
	&amp;&nbsp;orbobj.* -> corba_orb.*.</LI>

      </BLOCKQUOTE>

      Future work:
      <UL>

	<LI>There is a bug in the ORB-per-thread concurrency model
	caused by its use of the ACE Service Configurator. The bug is
	understood, and a patch is being readied and should be
	released no later than October 3rd.</LI>

	<LI>The ORB-per-thread model is not yet integrated with the
	other concurrency models; it must be selected at <I>compile
	time</I> rather than run time.  In order to use it, one must
	add <TT>-DTAO_HAS_TSS_ORBCORE</TT> to the compile line in both
	the library (<TT>$(TAO_ROOT)/tao</TT>) and the application
	(<I>e.g.</I>, <TT>$(TAO_ROOT)/tests/multiCubit</TT>). Future
	releases of TAO will fix this restriction so that all
	threading models are available at run-time.</LI>

	<LI>Support new concurrency models, e.g.,
	Thread-per-Request.</LI>

	<LI>Clean up the internals and analyze for performance bottlenecks using Quantify.</LI>

	<LI>Integrate the <A HREF="#poa">POA</A> implementation.</LI>

	<LI>Add support for <TT>resolve_initial_references</TT> using
	ACE support for UDP broadcast.</LI>

	<LI>Assist in porting higher level services (e.g., <A
	HREF="#eventchannel">Event Channel</A>) to TAO.</LI>
      </UL>
    </BLOCKQUOTE>

    <HR>

    <H3><A NAME="idl"></A>IDL Compiler</H3>
    Point of contact: <A HREF="mailto:gokhale@cs.wustl.edu">Andy Gokhale</A>

    <BLOCKQUOTE>
      Current status

      <UL>
	<LI> Generates C++ stubs and skeletons that use TAO's <A
	HREF="HICSS-97.ps.gz">interpretive IIOP protocol
	engine</A>.</LI>

	<LI>Works for <I>most</I> IDL constructs. Although code is
	generated for everything, support for unions, sequences whose
	element types are anonymous sequences or strings, arrays of
	strings, and other very complicated types may result in C++
	compilation errors.</LI>
      </UL>

      Future work:
      <UL>
	<LI>Add Orbix-like <TT>_bind</TT> calls in lieu of always
	needing a Naming Service.</LI>

	<LI>Improve IDL compiler to support complete IDL-to-C++ mapping.</LI>

	<LI>Fix bugs in the SunSoft IDL front-end we've uncovered.</LI>

	<LI>Use <A
	HREF="http://www.cs.utah.edu/projects/flux/flick/">Flick</A>
	(from the University of Utah) to generate compiled stubs.</LI>

	<LI>Goal is to measure the code size of the interpretive stubs
	generated by TAO IDL compiler <I>vs</I> code size of compiled
	stubs. Then compare the performance of each. We want to prove
	the thesis that TAO IDL compiler generated interpretive stubs
	have a small code size, yet are comparable in performance (or
	slightly less) than compiled stubs. Hence, it will be useful
	for small distributed equipment such as handsets, PDAs,
	etc.</LI>

	<LI>In doing the above, improvements to the IIOP protocol
	engine in terms of size/performance/determinism will be
	made.</LI>
      </UL>
    </BLOCKQUOTE>

<HR>
<H3>
<A NAME="eventchannel"></A>Real-time Event Channel</H3>
Point of contact: <A HREF="mailto:coryan@cs.wustl.edu">Carlos O'Ryan</A>
<BLOCKQUOTE>Current status:
<UL>
<LI>
The current Event Channel is running under Orbix, fully distributed, the
main test has three processes, one runs the EC itself, one a Supplier and
yet another a Consumer.</LI>

<LI>
The configuration runs can be done even on the distributed scenario, using
the Real-time "Scheduling Service", which now has an IDL interface.</LI>

<LI>
At run-time (no config runs) there is no need to use the Real-time Scheduling
Service, a faster, collocated implementation for the service is available.
Obviously the information is generated on the config runs and linked into
the program.</LI>

<LI>
We are using an implementation of the standard <A HREF="#naming">Naming
Service</A> for Orbix.</LI>
</UL>
Future work:
<UL>
<LI>
Port to TAO (once IDL compiler is available and stable).</LI>

<LI>
Change to use standard Naming Service rather than current Orbix <TT>_bind</TT>/<TT>_marker</TT>
calls.</LI>

<LI>
The Scheduling Service is completely independant of the EC and the configuration
of suppliers or consumers. I think it would be convenient to have a library
and binaries for it, including a tool to dump the results in a C++ compilable
form.</LI>
</UL>
</BLOCKQUOTE>

<HR>
<H3>
<A NAME="apps"></A>Test &amp; Example Applications</H3>
Point of contact: <A HREF="mailto:sumedh@cs.wustl.edu">Sumedh Mungee</A>
<BLOCKQUOTE>Current status:

<P>The TAO test application is meant to serve as a starting point for real-time
tests on the TAO system. It comprises the following parts:
<UL>
<LI>
<I>Server.</I> The server creates multiple CORBA objects (servants), each
with different real-time priorities. This priority is implemented by using
real-time thread support provided by the operating system. Thus, requests
sent to a high-priority servant are handled by a high-priority real-time
thread, and those sent to a lower priority servant are handled by correspondingly
lower priority threads.</LI>

<LI>
<I>Client.</I> The client component binds to the servants, and sends a
stream of CORBA requests to the servants. It measures the response time,
i.e. the time taken for the request to complete successfully. In particular,
it measures the time taken for requests sent to the high priority servant
to complete. The volume of lower priority requests is configurable. The
client is thus able to measure the performance of the high-priority servant
in the presence of competition from several lower-priority servants.</LI>
</UL>
Clearly, if the ORB endsystem handles the priorities of the various requests
correctly, increasing the volume of lower priority requests should not
affect the performance seen by the higher priority requests. The application
thus serves as a tool to measure and confirm this behavior.

<P>Future work:
<UL>
<LI>
Study the impacts of scheduling &amp; concurrency strategies on performance.</LI>

<LI>
Evolve into a testbed for discovering sources of performance non-determinism
&amp; priority inversion.</LI>
</UL>
</BLOCKQUOTE>

<HR>
<H3>
<A NAME="poa"></A>Portable Object Adapter</H3>
Point of contact: <A HREF="mailto:irfan@cs.wustl.edu">Irfan Pyrarli</A>
<BLOCKQUOTE>Current Status:
<UL>
<LI>
The POA is not integrated into this release, though we've begun migrating
TAO's OA to use POA method names.</LI>
</UL>
Critical work:
<BLOCKQUOTE>
<LI>
Re-generate win32 project files with new file names.</LI>

<LI>
Add resolve_initial_references() to resolve the "RootPOA" entry.</LI>
</BLOCKQUOTE>
Future work:
<UL>
<LI>
Mostly compliant with the <A HREF="http://siesta.cs.wustl.edu/~cleeland/tao/POA.pdf">ORB
Portability Specifications [orbos/97-05-15]</A> published by OMG.</LI>

<LI>
Provide extensions of the specification to ensure real-time delivery of
messages.</LI>
</UL>
</BLOCKQUOTE>

<HR>
<H3>
<A NAME="services"></A>CORBA Services</H3>
Point of contact: <A HREF="mailto:marina@cs.wustl.edu">Marina Spivak</A>
<BLOCKQUOTE>
<H4>
<A NAME="naming"></A>NAMING SERVICE</H4>
The Naming Service is a non-persistent implementation of the OMG Naming
Service specification.

<P>Current status:
<UL>
<LI>
This implementation works on ORBIX 2.0.</LI>
</UL>
Future work:
<UL>
<LI>
Port to TAO (once IDL compiler is available and stable).</LI>
</UL>

<H4>
<A NAME="trading"></A>TRADING SERVICE</H4>
The Trading Service is an implementation conforming to OMG Trading Service
specification.

<P>Current status:
<UL>
<LI>
This is a simple trader (registers/withdraws/describes offers and does
constraint based lookup for those offers) working on VisiBroker 2.0 v1.51.</LI>
</UL>
Future work:
<UL>
<LI>
Port to TAO.</LI>

<LI>
Implement Type Repository and Admin Interfaces for Trading Service.</LI>
</UL>
</BLOCKQUOTE>

<HR>
<H3>
<A NAME="ace"></A>ORB-related ACE Changes</H3>
Points of contact: <A HREF="mailto:cleeland@cs.wustl.edu">Chris Cleeland</A> and <A HREF="mailto:irfan@cs.wustl.edu">Irfan Pyrarli</A>

    <BLOCKQUOTE>
      Task List:

      <ul>
	<li>Fix <code>strsplit_r()</code> (waiting on response from
	user having problems).</li>
	
	<li>The current caching connector does not behave properly in
	the face of a non-blocking connect request.  The "fix" is
	simply to not support non-blocking connects through the cache.
	When the <code>connect()</code> fails with
	<code>EWOULDBLOCK</code>, morph the error to -1 and clean up
	the request.</li>

	<li>Service handlers obtained from the caching connector are
	not cleaned up.  The application needs to be able to signal
	that it's not using it any longer, and, when the application
	encounters an error, needs to effectively close down that
	connection for good so that a new connection can be initiated.
	We're still working through the details on how to accomplish
	this.</li>
	 
      </ul>
      
    </BLOCKQUOTE>

<HR ALIGN=LEFT>
</BODY>
<pre>
$Id$
</pre>
</HTML>
