<html>
  <!-- $Id$ -->
  <head>
    <title>TAO IDL compiler User's Guide</title>
  </head>

<BODY text = "#000000"
link="#0000ff"
vlink="#cc0000"
bgcolor="#ffffff">

  <body>
<HR><P>
      <h3>TAO IDL compiler User's Guide</h3>
    <H2>Scope</H2>

    <P>
      This document describes the options and features of TAO IDL
      compiler,
      it is not a reference manual or tutorial on IDL.
    </P>

    <H2>Generated Files</H2>

    <P>
      The IDL compiler generates 6 files from each <CODE>.idl</CODE>
      file,
      the file names are obtained by taking the IDL basename and
      appending
      <CODE>C.h</CODE>,
      <CODE>C.i</CODE>,
      <CODE>C.cpp</CODE>,
      <CODE>S.h</CODE>,
      <CODE>S.i</CODE>
      and <CODE>S.cpp</CODE>;
      the client stubs are declared in the <CODE>C.h</CODE> file,
      the skeletons in the <CODE>S.h</CODE> file.
    </P>

    <P>
      Both clients and servers should link against the object files
      for the stubs and skeletons,
      this is needed to transparently support collocated objects.
    </P>

    <H2>Options</H2>

    <P>
      The IDL compiler invokes your <CODE>C</CODE>
      (or <CODE>C++</CODE>) preprocessor to resolve included IDL files,
      it receives the common options for preprocessors
      (such as <CODE>-D</CODE> or <CODE>-I</CODE>);
      but also receives other options that are specific to it.
    </P>

    <P>
    <TABLE BORDER="2"
      CELLSPACING="2"
      CELLPADDING= "0">
      <TR>
	<TH>Option</TH><TH>Description</TH></TR>
      <TR NAME="V">
	<TD><CODE>-V</CODE></TD>
	<TD>The compiler printouts its version and exits</TD></TR>
      <TR NAME="Wb">
	<TD><CODE>-Wb,</CODE><EM>option_list</EM</TD>
	<TD>Pass options to the backend.</TD></TR>
      <TR NAME="export_macro">
	<TD></TD>
	<TD><CODE>export_macro=</CODE><EM>macro_name</EM></TD>
	<TD>
	  The compiler will emit 
	  <EM>macro_name</EM>
	  right after each <CODE>class</CODE> or <CODE>extern</CODE>
	  keyword,
	  this is needed for Windows/NT that requires special
	  directives to export symbols from DLLs,
	  usually the definition is just a space on unix platforms.
	</TD>
      </TR>
      <TR NAME="export_include">
	<TD></TD>
	<TD><CODE>export_include=</CODE><EM>include_path</EM></TD>
	<TD>
	  The compiler will generate code to include
	  <EM>include_path</EM> at the top of the client header,
	  this is usually a good place to define the export macro.
	</TD>
      </TR>
      <TR NAME="E">
	<TD><CODE>-E</CODE></TD>
	<TD>Only invoke the preprocessor</TD></TR>
      <TR NAME="Wp">
	<TD><CODE>-Wp,</CODE><EM>option_list</EM</TD>
	<TD>Pass options to the preprocessor.</TD>
      <TR NAME="D">
	<TD><CODE>-D</CODE><EM>macro_definition</EM></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      <TR NAME="U">
	<TD><CODE>-U</CODE><EM>macro_name</EM></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      <TR NAME="I">
	<TD><CODE>-I</CODE><EM>include_path</EM></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      <TR NAME="A">
	<TD><CODE>-A</CODE><EM>assertion</EM></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      <TR NAME="Y">
	<TD><CODE>-Y</CODE></TD>
        <TD>It is passed to the preprocessor</TD></TR>
     <TR NAME="H">
	<TD><CODE>-H</CODE></TD>
	<TD>IDL-Compiler-Generated Skeleton uses  Dynamic Hashed
            Operation Lookup Strategy. Default operation lookup
            strategy is Perfect hashing which uses <A
            HREF="http://www.cs.wustl.edu/~schmidt/gperf.ps.gz">gperf 
            </A> program, to generate lookup methods.
        </TD>
      </TR>
      <TR NAME="g">
           <TD><CODE>-g</CODE></TD>
           <TD> To specify the path for the perfect hasing program 
               (GPERF). Default is $ACE_ROOT/bin/gperf.
           </TD>
       </TR>

       <TR NAME="o">
            <TD><CODE>-o</CODE></TD>
            <TD> To specify the output directory to IDL compiler  as to where
                all the IDL-compiler-generated files are to be put. By
                default, all the files are put in the current directory
                from where <tao_idl> is called.
            </TD>
          </TR>
          
          <TR NAME="hc">
      <TD><CODE>-hc</CODE></TD>
      <TD>Client's header file name ending. Default is
          "C.h".</TD></TR> 
    <TR NAME="hs">
            <TD><CODE>-hs</CODE></TD>
            <TD>Server's header file name ending. Default is
                "S.h".</TD></TR>
    <TR NAME="hT">
            <TD><CODE>-hT</CODE></TD>
            <TD>Server's template header file name ending. Default is 
                "S_T.h".</TD></TR>
    <TR NAME="cs">
            <TD><CODE>-cs</CODE></TD>
            <TD>Client stub's file name ending. Default is
                "C.cpp".</TD></TR> 
    <TR NAME="ci">
            <TD><CODE>-ci</CODE></TD>
            <TD>Client inline file name ending. Default is
                "C.i".</TD></TR> 
    <TR NAME="ss">
            <TD><CODE>-ss</CODE></TD>
            <TD>Server skeleton file name ending. Default is
                "S.cpp".</TD></TR>
    <TR NAME="sT">
            <TD><CODE>-sT</CODE></TD>
            <TD>Server template skeleton file name ending. Default is 
                "S_T.cpp".</TD></TR>
     <TR NAME="si">
            <TD><CODE>-si</CODE></TD>
            <TD>Server inline skeleton file name ending. Default is 
                "S_i.cpp".</TD></TR>                
     <TR NAME="st">
             <TD><CODE>-st</CODE></TD>
             <TD>Server's template inline file name ending. Default is
                 "S_T.i".</TD></TR>
    </TABLE>
    </P>

    <hr><P>
    <address><a href="mailto:coryan@cs.wustl.edu">Carlos O'Ryan</a></address>
  </body>
</html>
