<html>
  <!-- $Id$ -->
  <head>
    <title>TAO IDL compiler User's Guide</title>
  </head>

<BODY text = "#000000"
link="#0000ff"
vlink="#cc0000"
bgcolor="#ffffff">

  <body>
    <CENTER>
      <h1>TAO IDL compiler User's Guide</h1>
    </CENTER>

    <H2>Scope</H2>

    <P>
      This document describes the options and features of TAO IDL
      compiler,
      it is not a reference manual or tutorial on IDL.
    </P>

    <H2>Generated Files</H2>

    <P>
      The IDL compiler generates 6 files from each <CODE>.idl</CODE>
      file,
      the file names are obtained by taking the IDL basename and
      appending
      <CODE>C.h</CODE>,
      <CODE>C.i</CODE>,
      <CODE>C.cpp</CODE>,
      <CODE>S.h</CODE>,
      <CODE>S.i</CODE>
      and <CODE>S.cpp</CODE>;
      the client stubs are declared in the <CODE>C.h</CODE> file,
      the skeletons in the <CODE>S.h</CODE> file.
    </P>

    <P>
      Both clients and servers should link against the object files
      for the stubs and skeletons,
      this is needed to transparently support collocated objects.
    </P>

    <H2>Options</H2>

    <P>
      The IDL compiler invokes your <CODE>C</CODE>
      (or <CODE>C++</CODE>) preprocessor to resolve included IDL files,
      it receives the common options for preprocessors
      (such as <CODE>-D</CODE> or <CODE>-I</CODE>);
      but also receives other options that are specific to it.
    </P>

    <P>
    <TABLE BORDER="2"
      CELLSPACING="2"
      CELLPADDING= "0">
      <TR>
	<TH>Option</TH><TH>Description</TH></TR>
      <TR NAME="V">
	<TD><CODE>-V</CODE></TD>
	<TD>The compiler printouts its version and exits</TD></TR>
      <TR NAME="Wb">
	<TD><CODE>-Wb,</CODE><EM>option_list</EM</TD>
	<TD>Pass options to the backend.</TD></TR>
      <TR NAME="export_macro">
	<TD></TD>
	<TD><CODE>export_macro=</CODE><EM>macro_name</EM></TD>
	<TD>
	  The compiler will emit 
	  <EM>macro_name</EM>
	  right after each <CODE>class</CODE> or <CODE>extern</CODE>
	  keyword,
	  this is needed for Windows/NT that requires special
	  directives to export symbols from DLLs,
	  usually the definition is just a space on unix platforms.
	</TD>
      </TR>
      <TR NAME="export_include">
	<TD></TD>
	<TD><CODE>export_include=</CODE><EM>include_path</EM></TD>
	<TD>
	  The compiler will generate code to include
	  <EM>include_path</EM> at the top of the client header,
	  this is usually a good place to define the export macro.
	</TD>
      </TR>
      <TR NAME="E">
	<TD><CODE>-E</CODE></TD>
	<TD>Only invoke the preprocessor</TD></TR>
      <TR NAME="Wp">
	<TD><CODE>-Wp,</CODE><EM>option_list</EM</TD>
	<TD>Pass options to the preprocessor.</TD>
      <TR NAME="D">
	<TD><CODE>-D</CODE><EM>macro_definition</EM></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      <TR NAME="U">
	<TD><CODE>-U</CODE><EM>macro_name</EM></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      <TR NAME="I">
	<TD><CODE>-I</CODE><EM>include_path</EM></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      <TR NAME="A">
	<TD><CODE>-A</CODE><EM>assertion</EM></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      <TR NAME="Y">
	<TD><CODE>-Y</CODE></TD>
	<TD>It is passed to the preprocessor</TD></TR>
      </TABLE>
    </P>

    <hr>
    <address><a href="mailto:coryan@cs.wustl.edu">Carlos O'Ryan</a></address>
  </body>
</html>
