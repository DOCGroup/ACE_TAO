<!-- $Id$ -->
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>TAO Implementation Repository</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#CC0000">

<hr>

<h1>TAO Implementation Repository </h1>

<p>Revision 3.02 - July 10, 1998</p>

<hr>

<h2>Table of Contents</h2>

<ul>
  <li><a href="#Overview">Overview</a> <ul>
      <li><a href="#PersistentandTransientIORs">Persistent and Transient IORs</a> </li>
      <li><a href="#TheImplementationRepository">The Implementation Repository</a> </li>
    </ul>
  </li>
  <li><a href="#TAOsImplementationRepository">TAO's Implementation Repository</a> <ul>
      <li><a href="#VirtualServerName">Virtual Server Name</a> </li>
      <li><a href="#NewIORs">New IORs</a> <ul>
          <li><a href="#WhatwaswrongwiththeoldIOR">What was wrong with the old IOR?</a> </li>
          <li><a href="#WhydoesImplRepocontainanOBJKey">Why does the Implementation Repository profile
            contain an Object Key?</a> </li>
        </ul>
      </li>
      <li><a href="#POAExtensions">POA Extensions</a> </li>
      <li><a href="#PossibleFutureGoals">Possible Future Goals</a> </li>
      <li><a href="#ServerRestrictions">Server Restrictions</a> </li>
      <li><a href="#PreliminaryInterface">Preliminary Interface</a> </li>
    </ul>
  </li>
  <li><a href="#AlternateImplementations">Alternate Implementations</a> </li>
  <li><a href="#AccessingtheImplementationRepository">Accessing the Implementation Repository</a>
    <ul>
      <li><a href="#HelperApplication">Helper Application</a> </li>
      <li><a href="#LocatinganinstanceofImplRepo">Locating an instance of the Implementation
        Repository</a> <ul>
          <li><a href="#Serverside">Server Side</a> </li>
          <li><a href="#Clientside">Client Side</a> </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Howitworks">How It Works</a> <ul>
      <li><a href="#HowServerProducesPersistentIORdefault">How a server produces a Persistent IOR
        (in the default case)</a> </li>
      <li><a href="#HowServerProducesPersistentIORcomplex">How a server produces a Persistent IOR
        (in the complex case)</a> </li>
      <li><a href="#HowClientUsesPersistentIOR">How a client uses a Persistent IOR</a> </li>
    </ul>
  </li>
</ul>

<hr>

<h2><a name="Overview">Overview</a></h2>

<p>This document describes the proposed design of the TAO
Implementation Repository, which was originally known as the
reactivator/activation service.  If you have any questions or comments
on our design, please post them to the <A HREF="ACE-mail.html">ACE</a>
mailing list &lt;<A
HREF="mailto:ace-useres@cs.wustl.edu">ace-users@cs.wustl.edu</A>&gt;
or send email to Darrell Brunsch &lt;<A
HREF="mailto:brunsch@cs.wustl.edu">brunsch@cs.wustl.edu</a>&gt;.<P>

<h3><a name="PersistentandTransientIORs">Persistent and Transient IORs</a></h3>

<p>CORBA defines two types of object references: <A
HREF="http://www.cs.wustl.edu/~schmidt/C++-report-col12.ps.gz">persistent
and transient</A>.  The difference between the two stems from the
lifetime of the reference in relation to the lifetime of the server
process that created it.  The lifetime of a transient object reference
is limited to the lifetime of its server process.  Once the server
process exits the transient object reference no longer exists. All
references to this object should now be invalid, even if the server is
restarted. In contrast, persistent object references can outlive their
originating server process.  Therefore, the server can exit and be
restarted without invalidating its persistent object references.  This
enables the implementation of features like automatic server
activation and object migration.</p>

<p>Note that both persistent and transient object references can refer
to objects that reside in <EM>manually activated</EM> servers,
<EM>i.e.</EM>, the so-called ``persistent servers.''  A persistent
server is a server that is launched manually, <EM>i.e.</EM>, it is
always running.  A persistent server can generate transient references
and/or persistent references.  </P>

</P>Developers should be aware that persistence of the object
reference does not imply any persistence on the object implementation
state.  It is certainly possible to provide persistent object
references for objects whose state is not persistent.  Therefore,
servant implementors are responsible for preserving the state of their
servants, <EM>e.g.</EM>, using a database or file. </p>

<h3><a name="TheImplementationRepository">The Implementation Repository</a></h3>

<p>According to the CORBA specification, &quot;The Implementation
Repository contains information that allows the ORB to locate and
activate implementations of objects&quot; [CORBA Spec Rev. 2.2:
2.1.14] In earlier revisions of the specification, there was a method
<code>get_implementation</code> in the CORBA Object interface. This
has been deprecated as of the CORBA 2.2 specification, leaving both
the interface and implementation of the Implementation Repository to
the ORB vendor.</p>

<p>A good paper describing the functionality of the CORBA
Implementation Repository is &quot;<a
href="http://www.cs.wustl.edu/~schmidt/michi.pdf">Binding, Migration,
and Scalability in CORBA</a>&quot; [Henning].  This paper describes
the following three functions of the Implementation Repository:

<ol>
  <li>Maintain a registry of known servers.</li>
  <li>Record which server is currently running, and which port and
      host it uses.</li>
  <li>Starts servers on demand if they are registered with the
      Implementation Repository.</li>
</ol>

<p>The TAO Implementation Repository is based on the design in this
paper.  The next section details our goals and plans for the
implementation.</p>

<hr>

<h2><a name="TAOsImplementationRepository">TAO's Implementation Repository</a></h2>

<p>The following is an overview of TAO'S Implementation Repository:

<ul>
  <li>Use of TAO's Implementation Repository will be optional.
      Real-time applications can choose not to use the Implementation
      Repository according to their
      performance/predictability/footprint requirements.</li> 

  <li>Use of TAO's Implementation Repository will be invisible to
      clients and servers for common use-case. For more
      complicated behavior, programs can use Implementation Repository
      extensions of the POA.</li>

  <li>TAO's Implementation Resository will work with any CORBA
      client that supports <CODE>LOCATION_FORWARD</CODE> IIOP messages
      and multiple profiles in IORs, even if the client is not
      implemented using TAO.</li> 

  <li>TAO's Implementation Repository will track all process that have
      registered with it by using a &quot;ping&quot; component located in
      the server. This ensures that multiple instances of the same
      server are not started.
<!-- Darrell, can you please elaborate on this a bit?  -->
</li> 

  <li>TAO will be fork-safe. Because the Implementation Repository will need to use fork/exec
    (or CreateProcess on NT) to launch servers, the open connection to
    the client will need to be preserved over the server creation.</li>
<!-- COR: Maybe I didn't explain myself properly when we discussed -->
<!-- COR: this, I would expect that after fork all connections are -->
<!-- COR: closed on the server, otherwise we will end up leaking -->
<!-- COR: resources (file descriptors or handles) -->
<!-- DB: Then I'm not sure how are we supposed to return a LOCATION -->
<!-- DB: FORWARD if we have to close the connection? -->
<!-- DCS: Darrell, I think it's ok to close the connection, as long as -->
<!-- we set up the right port number for the child process to listen -->
<!-- at, right?  Can you please clarify this a bit more in the text, BTW? -->

  <li>TAO will exploit features of IIOP 1.1 to safely and efficiently verify if an IOR was
    generated by TAO itself on the client side. The server will still determine this through
    the object key, since that is all that is passed in a request.</li>

  <li>TAO will support multiple profiles. 
<!-- Darrell, can you please clarify this just a bit, i.e., explain -->
<!-- what it means to support multiple profiles? -->
     Our goal is to have the clients contact the object first, and if
      that fails, then contact the Implementation Repository. 
<!-- Darrell, can you please clarify what the motivation is for the -->
<!-- Implementation Repository? -->
</li>
</ul>

<h3><a name="VirtualServerName">Virtual Server Name</a></h3>

<p>TAO's Implementation Repository must track which servers are
started and stopped.  The question is at what resolution?  For
instance, it cannot contain an entry for every object, since that
isn't time and space efficient.  It could contain an entry for every
server, and then group objects there. But that approach is inflexible
for object migration since objects are tied to their
executable. Instead, we want TAO's Implementation Repository to store
something in between an object and an executable. In the <a
href="http://www.cs.wustl.edu/~schmidt/michi.pdf">Henning</a> paper,
he mentions the use of a <EM>server name</EM> as the index for the
table maintained by the Implementation Repository. </p>
<!-- Darrell, can you please briefly explain what a server name is and -->
<!-- how it will be defined, i.e., by the application? -->

<p>We will use a virtual server name for a group of objects. 
<!-- Darrell, can you please define what a "virtual server name" is briefly?
The virtual server isn't restricted to being tied to an executable
or to an object. Since it isn't tied to an executable, the virtual
servers can be migrated to other servers.</p>
<!-- Darrell, can you please elaborate on this a bit?  It's not clear -->
<!-- why a virtual server enables migration! -->

<h3><a name="NewIORs">New IORs</a></h3>

<p>Standard CORBA IORs contain the following two sections:</p>

<!-- Darrell, can you please briefly explain what a "Type ID" and a -->
<!-- "Sequence of Tagged Profiles" are? -->
<table border="1">
  <tr>
    <td>Type ID</td>
    <td>Sequence of Tagged Profiles</td>
  </tr>
</table>

<p>Currently, TAO uses only one IIOP 1.0 Tagged Profile, which is
defined as follows:</p>

<table border="1">
  <tr>
    <td>Version</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>Transient/Persistent Flag</td>
        <td>TimeStamp</td>
        <td>POA ID</td>
        <td>OBJ ID</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>To accomodate the Implementation Repository and IIOP 1.1, the
Profile was changed in the CORBA specification as follows:</p>

<table border="1">
  <tr>
    <td>Version</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
    <td>Components</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>TAO</td>
        <td>TAO version</td>
        <td>TimeStamp/Server Name</td>
        <td>POA ID</td>
        <td>OBJ ID</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>In TAO, Transient objects will have a TimeStamp to ensure
uniqueness.  Likewise, persistent object will have a server name to
identify them in the Implementation Repository.</p>

<p>For Persistent IORs, a second tagged profile will be added in TAO
to point to the Implementation Repository, as follows:</p>

<table border="1">
  <tr>
    <td>Version</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
    <td>Components</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>TAO</td>
        <td>TAO version</td>
        <td>Server Name</td>
        <td>POA ID</td>
        <td>OBJ ID (actually the OBJ Key of the Server)</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>If the profile was meant for just calls to the Implementation
Repository, then the OBJ ID would be that of the Implementation
Repository Object.</p>

<h4><a name="WhatwaswrongwiththeoldIOR">What was wrong with the old IOR?</a></h4>

<p>We need a place to put a TAO marker in the IOR it so TAO servers
can differentiate TAO IORs from IORs of other vendors. In the original
scheme used in TAO, Persistent IORs had a null timestamp. To support
virtual servers, we will use that slot to store the server name so the
Implementation Repository knows which server to launch.</p>

<h4><a name="WhydoesImplRepocontainanOBJKey">Why does the Implementation Repository
profile contain an Object Key?</a></h4>

<p>It needs to know what the object key of the object when forwarding
is used. A server may contain more than one.
<!-- Darrell, "more than one" what?! -->
 </p>

<h3><a name="POAExtensions">POA Extensions</a></h3>

<p>TAO's POA will contain an new TAO-specific method called
<code>create_reference_with_virtual_server[_and_id] (...)</code>.
This method takes additional arguments for a virtual server name and a
sequence of Implementation Repository IORs. This method will
communicate with each Implementation Repository 
<!-- Darrell, I'm not sure what you mean by "each Implementation -->
<!-- Repository?"  Are there more than one?  Can you please clarify this?
and get its generated profile back. Then all the profiles will be
combined to produce an Persistent IOR.</p>

<h3><a name="PossibleFutureGoals">Possible Future Goals</a></h3>

<p>The following are features that may be added to support TAO's
Implementation Repository:

<ul>
  <li>Optimization on TAO clients to recognize when a server is
    restarted, and change all other IORs that contain the server
    instead of going through the Implementation Repository</li>

  <li>Some sort of server security that checks the executable to make sure it is the correct
    executable (checksum, signatures, etc).</li>
  <li>Add the ability to put servers into DLLs or Shared Object files so the Implementation
    Repository can load it via those methods.</li>
  <li>GUI interface for such things as the helper application.</li>
  <li>Federations of Implementation Repositories.</li>
  <li>The ability to start a remote server (possibly with rsh, ssh, rexec, etc)</li>
</ul>

<h3><a name="ServerRestrictions">Server Restrictions</a></h3>

<p>Servers that are restarted by the Implementation Repository must be
able to recreate enough state to deal with requests from a
client. Unless dynamic servant and POA activation is used, the
restarted server must also recreate the POA in which the object
associated with the persistent object reference was registered and
register this object with that POA. </p>

<!-- Darrell, can you please elaborate briefly on how these -->
<!-- restrictions actually affect the way that a TAO server is -->
<!-- written? -->

<h3><a name="PreliminaryInterface">Preliminary Interface</a></h3>

<p>The following is a proposed IDL interface for the TAO Implementation
Repository: </p>

<pre>module TAO
{
  // ....

  exception Already_Registered {};
  // Object already bound in the Implementation Repository

  exception Cannot_Activate
  {
    string reason_;
  };

  exception Not_Found {};
  // Object not found in the Implementation Repository  
  
  struct Environment_Variable
  {
    string name_;
    string value_;
  };
  // One environment variable
  
  struct INET_Addr
  {
    unsigned short port_;
    unsigned long host_;
  };      
  // The location of a server

  typedef sequence&lt;Environment_Variable&gt; Environment;
  // Complete environment

  typedef sequence&lt;string&gt; Command_Line_Options;
  // Command line options

  struct Process_Options
  {
    string executable_name_;
    // Executable name

    Command_Line_Options command_line_options_; 
    // Command line options

    Environment environment_; 
    // Environment

    string working_directory_;  
    // Working directory

    unsigned long creation_flags_;
    // Creation flags
  };

  interface Ping_Object
  {
    void ping ();
    // Used for checking for liveness of a server.
<!-- Darrell, can you please explain how this ping() will work, i.e., -->
<!-- will it throw an exception if the server isn't live? -->
  };

  interface Implementation_Repository
  {
    Object activate_object (in Object obj)
      raises (Not_Found,
              Cannot_Activate);
      // Restart server that will contain this persistent object and return the
      // new Object reference.
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;obj&gt; is not found
      // in the Implementation Repository.  The &lt;Cannot_Activate&gt; exception
      // is raised when &lt;obj&gt; is found in the Repository but could not be
      // activated.

    INET_Addr activate_server (in string server)
      raises (Not_Found,
              Cannot_Activate);
      // Restart server that is named &lt;server&gt; and return the host/port
      // 
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;server&gt; is not found
      // in the Implementation Repository.  The &lt;Cannot_Activate&gt; exception
      // is raised when &lt;server&gt; is found in the Repository but could not be
      // activated.

    void register_server (in string server,
                          in Process_Options options)
      raises (Already_Registered);
      // Restart server process when client is looking for &lt;server&gt;.
      //
      // The &lt;Already_Registered&gt; exception is raised when &lt;server&gt; has
      // already been registered with the Implementation Repository.
      // 
      // The &lt;Object_Not_Persistent&gt; exception is raised when &lt;server&gt; is
      // not a Persistent Object Reference.

    void reregister_server (in string server,
                            in Process_Options options)
      raises (Already_Registered);
      // Restart server process when client is looking for &lt;server&gt;.
      //
      // The &lt;Already_Registered&gt; exception is raised when &lt;server&gt; has
      // already been registered with the Implementation Repository.
      // 
      // The &lt;Object_Not_Persistent&gt; exception is raised when &lt;server&gt; is
      // not a Persistent Object Reference.

    void remove_server (in string server)
      raises (Not_Found);
      // Remove &lt;server&gt; from the Implementation Repository.
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;server&gt; is not found
      // in the Implementation Repository.

    Profile server_is_running (in string server,
                               in INET_Addr addr, 
                               in Ping_Object ping);
      // Used to notify the Implementation Repository that &lt;server&gt; is alive and
      // well at &lt;addr&gt;.

    void server_is_shutting_down (in string server);
      // Used to tell the Implementation Repository that &lt;server&gt; is shutting
      // down.
    };
};</pre>

<hr>

<h2><a name="AlternateImplementations">Alternate Implementations</a></h2>

<p>Other ORB vendors use alternative techniques for their
Implementation Repositories.  These techniques usually require new
naming techniques to access persistent object references and new
client-side APIs to bind to persistent object references. TAO's
Implementation Repository will not require such extensions. </p>

<p>Another design of an Implementation Repository uses an Object
Reference that points to the Implementation Repository instead of
pointing directly to the persistent object. This extra level of
indirection is used by the Implementation Repository to start the
server (if needed), and then use the Location Forwarding mechanism to
forward the client request to the server. This technique forces
clients to use the Implementation Repository (at least once) even when
the server is already running. </p>

<!-- Darrell, I don't see how we can get away from doing this as a -->
<!-- bootstrapping technique.  Can you please explain where in the -->
<!-- document we discuss how to avoid this initial indirection? -->

<hr>

<h2><a name="AccessingtheImplementationRepository">Accessing the Implementation Repository</a>
</h2>

<p>The Implementation Repository will be transparent to the clients
and the servers. </p>
<!-- Darrell, that's not entirely correct since the server program -->
<!-- must register its virtual server name, right? -->

<h3><a name="HelperApplication">Helper Application</a></h3>

<p>A helper application will be included with the Implementation
Repository. It will be a command-line utility that will assist users
with adding and removing server records (containing virtual server
names and executable name/options) from the Implementation
Repository. </p>

<!-- Darrell, I recommend that you take a look at how VisiBroker and -->
<!-- Orbix do this and write a short explanation of the command-line -->
<!-- utilities you propose to use! -->

<h3><a name="LocatinganinstanceofImplRepo">Locating an Instance of the
Implementation Repository </a></h3>

<h4><a name="Serverside">Server-side</a></h4>

<p>In the default case, the Implementation Repository will be found
via the command-line, environment variables, and multicast (in that
order).  This location strategy is consistent with that used by TAO to
local its default Naming Service instance. Using the POA extensions,
other Implementation Repositories can be specified in the call to
<code>POA::create_reference_with_virtual_server</code>.  The default
port of the Implementation Repository can be overridden through
command-line options or environment variables. </p>

<h4><a name="Clientside">Client-side</a></h4>

<p>One or more Implementation Repositories will be stored in
additional profiles in the IOR.
<!-- Darrell, please make sure you explain why a client might need -->
<!-- multiple Implementation Repositories. -->
Other Implementation Repositories can also be located by multicasting
(on a default multicast group) the server name of the Persistent
Object the client is interested in. The default multicast group and
default port of the Implementation Repository can be overridden
through command line options or environment variables. </p>

<hr>

<h2><a name="Howitworks">How It Works</a></h2>

<h3><a name="HowServerProducesPersistentIORdefault">How a server
produces a Persistent IOR (in the default case)</a></h3>

<p>Before a server starts, it must be registered (via a command-line
utility) with an implementation repository that supports
multicast. </p>
<!-- COR: is multicast support mandatory? OTOH it will be there -->
<!-- COR: always, right? -->
<!-- DB: I'm taking the default case to be that you wrote your -->
<!-- DB: before all this Impl Repo stuff came about.  So you -->
<!-- DB: won't have any environment variables or command line -->
<!-- DB: options that deal with the Impl Repo, so multicast is -->
<!-- DB: the only way we can do it without any work from the -->
<!-- DB: the user. -->

<ol>

  <li>Now the server will start up and call
  <code>ORB_init</code>. <code>ORB_init</code>, if
    not passed a server name, will take argv[0] and use that as a default server name (TAO
    expects this to be the executable name). </li>

  <li><code>ORB_init</code> will create a ping object.</li>

  <li><code>ORB_init</code> will look for Implementation Repositories
    on the command-line, environmental variables, and then through
    multicast (in that order). Once it finds one it registers itself
    and passes the ping object to the implementation repository with
    <CODE>server_is_running</CODE> operation.
<!-- Darrell, can you clarify if this a standard OMG CORBA operation -->
<!-- or a TAO extension? -->
</li>
  <li>The profile returned by registration will be stored for later use.</li>
  <li>Client later can call the <code>POA::create_reference</code> operation.</li>
  <li>The <code>create_reference</code> operation will create the local profile.</li>
  <li>The stored Implementation Repository profile will have its object id changed to be the
    object key just created.</li>
  <li>Both profiles will be joined together in a multiple profile IOR and returned.</li>
</ol>

<h3><a name="HowServerProducesPersistentIORcomplex">How a server produces a Persistent IOR
(in complex cases)</a></h3>

<p>As with the default case, the server must be registered with an
Implementation Repository, although it does not need to be multicast
aware.
<!-- Darrell, can you please clarify why it need not be multicast -->
<!-- aware? -->

<ol>
  <li><code>ORB_init</code> is called and does the default work (if it has Implementation
    Repositories to contact).</li>

  <li><code>POA::create_reference_with_virtual_server[_and_id]</code> will be called with a
    server name and list of Implementation Repositories. </li>

  <li>The profile for the object is created.</li>

  <li>The ping object created in <code>ORB_init</code> and the object key is passed to the
    Implementation Repositories, and their profiles are returned.</li>
  <li>The full IOR is built and returned.</li>
</ol>

<h3><a name="HowClientUsesPersistentIOR">How a client uses a Persistent IOR</a></h3>

<p>For all Clients: 

<ul>
  <li>Client obtains a Persistent Object Reference, which contains multiple profiles to both
    regular objects and Implementation Repositories.</li>
  <li>It will now make a request on the first profile, which is the last known profile for the
    object.</li>
  <li>If this fails, then the next one will be tried. And if that fails, the next. One of the
    other profiles will be a reference to the Implementation Repository, in which it will
    either return NOT_FOUND or will start up the server and return a Location Forward message.</li>
</ul>

<p>If everything fails, then most clients will return failure for the
request. TAO clients will also have added functionality where other
Implementation Repositories can be specified on the command-line, in
environment variables, or found through multicast will also be
contacted.

<ul>
  <li>If all of the profiles fail, then contact the other Implementation Repositories. First
    get those specified on the command line or in environment variables.</li>
  <li>Then, if multicast is available: <ul>
      <li>Multicast the Object Reference to a group of Implementation Repositories&nbsp; </li>
      <li>Wait until response or a timeout. The response will contain the Object Reference of a
        Implementation Repository that knows about the Object Reference </li>
    </ul>
  </li>
  <li>Now connect to any Implementation Repositories that have been found.</li>
  <li>Call <i>activate</i> passing the Persistent Object Reference.</li>
  <li>If a new Object Reference was sent back then retry the request using the it. If this
    request fails, then fail (no more retries).</li>
  <li>If a null reference was sent back, then fail.</li>
</ul>

<p>TAO clients will have an optimization where if there are several
IORs that have the same server name, and one of them gets forwarded,
then the client will be able to change its other IORs without going
through the overhead of contacting Implementation Repository.</p>

<hr>

<p>Back to the <a href="index.html">TAO documentation</a> page.</p>
<!--#include virtual="/~schmidt/cgi-sig.html" -->
</body>
</html>
