<!-- $Id$ -->
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>TAO Implementation Repository</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#CC0000">

<hr>

<h1>TAO Implementation Repository </h1>

<p>Revision 3 - July 8, 1998</p>
<!-- You could use a CVS ident tag here, like -->
<!-- $Date$ -->
<!-- or $Revision$ -->

<hr>

<h2>Overview</h2>

<p>This document describes the proposed design of the TAO Implementation Repository
(previously known as the reactivator or activation service). </p>

<h3>Persistent and Transient IORs</h3>

<p>CORBA defines two types of object references, persistent and transient objects.&nbsp; The
difference between the two is the lifetime of the reference in relation to the lifetime of
the server thread or process that created it.&nbsp; A transient object
      reference lifetime is tied to
the lifetime of its server.&nbsp;&nbsp;&nbsp; If the server stops or exits, the transient
object reference no longer exists.&nbsp; All references to this object should now be invalid, even
if the server is restarted.&nbsp; Persistent object references can outlive its se4rver.&nbsp; The
server can be stopped and restarted without invalidating all object references to it.
&nbsp; This enables the implementation of features like load-on-demand servers and object
migration.</p>

<!-- IMHO we should make the difference between persitent object -->
<!-- references and persistent objects, an infinite source of -->
<!-- confussion for our users, and me (coryan). -->

<h3>The Implementation Repository</h3>

<p>According to the CORBA specification, &quot;The Implementation Repository contains
information that allows the ORB to locate and activate implementations of objects&quot;
[CORBA Spec Rev.&nbsp; 2.2: 2.1.14]&nbsp; In earlier revisions of the specification, there
was a method get_implementation () in the CORBA Object interface.&nbsp; This has been
deprecated as of 2.2, leaving both the interface and implementation of the Implementation
Repository up to the ORB vendor.</p>

<p>A very good paper describing an implementation of the Implementation Repository is
&quot;<a href="http://www.cs.wustl.edu/~schmidt/michi.pdf">Binding, Migration, and
Scalability in CORBA</a>&quot; [Henning].&nbsp; In it he states that the Implementation
Repository has three functions: 

<ol>
  <li>Maintain a registry of known servers</li>
  <li>Record which server is currently running (and which port and host)</li>
  <li>Starts servers on demand if they are registered for it</li>
</ol>

<p>The TAO implementation will be implemented much like how this paper describes. &nbsp;
The next section details our goals and plans for the implementation.</p>

<hr>

<h2>TAO's Implementation Repository</h2>

<p>Here is an overview of our plans for the TAO'S Implementation Repository. 

<ul>
  <li>Use of the Implementation Repository will be optional.&nbsp; Real-time applications can
    choose not to use the Implementation Repository for performance reasons.</li>
  <li>Use of the Implementation Repository will be invisible to clients and servers for the
    common use-case.&nbsp; For more complicated behavior, programs can use Implementation
    Repository extensions of the POA.</li>
  <li>The Implementation will work with any CORBA client that supports LOCATION_FORWARD
    messages and multiple profiles in IORs, even if the client is not
implemented using TAO.</li>
  <li>The Implementation Repository will keep track of all process that have registered with
    it by using a &quot;ping&quot; object located in the server.&nbsp; This ensures that
    multiple instances of the same server are not started.</li>
  <li>TAO will be fork safe.&nbsp; Because the Implementation Repository will need to use
    fork/exec (or CreateProcess on NT) to start servers, then the open connection to the
    client will need to be preserved over the server creation.</li>
</ul>

<h3>Virtual Server Name</h3>

<p>The Implementation Repository must keep track of which servers are started and stopped.
&nbsp; The question is at what resolution?&nbsp; It cannot contain an entry for every
object, since that would take up too much room.&nbsp; It could contain an entry for every
server, and then group objects there.&nbsp; But that is sort of inflexible for object
migration, since objects are tied to their executable.&nbsp; Instead, we want it to be
something between object and executable.&nbsp; In the <a
href="http://www.cs.wustl.edu/~schmidt/michi.pdf">Henning</a> paper, he mentions the use
of a server name as the index for the table in the Implementation Repository.&nbsp; </p>

<p>We will use a virtual server name for a group of objects.&nbsp; So the virtual server
isn't restricted to being tied to an executable or to an object.&nbsp;&nbsp; Since it
isn't tied to an executable, the virtual servers can be migrated to other servers.</p>

<h3>New IORs</h3>

<p>Currently, the TAO IOR profile are set up as the following:</p>

<table border="1">
  <tr>
    <td>Type ID</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>Transient/Persistent Flag</td>
        <td>TimeStamp</td>
        <td>POA ID</td>
        <td>OBJ ID</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>We plan on adding several things to these IORs. 

<ol>
  <li><strong>IIOP 1.1 support:</strong> In addition to the Type ID, Host, Port, and Object
    Key, a Tagged Components section will be added.&nbsp; This is where a tag for orb type and
    version will be located.</li>
  <li><strong>Multiple Profiles support</strong>: Our goal is to have the clients contact the
    object first, and if that fails, then contact the Implementation
	Repository.&nbsp; </li>
<!-- Shouldn't this go into the section above along with the ImplRepo -->
<!-- "goodies" (coryan) -->
</ol>

<p>So the new profile will look like:</p>

<table border="1">
  <tr>
    <td>Version</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
    <td>Components</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>TAO</td>
        <td>TAO version</td>
        <td>TimeStamp/Server Name</td>
        <td>POA ID</td>
        <td>OBJ ID</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>Transient objects will have a TimeStamp and Persistent object have a server name.</p>

<p>Our Profile for the Implementation Repository objects look like this:</p>
<!-- This is not "our profile", this is a standard IIOP 1.1 profile -->
<!-- Maybe a small section explaining why we need to upgrade to -->
<!-- 1.1 or why the new protocol offers advantages to use -->

<table border="1">
  <tr>
    <td>Type ID</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
    <td>Components</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>TAO</td>
        <td>TAO version</td>
        <td>Server Name</td>
        <td>POA ID</td>
        <td>OBJ ID of the Implementation Repository or<br>
        OBJ Key of the Server.</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>Depending on whether it is a true Implementation Repository request (to register with
it) or one intended to start a server.</p>

<h4>What was wrong with the old IOR?</h4>

<p>We need a place to put a TAO marker in it so TAO servers can differentiate TAO IORs and
IORs from other vendors.&nbsp; In the old scheme, Persistent IORs had a null timestamp.
&nbsp; To support virtual servers, we need to use that spot to store the name (so the
Implementation Repository knows which server to start up).</p>

<h4>Why does the Implementation Repository contain an OBJ Key?</h4>

<p>It needs to know what the object key of the object when forwarding.&nbsp; A server may
contain more than one </p>

<h3>POA Extensions</h3>

<p>POA will contain a <CODE>create_reference_vserver (...)</CODE> that can take in additional arguments
for a virtual server name and a sequence of Implementation Repository IORs.&nbsp; This
will then communicate with each Implementation Repository and get its generated profile
back.&nbsp; Then all the profiles will be combined to produce an Persistent IOR.</p>

<h3>Possible Future Goals</h3>

<p>Some things that may be implemented in TAO relating to the Implementation Repository
domain: 

<ul>
  <li>Optimization on TAO clients to recognize when a server is restarted, and change all
    other IORs which contain that server instead of going through the Implementation
    Repository</li>
  <li>Some sort of server security that checks the executable to make sure it is the correct
    executable (checksum, signatures, etc).</li>
  <li>Add the ability to put servers into DLLs or Shared Object files so the Implementation
    Repository can load it via those methods.</li>
  <li>Federations of Implementation Repositories.</li>
</ul>

<h3>Server Restrictions</h3>

<p>Servers that are restarted by the Implementation Repository must be able to recreate
enough state to deal with requests from a client. Unless dynamic servant and POA
activation is used, the restarted server must also recreate the POA in which the
Persistent object was registered and register the persistent object with that POA. </p>

<h3>Preliminary Interface</h3>

<p>Here is a preliminary interface of the Implementation Repository in IDL: </p>

<pre>module TAO
{
  // ....

  exception Already_Registered {};
  // Object already bound in the Implementation Repository

  exception Cannot_Activate
  {
    string reason_;
  };

  exception Not_Found {};
  // Object not found in the Implementation Repository  
  
  struct Environment_Variable
  {
    string name_;
    string value_;
  };
  // One environment variable
  
  struct INET_Addr
  {
    unsigned short port_;
    unsigned long host_;
  };      
  // The location of a server

  typedef sequence&lt;Environment_Variable&gt; Environment;
  // Complete environment

  typedef sequence&lt;string&gt; Command_Line_Options;
  // Command line options

  struct Process_Options
  {
    string executable_name_;
    // Executable name

    Command_Line_Options command_line_options_; 
    // Command line options

    Environment environment_; 
    // Environment

    string working_directory_;  
    // Working directory

    unsigned long creation_flags_;
    // Creation flags
  };

  interface Ping_Object
  {
    void ping ();
    // Used for checking for liveness of a server.
  };

  interface Implementation_Repository
  {
    Object activate_object (in Object obj)
      raises (Not_Found,
              Cannot_Activate);
      // Restart server that will contain this persistent object and return the
      // new Object reference.
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;obj&gt; is not found
      // in the Implementation Repository.  The &lt;Cannot_Activate&gt; exception
      // is raised when &lt;obj&gt; is found in the Repository but could not be
      // activated.

    INET_Addr activate_server (in string server)
      raises (Not_Found,
              Cannot_Activate);
      // Restart server that is named &lt;server&gt; and return the host/port
      // 
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;server&gt; is not found
      // in the Implementation Repository.  The &lt;Cannot_Activate&gt; exception
      // is raised when &lt;server&gt; is found in the Repository but could not be
      // activated.

    void register_server (in string server,
                          in Process_Options options)
      raises (Already_Registered);
      // Restart server process when client is looking for &lt;server&gt;.
      //
      // The &lt;Already_Registered&gt; exception is raised when &lt;server&gt; has
      // already been registered with the Implementation Repository.
      // 
      // The &lt;Object_Not_Persistent&gt; exception is raised when &lt;server&gt; is
      // not a Persistent Object Reference.

    void reregister_server (in string server,
                            in Process_Options options)
      raises (Already_Registered);
      // Restart server process when client is looking for &lt;server&gt;.
      //
      // The &lt;Already_Registered&gt; exception is raised when &lt;server&gt; has
      // already been registered with the Implementation Repository.
      // 
      // The &lt;Object_Not_Persistent&gt; exception is raised when &lt;server&gt; is
      // not a Persistent Object Reference.

    void remove_server (in string server)
      raises (Not_Found);
      // Remove &lt;server&gt; from the Implementation Repository.
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;server&gt; is not found
      // in the Implementation Repository.

    Profile server_is_running (in string server,
                               in INET_Addr addr, 
                               in Ping_Object ping);
      // Used to notify the Implementation Repository that &lt;server&gt; is alive and
      // well at &lt;addr&gt;.

    void server_is_shutting_down (in string server);
      // Used to tell the Implementation Repository that &lt;server&gt; is shutting
      // down.
    };
};</pre>

<hr>

<h2>Alternate Implementations</h2>

<p>Other ORB vendors use alternative techniques for Implementation Repository. These
techniques usually require new naming techniques for persistent objects and new
client-side APIs to bind to persistent objects. TAO's Implementation Repository will not
require such extensions. </p>

<p>One implementation of an Implementation Repository could use an Object Reference that
points to the Implementation Repository instead of pointing directly to the persistent
object. This extra level of indirection is used by the Implementation Repository to start
the server, and then use the Location Forwarding mechanism to forward the client request
to the server. This technique forces clients to use the Implementation Repository (at
least once) even when the server is already running. </p>

<hr>

<h2>Accessing the Implementation Repository </h2>

<p>The Implementation Repository will be transparent to the clients and the servers. </p>

<h3>Helper Application</h3>

<p>A helper application will be part of the Implementation Repository. It will be a
command-line utility that will assist users with adding and removing Persistent Object
References from the Implementation Repository. </p>
<!-- Wouldn't this utility (or a similar one) be the mechanism to -->
<!-- configure the mapping between virtual server names and -->
<!-- executables. -->

<h3>Locating an instance of Implementation Repository </h3>

<h4>Server side</h4>

<p>The Implementation Repository will be located on the same host as the server. If not,
host information can be specified through command line options or environment variables.
The default port of the Implementation Repository can be overridden through command line
options or environment variables. </p>
<!-- How are we planning to start a "remote" server? Isn't federations -->
<!-- of ImplRepo a solution for that? What are the drawbacks or -->
<!-- advantages of using rsh ssh, rexec or a similar NT service? -->

<h4>Client side</h4>

<p>The correct Implementation Repository will be stored in another profile in the IOR.
&nbsp; Other Implementation Repositories can also be located by multicasting (on a default
multicast group) the server name of the Persistent Object the client is interested in. The
default multicast group can be override through command line options or environment
variables. The default port of the Implementation Repository can be overridden through
command line options or environment variables. </p>
<!-- Are we planning to support more than one ImplRepo profile -->
<!-- in the IOR? -->

<hr>

<h2>How it works</h2>

<h3>How a server produces a Persistent IOR (in the default case)</h3>

<p>Before the server starts, it must be registered (via a command-line utility) with an
implementation repository that supports multicast. 
<!-- is multicast support mandatory? OTOH it will be there always, -->
<!-- right? -->

<ol>
  <li>Now the server will start up and call ORB_init.&nbsp; ORB_init, if not passed a server
    name, will take argv[0] and use that as a default server name (TAO expects this to be the
    executable name).&nbsp; </li>
  <li>ORB_init will create a ping object.</li>
  <li>ORB_init will look for Implementation Repositories on the command line, environmental
    variables, and then through multicast -- in that order.&nbsp; Once it finds one it
    registers itself and passes the ping object to the implementation repository with
    server_is_running () call.</li>
  <li>The profile returned by registration will be stored for later use.</li>
  <li>Client later can call POA::CreateRef ()</li>
<!-- Irfan: is CreateRef the right name? Darrell: use <CODE></CODE> -->
  <li>First, CreateRef () will create the local profile</li>
  <li>The stored Implementation Repository profile will have its object id changed to be the
    object key just created.</li>
  <li>Both profiles will be joined together in a multiple profile IOR and returned.</li>
</ol>

<h3>How a server produces a Persistent IOR (in complex cases)</h3>

<p>As in the default case, the server must be registered with an Implementation Repository
already, although it does not need to be multicast aware. 

<ol>
  <li>ORB_init () is called with a server name and a list of Implementation Repositories. </li>
  <li>After creating a ping object, it will register itself with every Implementation
    Repository with <CODE>server_is_running ()</CODE> and store all of the returned profiles for later use.</li>
  <li>If POA::CreateRef () is called later, it will do the same as before and build a full
    IOR.</li>
</ol>

<h3>How a client uses a Persistent IOR</h3>

<p>For all Clients: 

<ul>
  <li>Client obtains a Persistent Object Reference, which contains multiple profiles to both
    regular objects and Implementation Repositories.</li>
  <li>It will now make a request on the first profile, which is the last known profile for the
    object.</li>
  <li>If this fails, then the next one will be tried.&nbsp; And if that fails, the next.
    &nbsp; One of the other profiles will be a reference to the Implementation Repository, in
    which it will either return NOT_FOUND or will start up the server and return a Location
    Forward message.</li>
</ul>

<p>If everything fails, then most clients will return failure for the request.&nbsp; TAO
clients will also have added functionality where other Implementation Repositories can be
specified on the command line, in environment variables, or found through multicast will
also be contacted. 

<ul>
  <li>If all of the profiles fail, then contact the other Implementation Repositories. &nbsp;
    First get those specified on the command line or in environment variables.</li>
  <li>Then, if multicast is available: <ul>
      <li>Multicast the Object Reference to a group of Implementation Repositories&nbsp; </li>
      <li>Wait until response or a timeout. The response will contain the Object Reference of a
        Implementation Repository that knows about the Object Reference </li>
    </ul>
  </li>
  <li>Now connect to any Implementation Repositories that have been found.</li>
  <li>Call <i>activate ()</i> passing the Persistent Object Reference.</li>
  <li>If a new Object Reference was sent back then retry the request using the it. If this
    request fails, then fail (no more retries).</li>
  <li>If a null reference was sent back, then fail.</li>
</ul>

<p>Another possible TAO clients will have an optimization where if there are several IORs
that have the same server name, and one of them gets forwarded, then the client will be
able to change its other IORs without going through the overhead of contacting
Implementation Repository.</p>

<hr>

<p>Back to the <a href="http://www.cs.wustl.edu/~schmidt/ACE_wrappers/TAO/docs/index.html">TAO
documentation</a> page. <!--#include virtual="/~schmidt/cgi-sig.html" --> </p>
</body>
</html>
