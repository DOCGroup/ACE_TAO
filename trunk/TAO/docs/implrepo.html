<!-- $Id$ -->
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>TAO Implementation Repository</title>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#CC0000">

<hr>

<h1>TAO Implementation Repository </h1>

<p>Revision 3.01 - July 9, 1998</p>

<hr>

<h2>Table of Contents</h2>

<p align="left"><a href="#Overview">Overview</a><br>
&nbsp;&nbsp;&nbsp; <a href="#PersistentandTransientIORs">Persistent and Transient IORs</a><br>
&nbsp;&nbsp;&nbsp; <a href="#TheImplementationRepository">The Implementation Repository</a>
<br>
<a href="#TAOsImplementationRepository">TAO's Implementation Repository</a><br>
&nbsp;&nbsp;&nbsp; <a href="#VirtualServerName">Virtual Server Name</a><br>
&nbsp;&nbsp;&nbsp; <a href="#NewIORs">New IORs</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#WhatwaswrongwiththeoldIOR">What was
wrong with the old IOR?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#WhydoesImplRepocontainanOBJKey">Why
does the Implementation Repository profile contain an Object Key?</a><br>
&nbsp;&nbsp;&nbsp; <a href="#POAExtensions">POA Extensions</a><br>
&nbsp;&nbsp;&nbsp; <a href="#PossibleFutureGoals">Possible Future Goals</a><br>
&nbsp;&nbsp;&nbsp; <a href="#ServerRestrictions">Server Restrictions</a><br>
&nbsp;&nbsp;&nbsp; <a href="#PreliminaryInterface">Preliminary Interface</a><br>
<a href="#AlternateImplementations">Alternate Implementations</a><br>
<a href="#AccessingtheImplementationRepository">Accessing the Implementation Repository</a><br>
&nbsp;&nbsp;&nbsp; <a href="#HelperApplication">Helper Application</a><br>
&nbsp;&nbsp;&nbsp; <a href="#LocatinganinstanceofImplRepo">Locating an instance of the
Implementation Repository</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Serverside">Server Side</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#Clientside">Client Side</a><br>
<a href="#Howitworks">How It Works</a><br>
&nbsp;&nbsp;&nbsp; <a href="#HowServerProducesPersistentIORdefault">How a server produces
a Persistent IOR (in the default case)</a><br>
&nbsp;&nbsp;&nbsp; <a href="#HowServerProducesPersistentIORcomplex">How a server produces
a Persistent IOR (in the complex case)</a><br>
&nbsp;&nbsp;&nbsp; <a href="#HowClientUsesPersistentIOR">How a client uses a Persistent
IOR</a></p>

<hr>

<h2><a name="Overview">Overview</a></h2>

<p>This document describes the proposed design of the TAO Implementation Repository
(previously known as the reactivator or activation service). </p>

<h3><a name="PersistentandTransientIORs">Persistent and Transient IORs</a></h3>

<p>CORBA defines two types of object references, persistent and transient.&nbsp; The
difference between the two is the lifetime of the reference in relation to the lifetime of
the server thread or process that created it.&nbsp; A transient object reference lifetime
is tied to the lifetime of its server.&nbsp;&nbsp;&nbsp; If the server stops or exits, the
transient object reference no longer exists.&nbsp; All references to this object should
now be invalid, even if the server is restarted.&nbsp; Persistent object references can
outlive its server.&nbsp; The server can be stopped and restarted without invalidating all
object references to it. &nbsp; This enables the implementation of features like
load-on-demand servers and object migration.</p>

<p>Note that both persistent and transient object references can refer to objects on
persistent servers.&nbsp; A persistent server is a server that is always running.&nbsp; It
can generate transient references, persistent references, or even
      both.
      Users should be aware that persistance of the object reference
      does not imply any persistance on the object implementation
      state, servant implementors should take the necessary measures
      to preserve the state of their servants,
      using,
      for instance,
      databases or files;
      it is certainly possible to provide persistent object references
      for objects whose state is not persistent.
</p>
<!-- IMHO we should make the difference between persitent object -->
<!-- references and persistent objects, an infinite source of -->
<!-- confussion for our users, and me (coryan). -->
<!-- DB: Done -->
<!-- COR: Added more detail, feel free to eliminate the redundant -->
<!-- repetitions ;-) -->

<h3><a name="TheImplementationRepository">The Implementation Repository</a></h3>

<p>According to the CORBA specification, &quot;The Implementation Repository contains
information that allows the ORB to locate and activate implementations of objects&quot;
[CORBA Spec Rev.&nbsp; 2.2: 2.1.14]&nbsp; In earlier revisions of the specification, there
was a method <CODE>get_implementation ()</CODE> in the CORBA Object
interface.&nbsp; This has been
deprecated as of 2.2, leaving both the interface and implementation of the Implementation
Repository up to the ORB vendor.</p>

<p>A very good paper describing an implementation of the Implementation Repository is
&quot;<a href="http://www.cs.wustl.edu/~schmidt/michi.pdf">Binding, Migration, and
Scalability in CORBA</a>&quot; [Henning].&nbsp; In it he states that the Implementation
Repository has three functions: 

<ol>
  <li>Maintain a registry of known servers</li>
  <li>Record which server is currently running (and which port and host)</li>
  <li>Starts servers on demand if they are registered for it</li>
</ol>

<p>The TAO implementation will be implemented much like how this paper describes. &nbsp;
The next section details our goals and plans for the implementation.</p>

<hr>

<h2><a name="TAOsImplementationRepository">TAO's Implementation Repository</a></h2>

<p>Here is an overview of our plans for the TAO'S Implementation Repository. 

<ul>
  <li>Use of the Implementation Repository will be optional.&nbsp; Real-time applications can
    choose not to use the Implementation Repository for performance reasons.</li>
  <li>Use of the Implementation Repository will be invisible to clients and servers for the
    common use-case.&nbsp; For more complicated behavior, programs can use Implementation
    Repository extensions of the POA.</li>
  <li>The Implementation will work with any CORBA client that supports LOCATION_FORWARD
    messages and multiple profiles in IORs, even if the client is not implemented using TAO.</li>
  <li>The Implementation Repository will keep track of all process that have registered with
    it by using a &quot;ping&quot; object located in the server.&nbsp; This ensures that
    multiple instances of the same server are not started.</li>
  <li>TAO will be fork safe<strong>.&nbsp; </strong>Because the Implementation Repository will
    need to use fork/exec (or CreateProcess on NT) to start servers, then the open connection
    to the client will need to be preserved over the server creation.</li>
<!-- COR: Maybe I didn't explain myself properly when we discussed -->
<!-- COR: this, I would expect that after fork all connections are -->
<!-- COR: closed on the server, otherwise we will end up leaking -->
<!-- COR: resources (file descriptors or handles) -->

  <li>TAO will have IIOP 1.1 support.&nbsp; In addition to the Type ID, Host, Port, and Object
    Key, a Tagged Components section will be added.&nbsp; This is where a tag for orb type and
    version will be located.</li>
<!-- COR: As you point out below IIOP 1.1 is not needed, so why -->
<!-- COR: include it here? -->
<!-- COR: Anyway I would say: TAO will exploit features of IIOP 1.1 to -->
<!-- COR: safely and efficiently verify if an IOR was generated by TAO -->
<!-- COR: itself. -->
  <li>Multiple Profiles support. Our goal is to have the clients contact the object first, and
    if that fails, then contact the Implementation Repository.&nbsp; </li>
</ul>

<h3><a name="VirtualServerName">Virtual Server Name</a></h3>

<p>The Implementation Repository must keep track of which servers are started and stopped.
&nbsp; The question is at what resolution?&nbsp; It cannot contain an entry for every
object, since that would take up too much room.&nbsp; It could contain an entry for every
server, and then group objects there.&nbsp; But that is sort of inflexible for object
migration, since objects are tied to their executable.&nbsp; Instead, we want it to be
something between object and executable.&nbsp; In the <a
href="http://www.cs.wustl.edu/~schmidt/michi.pdf">Henning</a> paper, he mentions the use
of a server name as the index for the table in the Implementation Repository.&nbsp; </p>

<p>We will use a virtual server name for a group of objects.&nbsp; So the virtual server
isn't restricted to being tied to an executable or to an object.&nbsp;&nbsp; Since it
isn't tied to an executable, the virtual servers can be migrated to other servers.</p>

<h3><a name="NewIORs">New IORs</a></h3>

<p>IORs contain two sections:</p>

<table border="1">
  <tr>
    <td>Type ID</td>
    <td>Sequence of Tagged Profiles</td>
  </tr>
</table>

<p>Currently, TAO uses only one IIOP 1.0 Tagged Profile, and that is set up as the following:</p>

<table border="1">
  <tr>
    <td>Version</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>Transient/Persistent Flag</td>
        <td>TimeStamp</td>
        <td>POA ID</td>
        <td>OBJ ID</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>To accomodate the Implementation Repository and IIOP 1.1, the Profile was changed to
look like the following:</p>

<table border="1">
  <tr>
    <td>Version</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
    <td>Components</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>TAO</td>
        <td>TAO version</td>
        <td>TimeStamp/Server Name</td>
        <td>POA ID</td>
        <td>OBJ ID</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>Transient objects will have a TimeStamp and Persistent object have a server name.</p>

<p>For Persistent IORs, a second tagged profile will be added to point to the
Implementation Repository:</p>
<!-- DB: I rephrased it so maybe that clears it up a bit.  Do we need -->
<!-- DB: anything about IIOP 1.1?  I mean, we don't really require it, -->
<!-- DB: do we? -->
<!-- COR: Ah, good point, I believe that IIOP 1.1 will help us -->
<!-- COR: because we will use a standard mechanism to check if the -->
<!-- COR: IOR was generated by TAO, but you are right -->

<table border="1">
  <tr>
    <td>Version</td>
    <td>Host</td>
    <td>Port</td>
    <td>Object Key</td>
    <td>Components</td>
  </tr>
</table>

<table border="0">
  <tr>
    <td>Object Key: </td>
    <td><table border="1">
      <tr>
        <td>TAO</td>
        <td>TAO version</td>
        <td>Server Name</td>
        <td>POA ID</td>
        <td>OBJ ID (actually the OBJ Key of the Server)</td>
      </tr>
    </table>
    </td>
  </tr>
</table>

<p>If the profile was meant for just calls to the Implementation Repository, then the OBJ
ID would be that of the Implementation Repository Object.</p>

<h4><a name="WhatwaswrongwiththeoldIOR">What was wrong with the old IOR?</a></h4>

<p>We need a place to put a TAO marker in it so TAO servers can differentiate TAO IORs and
IORs from other vendors.&nbsp; In the old scheme, Persistent IORs had a null timestamp.
&nbsp; To support virtual servers, we need to use that spot to store the name (so the
Implementation Repository knows which server to start up).</p>

<h4><a name="WhydoesImplRepocontainanOBJKey">Why does the Implementation Repository
profile contain an Object Key?</a></h4>

<p>It needs to know what the object key of the object when forwarding.&nbsp; A server may
contain more than one </p>

<h3><a name="POAExtensions">POA Extensions</a></h3>

<p>POA will contain <code>create_reference_with_virtual_server[_and_id] (...)</code> that
can take in additional arguments for a virtual server name and a sequence of
Implementation Repository IORs.&nbsp; This will then communicate with each Implementation
Repository and get its generated profile back.&nbsp; Then all the profiles will be
combined to produce an Persistent IOR.</p>

<h3><a name="PossibleFutureGoals">Possible Future Goals</a></h3>

<p>Some things that may be implemented in TAO relating to the Implementation Repository
domain: 

<ul>
  <li>Optimization on TAO clients to recognize when a server is restarted, and change all
    other IORs which contain that server instead of going through the Implementation
    Repository</li>
  <li>Some sort of server security that checks the executable to make sure it is the correct
    executable (checksum, signatures, etc).</li>
  <li>Add the ability to put servers into DLLs or Shared Object files so the Implementation
    Repository can load it via those methods.</li>
  <li>GUI interface for such things as the helper application.</li>
  <li>Federations of Implementation Repositories.</li>
</ul>

<h3><a name="ServerRestrictions">Server Restrictions</a></h3>

<p>Servers that are restarted by the Implementation Repository must be able to recreate
enough state to deal with requests from a client. Unless dynamic servant and POA
activation is used, the restarted server must also recreate the POA in which the
Persistent object was registered and register the persistent object with that POA. </p>

<h3><a name="PreliminaryInterface">Preliminary Interface</a></h3>

<p>Here is a preliminary interface of the Implementation Repository in IDL: </p>

<pre>module TAO
{
  // ....

  exception Already_Registered {};
  // Object already bound in the Implementation Repository

  exception Cannot_Activate
  {
    string reason_;
  };

  exception Not_Found {};
  // Object not found in the Implementation Repository  
  
  struct Environment_Variable
  {
    string name_;
    string value_;
  };
  // One environment variable
  
  struct INET_Addr
  {
    unsigned short port_;
    unsigned long host_;
  };      
  // The location of a server

  typedef sequence&lt;Environment_Variable&gt; Environment;
  // Complete environment

  typedef sequence&lt;string&gt; Command_Line_Options;
  // Command line options

  struct Process_Options
  {
    string executable_name_;
    // Executable name

    Command_Line_Options command_line_options_; 
    // Command line options

    Environment environment_; 
    // Environment

    string working_directory_;  
    // Working directory

    unsigned long creation_flags_;
    // Creation flags
  };

  interface Ping_Object
  {
    void ping ();
    // Used for checking for liveness of a server.
  };

  interface Implementation_Repository
  {
    Object activate_object (in Object obj)
      raises (Not_Found,
              Cannot_Activate);
      // Restart server that will contain this persistent object and return the
      // new Object reference.
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;obj&gt; is not found
      // in the Implementation Repository.  The &lt;Cannot_Activate&gt; exception
      // is raised when &lt;obj&gt; is found in the Repository but could not be
      // activated.

    INET_Addr activate_server (in string server)
      raises (Not_Found,
              Cannot_Activate);
      // Restart server that is named &lt;server&gt; and return the host/port
      // 
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;server&gt; is not found
      // in the Implementation Repository.  The &lt;Cannot_Activate&gt; exception
      // is raised when &lt;server&gt; is found in the Repository but could not be
      // activated.

    void register_server (in string server,
                          in Process_Options options)
      raises (Already_Registered);
      // Restart server process when client is looking for &lt;server&gt;.
      //
      // The &lt;Already_Registered&gt; exception is raised when &lt;server&gt; has
      // already been registered with the Implementation Repository.
      // 
      // The &lt;Object_Not_Persistent&gt; exception is raised when &lt;server&gt; is
      // not a Persistent Object Reference.

    void reregister_server (in string server,
                            in Process_Options options)
      raises (Already_Registered);
      // Restart server process when client is looking for &lt;server&gt;.
      //
      // The &lt;Already_Registered&gt; exception is raised when &lt;server&gt; has
      // already been registered with the Implementation Repository.
      // 
      // The &lt;Object_Not_Persistent&gt; exception is raised when &lt;server&gt; is
      // not a Persistent Object Reference.

    void remove_server (in string server)
      raises (Not_Found);
      // Remove &lt;server&gt; from the Implementation Repository.
      //
      // The &lt;Not_Found&gt; exception is raised when &lt;server&gt; is not found
      // in the Implementation Repository.

    Profile server_is_running (in string server,
                               in INET_Addr addr, 
                               in Ping_Object ping);
      // Used to notify the Implementation Repository that &lt;server&gt; is alive and
      // well at &lt;addr&gt;.

    void server_is_shutting_down (in string server);
      // Used to tell the Implementation Repository that &lt;server&gt; is shutting
      // down.
    };
};</pre>

<hr>

<h2><a name="AlternateImplementations">Alternate Implementations</a></h2>

<p>Other ORB vendors use alternative techniques for Implementation Repository. These
techniques usually require new naming techniques for persistent objects and new
client-side APIs to bind to persistent objects. TAO's Implementation Repository will not
require such extensions. </p>

<p>Another implementation of an Implementation Repository uses an Object Reference that
points to the Implementation Repository instead of pointing directly to the persistent
object. This extra level of indirection is used by the Implementation Repository to start
the server (if needed), and then use the Location Forwarding mechanism to forward the
client request to the server. This technique forces clients to use the Implementation
Repository (at least once) even when the server is already running. </p>

<hr>

<h2><a name="AccessingtheImplementationRepository">Accessing the Implementation Repository</a>
</h2>

<p>The Implementation Repository will be transparent to the clients and the servers. </p>

<h3><a name="HelperApplication">Helper Application</a></h3>

<p>A helper application will be included with the Implementation Repository. It will be a
command-line utility that will assist users with adding and removing server records
(containing virtual server names and executable name/options) from the Implementation
Repository. </p>

<h3><a name="LocatinganinstanceofImplRepo">Locating an instance of the Implementation
Repository </a></h3>

<h4><a name="Serverside">Server side</a></h4>

<p>In the default case, the Implementation Repository will be found via the command-line,
environment variables, and multicast (in that order).&nbsp; Using the POA extensions,
other Implementation Repositories can be specified in the call to <code>POA::create_reference_with_virtual_server</code>
().&nbsp; The default port of the Implementation Repository can be overridden through
command line options or environment variables. </p>
<!-- How are we planning to start a "remote" server? Isn't federations -->
<!-- of ImplRepo a solution for that? What are the drawbacks or -->
<!-- advantages of using rsh ssh, rexec or a similar NT service? -->
<!-- DB: Hmm, I reworded this, but where would a discussion of this -->
<!-- DB: be put? -->
<!-- COR: What about a "Future extensions" -->
<!-- COR: or "Things we will not implement on the first release" -->

<h4><a name="Clientside">Client side</a></h4>

<p>One or more Implementation Repositories will be stored in additional profiles in the
IOR. &nbsp; Other Implementation Repositories can also be located by multicasting (on a
default multicast group) the server name of the Persistent Object the client is interested
in. The default multicast group and default port of the Implementation Repository can be
overridden through command line options or environment variables. </p>

<hr>

<h2><a name="Howitworks">How It Works</a></h2>

<h3><a name="HowServerProducesPersistentIORdefault">How a server produces a Persistent IOR
(in the default case)</a></h3>

<p>Before the server starts, it must be registered (via a command-line utility) with an
implementation repository that supports multicast.
<!-- COR: is multicast support mandatory? OTOH it will be there -->
<!-- COR: always, right? --> 

<ol>
  <li>Now the server will start up and call <code>ORB_init</code>.&nbsp; <code>ORB_init</code>,
    if not passed a server name, will take argv[0] and use that as a default server name (TAO
    expects this to be the executable name).&nbsp; </li>
  <li><code>ORB_init</code> will create a ping object.</li>
  <li><code>ORB_init</code> will look for Implementation Repositories on the command line,
    environmental variables, and then through multicast -- in that order.&nbsp; Once it finds
    one it registers itself and passes the ping object to the implementation repository with
    server_is_running () call.</li>
  <li>The profile returned by registration will be stored for later use.</li>
  <li>Client later can call <code>POA::create_reference</code> ().</li>
  <li>First, <code>create_reference</code> () will create the local profile.</li>
  <li>The stored Implementation Repository profile will have its object id changed to be the
    object key just created.</li>
  <li>Both profiles will be joined together in a multiple profile IOR and returned.</li>
</ol>

<h3><a name="HowServerProducesPersistentIORcomplex">How a server produces a Persistent IOR
(in complex cases)</a></h3>

<p>As in the default case, the server must be registered with an Implementation Repository
already, although it does not need to be multicast aware. 

<ol>
  <li><code>ORB_init</code> is called and does the default work (if it has Implementation
    Repositories to contact).</li>
  <li><code>POA::create_reference_with_virtual_server[_and_id]</code> () will be called with a
    server name and list of Implementation Repositories.&nbsp; </li>
  <li>The profile for the object is created.</li>
  <li>The ping object created in <code>ORB_init</code> and the object key is passed to the
    Implementation Repositories, and their profiles are returned.</li>
  <li>The full IOR is built and returned.</li>
</ol>

<h3><a name="HowClientUsesPersistentIOR">How a client uses a Persistent IOR</a></h3>

<p>For all Clients: 

<ul>
  <li>Client obtains a Persistent Object Reference, which contains multiple profiles to both
    regular objects and Implementation Repositories.</li>
  <li>It will now make a request on the first profile, which is the last known profile for the
    object.</li>
  <li>If this fails, then the next one will be tried.&nbsp; And if that fails, the next.
    &nbsp; One of the other profiles will be a reference to the Implementation Repository, in
    which it will either return NOT_FOUND or will start up the server and return a Location
    Forward message.</li>
</ul>

<p>If everything fails, then most clients will return failure for the request.&nbsp; TAO
clients will also have added functionality where other Implementation Repositories can be
specified on the command line, in environment variables, or found through multicast will
also be contacted. 

<ul>
  <li>If all of the profiles fail, then contact the other Implementation Repositories. &nbsp;
    First get those specified on the command line or in environment variables.</li>
  <li>Then, if multicast is available: <ul>
      <li>Multicast the Object Reference to a group of Implementation Repositories&nbsp; </li>
      <li>Wait until response or a timeout. The response will contain the Object Reference of a
        Implementation Repository that knows about the Object Reference </li>
    </ul>
  </li>
  <li>Now connect to any Implementation Repositories that have been found.</li>
  <li>Call <i>activate ()</i> passing the Persistent Object Reference.</li>
  <li>If a new Object Reference was sent back then retry the request using the it. If this
    request fails, then fail (no more retries).</li>
  <li>If a null reference was sent back, then fail.</li>
</ul>

<p>Another possible TAO clients will have an optimization where if there are several IORs
that have the same server name, and one of them gets forwarded, then the client will be
able to change its other IORs without going through the overhead of contacting
Implementation Repository.</p>

<hr>

<p>Back to the <a href="index.html">TAO documentation</a> page. <!--#include virtual="/~schmidt/cgi-sig.html" --> </p>
</body>
</html>
