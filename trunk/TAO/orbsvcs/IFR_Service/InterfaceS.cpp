/* -*- C++ -*- */
// $Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

// Contains all skeleton source code generated from Interface.idl
// except that for CORBA::IRObject and CORBA::TypeCodeFactory, which
// is included in tao/InterfaceS.cpp.

#include "InterfaceS.h"

ACE_RCSID(IFR_Service, IFR_skel, "$Id$")

#if !defined (__ACE_INLINE__)
#include "InterfaceS.i"
#endif /* !defined INLINE */

class TAO_CORBA_IRObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:52 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IRObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IRObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15,  0, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15,  1, 15, 15, 15, 15,  0, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,
#else
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15,  0, 15,  0, 15, 15,
      0, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,  1, 15, 15, 15,
     15,  0, 15, 15, 15, 15, 15, 15,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IRObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 4,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 14,
      HASH_VALUE_RANGE = 10,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::IRObject::_is_a_skel},
      {"",0},
      {"destroy",       &POA_CORBA::IRObject::destroy_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_CORBA::IRObject::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA::IRObject::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:05:52 */
static TAO_CORBA_IRObject_Perfect_Hash_OpTable tao_CORBA_IRObject_optable;

CORBA::IRObject_ptr _TAO_collocation_POA_CORBA_IRObject_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::IRObject_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_IRObject (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_IRObject_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer =
    _TAO_collocation_POA_CORBA_IRObject_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_CORBA_IRObject_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_CORBA_IRObject_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_IRObject_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::IRObject::IRObject (void)
{
  this->optable_ = &tao_CORBA_IRObject_optable;
}

// copy ctor
POA_CORBA::IRObject::IRObject (const IRObject& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::IRObject::~IRObject (void)
{
}

void POA_CORBA::IRObject::_get_def_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *)_tao_object_reference;

  IR::DefinitionKind _tao_retval;

  _tao_retval = _tao_impl->def_kind (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_CORBA::IRObject::destroy_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *)_tao_object_reference;

  _tao_impl->destroy (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_CORBA::IRObject::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::IRObject::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::IRObject::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::IRObject::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::IRObject::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA::IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

CORBA::IRObject*
POA_CORBA::IRObject::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::IRObject_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_IRObject (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::IRObject::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_IRObject::_tao_thru_poa_collocated_IRObject (
  TAO_Stub *stub
)
  :  CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_IRObject::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_IRObject::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::DefinitionKind POA_CORBA::_tao_thru_poa_collocated_IRObject::def_kind  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::DefinitionKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "def_kind",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->def_kind (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_IRObject::destroy  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "destroy",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->destroy (
      ACE_TRY_ENV
    );
  return;
}

class TAO_IR_Contained_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Contained_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Contained_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Contained_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::Contained::move_skel},
      {"_is_a",  &POA_IR::Contained::_is_a_skel},
      {"_get_id",       &POA_IR::Contained::_get_id_skel},
      {"_set_id",       &POA_IR::Contained::_set_id_skel},
      {"describe",      &POA_IR::Contained::describe_skel},
      {"_get_name",     &POA_IR::Contained::_get_name_skel},
      {"_set_name",     &POA_IR::Contained::_set_name_skel},
      {"_get_version",  &POA_IR::Contained::_get_version_skel},
      {"_set_version",  &POA_IR::Contained::_set_version_skel},
      {"_get_def_kind",         &POA_IR::Contained::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::Contained::_get_defined_in_skel},
      {"destroy",       &POA_IR::Contained::destroy_skel},
      {"_get_absolute_name",    &POA_IR::Contained::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::Contained::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::Contained::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  -1,  15,  16,  -1,  -1,  -1,  -1,  17,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  18,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Contained_Perfect_Hash_OpTable tao_IR_Contained_optable;

IR::Contained_ptr _TAO_collocation_POA_IR_Contained_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::Contained_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_Contained (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_Contained_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_Contained_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_Contained_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_Contained_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_Contained_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_Contained_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::Contained::Contained (void)
{
  this->optable_ = &tao_IR_Contained_optable;
}

// copy ctor
POA_IR::Contained::Contained (const Contained& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Contained::~Contained (void)
{
}

void POA_IR::Contained::_get_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

  _tao_retval = _tao_impl->id (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_set_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->id (
      id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::Contained::_get_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

  _tao_retval = _tao_impl->name (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_set_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->name (
      name.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::Contained::_get_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

  _tao_retval = _tao_impl->version (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_set_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var version;
  if (!(
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->version (
      version.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::Contained::_get_defined_in_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR::Container_var _tao_retval;

  _tao_retval = _tao_impl->defined_in (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_get_absolute_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

  _tao_retval = _tao_impl->absolute_name (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_get_containing_repository_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR::Repository_var _tao_retval;

  _tao_retval = _tao_impl->containing_repository (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::describe_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR::Contained::Description_var _tao_retval;

  _tao_retval = _tao_impl->describe (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::move_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR::Container_var new_container;
  CORBA::String_var new_name;
  CORBA::String_var new_version;
  if (!(
    (_tao_in >> new_container.out ()) &&
    (_tao_in >> new_name.out ()) &&
    (_tao_in >> new_version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->move (
      new_container.in (),
      new_name.in (),
      new_version.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::Contained::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Contained::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Contained::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Contained::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Contained::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Contained:1.0";
}

IR::Contained*
POA_IR::Contained::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::Contained_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_Contained (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::Contained::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_Contained::_tao_thru_poa_collocated_Contained (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_Contained::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_Contained::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


char * POA_IR::_tao_thru_poa_collocated_Contained::id  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->id (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_Contained::id  (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->id (
      id,
      ACE_TRY_ENV
    );
  return;
}

char * POA_IR::_tao_thru_poa_collocated_Contained::name  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->name (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_Contained::name  (
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->name (
      name,
      ACE_TRY_ENV
    );
  return;
}

char * POA_IR::_tao_thru_poa_collocated_Contained::version  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->version (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_Contained::version  (
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->version (
      version,
      ACE_TRY_ENV
    );
  return;
}

IR::Container_ptr POA_IR::_tao_thru_poa_collocated_Contained::defined_in  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::Container_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "defined_in",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->defined_in (
      ACE_TRY_ENV
    );

}

char * POA_IR::_tao_thru_poa_collocated_Contained::absolute_name  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "absolute_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->absolute_name (
      ACE_TRY_ENV
    );

}

IR::Repository_ptr POA_IR::_tao_thru_poa_collocated_Contained::containing_repository  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::Repository_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "containing_repository",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->containing_repository (
      ACE_TRY_ENV
    );

}

IR::Contained::Description * POA_IR::_tao_thru_poa_collocated_Contained::describe  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::Contained::Description_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "describe",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->describe (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_Contained::move  (
    IR::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "move",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->move (
      new_container,
      new_name,
      new_version,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_Container_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 15,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39,  0,
     39,  0,  0,  0, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39,  0, 20,  5,
     39,  0, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 10, 10, 39, 39, 39, 10,  0, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39,
#else
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 15, 39,  0, 39,  0,
      0,  0, 39, 39, 39, 39, 39, 39,  0, 20,
      5, 39,  0, 39, 39, 10, 10, 39, 39, 39,
     10,  0, 39, 39, 39, 39, 39, 39,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 19,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 17,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 38,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup",        &POA_IR::Container::lookup_skel},
      {"destroy",       &POA_IR::Container::destroy_skel},
      {"lookup_name",   &POA_IR::Container::lookup_name_skel},
      {"create_value",  &POA_IR::Container::create_value_skel},
      {"create_module",         &POA_IR::Container::create_module_skel},
      {"create_native",         &POA_IR::Container::create_native_skel},
      {"create_interface",      &POA_IR::Container::create_interface_skel},
      {"create_union",  &POA_IR::Container::create_union_skel},
      {"contents",      &POA_IR::Container::contents_skel},
      {"_is_a",  &POA_IR::Container::_is_a_skel},
      {"create_exception",      &POA_IR::Container::create_exception_skel},
      {"create_alias",  &POA_IR::Container::create_alias_skel},
      {"create_struct",         &POA_IR::Container::create_struct_skel},
      {"create_constant",       &POA_IR::Container::create_constant_skel},
      {"create_value_box",      &POA_IR::Container::create_value_box_skel},
      {"describe_contents",     &POA_IR::Container::describe_contents_skel},
      {"_get_def_kind",         &POA_IR::Container::_get_def_kind_skel},
      {"create_enum",   &POA_IR::Container::create_enum_skel},
      {"_non_existent",  &POA_IR::Container::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,   7,  -1, -10,  -2,   8,   9, -42,
       -1,  -1,  12,  13,  14,  -1,  15,  16,  17,  18,  -1,  19,  20,  21,
       22,  -1,  -1,  23,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Container_Perfect_Hash_OpTable tao_IR_Container_optable;

IR::Container_ptr _TAO_collocation_POA_IR_Container_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::Container_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_Container (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_Container_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_Container_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_Container_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_Container_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_Container_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_Container_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::Container::Container (void)
{
  this->optable_ = &tao_IR_Container_optable;
}

// copy ctor
POA_IR::Container::Container (const Container& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Container::~Container (void)
{
}

void POA_IR::Container::lookup_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::Contained_var _tao_retval;
  CORBA::String_var search_name;
  if (!(
    (_tao_in >> search_name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->lookup (
      search_name.in (),
      ACE_TRY_ENV
    );

      ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::ContainedSeq_var _tao_retval;
  IR::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->contents (
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::lookup_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::ContainedSeq_var _tao_retval;
  CORBA::String_var search_name;
  CORBA::Long levels_to_search;
  IR::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> search_name.out ()) &&
    (_tao_in >> levels_to_search) &&
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->lookup_name (
      search_name.in (),
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::describe_contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::Container::DescriptionSeq_var _tao_retval;
  IR::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  CORBA::Long max_returned_objs;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited)) &&
    (_tao_in >> max_returned_objs)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->describe_contents (
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_module_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::ModuleDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_module (
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_constant_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::ConstantDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var type;
  CORBA::Any value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_constant (
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      value,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_struct_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::StructDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_struct (
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_union_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::UnionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var discriminator_type;
  IR::UnionMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> discriminator_type.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_union (
      id.in (),
      name.in (),
      version.in (),
      discriminator_type.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_enum_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::EnumDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::EnumMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_enum (
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_alias_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::AliasDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var original_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_alias (
      id.in (),
      name.in (),
      version.in (),
      original_type.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::InterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::InterfaceDefSeq base_interfaces;
  CORBA::Boolean is_abstract;
  CORBA::Boolean is_local;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_local))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_interface (
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      is_abstract,
      is_local,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::ValueDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::Boolean is_custom;
  CORBA::Boolean is_abstract;
  IR::ValueDef_var base_value;
  CORBA::Boolean is_truncatable;
  IR::ValueDefSeq abstract_base_values;
  IR::InterfaceDefSeq supported_interfaces;
  IR::InitializerSeq initializers;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_custom)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> base_value.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable)) &&
    (_tao_in >> abstract_base_values) &&
    (_tao_in >> supported_interfaces) &&
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_value (
      id.in (),
      name.in (),
      version.in (),
      is_custom,
      is_abstract,
      base_value.in (),
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_value_box_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::ValueBoxDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var original_type_def;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_value_box (
      id.in (),
      name.in (),
      version.in (),
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_exception_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::ExceptionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_exception (
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_native_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR::NativeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_native (
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Container::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Container *_tao_impl = (POA_IR::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Container::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Container::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Container::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Container:1.0";
}

IR::Container*
POA_IR::Container::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::Container_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_Container (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::Container::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_Container::_tao_thru_poa_collocated_Container (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_Container::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_Container::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::Contained_ptr POA_IR::_tao_thru_poa_collocated_Container::lookup  (
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "lookup",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->lookup (
      search_name,
      ACE_TRY_ENV
    );

}

IR::ContainedSeq * POA_IR::_tao_thru_poa_collocated_Container::contents  (
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->contents (
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

}

IR::ContainedSeq * POA_IR::_tao_thru_poa_collocated_Container::lookup_name  (
    const char * search_name,
    CORBA::Long levels_to_search,
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "lookup_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->lookup_name (
      search_name,
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

}

IR::Container::DescriptionSeq * POA_IR::_tao_thru_poa_collocated_Container::describe_contents  (
    IR::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::Container::DescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "describe_contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->describe_contents (
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );

}

IR::ModuleDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_module  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ModuleDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_module",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_module (
      id,
      name,
      version,
      ACE_TRY_ENV
    );

}

IR::ConstantDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_constant  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ConstantDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_constant",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_constant (
      id,
      name,
      version,
      type,
      value,
      ACE_TRY_ENV
    );

}

IR::StructDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_struct  (
    const char * id,
    const char * name,
    const char * version,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::StructDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_struct",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_struct (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}

IR::UnionDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_union  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr discriminator_type,
    const IR::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::UnionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_union",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_union (
      id,
      name,
      version,
      discriminator_type,
      members,
      ACE_TRY_ENV
    );

}

IR::EnumDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_enum  (
    const char * id,
    const char * name,
    const char * version,
    const IR::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::EnumDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_enum",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_enum (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}

IR::AliasDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_alias  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::AliasDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_alias",
       forward_to.out (),
     ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_alias (
      id,
      name,
      version,
      original_type,
      ACE_TRY_ENV
    );

}

IR::InterfaceDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_interface  (
    const char * id,
    const char * name,
    const char * version,
    const IR::InterfaceDefSeq & base_interfaces,
    CORBA::Boolean is_abstract,
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_interface (
      id,
      name,
      version,
      base_interfaces,
      is_abstract,
      is_local,
      ACE_TRY_ENV
    );

}

IR::ValueDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_value  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    IR::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const IR::ValueDefSeq & abstract_base_values,
    const IR::InterfaceDefSeq & supported_interfaces,
    const IR::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_value (
      id,
      name,
      version,
      is_custom,
      is_abstract,
      base_value,
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );

}

IR::ValueBoxDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_value_box  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ValueBoxDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_value_box",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_value_box (
      id,
      name,
      version,
      original_type_def,
      ACE_TRY_ENV
    );

}

IR::ExceptionDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_exception  (
    const char * id,
    const char * name,
    const char * version,
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ExceptionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_exception",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_exception (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}

IR::NativeDef_ptr POA_IR::_tao_thru_poa_collocated_Container::create_native  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::NativeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_native",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_native (
      id,
      name,
      version,
      ACE_TRY_ENV
    );

}



class TAO_IR_IDLType_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_IDLType_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_IDLType_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_IDLType_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::IDLType::_is_a_skel},
      {"",0},
      {"destroy",       &POA_IR::IDLType::destroy_skel},
      {"",0},
      {"_get_type",     &POA_IR::IDLType::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_IR::IDLType::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_IR::IDLType::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_IDLType_Perfect_Hash_OpTable tao_IR_IDLType_optable;

IR::IDLType_ptr _TAO_collocation_POA_IR_IDLType_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::IDLType_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_IDLType (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_IDLType_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_IDLType_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_IDLType_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_IDLType_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_IDLType_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_IDLType_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::IDLType::IDLType (void)
{
  this->optable_ = &tao_IR_IDLType_optable;
}

// copy ctor
POA_IR::IDLType::IDLType (const IDLType& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::IDLType::~IDLType (void)
{
}

void POA_IR::IDLType::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::IDLType::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::IDLType::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::IDLType::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::IDLType::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::IDLType::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/IDLType:1.0";
}

IR::IDLType*
POA_IR::IDLType::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::IDLType_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_IDLType (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::IDLType::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_IDLType::_tao_thru_poa_collocated_IDLType (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_IDLType::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/IDLType:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_IDLType::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/IDLType:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_IDLType::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/IDLType:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}



class TAO_IR_Repository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 20,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 15,
     71,  0, 23, 10, 71,  5, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71,  0,  0, 15,
     71,  0, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 30,  0, 71, 71, 71,  0,  0, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71,
#else
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 20, 71, 15, 71,  0,
     23, 10, 71,  5, 71, 71, 71, 71,  0,  0,
     15, 71,  0, 71, 71, 30,  0, 71, 71, 71,
      0,  0, 71, 71, 71, 71, 71, 71,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 70,
      HASH_VALUE_RANGE = 65,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup",        &POA_IR::Repository::lookup_skel},
      {"create_enum",   &POA_IR::Repository::create_enum_skel},
      {"create_array",  &POA_IR::Repository::create_array_skel},
      {"create_struct",         &POA_IR::Repository::create_struct_skel},
      {"create_constant",       &POA_IR::Repository::create_constant_skel},
      {"create_value_box",      &POA_IR::Repository::create_value_box_skel},
      {"create_string",         &POA_IR::Repository::create_string_skel},
      {"create_wstring",        &POA_IR::Repository::create_wstring_skel},
      {"lookup_name",   &POA_IR::Repository::lookup_name_skel},
      {"create_value",  &POA_IR::Repository::create_value_skel},
      {"create_module",         &POA_IR::Repository::create_module_skel},
      {"create_native",         &POA_IR::Repository::create_native_skel},
      {"create_sequence",       &POA_IR::Repository::create_sequence_skel},
      {"create_interface",      &POA_IR::Repository::create_interface_skel},
      {"create_union",  &POA_IR::Repository::create_union_skel},
      {"get_primitive",         &POA_IR::Repository::get_primitive_skel},
      {"destroy",       &POA_IR::Repository::destroy_skel},
      {"create_exception",      &POA_IR::Repository::create_exception_skel},
      {"lookup_id",     &POA_IR::Repository::lookup_id_skel},
      {"_non_existent",  &POA_IR::Repository::_non_existent_skel},
      {"create_fixed",  &POA_IR::Repository::create_fixed_skel},
      {"get_canonical_typecode",        &POA_IR::Repository::get_canonical_typecode_skel},
      {"contents",      &POA_IR::Repository::contents_skel},
      {"_is_a",  &POA_IR::Repository::_is_a_skel},
      {"create_alias",  &POA_IR::Repository::create_alias_skel},
      {"_get_def_kind",         &POA_IR::Repository::_get_def_kind_skel},
      {"describe_contents",     &POA_IR::Repository::describe_contents_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,  -1,  -1, -16,  -2,   7,   8,   9,
       -1,  10,  11,  -1,  12,  13,  -1,  14,  15, -84,  -1,  18,  19,  20,
       21,  -1,  22,  23,  24,  25,  -1,  26,  -1,  27,  28,  -1,  29,  -1,
       30,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       31,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       32,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Repository_Perfect_Hash_OpTable tao_IR_Repository_optable;

IR::Repository_ptr _TAO_collocation_POA_IR_Repository_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::Repository_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_Repository (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_Repository_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_Repository_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_Repository_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_Repository_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_Repository_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_Repository_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::Repository::Repository (void)
{
  this->optable_ = &tao_IR_Repository_optable;
}

// copy ctor
POA_IR::Repository::Repository (const Repository& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Repository::~Repository (void)
{
}

void POA_IR::Repository::lookup_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR::Contained_var _tao_retval;
  CORBA::String_var search_id;
  if (!(
    (_tao_in >> search_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->lookup_id (
      search_id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::get_canonical_typecode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
  CORBA::TypeCode_var tc;
  if (!(
    (_tao_in >> tc.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->get_canonical_typecode (
      tc.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::get_primitive_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR::PrimitiveDef_var _tao_retval;
  IR::PrimitiveKind kind;
  if (!(
    (_tao_in >> kind)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->get_primitive (
      kind,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_string_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR::StringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_string (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_wstring_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR::WstringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_wstring (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_sequence_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR::SequenceDef_var _tao_retval;
  CORBA::ULong bound;
  IR::IDLType_var element_type;
  if (!(
    (_tao_in >> bound) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_sequence (
      bound,
      element_type.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_array_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR::ArrayDef_var _tao_retval;
  CORBA::ULong length;
  IR::IDLType_var element_type;
  if (!(
    (_tao_in >> length) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

   _tao_retval = _tao_impl->create_array (
      length,
      element_type.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_fixed_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR::FixedDef_var _tao_retval;
  CORBA::UShort digits;
  CORBA::Short scale;
  if (!(
    (_tao_in >> digits) &&
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_fixed (
      digits,
      scale,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Repository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Repository::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Repository::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Repository:1.0") == 0)
    return ACE_static_cast (POA_IR::Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Repository::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Repository:1.0";
}

IR::Repository*
POA_IR::Repository::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::Repository_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_Repository (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::Repository::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_Repository::_tao_thru_poa_collocated_Repository (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_Repository::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_Repository::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::Contained_ptr POA_IR::_tao_thru_poa_collocated_Repository::lookup_id  (
    const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "lookup_id",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->lookup_id (
      search_id,
      ACE_TRY_ENV
    );

}

CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_Repository::get_canonical_typecode  (
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "get_canonical_typecode",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->get_canonical_typecode (
      tc,
      ACE_TRY_ENV
    );

}

IR::PrimitiveDef_ptr POA_IR::_tao_thru_poa_collocated_Repository::get_primitive  (
    IR::PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::PrimitiveDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "get_primitive",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->get_primitive (
      kind,
      ACE_TRY_ENV
    );

}

IR::StringDef_ptr POA_IR::_tao_thru_poa_collocated_Repository::create_string  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::StringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_string",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_string (
      bound,
      ACE_TRY_ENV
    );

}

IR::WstringDef_ptr POA_IR::_tao_thru_poa_collocated_Repository::create_wstring  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::WstringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_wstring",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_wstring (
      bound,
      ACE_TRY_ENV
    );

}

IR::SequenceDef_ptr POA_IR::_tao_thru_poa_collocated_Repository::create_sequence  (
    CORBA::ULong bound,
    IR::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::SequenceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_sequence",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_sequence (
      bound,
      element_type,
      ACE_TRY_ENV
    );

}

IR::ArrayDef_ptr POA_IR::_tao_thru_poa_collocated_Repository::create_array  (
    CORBA::ULong length,
    IR::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ArrayDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_array",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_array (
      length,
      element_type,
      ACE_TRY_ENV
    );

}

IR::FixedDef_ptr POA_IR::_tao_thru_poa_collocated_Repository::create_fixed  (
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::FixedDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_fixed",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_fixed (
      digits,
      scale,
      ACE_TRY_ENV
    );

}



class TAO_IR_ComponentRepository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentRepository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 15,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54,  5,
     54,  0, 25, 15, 54, 10, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 10,  0,  3,
     54, 25, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54,  0,  5, 54, 54, 54,  0, 20, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54,
#else
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 15, 54,  5, 54,  0,
     25, 15, 54, 10, 54, 54, 54, 54, 10,  0,
      3, 54, 25, 54, 54,  0,  5, 54, 54, 54,
      0, 20, 54, 54, 54, 54, 54, 54,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 29,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 8,
      MAX_HASH_VALUE = 53,
      HASH_VALUE_RANGE = 46,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"contents",      &POA_IR::ComponentRepository::contents_skel},
      {"create_enum",   &POA_IR::ComponentRepository::create_enum_skel},
      {"create_alias",  &POA_IR::ComponentRepository::create_alias_skel},
      {"create_union",  &POA_IR::ComponentRepository::create_union_skel},
      {"create_value_box",      &POA_IR::ComponentRepository::create_value_box_skel},
      {"create_struct",         &POA_IR::ComponentRepository::create_struct_skel},
      {"create_exception",      &POA_IR::ComponentRepository::create_exception_skel},
      {"create_constant",       &POA_IR::ComponentRepository::create_constant_skel},
      {"create_component",      &POA_IR::ComponentRepository::create_component_skel},
      {"create_string",         &POA_IR::ComponentRepository::create_string_skel},
      {"create_wstring",        &POA_IR::ComponentRepository::create_wstring_skel},
      {"_is_a",  &POA_IR::ComponentRepository::_is_a_skel},
      {"create_home",   &POA_IR::ComponentRepository::create_home_skel},
      {"create_value",  &POA_IR::ComponentRepository::create_value_skel},
      {"create_module",         &POA_IR::ComponentRepository::create_module_skel},
      {"create_native",         &POA_IR::ComponentRepository::create_native_skel},
      {"create_sequence",       &POA_IR::ComponentRepository::create_sequence_skel},
      {"create_interface",      &POA_IR::ComponentRepository::create_interface_skel},
      {"create_array",  &POA_IR::ComponentRepository::create_array_skel},
      {"_non_existent",  &POA_IR::ComponentRepository::_non_existent_skel},
      {"lookup_name",   &POA_IR::ComponentRepository::lookup_name_skel},
      {"create_fixed",  &POA_IR::ComponentRepository::create_fixed_skel},
      {"get_primitive",         &POA_IR::ComponentRepository::get_primitive_skel},
      {"lookup",        &POA_IR::ComponentRepository::lookup_skel},
      {"describe_contents",     &POA_IR::ComponentRepository::describe_contents_skel},
      {"lookup_id",     &POA_IR::ComponentRepository::lookup_id_skel},
      {"get_canonical_typecode",        &POA_IR::ComponentRepository::get_canonical_typecode_skel},
      {"destroy",       &POA_IR::ComponentRepository::destroy_skel},
      {"_get_def_kind",         &POA_IR::ComponentRepository::_get_def_kind_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,   8,  -1,  -1,   9,  10, -22,
       -2,  11,  12,  -1,  13,  14,  15,  16,  -1,  17,  18,  19,  20,  21,
      -68,  -1,  24,  25,  26,  27,  -1,  -1,  28,  29,  30,  -1,  -1,  31,
       32,  -1,  33,  -1,  -1,  34,  -1,  -1,  -1,  -1,  35,  36,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ComponentRepository_Perfect_Hash_OpTable tao_IR_ComponentRepository_optable;

IR::ComponentRepository_ptr _TAO_collocation_POA_IR_ComponentRepository_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ComponentRepository_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ComponentRepository (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ComponentRepository_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ComponentRepository_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ComponentRepository_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ComponentRepository_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ComponentRepository_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ComponentRepository_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ComponentRepository::ComponentRepository (void)
{
  this->optable_ = &tao_IR_ComponentRepository_optable;
}

// copy ctor
POA_IR::ComponentRepository::ComponentRepository (const ComponentRepository& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Repository) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentRepository::~ComponentRepository (void)
{
}

void POA_IR::ComponentRepository::create_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *)_tao_object_reference;

  IR::ComponentDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ComponentDef_var base_component;
  IR::InterfaceDefSeq supports_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_component.out ()) &&
    (_tao_in >> supports_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_component (
      id.in (),
      name.in (),
      version.in (),
      base_component.in (),
      supports_interfaces,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentRepository::create_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *)_tao_object_reference;

  IR::HomeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::HomeDef_var base_home;
  IR::ComponentDef_var managed_component;
  IR::ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_home.out ()) &&
    (_tao_in >> managed_component.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_home (
      id.in (),
      name.in (),
      version.in (),
      base_home.in (),
      managed_component.in (),
      primary_key.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentRepository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentRepository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ComponentRepository::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentRepository::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentRepository:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentRepository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Repository:1.0") == 0)
    return ACE_static_cast (POA_IR::Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentRepository::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR::ComponentRepository*
POA_IR::ComponentRepository::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ComponentRepository_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ComponentRepository (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ComponentRepository::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ComponentRepository::_tao_thru_poa_collocated_ComponentRepository (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Repository) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ComponentRepository::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ComponentRepository::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::ComponentDef_ptr POA_IR::_tao_thru_poa_collocated_ComponentRepository::create_component  (
    const char * id,
    const char * name,
    const char * version,
    IR::ComponentDef_ptr base_component,
    const IR::InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_component (
      id,
      name,
      version,
      base_component,
      supports_interfaces,
      ACE_TRY_ENV
    );

}

IR::HomeDef_ptr POA_IR::_tao_thru_poa_collocated_ComponentRepository::create_home  (
    const char * id,
    const char * name,
    const char * version,
    IR::HomeDef_ptr base_home,
    IR::ComponentDef_ptr managed_component,
    IR::ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_home",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_home (
      id,
      name,
      version,
      base_home,
      managed_component,
      primary_key,
      ACE_TRY_ENV
    );

}



class TAO_IR_ModuleDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 10,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52,  0, 15,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 20,  0,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 10, 20, 52, 52, 52, 10, 15, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 10, 52,  0, 52,  0,
     15,  0, 52, 52, 52, 52, 52, 52, 20,  0,
      5, 52, 10, 52, 52, 10, 20, 52, 52, 52,
     10, 15, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 30,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 48,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ModuleDef::move_skel},
      {"create_enum",   &POA_IR::ModuleDef::create_enum_skel},
      {"create_value",  &POA_IR::ModuleDef::create_value_skel},
      {"create_module",         &POA_IR::ModuleDef::create_module_skel},
      {"create_native",         &POA_IR::ModuleDef::create_native_skel},
      {"_is_a",  &POA_IR::ModuleDef::_is_a_skel},
      {"create_interface",      &POA_IR::ModuleDef::create_interface_skel},
      {"create_union",  &POA_IR::ModuleDef::create_union_skel},
      {"contents",      &POA_IR::ModuleDef::contents_skel},
      {"_get_name",     &POA_IR::ModuleDef::_get_name_skel},
      {"_set_name",     &POA_IR::ModuleDef::_set_name_skel},
      {"create_exception",      &POA_IR::ModuleDef::create_exception_skel},
      {"create_alias",  &POA_IR::ModuleDef::create_alias_skel},
      {"describe",      &POA_IR::ModuleDef::describe_skel},
      {"create_value_box",      &POA_IR::ModuleDef::create_value_box_skel},
      {"_get_version",  &POA_IR::ModuleDef::_get_version_skel},
      {"_set_version",  &POA_IR::ModuleDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ModuleDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::ModuleDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::ModuleDef::lookup_name_skel},
      {"_get_id",       &POA_IR::ModuleDef::_get_id_skel},
      {"_set_id",       &POA_IR::ModuleDef::_set_id_skel},
      {"create_struct",         &POA_IR::ModuleDef::create_struct_skel},
      {"create_constant",       &POA_IR::ModuleDef::create_constant_skel},
      {"lookup",        &POA_IR::ModuleDef::lookup_skel},
      {"destroy",       &POA_IR::ModuleDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ModuleDef::_get_def_kind_skel},
      {"describe_contents",     &POA_IR::ModuleDef::describe_contents_skel},
      {"_non_existent",  &POA_IR::ModuleDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ModuleDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -7,  -2, -13,  -2, -19,  -2,   5,   6, -59,
       -1,   9,  10,  11,  12, -63,  -1,  15,  16,  17, -24,  -2,  18, -69,
       21,  -1,  22,  23, -59,  26,  -1,  27,  28,  29,  30,  -1,  -1,  -1,
       31,  32,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  33,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ModuleDef_Perfect_Hash_OpTable tao_IR_ModuleDef_optable;

IR::ModuleDef_ptr _TAO_collocation_POA_IR_ModuleDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ModuleDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ModuleDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ModuleDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ModuleDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ModuleDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ModuleDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ModuleDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ModuleDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ModuleDef::ModuleDef (void)
{
  this->optable_ = &tao_IR_ModuleDef_optable;
}

// copy ctor
POA_IR::ModuleDef::ModuleDef (const ModuleDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ModuleDef::~ModuleDef (void)
{
}

void POA_IR::ModuleDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ModuleDef *_tao_impl = (POA_IR::ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ModuleDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ModuleDef *_tao_impl = (POA_IR::ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ModuleDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ModuleDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ModuleDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ModuleDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ModuleDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ModuleDef:1.0";
}

IR::ModuleDef*
POA_IR::ModuleDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ModuleDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ModuleDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ModuleDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ModuleDef::_tao_thru_poa_collocated_ModuleDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ModuleDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ModuleDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ModuleDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ModuleDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ModuleDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ModuleDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_IR_ConstantDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ConstantDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ConstantDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ConstantDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ConstantDef::move_skel},
      {"_is_a",  &POA_IR::ConstantDef::_is_a_skel},
      {"_get_id",       &POA_IR::ConstantDef::_get_id_skel},
      {"_set_id",       &POA_IR::ConstantDef::_set_id_skel},
      {"describe",      &POA_IR::ConstantDef::describe_skel},
      {"_get_type",     &POA_IR::ConstantDef::_get_type_skel},
      {"_set_name",     &POA_IR::ConstantDef::_set_name_skel},
      {"_get_name",     &POA_IR::ConstantDef::_get_name_skel},
      {"_get_value",    &POA_IR::ConstantDef::_get_value_skel},
      {"_set_value",    &POA_IR::ConstantDef::_set_value_skel},
      {"_get_version",  &POA_IR::ConstantDef::_get_version_skel},
      {"_set_version",  &POA_IR::ConstantDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ConstantDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ConstantDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ConstantDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ConstantDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::ConstantDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::ConstantDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::ConstantDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ConstantDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46, -46,  -1, -46,  16,
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ConstantDef_Perfect_Hash_OpTable tao_IR_ConstantDef_optable;

IR::ConstantDef_ptr _TAO_collocation_POA_IR_ConstantDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ConstantDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ConstantDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ConstantDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ConstantDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ConstantDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ConstantDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ConstantDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ConstantDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ConstantDef::ConstantDef (void)
{
  this->optable_ = &tao_IR_ConstantDef_optable;
}

// copy ctor
POA_IR::ConstantDef::ConstantDef (const ConstantDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ConstantDef::~ConstantDef (void)
{
}

void POA_IR::ConstantDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ConstantDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ConstantDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  IR::IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->type_def (
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ConstantDef::_get_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::Any_var _tao_retval;

  _tao_retval = _tao_impl->value (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ConstantDef::_set_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::Any value;
  if (!(
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->value (
      value,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ConstantDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConstantDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ConstantDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ConstantDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ConstantDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ConstantDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ConstantDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConstantDef:1.0";
}

IR::ConstantDef*
POA_IR::ConstantDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ConstantDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ConstantDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ConstantDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ConstantDef::_tao_thru_poa_collocated_ConstantDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ConstantDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ConstantDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_ConstantDef::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_ConstantDef::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ConstantDef::type_def  (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type_def (
      type_def,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Any * POA_IR::_tao_thru_poa_collocated_ConstantDef::value  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Any_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "value",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->value (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ConstantDef::value  (
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "value",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->value (
      value,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_TypedefDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_TypedefDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_TypedefDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_TypedefDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::TypedefDef::move_skel},
      {"_is_a",  &POA_IR::TypedefDef::_is_a_skel},
      {"_get_id",       &POA_IR::TypedefDef::_get_id_skel},
      {"_set_id",       &POA_IR::TypedefDef::_set_id_skel},
      {"describe",      &POA_IR::TypedefDef::describe_skel},
      {"_get_name",     &POA_IR::TypedefDef::_get_name_skel},
      {"_get_type",     &POA_IR::TypedefDef::_get_type_skel},
      {"_set_name",     &POA_IR::TypedefDef::_set_name_skel},
      {"_get_version",  &POA_IR::TypedefDef::_get_version_skel},
      {"_set_version",  &POA_IR::TypedefDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::TypedefDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::TypedefDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::TypedefDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::TypedefDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::TypedefDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::TypedefDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_TypedefDef_Perfect_Hash_OpTable tao_IR_TypedefDef_optable;

IR::TypedefDef_ptr _TAO_collocation_POA_IR_TypedefDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::TypedefDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_TypedefDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_TypedefDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_TypedefDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_TypedefDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_TypedefDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_TypedefDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_TypedefDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::TypedefDef::TypedefDef (void)
{
  this->optable_ = &tao_IR_TypedefDef_optable;
}

// copy ctor
POA_IR::TypedefDef::TypedefDef (const TypedefDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::TypedefDef::~TypedefDef (void)
{
}

void POA_IR::TypedefDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::TypedefDef *_tao_impl = (POA_IR::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::TypedefDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::TypedefDef *_tao_impl = (POA_IR::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::TypedefDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::TypedefDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::TypedefDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/TypedefDef:1.0";
}

IR::TypedefDef*
POA_IR::TypedefDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::TypedefDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_TypedefDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::TypedefDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_TypedefDef::_tao_thru_poa_collocated_TypedefDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_TypedefDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::TypedefDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/TypedefDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_TypedefDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::TypedefDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/TypedefDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_IR_StructDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_StructDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_StructDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 20,  3,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 10, 15,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 15, 15, 52, 52, 52, 15,  5, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52,  0, 52,  0, 52, 20,
      3,  0, 52, 52, 52, 52, 52, 52, 10, 15,
      5, 52, 10, 52, 52, 15, 15, 52, 52, 52,
     15,  5, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_StructDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::StructDef::_is_a_skel},
      {"_get_name",     &POA_IR::StructDef::_get_name_skel},
      {"_get_type",     &POA_IR::StructDef::_get_type_skel},
      {"_set_name",     &POA_IR::StructDef::_set_name_skel},
      {"_get_id",       &POA_IR::StructDef::_get_id_skel},
      {"_set_id",       &POA_IR::StructDef::_set_id_skel},
      {"describe",      &POA_IR::StructDef::describe_skel},
      {"destroy",       &POA_IR::StructDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::StructDef::_get_def_kind_skel},
      {"_get_version",  &POA_IR::StructDef::_get_version_skel},
      {"_set_version",  &POA_IR::StructDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::StructDef::_get_absolute_name_skel},
      {"move",  &POA_IR::StructDef::move_skel},
      {"_get_defined_in",       &POA_IR::StructDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::StructDef::lookup_name_skel},
      {"lookup",        &POA_IR::StructDef::lookup_skel},
      {"_get_members",  &POA_IR::StructDef::_get_members_skel},
      {"_set_members",  &POA_IR::StructDef::_set_members_skel},
      {"_non_existent",  &POA_IR::StructDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::StructDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::StructDef::create_value_skel},
      {"create_module",         &POA_IR::StructDef::create_module_skel},
      {"create_native",         &POA_IR::StructDef::create_native_skel},
      {"describe_contents",     &POA_IR::StructDef::describe_contents_skel},
      {"create_interface",      &POA_IR::StructDef::create_interface_skel},
      {"create_union",  &POA_IR::StructDef::create_union_skel},
      {"create_exception",      &POA_IR::StructDef::create_exception_skel},
      {"contents",      &POA_IR::StructDef::contents_skel},
      {"create_enum",   &POA_IR::StructDef::create_enum_skel},
      {"create_alias",  &POA_IR::StructDef::create_alias_skel},
      {"create_struct",         &POA_IR::StructDef::create_struct_skel},
      {"create_constant",       &POA_IR::StructDef::create_constant_skel},
      {"create_value_box",      &POA_IR::StructDef::create_value_box_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -3,   5,  -1,  -9,  -2, -57, -54,  11,  -1, -14,
       -2,  12,  13, -55,  16,  17,  18,  19,  -1,  -1, -21,  -2,  20, -54,
       23, -26,  -2,  24,  25, -55,  -1,  28,  29,  30,  -1,  -1,  -1,  31,
       -1,  32,  -1,  -1,  33,  34,  35,  -1,  36,  37,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_StructDef_Perfect_Hash_OpTable tao_IR_StructDef_optable;

IR::StructDef_ptr _TAO_collocation_POA_IR_StructDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::StructDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_StructDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_StructDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_StructDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_StructDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_StructDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_StructDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_StructDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::StructDef::StructDef (void)
{
  this->optable_ = &tao_IR_StructDef_optable;
}

// copy ctor
POA_IR::StructDef::StructDef (const StructDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::StructDef::~StructDef (void)
{
}

void POA_IR::StructDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *)_tao_object_reference;

  IR::StructMemberSeq_var _tao_retval;

  _tao_retval = _tao_impl->members (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::StructDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *)_tao_object_reference;

  IR::StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->members (
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::StructDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::StructDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::StructDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::StructDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/StructDef:1.0") == 0)
    return ACE_static_cast (POA_IR::StructDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::StructDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StructDef:1.0";
}

IR::StructDef*
POA_IR::StructDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::StructDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_StructDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::StructDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_StructDef::_tao_thru_poa_collocated_StructDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_StructDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StructDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_StructDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StructDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::StructMemberSeq * POA_IR::_tao_thru_poa_collocated_StructDef::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StructDef:1.0"
        )
    )->members (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_StructDef::members  (
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StructDef:1.0"
        )
    )->members (
      members,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_UnionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_UnionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_UnionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68,  0,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68,  0,
     68, 25,  3,  0,  0, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 10,  0, 10,
     68, 10, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 30, 15, 68, 68, 68,  5,  5, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68,
#else
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68,  0, 68,  0, 68, 25,
      3,  0,  0, 68, 68, 68, 68, 68, 10,  0,
     10, 68, 10, 68, 68, 30, 15, 68, 68, 68,
      5,  5, 68, 68, 68, 68, 68, 68,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_UnionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 67,
      HASH_VALUE_RANGE = 64,
      DUPLICATES = 8
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::UnionDef::move_skel},
      {"_is_a",  &POA_IR::UnionDef::_is_a_skel},
      {"_get_name",     &POA_IR::UnionDef::_get_name_skel},
      {"_get_type",     &POA_IR::UnionDef::_get_type_skel},
      {"_set_name",     &POA_IR::UnionDef::_set_name_skel},
      {"_get_id",       &POA_IR::UnionDef::_get_id_skel},
      {"_set_id",       &POA_IR::UnionDef::_set_id_skel},
      {"describe",      &POA_IR::UnionDef::describe_skel},
      {"destroy",       &POA_IR::UnionDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::UnionDef::_get_def_kind_skel},
      {"_get_absolute_name",    &POA_IR::UnionDef::_get_absolute_name_skel},
      {"lookup_name",   &POA_IR::UnionDef::lookup_name_skel},
      {"_get_version",  &POA_IR::UnionDef::_get_version_skel},
      {"_set_version",  &POA_IR::UnionDef::_set_version_skel},
      {"_get_discriminator_type",       &POA_IR::UnionDef::_get_discriminator_type_skel},
      {"_get_defined_in",       &POA_IR::UnionDef::_get_defined_in_skel},
      {"lookup",        &POA_IR::UnionDef::lookup_skel},
      {"_get_discriminator_type_def",   &POA_IR::UnionDef::_get_discriminator_type_def_skel},
      {"_set_discriminator_type_def",   &POA_IR::UnionDef::_set_discriminator_type_def_skel},
      {"_non_existent",  &POA_IR::UnionDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::UnionDef::_get_containing_repository_skel},
      {"create_enum",   &POA_IR::UnionDef::create_enum_skel},
      {"create_value",  &POA_IR::UnionDef::create_value_skel},
      {"create_module",         &POA_IR::UnionDef::create_module_skel},
      {"create_native",         &POA_IR::UnionDef::create_native_skel},
      {"create_interface",      &POA_IR::UnionDef::create_interface_skel},
      {"_get_members",  &POA_IR::UnionDef::_get_members_skel},
      {"_set_members",  &POA_IR::UnionDef::_set_members_skel},
      {"create_value_box",      &POA_IR::UnionDef::create_value_box_skel},
      {"create_union",  &POA_IR::UnionDef::create_union_skel},
      {"describe_contents",     &POA_IR::UnionDef::describe_contents_skel},
      {"create_exception",      &POA_IR::UnionDef::create_exception_skel},
      {"create_struct",         &POA_IR::UnionDef::create_struct_skel},
      {"create_constant",       &POA_IR::UnionDef::create_constant_skel},
      {"contents",      &POA_IR::UnionDef::contents_skel},
      {"create_alias",  &POA_IR::UnionDef::create_alias_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -6,  -3,   4,   5,  -1,  -9,  -2, -74, -70,  11,  -1, -16,
       -2,  12,  13,  -1,  14, -21,  -2,  15, -76,  18,  -1,  19,  20, -75,
       23,  -1,  -1,  24,  -1,  -1, -27,  -2,  25,  26, -71, -30,  -2,  29,
      -70,  -1,  -1,  -1,  32,  33,  -1,  -1,  34,  35,  -1,  36,  -1,  37,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  38,  -1,  -1,  -1,  39,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_UnionDef_Perfect_Hash_OpTable tao_IR_UnionDef_optable;

IR::UnionDef_ptr _TAO_collocation_POA_IR_UnionDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::UnionDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_UnionDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_UnionDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_UnionDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_UnionDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_UnionDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_UnionDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_UnionDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::UnionDef::UnionDef (void)
{
  this->optable_ = &tao_IR_UnionDef_optable;
}

// copy ctor
POA_IR::UnionDef::UnionDef (const UnionDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::UnionDef::~UnionDef (void)
{
}

void POA_IR::UnionDef::_get_discriminator_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->discriminator_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UnionDef::_get_discriminator_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->discriminator_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UnionDef::_set_discriminator_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR::IDLType_var discriminator_type_def;
  if (!(
    (_tao_in >> discriminator_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->discriminator_type_def (
      discriminator_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::UnionDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR::UnionMemberSeq_var _tao_retval;

  _tao_retval = _tao_impl->members (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UnionDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR::UnionMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->members (
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::UnionDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UnionDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::UnionDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::UnionDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/UnionDef:1.0") == 0)
    return ACE_static_cast (POA_IR::UnionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::UnionDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UnionDef:1.0";
}

IR::UnionDef*
POA_IR::UnionDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::UnionDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_UnionDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::UnionDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_UnionDef::_tao_thru_poa_collocated_UnionDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_UnionDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_UnionDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_UnionDef::discriminator_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "discriminator_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_UnionDef::discriminator_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "discriminator_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_UnionDef::discriminator_type_def  (
    IR::IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "discriminator_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type_def (
      discriminator_type_def,
      ACE_TRY_ENV
    );
  return;
}

IR::UnionMemberSeq * POA_IR::_tao_thru_poa_collocated_UnionDef::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::UnionMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->members (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_UnionDef::members  (
    const IR::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->members (
      members,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_EnumDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EnumDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EnumDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 10, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 10, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EnumDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EnumDef::move_skel},
      {"_is_a",  &POA_IR::EnumDef::_is_a_skel},
      {"_get_id",       &POA_IR::EnumDef::_get_id_skel},
      {"_set_id",       &POA_IR::EnumDef::_set_id_skel},
      {"describe",      &POA_IR::EnumDef::describe_skel},
      {"_get_name",     &POA_IR::EnumDef::_get_name_skel},
      {"_get_type",     &POA_IR::EnumDef::_get_type_skel},
      {"_set_name",     &POA_IR::EnumDef::_set_name_skel},
      {"_get_version",  &POA_IR::EnumDef::_get_version_skel},
      {"_set_version",  &POA_IR::EnumDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EnumDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::EnumDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EnumDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EnumDef::_get_absolute_name_skel},
      {"_get_members",  &POA_IR::EnumDef::_get_members_skel},
      {"_set_members",  &POA_IR::EnumDef::_set_members_skel},
      {"_non_existent",  &POA_IR::EnumDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EnumDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_EnumDef_Perfect_Hash_OpTable tao_IR_EnumDef_optable;

IR::EnumDef_ptr _TAO_collocation_POA_IR_EnumDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::EnumDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_EnumDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_EnumDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_EnumDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_EnumDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_EnumDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_EnumDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_EnumDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::EnumDef::EnumDef (void)
{
  this->optable_ = &tao_IR_EnumDef_optable;
}

// copy ctor
POA_IR::EnumDef::EnumDef (const EnumDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EnumDef::~EnumDef (void)
{
}

void POA_IR::EnumDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *)_tao_object_reference;

  IR::EnumMemberSeq_var _tao_retval;

  _tao_retval = _tao_impl->members (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::EnumDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *)_tao_object_reference;

  IR::EnumMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->members (
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::EnumDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EnumDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EnumDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EnumDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EnumDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EnumDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EnumDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EnumDef:1.0";
}

IR::EnumDef*
POA_IR::EnumDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::EnumDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_EnumDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::EnumDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_EnumDef::_tao_thru_poa_collocated_EnumDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_EnumDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EnumDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_EnumDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EnumDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::EnumMemberSeq * POA_IR::_tao_thru_poa_collocated_EnumDef::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::EnumMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EnumDef:1.0"
        )
    )->members (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_EnumDef::members  (
    const IR::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EnumDef:1.0"
        )
    )->members (
      members,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_AliasDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_AliasDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_AliasDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_AliasDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::AliasDef::move_skel},
      {"_is_a",  &POA_IR::AliasDef::_is_a_skel},
      {"_get_id",       &POA_IR::AliasDef::_get_id_skel},
      {"_set_id",       &POA_IR::AliasDef::_set_id_skel},
      {"describe",      &POA_IR::AliasDef::describe_skel},
      {"_get_name",     &POA_IR::AliasDef::_get_name_skel},
      {"_get_type",     &POA_IR::AliasDef::_get_type_skel},
      {"_set_name",     &POA_IR::AliasDef::_set_name_skel},
      {"_get_version",  &POA_IR::AliasDef::_get_version_skel},
      {"_set_version",  &POA_IR::AliasDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::AliasDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::AliasDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::AliasDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::AliasDef::_get_absolute_name_skel},
      {"_get_original_type_def",        &POA_IR::AliasDef::_get_original_type_def_skel},
      {"_set_original_type_def",        &POA_IR::AliasDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_IR::AliasDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::AliasDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_AliasDef_Perfect_Hash_OpTable tao_IR_AliasDef_optable;

IR::AliasDef_ptr _TAO_collocation_POA_IR_AliasDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::AliasDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_AliasDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_AliasDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_AliasDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_AliasDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_AliasDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_AliasDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_AliasDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::AliasDef::AliasDef (void)
{
  this->optable_ = &tao_IR_AliasDef_optable;
}

// copy ctor
POA_IR::AliasDef::AliasDef (const AliasDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::AliasDef::~AliasDef (void)
{
}

void POA_IR::AliasDef::_get_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->original_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::AliasDef::_set_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *)_tao_object_reference;

  IR::IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->original_type_def (
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::AliasDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::AliasDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::AliasDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::AliasDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/AliasDef:1.0") == 0)
    return ACE_static_cast (POA_IR::AliasDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::AliasDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AliasDef:1.0";
}

IR::AliasDef*
POA_IR::AliasDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::AliasDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_AliasDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::AliasDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_AliasDef::_tao_thru_poa_collocated_AliasDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_AliasDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AliasDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_AliasDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AliasDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_AliasDef::original_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AliasDef:1.0"
        )
    )->original_type_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_AliasDef::original_type_def  (
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "original_type_def",
      forward_to.out (),
     ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AliasDef:1.0"
        )
    )->original_type_def (
      original_type_def,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_NativeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_NativeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_NativeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_NativeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::NativeDef::move_skel},
      {"_is_a",  &POA_IR::NativeDef::_is_a_skel},
      {"_get_id",       &POA_IR::NativeDef::_get_id_skel},
      {"_set_id",       &POA_IR::NativeDef::_set_id_skel},
      {"describe",      &POA_IR::NativeDef::describe_skel},
      {"_get_name",     &POA_IR::NativeDef::_get_name_skel},
      {"_get_type",     &POA_IR::NativeDef::_get_type_skel},
      {"_set_name",     &POA_IR::NativeDef::_set_name_skel},
      {"_get_version",  &POA_IR::NativeDef::_get_version_skel},
      {"_set_version",  &POA_IR::NativeDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::NativeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::NativeDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::NativeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::NativeDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::NativeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::NativeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_NativeDef_Perfect_Hash_OpTable tao_IR_NativeDef_optable;

IR::NativeDef_ptr _TAO_collocation_POA_IR_NativeDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::NativeDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_NativeDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_NativeDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_NativeDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_NativeDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_NativeDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_NativeDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_NativeDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::NativeDef::NativeDef (void)
{
  this->optable_ = &tao_IR_NativeDef_optable;
}

// copy ctor
POA_IR::NativeDef::NativeDef (const NativeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::NativeDef::~NativeDef (void)
{
}

void POA_IR::NativeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::NativeDef *_tao_impl = (POA_IR::NativeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::NativeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::NativeDef *_tao_impl = (POA_IR::NativeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::NativeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/NativeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::NativeDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/NativeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::NativeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::NativeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/NativeDef:1.0";
}

IR::NativeDef*
POA_IR::NativeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::NativeDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_NativeDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::NativeDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_NativeDef::_tao_thru_poa_collocated_NativeDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_NativeDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::NativeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/NativeDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_NativeDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::NativeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/NativeDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_IR_PrimitiveDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PrimitiveDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PrimitiveDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  5, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PrimitiveDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::PrimitiveDef::_is_a_skel},
      {"",0},
      {"destroy",       &POA_IR::PrimitiveDef::destroy_skel},
      {"",0},
      {"_get_kind",     &POA_IR::PrimitiveDef::_get_kind_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_IR::PrimitiveDef::_get_def_kind_skel},
      {"_get_type",     &POA_IR::PrimitiveDef::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_non_existent",  &POA_IR::PrimitiveDef::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_PrimitiveDef_Perfect_Hash_OpTable tao_IR_PrimitiveDef_optable;

IR::PrimitiveDef_ptr _TAO_collocation_POA_IR_PrimitiveDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::PrimitiveDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_PrimitiveDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_PrimitiveDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_PrimitiveDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_PrimitiveDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_PrimitiveDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_PrimitiveDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_PrimitiveDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::PrimitiveDef::PrimitiveDef (void)
{
  this->optable_ = &tao_IR_PrimitiveDef_optable;
}

// copy ctor
POA_IR::PrimitiveDef::PrimitiveDef (const PrimitiveDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PrimitiveDef::~PrimitiveDef (void)
{
}

void POA_IR::PrimitiveDef::_get_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *)_tao_object_reference;

  IR::PrimitiveKind _tao_retval;

  _tao_retval = _tao_impl->kind (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::PrimitiveDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimitiveDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PrimitiveDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PrimitiveDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PrimitiveDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PrimitiveDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PrimitiveDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimitiveDef:1.0";
}

IR::PrimitiveDef*
POA_IR::PrimitiveDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::PrimitiveDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_PrimitiveDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::PrimitiveDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_PrimitiveDef::_tao_thru_poa_collocated_PrimitiveDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_PrimitiveDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimitiveDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_PrimitiveDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimitiveDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::PrimitiveKind POA_IR::_tao_thru_poa_collocated_PrimitiveDef::kind  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::PrimitiveKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "kind",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimitiveDef:1.0"
        )
    )->kind (
      ACE_TRY_ENV
    );

}



class TAO_IR_StringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_StringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_StringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_StringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::StringDef::_is_a_skel},
      {"destroy",       &POA_IR::StringDef::destroy_skel},
      {"_get_type",     &POA_IR::StringDef::_get_type_skel},
      {"_get_bound",    &POA_IR::StringDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::StringDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::StringDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::StringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -25,  -1,  -1,  10,
       -1,  -1,  -1,  -1,  11,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_StringDef_Perfect_Hash_OpTable tao_IR_StringDef_optable;

IR::StringDef_ptr _TAO_collocation_POA_IR_StringDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::StringDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_StringDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_StringDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_StringDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_StringDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_StringDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_StringDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_StringDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::StringDef::StringDef (void)
{
  this->optable_ = &tao_IR_StringDef_optable;
}

// copy ctor
POA_IR::StringDef::StringDef (const StringDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::StringDef::~StringDef (void)
{
}

void POA_IR::StringDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

  _tao_retval = _tao_impl->bound (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::StringDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->bound (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::StringDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::StringDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::StringDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::StringDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/StringDef:1.0") == 0)
    return ACE_static_cast (POA_IR::StringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::StringDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StringDef:1.0";
}

IR::StringDef*
POA_IR::StringDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::StringDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_StringDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::StringDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_StringDef::_tao_thru_poa_collocated_StringDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_StringDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StringDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_StringDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StringDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::ULong POA_IR::_tao_thru_poa_collocated_StringDef::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StringDef:1.0"
        )
    )->bound (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_StringDef::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StringDef:1.0"
        )
    )->bound (
      bound,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_WstringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_WstringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_WstringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_WstringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::WstringDef::_is_a_skel},
      {"destroy",       &POA_IR::WstringDef::destroy_skel},
      {"_get_type",     &POA_IR::WstringDef::_get_type_skel},
      {"_get_bound",    &POA_IR::WstringDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::WstringDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::WstringDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::WstringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -25,  -1,  -1,  10,
       -1,  -1,  -1,  -1,  11,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_WstringDef_Perfect_Hash_OpTable tao_IR_WstringDef_optable;

IR::WstringDef_ptr _TAO_collocation_POA_IR_WstringDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::WstringDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_WstringDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_WstringDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_WstringDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_WstringDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_WstringDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_WstringDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_WstringDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::WstringDef::WstringDef (void)
{
  this->optable_ = &tao_IR_WstringDef_optable;
}

// copy ctor
POA_IR::WstringDef::WstringDef (const WstringDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::WstringDef::~WstringDef (void)
{
}

void POA_IR::WstringDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

  _tao_retval = _tao_impl->bound (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::WstringDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->bound (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::WstringDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::WstringDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::WstringDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::WstringDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/WstringDef:1.0") == 0)
    return ACE_static_cast (POA_IR::WstringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::WstringDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/WstringDef:1.0";
}

IR::WstringDef*
POA_IR::WstringDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::WstringDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_WstringDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::WstringDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_WstringDef::_tao_thru_poa_collocated_WstringDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_WstringDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/WstringDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_WstringDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/WstringDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::ULong POA_IR::_tao_thru_poa_collocated_WstringDef::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/WstringDef:1.0"
        )
    )->bound (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_WstringDef::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/WstringDef:1.0"
        )
    )->bound (
      bound,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_FixedDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FixedDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FixedDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19,  0,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FixedDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::FixedDef::_is_a_skel},
      {"destroy",       &POA_IR::FixedDef::destroy_skel},
      {"_get_type",     &POA_IR::FixedDef::_get_type_skel},
      {"_get_scale",    &POA_IR::FixedDef::_get_scale_skel},
      {"_set_scale",    &POA_IR::FixedDef::_set_scale_skel},
      {"_get_digits",   &POA_IR::FixedDef::_get_digits_skel},
      {"_set_digits",   &POA_IR::FixedDef::_set_digits_skel},
      {"_get_def_kind",         &POA_IR::FixedDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::FixedDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -8,  -2, -10,  -2,   5,  -1,   6,  -1,   7, -27, -26,  -1,  12,
       -1,  -1,  -1,  -1,  13,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_FixedDef_Perfect_Hash_OpTable tao_IR_FixedDef_optable;

IR::FixedDef_ptr _TAO_collocation_POA_IR_FixedDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::FixedDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_FixedDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_FixedDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_FixedDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_FixedDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_FixedDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_FixedDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_FixedDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::FixedDef::FixedDef (void)
{
  this->optable_ = &tao_IR_FixedDef_optable;
}

// copy ctor
POA_IR::FixedDef::FixedDef (const FixedDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FixedDef::~FixedDef (void)
{
}

void POA_IR::FixedDef::_get_digits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::UShort _tao_retval = 0;

  _tao_retval = _tao_impl->digits (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::FixedDef::_set_digits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::UShort digits;
  if (!(
    (_tao_in >> digits)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->digits (
      digits,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::FixedDef::_get_scale_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::Short _tao_retval = 0;

  _tao_retval = _tao_impl->scale (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::FixedDef::_set_scale_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::Short scale;
  if (!(
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->scale (
      scale,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::FixedDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FixedDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FixedDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FixedDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FixedDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FixedDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FixedDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FixedDef:1.0";
}

IR::FixedDef*
POA_IR::FixedDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::FixedDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_FixedDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::FixedDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_FixedDef::_tao_thru_poa_collocated_FixedDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_FixedDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_FixedDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::UShort POA_IR::_tao_thru_poa_collocated_FixedDef::digits  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::UShort _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "digits",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->digits (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_FixedDef::digits  (
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "digits",
       forward_to.out (),
     ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->digits (
      digits,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Short POA_IR::_tao_thru_poa_collocated_FixedDef::scale  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Short _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "scale",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->scale (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_FixedDef::scale  (
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "scale",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->scale (
      scale,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_SequenceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_SequenceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_SequenceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_SequenceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::SequenceDef::_is_a_skel},
      {"destroy",       &POA_IR::SequenceDef::destroy_skel},
      {"_get_type",     &POA_IR::SequenceDef::_get_type_skel},
      {"_get_bound",    &POA_IR::SequenceDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::SequenceDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::SequenceDef::_get_def_kind_skel},
      {"_get_element_type",     &POA_IR::SequenceDef::_get_element_type_skel},
      {"_non_existent",  &POA_IR::SequenceDef::_non_existent_skel},
      {"_get_element_type_def",         &POA_IR::SequenceDef::_get_element_type_def_skel},
      {"_set_element_type_def",         &POA_IR::SequenceDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -28,  -1,  -1,  10,
       -1,  -1,  -1,  11,  12, -13,  -2, -23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_SequenceDef_Perfect_Hash_OpTable tao_IR_SequenceDef_optable;

IR::SequenceDef_ptr _TAO_collocation_POA_IR_SequenceDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::SequenceDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_SequenceDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_SequenceDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_SequenceDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_SequenceDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_SequenceDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_SequenceDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_SequenceDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::SequenceDef::SequenceDef (void)
{
  this->optable_ = &tao_IR_SequenceDef_optable;
}

// copy ctor
POA_IR::SequenceDef::SequenceDef (const SequenceDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::SequenceDef::~SequenceDef (void)
{
}

void POA_IR::SequenceDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

  _tao_retval = _tao_impl->bound (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::SequenceDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->bound (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::SequenceDef::_get_element_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->element_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::SequenceDef::_get_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->element_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::SequenceDef::_set_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  IR::IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->element_type_def (
      element_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::SequenceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::SequenceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::SequenceDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::SequenceDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/SequenceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::SequenceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::SequenceDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/SequenceDef:1.0";
}

IR::SequenceDef*
POA_IR::SequenceDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::SequenceDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_SequenceDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::SequenceDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_SequenceDef::_tao_thru_poa_collocated_SequenceDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_SequenceDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_SequenceDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::ULong POA_IR::_tao_thru_poa_collocated_SequenceDef::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->bound (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_SequenceDef::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->bound (
      bound,
      ACE_TRY_ENV
    );
  return;
}

CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_SequenceDef::element_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type",
       forward_to.out (),
     ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_SequenceDef::element_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_SequenceDef::element_type_def  (
    IR::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type_def (
      element_type_def,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_ArrayDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ArrayDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ArrayDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ArrayDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::ArrayDef::_is_a_skel},
      {"destroy",       &POA_IR::ArrayDef::destroy_skel},
      {"_get_type",     &POA_IR::ArrayDef::_get_type_skel},
      {"_get_length",   &POA_IR::ArrayDef::_get_length_skel},
      {"_set_length",   &POA_IR::ArrayDef::_set_length_skel},
      {"_get_def_kind",         &POA_IR::ArrayDef::_get_def_kind_skel},
      {"_get_element_type",     &POA_IR::ArrayDef::_get_element_type_skel},
      {"_non_existent",  &POA_IR::ArrayDef::_non_existent_skel},
      {"_get_element_type_def",         &POA_IR::ArrayDef::_get_element_type_def_skel},
      {"_set_element_type_def",         &POA_IR::ArrayDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7,  -1, -29,  -1,  10,
       -1,  -1,  -1,  11,  12, -13,  -2, -23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ArrayDef_Perfect_Hash_OpTable tao_IR_ArrayDef_optable;

IR::ArrayDef_ptr _TAO_collocation_POA_IR_ArrayDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ArrayDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ArrayDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ArrayDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ArrayDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ArrayDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ArrayDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ArrayDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ArrayDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ArrayDef::ArrayDef (void)
{
  this->optable_ = &tao_IR_ArrayDef_optable;
}

// copy ctor
POA_IR::ArrayDef::ArrayDef (const ArrayDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ArrayDef::~ArrayDef (void)
{
}

void POA_IR::ArrayDef::_get_length_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

  _tao_retval = _tao_impl->length (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ArrayDef::_set_length_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::ULong length;
  if (!(
    (_tao_in >> length)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->length (
      length,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ArrayDef::_get_element_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->element_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ArrayDef::_get_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->element_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ArrayDef::_set_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  IR::IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->element_type_def (
      element_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ArrayDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ArrayDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ArrayDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ArrayDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ArrayDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ArrayDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ArrayDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ArrayDef:1.0";
}

IR::ArrayDef*
POA_IR::ArrayDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ArrayDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ArrayDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ArrayDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ArrayDef::_tao_thru_poa_collocated_ArrayDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ArrayDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ArrayDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::ULong POA_IR::_tao_thru_poa_collocated_ArrayDef::length  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
   CORBA::Object_var forward_to;
 servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "length",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->length (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ArrayDef::length  (
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "length",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->length (
      length,
      ACE_TRY_ENV
    );
  return;
}

CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_ArrayDef::element_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_ArrayDef::element_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ArrayDef::element_type_def  (
    IR::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type_def (
      element_type_def,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_ExceptionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ExceptionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ExceptionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 20,  3,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 10, 15,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 15, 15, 52, 52, 52, 15,  5, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52,  0, 52,  0, 52, 20,
      3,  0, 52, 52, 52, 52, 52, 52, 10, 15,
      5, 52, 10, 52, 52, 15, 15, 52, 52, 52,
     15,  5, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ExceptionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::ExceptionDef::_is_a_skel},
      {"_get_type",     &POA_IR::ExceptionDef::_get_type_skel},
      {"_set_name",     &POA_IR::ExceptionDef::_set_name_skel},
      {"_get_name",     &POA_IR::ExceptionDef::_get_name_skel},
      {"_get_id",       &POA_IR::ExceptionDef::_get_id_skel},
      {"_set_id",       &POA_IR::ExceptionDef::_set_id_skel},
      {"describe",      &POA_IR::ExceptionDef::describe_skel},
      {"destroy",       &POA_IR::ExceptionDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ExceptionDef::_get_def_kind_skel},
      {"_get_version",  &POA_IR::ExceptionDef::_get_version_skel},
      {"_set_version",  &POA_IR::ExceptionDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ExceptionDef::_get_absolute_name_skel},
      {"move",  &POA_IR::ExceptionDef::move_skel},
      {"_get_defined_in",       &POA_IR::ExceptionDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::ExceptionDef::lookup_name_skel},
      {"lookup",        &POA_IR::ExceptionDef::lookup_skel},
      {"_get_members",  &POA_IR::ExceptionDef::_get_members_skel},
      {"_set_members",  &POA_IR::ExceptionDef::_set_members_skel},
      {"_non_existent",  &POA_IR::ExceptionDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ExceptionDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::ExceptionDef::create_value_skel},
      {"create_module",         &POA_IR::ExceptionDef::create_module_skel},
      {"create_native",         &POA_IR::ExceptionDef::create_native_skel},
      {"describe_contents",     &POA_IR::ExceptionDef::describe_contents_skel},
      {"create_interface",      &POA_IR::ExceptionDef::create_interface_skel},
      {"create_union",  &POA_IR::ExceptionDef::create_union_skel},
      {"create_exception",      &POA_IR::ExceptionDef::create_exception_skel},
      {"contents",      &POA_IR::ExceptionDef::contents_skel},
      {"create_enum",   &POA_IR::ExceptionDef::create_enum_skel},
      {"create_alias",  &POA_IR::ExceptionDef::create_alias_skel},
      {"create_struct",         &POA_IR::ExceptionDef::create_struct_skel},
      {"create_constant",       &POA_IR::ExceptionDef::create_constant_skel},
      {"create_value_box",      &POA_IR::ExceptionDef::create_value_box_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -3,   5,  -1,  -9,  -2, -57, -54,  11,  -1, -14,
       -2,  12,  13, -55,  16,  17,  18,  19,  -1,  -1, -21,  -2,  20, -54,
       23, -26,  -2,  24,  25, -55,  -1,  28,  29,  30,  -1,  -1,  -1,  31,
       -1,  32,  -1,  -1,  33,  34,  35,  -1,  36,  37,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ExceptionDef_Perfect_Hash_OpTable tao_IR_ExceptionDef_optable;

IR::ExceptionDef_ptr _TAO_collocation_POA_IR_ExceptionDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ExceptionDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ExceptionDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ExceptionDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ExceptionDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ExceptionDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ExceptionDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ExceptionDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ExceptionDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ExceptionDef::ExceptionDef (void)
{
  this->optable_ = &tao_IR_ExceptionDef_optable;
}

// copy ctor
POA_IR::ExceptionDef::ExceptionDef (const ExceptionDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ExceptionDef::~ExceptionDef (void)
{
}

void POA_IR::ExceptionDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ExceptionDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  IR::StructMemberSeq_var _tao_retval;

  _tao_retval = _tao_impl->members (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ExceptionDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  IR::StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->members (
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ExceptionDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ExceptionDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ExceptionDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ExceptionDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ExceptionDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ExceptionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ExceptionDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ExceptionDef:1.0";
}

IR::ExceptionDef*
POA_IR::ExceptionDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ExceptionDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ExceptionDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ExceptionDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ExceptionDef::_tao_thru_poa_collocated_ExceptionDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ExceptionDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ExceptionDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_ExceptionDef::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}

IR::StructMemberSeq * POA_IR::_tao_thru_poa_collocated_ExceptionDef::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->members (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ExceptionDef::members  (
    const IR::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->members (
      members,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_AttributeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_AttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_AttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_AttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::AttributeDef::move_skel},
      {"_is_a",  &POA_IR::AttributeDef::_is_a_skel},
      {"_get_id",       &POA_IR::AttributeDef::_get_id_skel},
      {"_set_id",       &POA_IR::AttributeDef::_set_id_skel},
      {"describe",      &POA_IR::AttributeDef::describe_skel},
      {"_get_type",     &POA_IR::AttributeDef::_get_type_skel},
      {"_set_name",     &POA_IR::AttributeDef::_set_name_skel},
      {"_get_name",     &POA_IR::AttributeDef::_get_name_skel},
      {"_set_mode",     &POA_IR::AttributeDef::_set_mode_skel},
      {"_get_mode",     &POA_IR::AttributeDef::_get_mode_skel},
      {"_get_version",  &POA_IR::AttributeDef::_get_version_skel},
      {"_set_version",  &POA_IR::AttributeDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::AttributeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::AttributeDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::AttributeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::AttributeDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::AttributeDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::AttributeDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::AttributeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::AttributeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -5,   4,   5,  -1, -43,   8, -43, -14,  -2, -38,  16,
       -1,  17,  -1,  18,  19,  -1,  -1, -20,  -2, -38,  -1,  -1,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_AttributeDef_Perfect_Hash_OpTable tao_IR_AttributeDef_optable;

IR::AttributeDef_ptr _TAO_collocation_POA_IR_AttributeDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::AttributeDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_AttributeDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_AttributeDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_AttributeDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_AttributeDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_AttributeDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_AttributeDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_AttributeDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::AttributeDef::AttributeDef (void)
{
  this->optable_ = &tao_IR_AttributeDef_optable;
}

// copy ctor
POA_IR::AttributeDef::AttributeDef (const AttributeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::AttributeDef::~AttributeDef (void)
{
}

void POA_IR::AttributeDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::AttributeDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::AttributeDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR::IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->type_def (
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::AttributeDef::_get_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR::AttributeMode _tao_retval;

  _tao_retval = _tao_impl->mode (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::AttributeDef::_set_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR::AttributeMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );


  _tao_impl->mode (
      mode,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::AttributeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::AttributeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::AttributeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::AttributeDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/AttributeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::AttributeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::AttributeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AttributeDef:1.0";
}

IR::AttributeDef*
POA_IR::AttributeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::AttributeDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_AttributeDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::AttributeDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_AttributeDef::_tao_thru_poa_collocated_AttributeDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_AttributeDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_AttributeDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_AttributeDef::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_AttributeDef::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_AttributeDef::type_def  (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type_def (
      type_def,
      ACE_TRY_ENV
    );
  return;
}

IR::AttributeMode POA_IR::_tao_thru_poa_collocated_AttributeDef::mode  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::AttributeMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->mode (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_AttributeDef::mode  (
    IR::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->mode (
      mode,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_OperationDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_OperationDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_OperationDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_OperationDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::OperationDef::move_skel},
      {"_is_a",  &POA_IR::OperationDef::_is_a_skel},
      {"_get_mode",     &POA_IR::OperationDef::_get_mode_skel},
      {"_set_name",     &POA_IR::OperationDef::_set_name_skel},
      {"_get_name",     &POA_IR::OperationDef::_get_name_skel},
      {"_set_mode",     &POA_IR::OperationDef::_set_mode_skel},
      {"_get_params",   &POA_IR::OperationDef::_get_params_skel},
      {"_set_params",   &POA_IR::OperationDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::OperationDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::OperationDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::OperationDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::OperationDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::OperationDef::_get_version_skel},
      {"_set_version",  &POA_IR::OperationDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::OperationDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::OperationDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::OperationDef::_get_id_skel},
      {"_set_id",       &POA_IR::OperationDef::_set_id_skel},
      {"describe",      &POA_IR::OperationDef::describe_skel},
      {"_get_result_def",       &POA_IR::OperationDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::OperationDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::OperationDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::OperationDef::_get_result_skel},
      {"destroy",       &POA_IR::OperationDef::destroy_skel},
      {"_non_existent",  &POA_IR::OperationDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::OperationDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_OperationDef_Perfect_Hash_OpTable tao_IR_OperationDef_optable;

IR::OperationDef_ptr _TAO_collocation_POA_IR_OperationDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::OperationDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_OperationDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_OperationDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_OperationDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_OperationDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_OperationDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_OperationDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_OperationDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::OperationDef::OperationDef (void)
{
  this->optable_ = &tao_IR_OperationDef_optable;
}

// copy ctor
POA_IR::OperationDef::OperationDef (const OperationDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::OperationDef::~OperationDef (void)
{
}

void POA_IR::OperationDef::_get_result_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->result (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_get_result_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->result_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_result_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::IDLType_var result_def;
  if (!(
    (_tao_in >> result_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->result_def (
      result_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::OperationDef::_get_params_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::ParDescriptionSeq_var _tao_retval;

  _tao_retval = _tao_impl->params (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_params_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::ParDescriptionSeq params;
  if (!(
    (_tao_in >> params)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->params (
      params,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::OperationDef::_get_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::OperationMode _tao_retval;

  _tao_retval = _tao_impl->mode (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::OperationMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->mode (
      mode,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::OperationDef::_get_contexts_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::ContextIdSeq_var _tao_retval;

  _tao_retval = _tao_impl->contexts (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_contexts_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::ContextIdSeq contexts;
  if (!(
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->contexts (
      contexts,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::OperationDef::_get_exceptions_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::ExceptionDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->exceptions (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_exceptions_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR::ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->exceptions (
      exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::OperationDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::OperationDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::OperationDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::OperationDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::OperationDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/OperationDef:1.0";
}

IR::OperationDef*
POA_IR::OperationDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::OperationDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_OperationDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::OperationDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_OperationDef::_tao_thru_poa_collocated_OperationDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_OperationDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_OperationDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_OperationDef::result  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "result",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_OperationDef::result_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "result_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_OperationDef::result_def  (
    IR::IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "result_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result_def (
      result_def,
      ACE_TRY_ENV
    );
  return;
}

IR::ParDescriptionSeq * POA_IR::_tao_thru_poa_collocated_OperationDef::params  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ParDescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "params",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->params (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_OperationDef::params  (
    const IR::ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "params",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->params (
      params,
      ACE_TRY_ENV
    );
  return;
}

IR::OperationMode POA_IR::_tao_thru_poa_collocated_OperationDef::mode  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::OperationMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->mode (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_OperationDef::mode  (
    IR::OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->mode (
      mode,
      ACE_TRY_ENV
    );
  return;
}

IR::ContextIdSeq * POA_IR::_tao_thru_poa_collocated_OperationDef::contexts  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ContextIdSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "contexts",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->contexts (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_OperationDef::contexts  (
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "contexts",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->contexts (
      contexts,
      ACE_TRY_ENV
    );
  return;
}

IR::ExceptionDefSeq * POA_IR::_tao_thru_poa_collocated_OperationDef::exceptions  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ExceptionDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "exceptions",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->exceptions (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_OperationDef::exceptions  (
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "exceptions",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->exceptions (
      exceptions,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_InterfaceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_InterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_InterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66,  0,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66,  0,
     66, 20,  8,  0, 66, 66, 66, 10, 66, 66,
     66, 66, 66, 66, 66, 66, 66,  0,  0,  5,
     66,  0, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 10, 30, 66, 66, 66, 20, 25, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66,
#else
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66,  0, 66,  0, 66, 20,
      8,  0, 66, 66, 66, 10, 66, 66,  0,  0,
      5, 66,  0, 66, 66, 10, 30, 66, 66, 66,
     20, 25, 66, 66, 66, 66, 66, 66,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_InterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 40,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 65,
      HASH_VALUE_RANGE = 62,
      DUPLICATES = 11
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::InterfaceDef::move_skel},
      {"_is_a",  &POA_IR::InterfaceDef::_is_a_skel},
      {"lookup",        &POA_IR::InterfaceDef::lookup_skel},
      {"_get_name",     &POA_IR::InterfaceDef::_get_name_skel},
      {"_get_type",     &POA_IR::InterfaceDef::_get_type_skel},
      {"_set_name",     &POA_IR::InterfaceDef::_set_name_skel},
      {"lookup_name",   &POA_IR::InterfaceDef::lookup_name_skel},
      {"_get_is_local",         &POA_IR::InterfaceDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::InterfaceDef::_set_is_local_skel},
      {"is_a",  &POA_IR::InterfaceDef::is_a_skel},
      {"_get_id",       &POA_IR::InterfaceDef::_get_id_skel},
      {"_set_id",       &POA_IR::InterfaceDef::_set_id_skel},
      {"describe",      &POA_IR::InterfaceDef::describe_skel},
      {"_get_version",  &POA_IR::InterfaceDef::_get_version_skel},
      {"_set_version",  &POA_IR::InterfaceDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::InterfaceDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::InterfaceDef::_get_defined_in_skel},
      {"_get_def_kind",         &POA_IR::InterfaceDef::_get_def_kind_skel},
      {"_get_base_interfaces",  &POA_IR::InterfaceDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::InterfaceDef::_set_base_interfaces_skel},
      {"create_enum",   &POA_IR::InterfaceDef::create_enum_skel},
      {"create_value",  &POA_IR::InterfaceDef::create_value_skel},
      {"create_module",         &POA_IR::InterfaceDef::create_module_skel},
      {"create_native",         &POA_IR::InterfaceDef::create_native_skel},
      {"describe_contents",     &POA_IR::InterfaceDef::describe_contents_skel},
      {"create_attribute",      &POA_IR::InterfaceDef::create_attribute_skel},
      {"create_interface",      &POA_IR::InterfaceDef::create_interface_skel},
      {"create_union",  &POA_IR::InterfaceDef::create_union_skel},
      {"contents",      &POA_IR::InterfaceDef::contents_skel},
      {"destroy",       &POA_IR::InterfaceDef::destroy_skel},
      {"create_operation",      &POA_IR::InterfaceDef::create_operation_skel},
      {"create_exception",      &POA_IR::InterfaceDef::create_exception_skel},
      {"create_alias",  &POA_IR::InterfaceDef::create_alias_skel},
      {"_non_existent",  &POA_IR::InterfaceDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::InterfaceDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::InterfaceDef::_set_is_abstract_skel},
      {"_get_containing_repository",    &POA_IR::InterfaceDef::_get_containing_repository_skel},
      {"create_value_box",      &POA_IR::InterfaceDef::create_value_box_skel},
      {"create_struct",         &POA_IR::InterfaceDef::create_struct_skel},
      {"create_constant",       &POA_IR::InterfaceDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -11,   -2,  -14,   -2,    4,    5,    6,  -17,   -2,  103,   -1,   10,   -1,  -78,
        13,  -78,   16,  -75,   19,   -1,   20,   21,  -22,   -2,  -26,   -2,  -29,   -2,
       -34,   -2,  -73,   24,   25,  -74,   -1,   28,  -75,   31,   32,   -1,   33,  -78,
        36,   37,  -38,   -2,  -67,   -7,   -3,   -1,   -1,   40,   -1,   -1,   -1,   -1,
        41,   -1,   -1,   -1,   -1,   -1,   -1,   42,   -1,   43,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_InterfaceDef_Perfect_Hash_OpTable tao_IR_InterfaceDef_optable;

IR::InterfaceDef_ptr _TAO_collocation_POA_IR_InterfaceDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::InterfaceDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_InterfaceDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_InterfaceDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_InterfaceDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_InterfaceDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_InterfaceDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_InterfaceDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_InterfaceDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::InterfaceDef::InterfaceDef (void)
{
  this->optable_ = &tao_IR_InterfaceDef_optable;
}

// copy ctor
POA_IR::InterfaceDef::InterfaceDef (const InterfaceDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::InterfaceDef::~InterfaceDef (void)
{
}

void POA_IR::InterfaceDef::_get_base_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR::InterfaceDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->base_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::_set_base_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR::InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->base_interfaces (
      base_interfaces,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::InterfaceDef::_get_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_abstract (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::_set_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean is_abstract;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_abstract))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::InterfaceDef::_get_is_local_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_local (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::_set_is_local_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean is_local;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_local))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_local (
      is_local,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::InterfaceDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var interface_id;
  if (!(
    (_tao_in >> interface_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->is_a (
      interface_id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::create_attribute_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR::AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var type;
  IR::AttributeMode mode;
  IR::ExceptionDefSeq get_exceptions;
  IR::ExceptionDefSeq put_exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> get_exceptions) &&
    (_tao_in >> put_exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_attribute (
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::create_operation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR::OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var result;
  IR::OperationMode mode;
  IR::ParDescriptionSeq params;
  IR::ExceptionDefSeq exceptions;
  IR::ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_operation (
      id.in (),
      name.in (),
      version.in (),
      result.in (),
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::InterfaceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::InterfaceDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::InterfaceDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::InterfaceDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/InterfaceDef:1.0";
}

IR::InterfaceDef*
POA_IR::InterfaceDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::InterfaceDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_InterfaceDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::InterfaceDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_InterfaceDef::_tao_thru_poa_collocated_InterfaceDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_InterfaceDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_InterfaceDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::InterfaceDefSeq * POA_IR::_tao_thru_poa_collocated_InterfaceDef::base_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->base_interfaces (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_InterfaceDef::base_interfaces  (
    const IR::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->base_interfaces (
      base_interfaces,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_InterfaceDef::is_abstract  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_abstract (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_InterfaceDef::is_abstract  (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_InterfaceDef::is_local  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_local",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_local (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_InterfaceDef::is_local  (
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_local",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_local (
      is_local,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_InterfaceDef::is_a  (
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_a (
      interface_id,
      ACE_TRY_ENV
    );

}

IR::AttributeDef_ptr POA_IR::_tao_thru_poa_collocated_InterfaceDef::create_attribute  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    IR::AttributeMode mode,
    const IR::ExceptionDefSeq & get_exceptions,
    const IR::ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_attribute",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->create_attribute (
      id,
      name,
      version,
      type,
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

}

IR::OperationDef_ptr POA_IR::_tao_thru_poa_collocated_InterfaceDef::create_operation  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr result,
    IR::OperationMode mode,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_operation",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->create_operation (
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

}



class TAO_IR_ValueMemberDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueMemberDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueMemberDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37,  0, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueMemberDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueMemberDef::move_skel},
      {"_is_a",  &POA_IR::ValueMemberDef::_is_a_skel},
      {"_get_id",       &POA_IR::ValueMemberDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueMemberDef::_set_id_skel},
      {"describe",      &POA_IR::ValueMemberDef::describe_skel},
      {"_get_type",     &POA_IR::ValueMemberDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueMemberDef::_set_name_skel},
      {"_get_name",     &POA_IR::ValueMemberDef::_get_name_skel},
      {"_get_access",   &POA_IR::ValueMemberDef::_get_access_skel},
      {"_set_access",   &POA_IR::ValueMemberDef::_set_access_skel},
      {"_get_version",  &POA_IR::ValueMemberDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueMemberDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ValueMemberDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ValueMemberDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ValueMemberDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ValueMemberDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::ValueMemberDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::ValueMemberDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::ValueMemberDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ValueMemberDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46,  -1, -47, -46,  16,
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ValueMemberDef_Perfect_Hash_OpTable tao_IR_ValueMemberDef_optable;

IR::ValueMemberDef_ptr _TAO_collocation_POA_IR_ValueMemberDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ValueMemberDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ValueMemberDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ValueMemberDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ValueMemberDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ValueMemberDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ValueMemberDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ValueMemberDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ValueMemberDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ValueMemberDef::ValueMemberDef (void)
{
  this->optable_ = &tao_IR_ValueMemberDef_optable;
}

// copy ctor
POA_IR::ValueMemberDef::ValueMemberDef (const ValueMemberDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueMemberDef::~ValueMemberDef (void)
{
}

void POA_IR::ValueMemberDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueMemberDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueMemberDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  IR::IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->type_def (
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueMemberDef::_get_access_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::Visibility _tao_retval = 0;

  _tao_retval = _tao_impl->access (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueMemberDef::_set_access_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::Visibility access;
  if (!(
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->access (
      access,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueMemberDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueMemberDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueMemberDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueMemberDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueMemberDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueMemberDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueMemberDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueMemberDef:1.0";
}

IR::ValueMemberDef*
POA_IR::ValueMemberDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ValueMemberDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ValueMemberDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ValueMemberDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ValueMemberDef::_tao_thru_poa_collocated_ValueMemberDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueMemberDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueMemberDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_IR::_tao_thru_poa_collocated_ValueMemberDef::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}

IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_ValueMemberDef::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueMemberDef::type_def  (
    IR::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type_def (
      type_def,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Visibility POA_IR::_tao_thru_poa_collocated_ValueMemberDef::access  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Visibility _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "access",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->access (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueMemberDef::access  (
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "access",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->access (
      access,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_ValueDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 50, 35,  0, 86, 86, 86, 20, 86, 86,
     86, 86, 86, 86, 86, 86, 86,  0,  0, 15,
     86,  0, 86,  0, 86, 86, 86, 86, 86, 86,
     86, 86, 20, 20, 86, 86, 86,  5,  5, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86,
#else
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86,  0, 86,  0, 86, 50,
     35,  0, 86, 86, 86, 20, 86, 86,  0,  0,
     15, 86,  0, 86,  0, 20, 20, 86, 86, 86,
      5,  5, 86, 86, 86, 86, 86, 86,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 85,
      HASH_VALUE_RANGE = 82,
      DUPLICATES = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueDef::move_skel},
      {"_is_a",  &POA_IR::ValueDef::_is_a_skel},
      {"lookup",        &POA_IR::ValueDef::lookup_skel},
      {"_get_name",     &POA_IR::ValueDef::_get_name_skel},
      {"_get_type",     &POA_IR::ValueDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueDef::_set_name_skel},
      {"lookup_name",   &POA_IR::ValueDef::lookup_name_skel},
      {"_get_is_custom",        &POA_IR::ValueDef::_get_is_custom_skel},
      {"_set_is_custom",        &POA_IR::ValueDef::_set_is_custom_skel},
      {"_get_base_value",       &POA_IR::ValueDef::_get_base_value_skel},
      {"_set_base_value",       &POA_IR::ValueDef::_set_base_value_skel},
      {"_get_absolute_name",    &POA_IR::ValueDef::_get_absolute_name_skel},
      {"_get_is_truncatable",   &POA_IR::ValueDef::_get_is_truncatable_skel},
      {"_set_is_truncatable",   &POA_IR::ValueDef::_set_is_truncatable_skel},
      {"is_a",  &POA_IR::ValueDef::is_a_skel},
      {"_get_version",  &POA_IR::ValueDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueDef::_set_version_skel},
      {"_get_defined_in",       &POA_IR::ValueDef::_get_defined_in_skel},
      {"_get_containing_repository",    &POA_IR::ValueDef::_get_containing_repository_skel},
      {"_non_existent",  &POA_IR::ValueDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::ValueDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::ValueDef::_set_is_abstract_skel},
      {"_get_initializers",     &POA_IR::ValueDef::_get_initializers_skel},
      {"_set_initializers",     &POA_IR::ValueDef::_set_initializers_skel},
      {"_get_id",       &POA_IR::ValueDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueDef::_set_id_skel},
      {"describe",      &POA_IR::ValueDef::describe_skel},
      {"_get_supported_interfaces",     &POA_IR::ValueDef::_get_supported_interfaces_skel},
      {"_set_abstract_base_values",     &POA_IR::ValueDef::_set_abstract_base_values_skel},
      {"_get_abstract_base_values",     &POA_IR::ValueDef::_get_abstract_base_values_skel},
      {"_set_supported_interfaces",     &POA_IR::ValueDef::_set_supported_interfaces_skel},
      {"destroy",       &POA_IR::ValueDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ValueDef::_get_def_kind_skel},
      {"create_enum",   &POA_IR::ValueDef::create_enum_skel},
      {"create_value",  &POA_IR::ValueDef::create_value_skel},
      {"create_module",         &POA_IR::ValueDef::create_module_skel},
      {"create_native",         &POA_IR::ValueDef::create_native_skel},
      {"create_attribute",      &POA_IR::ValueDef::create_attribute_skel},
      {"create_interface",      &POA_IR::ValueDef::create_interface_skel},
      {"create_value_member",   &POA_IR::ValueDef::create_value_member_skel},
      {"create_value_box",      &POA_IR::ValueDef::create_value_box_skel},
      {"describe_contents",     &POA_IR::ValueDef::describe_contents_skel},
      {"create_union",  &POA_IR::ValueDef::create_union_skel},
      {"contents",      &POA_IR::ValueDef::contents_skel},
      {"create_operation",      &POA_IR::ValueDef::create_operation_skel},
      {"create_exception",      &POA_IR::ValueDef::create_exception_skel},
      {"create_alias",  &POA_IR::ValueDef::create_alias_skel},
      {"create_struct",         &POA_IR::ValueDef::create_struct_skel},
      {"create_constant",       &POA_IR::ValueDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -7,  -3,   4,   5,   6, -11,  -2, -92,  -1,  10, -13,  -2,
      -92, -88, -16,  -2,  15, -88,  -1,  -1,  -1,  -1,  18, -19,  -2, -87,
      -24,  -2,  21,  22,  -1,  23, -26,  -2, -93, -88, -28,  -2, -31,  -4,
      -89,  30,  -1, -90,  -1,  35,  36,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       -1,  -1,  -1, -39,  -2,  37,  38, -89, -41,  -2, -87,  -1,  -1,  43,
       -1,  44,  45,  -1,  -1,  -1,  -1,  46,  47, -48,  -2, -87,  50,  51,
       -1,  52,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ValueDef_Perfect_Hash_OpTable tao_IR_ValueDef_optable;

IR::ValueDef_ptr _TAO_collocation_POA_IR_ValueDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ValueDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ValueDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ValueDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ValueDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ValueDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ValueDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ValueDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ValueDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ValueDef::ValueDef (void)
{
  this->optable_ = &tao_IR_ValueDef_optable;
}

// copy ctor
POA_IR::ValueDef::ValueDef (const ValueDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueDef::~ValueDef (void)
{
}

void POA_IR::ValueDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::InterfaceDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->supported_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->supported_interfaces (
      supported_interfaces,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueDef::_get_initializers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::InitializerSeq_var _tao_retval;

  _tao_retval = _tao_impl->initializers (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_initializers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::InitializerSeq initializers;
  if (!(
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->initializers (
      initializers,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueDef::_get_base_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::ValueDef_var _tao_retval;

  _tao_retval = _tao_impl->base_value (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_base_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::ValueDef_var base_value;
  if (!(
    (_tao_in >> base_value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->base_value (
      base_value.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueDef::_get_abstract_base_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::ValueDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->abstract_base_values (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_abstract_base_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::ValueDefSeq abstract_base_values;
  if (!(
    (_tao_in >> abstract_base_values)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->abstract_base_values (
      abstract_base_values,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueDef::_get_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_abstract (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_abstract;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_abstract))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueDef::_get_is_custom_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_custom (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_is_custom_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_custom;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_custom))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_custom (
      is_custom,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueDef::_get_is_truncatable_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_truncatable (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_is_truncatable_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_truncatable;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_truncatable (
      is_truncatable,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->is_a (
      id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::create_value_member_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::ValueMemberDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var type;
  CORBA::Visibility access;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_value_member (
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      access,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::create_attribute_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var type;
  IR::AttributeMode mode;
  IR::ExceptionDefSeq get_exceptions;
  IR::ExceptionDefSeq put_exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> get_exceptions) &&
    (_tao_in >> put_exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_attribute (
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::create_operation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR::OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::IDLType_var result;
  IR::OperationMode mode;
  IR::ParDescriptionSeq params;
  IR::ExceptionDefSeq exceptions;
  IR::ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_operation (
      id.in (),
      name.in (),
      version.in (),
      result.in (),
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueDef:1.0";
}

IR::ValueDef*
POA_IR::ValueDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ValueDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ValueDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ValueDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ValueDef::_tao_thru_poa_collocated_ValueDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::InterfaceDefSeq * POA_IR::_tao_thru_poa_collocated_ValueDef::supported_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->supported_interfaces (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueDef::supported_interfaces  (
    const IR::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->supported_interfaces (
      supported_interfaces,
      ACE_TRY_ENV
    );
  return;
}

IR::InitializerSeq * POA_IR::_tao_thru_poa_collocated_ValueDef::initializers  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::InitializerSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "initializers",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->initializers (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueDef::initializers  (
    const IR::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "initializers",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->initializers (
      initializers,
      ACE_TRY_ENV
    );
  return;
}

IR::ValueDef_ptr POA_IR::_tao_thru_poa_collocated_ValueDef::base_value  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->base_value (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueDef::base_value  (
    IR::ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->base_value (
      base_value,
      ACE_TRY_ENV
    );
  return;
}

IR::ValueDefSeq * POA_IR::_tao_thru_poa_collocated_ValueDef::abstract_base_values  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ValueDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "abstract_base_values",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->abstract_base_values (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueDef::abstract_base_values  (
    const IR::ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "abstract_base_values",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->abstract_base_values (
      abstract_base_values,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueDef::is_abstract  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_abstract (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueDef::is_abstract  (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueDef::is_custom  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_custom",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_custom (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueDef::is_custom  (
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_custom",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_custom (
      is_custom,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueDef::is_truncatable  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_truncatable",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_truncatable (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueDef::is_truncatable  (
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_truncatable",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_truncatable (
      is_truncatable,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueDef::is_a  (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_a (
      id,
      ACE_TRY_ENV
    );

}

IR::ValueMemberDef_ptr POA_IR::_tao_thru_poa_collocated_ValueDef::create_value_member  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ValueMemberDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_value_member",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_value_member (
      id,
      name,
      version,
      type,
      access,
      ACE_TRY_ENV
    );

}

IR::AttributeDef_ptr POA_IR::_tao_thru_poa_collocated_ValueDef::create_attribute  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr type,
    IR::AttributeMode mode,
    const IR::ExceptionDefSeq & get_exceptions,
    const IR::ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_attribute",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_attribute (
      id,
      name,
      version,
      type,
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

}

IR::OperationDef_ptr POA_IR::_tao_thru_poa_collocated_ValueDef::create_operation  (
    const char * id,
    const char * name,
    const char * version,
    IR::IDLType_ptr result,
    IR::OperationMode mode,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    const IR::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_operation",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_operation (
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );
}

class TAO_IR_ValueBoxDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueBoxDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueBoxDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueBoxDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueBoxDef::move_skel},
      {"_is_a",  &POA_IR::ValueBoxDef::_is_a_skel},
      {"_get_id",       &POA_IR::ValueBoxDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueBoxDef::_set_id_skel},
      {"describe",      &POA_IR::ValueBoxDef::describe_skel},
      {"_get_name",     &POA_IR::ValueBoxDef::_get_name_skel},
      {"_get_type",     &POA_IR::ValueBoxDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueBoxDef::_set_name_skel},
      {"_get_version",  &POA_IR::ValueBoxDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueBoxDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ValueBoxDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ValueBoxDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ValueBoxDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ValueBoxDef::_get_absolute_name_skel},
      {"_get_original_type_def",        &POA_IR::ValueBoxDef::_get_original_type_def_skel},
      {"_set_original_type_def",        &POA_IR::ValueBoxDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_IR::ValueBoxDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ValueBoxDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ValueBoxDef_Perfect_Hash_OpTable tao_IR_ValueBoxDef_optable;

IR::ValueBoxDef_ptr _TAO_collocation_POA_IR_ValueBoxDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ValueBoxDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ValueBoxDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ValueBoxDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ValueBoxDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ValueBoxDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ValueBoxDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ValueBoxDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ValueBoxDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ValueBoxDef::ValueBoxDef (void)
{
  this->optable_ = &tao_IR_ValueBoxDef_optable;
}

// copy ctor
POA_IR::ValueBoxDef::ValueBoxDef (const ValueBoxDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueBoxDef::~ValueBoxDef (void)
{
}

void POA_IR::ValueBoxDef::_get_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *)_tao_object_reference;

  IR::IDLType_var _tao_retval;

  _tao_retval = _tao_impl->original_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueBoxDef::_set_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *)_tao_object_reference;

  IR::IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->original_type_def (
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ValueBoxDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueBoxDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueBoxDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueBoxDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueBoxDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueBoxDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueBoxDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueBoxDef:1.0";
}

IR::ValueBoxDef*
POA_IR::ValueBoxDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ValueBoxDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ValueBoxDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ValueBoxDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ValueBoxDef::_tao_thru_poa_collocated_ValueBoxDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueBoxDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
       forward_to.out (),
     ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueBoxDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ValueBoxDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueBoxDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::IDLType_ptr POA_IR::_tao_thru_poa_collocated_ValueBoxDef::original_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueBoxDef:1.0"
        )
    )->original_type_def (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ValueBoxDef::original_type_def  (
    IR::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueBoxDef:1.0"
        )
    )->original_type_def (
      original_type_def,
      ACE_TRY_ENV
    );
  return;
}



class TAO_IR_ProvidesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ProvidesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ProvidesDef::move_skel},
      {"_is_a",  &POA_IR::ProvidesDef::_is_a_skel},
      {"_get_id",       &POA_IR::ProvidesDef::_get_id_skel},
      {"_set_id",       &POA_IR::ProvidesDef::_set_id_skel},
      {"describe",      &POA_IR::ProvidesDef::describe_skel},
      {"_get_name",     &POA_IR::ProvidesDef::_get_name_skel},
      {"_set_name",     &POA_IR::ProvidesDef::_set_name_skel},
      {"_get_version",  &POA_IR::ProvidesDef::_get_version_skel},
      {"_set_version",  &POA_IR::ProvidesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ProvidesDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ProvidesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ProvidesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ProvidesDef::_get_absolute_name_skel},
      {"_get_interface_type",   &POA_IR::ProvidesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::ProvidesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ProvidesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  -1,  15,  16,  17,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ProvidesDef_Perfect_Hash_OpTable tao_IR_ProvidesDef_optable;

IR::ProvidesDef_ptr _TAO_collocation_POA_IR_ProvidesDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ProvidesDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ProvidesDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ProvidesDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ProvidesDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ProvidesDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ProvidesDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ProvidesDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ProvidesDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ProvidesDef::ProvidesDef (void)
{
  this->optable_ = &tao_IR_ProvidesDef_optable;
}

// copy ctor
POA_IR::ProvidesDef::ProvidesDef (const ProvidesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ProvidesDef::~ProvidesDef (void)
{
}

void POA_IR::ProvidesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *)_tao_object_reference;

  IR::InterfaceDef_var _tao_retval;

  _tao_retval = _tao_impl->interface_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ProvidesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ProvidesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ProvidesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ProvidesDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ProvidesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ProvidesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ProvidesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

IR::ProvidesDef*
POA_IR::ProvidesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ProvidesDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ProvidesDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ProvidesDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ProvidesDef::_tao_thru_poa_collocated_ProvidesDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ProvidesDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ProvidesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ProvidesDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ProvidesDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ProvidesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ProvidesDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::InterfaceDef_ptr POA_IR::_tao_thru_poa_collocated_ProvidesDef::interface_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "interface_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ProvidesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ProvidesDef:1.0"
        )
    )->interface_type (
      ACE_TRY_ENV
    );

}



class TAO_IR_UsesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_UsesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_UsesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_UsesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::UsesDef::move_skel},
      {"_is_a",  &POA_IR::UsesDef::_is_a_skel},
      {"_get_id",       &POA_IR::UsesDef::_get_id_skel},
      {"_set_id",       &POA_IR::UsesDef::_set_id_skel},
      {"describe",      &POA_IR::UsesDef::describe_skel},
      {"_get_name",     &POA_IR::UsesDef::_get_name_skel},
      {"_set_name",     &POA_IR::UsesDef::_set_name_skel},
      {"_get_version",  &POA_IR::UsesDef::_get_version_skel},
      {"_set_version",  &POA_IR::UsesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::UsesDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::UsesDef::_get_defined_in_skel},
      {"_get_is_multiple",      &POA_IR::UsesDef::_get_is_multiple_skel},
      {"destroy",       &POA_IR::UsesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::UsesDef::_get_absolute_name_skel},
      {"_get_interface_type",   &POA_IR::UsesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::UsesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::UsesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  15,  16,  17,  18,  -1,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_UsesDef_Perfect_Hash_OpTable tao_IR_UsesDef_optable;

IR::UsesDef_ptr _TAO_collocation_POA_IR_UsesDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::UsesDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_UsesDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_UsesDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_UsesDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_UsesDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_UsesDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_UsesDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_UsesDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::UsesDef::UsesDef (void)
{
  this->optable_ = &tao_IR_UsesDef_optable;
}

// copy ctor
POA_IR::UsesDef::UsesDef (const UsesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::UsesDef::~UsesDef (void)
{
}

void POA_IR::UsesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *)_tao_object_reference;

  IR::InterfaceDef_var _tao_retval;

  _tao_retval = _tao_impl->interface_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UsesDef::_get_is_multiple_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_multiple (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UsesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UsesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::UsesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::UsesDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/UsesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::UsesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::UsesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

IR::UsesDef*
POA_IR::UsesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::UsesDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_UsesDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::UsesDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_UsesDef::_tao_thru_poa_collocated_UsesDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_UsesDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_UsesDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::InterfaceDef_ptr POA_IR::_tao_thru_poa_collocated_UsesDef::interface_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "interface_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->interface_type (
      ACE_TRY_ENV
    );

}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_UsesDef::is_multiple  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_multiple",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->is_multiple (
      ACE_TRY_ENV
    );

}



class TAO_IR_EventDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EventDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EventDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EventDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EventDef::move_skel},
      {"_is_a",  &POA_IR::EventDef::_is_a_skel},
      {"_get_id",       &POA_IR::EventDef::_get_id_skel},
      {"_set_id",       &POA_IR::EventDef::_set_id_skel},
      {"describe",      &POA_IR::EventDef::describe_skel},
      {"_get_name",     &POA_IR::EventDef::_get_name_skel},
      {"_set_name",     &POA_IR::EventDef::_set_name_skel},
      {"_get_version",  &POA_IR::EventDef::_get_version_skel},
      {"_set_version",  &POA_IR::EventDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EventDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::EventDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::EventDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EventDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EventDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::EventDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EventDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EventDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_EventDef_Perfect_Hash_OpTable tao_IR_EventDef_optable;

IR::EventDef_ptr _TAO_collocation_POA_IR_EventDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::EventDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_EventDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_EventDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_EventDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_EventDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_EventDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_EventDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_EventDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::EventDef::EventDef (void)
{
  this->optable_ = &tao_IR_EventDef_optable;
}

// copy ctor
POA_IR::EventDef::EventDef (const EventDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EventDef::~EventDef (void)
{
}

void POA_IR::EventDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var event_id;
  if (!(
    (_tao_in >> event_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->is_a (
      event_id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::EventDef::_get_event_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *)_tao_object_reference;

  IR::ValueDef_var _tao_retval;

  _tao_retval = _tao_impl->event (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::EventDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EventDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EventDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EventDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EventDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

IR::EventDef*
POA_IR::EventDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::EventDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_EventDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::EventDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_EventDef::_tao_thru_poa_collocated_EventDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_EventDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_EventDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_EventDef::is_a  (
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->is_a (
      event_id,
      ACE_TRY_ENV
    );

}

IR::ValueDef_ptr POA_IR::_tao_thru_poa_collocated_EventDef::event  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "event",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->event (
      ACE_TRY_ENV
    );

}



class TAO_IR_EmitsDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EmitsDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EmitsDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EmitsDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EmitsDef::move_skel},
      {"_is_a",  &POA_IR::EmitsDef::_is_a_skel},
      {"_get_id",       &POA_IR::EmitsDef::_get_id_skel},
      {"_set_id",       &POA_IR::EmitsDef::_set_id_skel},
      {"describe",      &POA_IR::EmitsDef::describe_skel},
      {"_get_name",     &POA_IR::EmitsDef::_get_name_skel},
      {"_set_name",     &POA_IR::EmitsDef::_set_name_skel},
      {"_get_version",  &POA_IR::EmitsDef::_get_version_skel},
      {"_set_version",  &POA_IR::EmitsDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EmitsDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::EmitsDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::EmitsDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EmitsDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EmitsDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::EmitsDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EmitsDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EmitsDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_EmitsDef_Perfect_Hash_OpTable tao_IR_EmitsDef_optable;

IR::EmitsDef_ptr _TAO_collocation_POA_IR_EmitsDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::EmitsDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_EmitsDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_EmitsDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_EmitsDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_EmitsDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_EmitsDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_EmitsDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_EmitsDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::EmitsDef::EmitsDef (void)
{
  this->optable_ = &tao_IR_EmitsDef_optable;
}

// copy ctor
POA_IR::EmitsDef::EmitsDef (const EmitsDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EmitsDef::~EmitsDef (void)
{
}

void POA_IR::EmitsDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EmitsDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EmitsDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EmitsDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EmitsDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EmitsDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EmitsDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

IR::EmitsDef*
POA_IR::EmitsDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::EmitsDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_EmitsDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::EmitsDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_EmitsDef::_tao_thru_poa_collocated_EmitsDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_EventDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_EmitsDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::EmitsDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EmitsDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_EmitsDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::EmitsDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EmitsDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_IR_PublishesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PublishesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PublishesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PublishesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::PublishesDef::move_skel},
      {"_is_a",  &POA_IR::PublishesDef::_is_a_skel},
      {"_get_id",       &POA_IR::PublishesDef::_get_id_skel},
      {"_set_id",       &POA_IR::PublishesDef::_set_id_skel},
      {"describe",      &POA_IR::PublishesDef::describe_skel},
      {"_get_name",     &POA_IR::PublishesDef::_get_name_skel},
      {"_set_name",     &POA_IR::PublishesDef::_set_name_skel},
      {"_get_version",  &POA_IR::PublishesDef::_get_version_skel},
      {"_set_version",  &POA_IR::PublishesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::PublishesDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::PublishesDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::PublishesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::PublishesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::PublishesDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::PublishesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::PublishesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::PublishesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_PublishesDef_Perfect_Hash_OpTable tao_IR_PublishesDef_optable;

IR::PublishesDef_ptr _TAO_collocation_POA_IR_PublishesDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::PublishesDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_PublishesDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_PublishesDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_PublishesDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_PublishesDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_PublishesDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_PublishesDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_PublishesDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::PublishesDef::PublishesDef (void)
{
  this->optable_ = &tao_IR_PublishesDef_optable;
}

// copy ctor
POA_IR::PublishesDef::PublishesDef (const PublishesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PublishesDef::~PublishesDef (void)
{
}

void POA_IR::PublishesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PublishesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PublishesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PublishesDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PublishesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PublishesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PublishesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

IR::PublishesDef*
POA_IR::PublishesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::PublishesDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_PublishesDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::PublishesDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_PublishesDef::_tao_thru_poa_collocated_PublishesDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_EventDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_PublishesDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::PublishesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PublishesDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_PublishesDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::PublishesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PublishesDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_IR_ConsumesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ConsumesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ConsumesDef::move_skel},
      {"_is_a",  &POA_IR::ConsumesDef::_is_a_skel},
      {"_get_id",       &POA_IR::ConsumesDef::_get_id_skel},
      {"_set_id",       &POA_IR::ConsumesDef::_set_id_skel},
      {"describe",      &POA_IR::ConsumesDef::describe_skel},
      {"_get_name",     &POA_IR::ConsumesDef::_get_name_skel},
      {"_set_name",     &POA_IR::ConsumesDef::_set_name_skel},
      {"_get_version",  &POA_IR::ConsumesDef::_get_version_skel},
      {"_set_version",  &POA_IR::ConsumesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ConsumesDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::ConsumesDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::ConsumesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ConsumesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ConsumesDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::ConsumesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::ConsumesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ConsumesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ConsumesDef_Perfect_Hash_OpTable tao_IR_ConsumesDef_optable;

IR::ConsumesDef_ptr _TAO_collocation_POA_IR_ConsumesDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ConsumesDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ConsumesDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ConsumesDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ConsumesDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ConsumesDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ConsumesDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ConsumesDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ConsumesDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ConsumesDef::ConsumesDef (void)
{
  this->optable_ = &tao_IR_ConsumesDef_optable;
}

// copy ctor
POA_IR::ConsumesDef::ConsumesDef (const ConsumesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ConsumesDef::~ConsumesDef (void)
{
}

void POA_IR::ConsumesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConsumesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ConsumesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ConsumesDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ConsumesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ConsumesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ConsumesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

IR::ConsumesDef*
POA_IR::ConsumesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ConsumesDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ConsumesDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ConsumesDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ConsumesDef::_tao_thru_poa_collocated_ConsumesDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_EventDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ConsumesDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ConsumesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConsumesDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ConsumesDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ConsumesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConsumesDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_IR_ComponentDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82,  0,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82,  0,
     82, 30,  5, 10, 82, 82, 82,  0, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 45, 30, 15,
     82, 30, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82,  0, 20, 82, 82, 82, 30, 25, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82,
#else
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82,  0, 82,  0, 82, 30,
      5, 10, 82, 82, 82,  0, 82, 82, 45, 30,
     15, 82, 30, 82, 82,  0, 20, 82, 82, 82,
     30, 25, 82, 82, 82, 82, 82, 82,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 54,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 81,
      HASH_VALUE_RANGE = 78,
      DUPLICATES = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a",  &POA_IR::ComponentDef::is_a_skel},
      {"_is_a",  &POA_IR::ComponentDef::_is_a_skel},
      {"_get_id",       &POA_IR::ComponentDef::_get_id_skel},
      {"_set_id",       &POA_IR::ComponentDef::_set_id_skel},
      {"_get_emits_events",     &POA_IR::ComponentDef::_get_emits_events_skel},
      {"_get_def_kind",         &POA_IR::ComponentDef::_get_def_kind_skel},
      {"_get_name",     &POA_IR::ComponentDef::_get_name_skel},
      {"_get_type",     &POA_IR::ComponentDef::_get_type_skel},
      {"_set_name",     &POA_IR::ComponentDef::_set_name_skel},
      {"_get_uses_interfaces",  &POA_IR::ComponentDef::_get_uses_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::ComponentDef::_set_base_interfaces_skel},
      {"_get_base_interfaces",  &POA_IR::ComponentDef::_get_base_interfaces_skel},
      {"_get_consumes_events",  &POA_IR::ComponentDef::_get_consumes_events_skel},
      {"_get_publishes_events",         &POA_IR::ComponentDef::_get_publishes_events_skel},
      {"describe_contents",     &POA_IR::ComponentDef::describe_contents_skel},
      {"describe",      &POA_IR::ComponentDef::describe_skel},
      {"_get_provides_interfaces",      &POA_IR::ComponentDef::_get_provides_interfaces_skel},
      {"_get_supported_interfaces",     &POA_IR::ComponentDef::_get_supported_interfaces_skel},
      {"_set_supported_interfaces",     &POA_IR::ComponentDef::_set_supported_interfaces_skel},
      {"_get_version",  &POA_IR::ComponentDef::_get_version_skel},
      {"_set_version",  &POA_IR::ComponentDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ComponentDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::ComponentDef::_get_defined_in_skel},
      {"_non_existent",  &POA_IR::ComponentDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::ComponentDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::ComponentDef::_set_is_abstract_skel},
      {"destroy",       &POA_IR::ComponentDef::destroy_skel},
      {"contents",      &POA_IR::ComponentDef::contents_skel},
      {"_get_base_component",   &POA_IR::ComponentDef::_get_base_component_skel},
      {"create_uses",   &POA_IR::ComponentDef::create_uses_skel},
      {"create_emits",  &POA_IR::ComponentDef::create_emits_skel},
      {"create_alias",  &POA_IR::ComponentDef::create_alias_skel},
      {"_get_is_basic",         &POA_IR::ComponentDef::_get_is_basic_skel},
      {"move",  &POA_IR::ComponentDef::move_skel},
      {"create_provides",       &POA_IR::ComponentDef::create_provides_skel},
      {"create_consumes",       &POA_IR::ComponentDef::create_consumes_skel},
      {"create_publishes",      &POA_IR::ComponentDef::create_publishes_skel},
      {"_get_containing_repository",    &POA_IR::ComponentDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::ComponentDef::create_value_skel},
      {"create_module",         &POA_IR::ComponentDef::create_module_skel},
      {"create_native",         &POA_IR::ComponentDef::create_native_skel},
      {"create_attribute",      &POA_IR::ComponentDef::create_attribute_skel},
      {"create_interface",      &POA_IR::ComponentDef::create_interface_skel},
      {"create_union",  &POA_IR::ComponentDef::create_union_skel},
      {"_get_is_local",         &POA_IR::ComponentDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::ComponentDef::_set_is_local_skel},
      {"create_operation",      &POA_IR::ComponentDef::create_operation_skel},
      {"create_exception",      &POA_IR::ComponentDef::create_exception_skel},
      {"create_struct",         &POA_IR::ComponentDef::create_struct_skel},
      {"create_constant",       &POA_IR::ComponentDef::create_constant_skel},
      {"lookup_name",   &POA_IR::ComponentDef::lookup_name_skel},
      {"create_enum",   &POA_IR::ComponentDef::create_enum_skel},
      {"create_value_box",      &POA_IR::ComponentDef::create_value_box_skel},
      {"lookup",        &POA_IR::ComponentDef::lookup_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -6,   -2,    4,    5,  -10,   -3,  -13,   -4,  -21,   -2,  -91,  -23,
        -2,  -28,   -2,    8,    9,  -94,  -93,   17,   18,   19,   20,  -96,   -1,  -95,
        25,   -1,   26,  -34,   -2,   27,  -38,   -2, -102,   30,   31,   32,   -1,   33,
       -92,   36,   37,  -92,   40,  -43,   -2,  -45,   -2,   41,   42,  -87,  -48,   -2,
       -88,   47,  -85,  -50,   -2,  -83,   -1,   52,   -1,   53,   54,   -1,   -1,   -1,
        -1,   55,   -1,   -1,   -1,   -1,   56,   -1,   -1,   -1,   -1,   57,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ComponentDef_Perfect_Hash_OpTable tao_IR_ComponentDef_optable;

IR::ComponentDef_ptr _TAO_collocation_POA_IR_ComponentDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::ComponentDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_ComponentDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_ComponentDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_ComponentDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_ComponentDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_ComponentDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_ComponentDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_ComponentDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::ComponentDef::ComponentDef (void)
{
  this->optable_ = &tao_IR_ComponentDef_optable;
}

// copy ctor
POA_IR::ComponentDef::ComponentDef (const ComponentDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentDef::~ComponentDef (void)
{
}

void POA_IR::ComponentDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::InterfaceDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->supported_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->supported_interfaces (
      supported_interfaces,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
}

void POA_IR::ComponentDef::_get_base_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::ComponentDef_var _tao_retval;

  _tao_retval = _tao_impl->base_component (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_provides_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::ProvidesDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->provides_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_uses_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::UsesDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->uses_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_emits_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::EmitsDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->emits_events (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_publishes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::PublishesDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->publishes_events (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_consumes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::ConsumesDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->consumes_events (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_basic (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_provides_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::ProvidesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::InterfaceDef_var interface_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_provides (
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_uses_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::UsesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::InterfaceDef_var interface_type;
  CORBA::Boolean is_multiple;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_multiple))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_uses (
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      is_multiple,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_emits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::EmitsDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_emits (
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_publishes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::PublishesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_publishes (
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

 _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_consumes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR::ConsumesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_consumes (
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ComponentDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

IR::ComponentDef*
POA_IR::ComponentDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::ComponentDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_ComponentDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::ComponentDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_ComponentDef::_tao_thru_poa_collocated_ComponentDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_InterfaceDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ComponentDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ComponentDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::InterfaceDefSeq * POA_IR::_tao_thru_poa_collocated_ComponentDef::supported_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
      ACE_TRY_ENV
    );

}

void POA_IR::_tao_thru_poa_collocated_ComponentDef::supported_interfaces  (
    const IR::InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
      supported_interfaces,
      ACE_TRY_ENV
    );
  return;
}

IR::ComponentDef_ptr POA_IR::_tao_thru_poa_collocated_ComponentDef::base_component  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->base_component (
      ACE_TRY_ENV
    );

}

IR::ProvidesDefSeq * POA_IR::_tao_thru_poa_collocated_ComponentDef::provides_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ProvidesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "provides_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->provides_interfaces (
      ACE_TRY_ENV
    );

}

IR::UsesDefSeq * POA_IR::_tao_thru_poa_collocated_ComponentDef::uses_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::UsesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "uses_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->uses_interfaces (
      ACE_TRY_ENV
    );

}

IR::EmitsDefSeq * POA_IR::_tao_thru_poa_collocated_ComponentDef::emits_events  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::EmitsDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "emits_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->emits_events (
      ACE_TRY_ENV
    );

}

IR::PublishesDefSeq * POA_IR::_tao_thru_poa_collocated_ComponentDef::publishes_events  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::PublishesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "publishes_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->publishes_events (
      ACE_TRY_ENV
    );

}

IR::ConsumesDefSeq * POA_IR::_tao_thru_poa_collocated_ComponentDef::consumes_events  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ConsumesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "consumes_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->consumes_events (
      ACE_TRY_ENV
    );

}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_ComponentDef::is_basic  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_basic",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->is_basic (
      ACE_TRY_ENV
    );

}

IR::ProvidesDef_ptr POA_IR::_tao_thru_poa_collocated_ComponentDef::create_provides  (
    const char * id,
    const char * name,
    const char * version,
    IR::InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ProvidesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_provides",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_provides (
      id,
      name,
      version,
      interface_type,
      ACE_TRY_ENV
    );

}

IR::UsesDef_ptr POA_IR::_tao_thru_poa_collocated_ComponentDef::create_uses  (
    const char * id,
    const char * name,
    const char * version,
    IR::InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::UsesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_uses",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_uses (
      id,
      name,
      version,
      interface_type,
      is_multiple,
      ACE_TRY_ENV
    );

}

IR::EmitsDef_ptr POA_IR::_tao_thru_poa_collocated_ComponentDef::create_emits  (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::EmitsDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_emits",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_emits (
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );

}

IR::PublishesDef_ptr POA_IR::_tao_thru_poa_collocated_ComponentDef::create_publishes  (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::PublishesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_publishes",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_publishes (
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );

}

IR::ConsumesDef_ptr POA_IR::_tao_thru_poa_collocated_ComponentDef::create_consumes  (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ConsumesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_consumes",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_consumes (
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );

}



class TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32,  0,  0, 32, 32, 32, 10, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,  0,  5,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 10, 32, 32, 32, 32,  5, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,
#else
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32,  0, 32,  0, 32, 32,
      0,  0, 32, 32, 32, 10, 32, 32, 32,  0,
      5, 32, 32, 32, 32, 32, 10, 32, 32, 32,
     32,  5, 32, 32, 32, 32, 32, 32,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 31,
      HASH_VALUE_RANGE = 28,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::PrimaryKeyDef::move_skel},
      {"_is_a",  &POA_IR::PrimaryKeyDef::_is_a_skel},
      {"_get_id",       &POA_IR::PrimaryKeyDef::_get_id_skel},
      {"_set_id",       &POA_IR::PrimaryKeyDef::_set_id_skel},
      {"describe",      &POA_IR::PrimaryKeyDef::describe_skel},
      {"_get_name",     &POA_IR::PrimaryKeyDef::_get_name_skel},
      {"_set_name",     &POA_IR::PrimaryKeyDef::_set_name_skel},
      {"destroy",       &POA_IR::PrimaryKeyDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::PrimaryKeyDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::PrimaryKeyDef::is_a_skel},
      {"_get_version",  &POA_IR::PrimaryKeyDef::_get_version_skel},
      {"_set_version",  &POA_IR::PrimaryKeyDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::PrimaryKeyDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::PrimaryKeyDef::_get_defined_in_skel},
      {"_get_primary_key",      &POA_IR::PrimaryKeyDef::_get_primary_key_skel},
      {"_non_existent",  &POA_IR::PrimaryKeyDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::PrimaryKeyDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -38,   8, -38,  -1,  -1,  11,  12,
       13, -14,  -2, -33,  16,  -1,  17,  18,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable tao_IR_PrimaryKeyDef_optable;

IR::PrimaryKeyDef_ptr _TAO_collocation_POA_IR_PrimaryKeyDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::PrimaryKeyDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_PrimaryKeyDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_PrimaryKeyDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_PrimaryKeyDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_PrimaryKeyDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_PrimaryKeyDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_PrimaryKeyDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_PrimaryKeyDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (void)
{
  this->optable_ = &tao_IR_PrimaryKeyDef_optable;
}

// copy ctor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (const PrimaryKeyDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PrimaryKeyDef::~PrimaryKeyDef (void)
{
}

void POA_IR::PrimaryKeyDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var primary_key_id;
  if (!(
    (_tao_in >> primary_key_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->is_a (
      primary_key_id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::PrimaryKeyDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *)_tao_object_reference;

  IR::ValueDef_var _tao_retval;

  _tao_retval = _tao_impl->primary_key (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::PrimaryKeyDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimaryKeyDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PrimaryKeyDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PrimaryKeyDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PrimaryKeyDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PrimaryKeyDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PrimaryKeyDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

IR::PrimaryKeyDef*
POA_IR::PrimaryKeyDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::PrimaryKeyDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_PrimaryKeyDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::PrimaryKeyDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_PrimaryKeyDef::_tao_thru_poa_collocated_PrimaryKeyDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_PrimaryKeyDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_PrimaryKeyDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_PrimaryKeyDef::is_a  (
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->is_a (
      primary_key_id,
      ACE_TRY_ENV
    );

}

IR::ValueDef_ptr POA_IR::_tao_thru_poa_collocated_PrimaryKeyDef::primary_key  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->primary_key (
      ACE_TRY_ENV
    );

}



class TAO_IR_FactoryDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FactoryDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FactoryDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FactoryDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::FactoryDef::move_skel},
      {"_is_a",  &POA_IR::FactoryDef::_is_a_skel},
      {"_get_mode",     &POA_IR::FactoryDef::_get_mode_skel},
      {"_set_name",     &POA_IR::FactoryDef::_set_name_skel},
      {"_get_name",     &POA_IR::FactoryDef::_get_name_skel},
      {"_set_mode",     &POA_IR::FactoryDef::_set_mode_skel},
      {"_get_params",   &POA_IR::FactoryDef::_get_params_skel},
      {"_set_params",   &POA_IR::FactoryDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::FactoryDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::FactoryDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::FactoryDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::FactoryDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::FactoryDef::_get_version_skel},
      {"_set_version",  &POA_IR::FactoryDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::FactoryDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::FactoryDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::FactoryDef::_get_id_skel},
      {"_set_id",       &POA_IR::FactoryDef::_set_id_skel},
      {"describe",      &POA_IR::FactoryDef::describe_skel},
      {"_get_result_def",       &POA_IR::FactoryDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::FactoryDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::FactoryDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::FactoryDef::_get_result_skel},
      {"destroy",       &POA_IR::FactoryDef::destroy_skel},
      {"_non_existent",  &POA_IR::FactoryDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::FactoryDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_FactoryDef_Perfect_Hash_OpTable tao_IR_FactoryDef_optable;

IR::FactoryDef_ptr _TAO_collocation_POA_IR_FactoryDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::FactoryDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_FactoryDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_FactoryDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_FactoryDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_FactoryDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_FactoryDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_FactoryDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_FactoryDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::FactoryDef::FactoryDef (void)
{
  this->optable_ = &tao_IR_FactoryDef_optable;
}

// copy ctor
POA_IR::FactoryDef::FactoryDef (const FactoryDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,OperationDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FactoryDef::~FactoryDef (void)
{
}

void POA_IR::FactoryDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FactoryDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FactoryDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FactoryDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FactoryDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FactoryDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FactoryDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

IR::FactoryDef*
POA_IR::FactoryDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::FactoryDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_FactoryDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::FactoryDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_FactoryDef::_tao_thru_poa_collocated_FactoryDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_OperationDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_FactoryDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::FactoryDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FactoryDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_FactoryDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::FactoryDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FactoryDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_IR_FinderDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FinderDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FinderDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FinderDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::FinderDef::move_skel},
      {"_is_a",  &POA_IR::FinderDef::_is_a_skel},
      {"_get_mode",     &POA_IR::FinderDef::_get_mode_skel},
      {"_set_name",     &POA_IR::FinderDef::_set_name_skel},
      {"_get_name",     &POA_IR::FinderDef::_get_name_skel},
      {"_set_mode",     &POA_IR::FinderDef::_set_mode_skel},
      {"_get_params",   &POA_IR::FinderDef::_get_params_skel},
      {"_set_params",   &POA_IR::FinderDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::FinderDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::FinderDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::FinderDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::FinderDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::FinderDef::_get_version_skel},
      {"_set_version",  &POA_IR::FinderDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::FinderDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::FinderDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::FinderDef::_get_id_skel},
      {"_set_id",       &POA_IR::FinderDef::_set_id_skel},
      {"describe",      &POA_IR::FinderDef::describe_skel},
      {"_get_result_def",       &POA_IR::FinderDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::FinderDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::FinderDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::FinderDef::_get_result_skel},
      {"destroy",       &POA_IR::FinderDef::destroy_skel},
      {"_non_existent",  &POA_IR::FinderDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::FinderDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_FinderDef_Perfect_Hash_OpTable tao_IR_FinderDef_optable;

IR::FinderDef_ptr _TAO_collocation_POA_IR_FinderDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::FinderDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_FinderDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_FinderDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_FinderDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_FinderDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_FinderDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_FinderDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_FinderDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::FinderDef::FinderDef (void)
{
  this->optable_ = &tao_IR_FinderDef_optable;
}

// copy ctor
POA_IR::FinderDef::FinderDef (const FinderDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,OperationDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FinderDef::~FinderDef (void)
{
}

void POA_IR::FinderDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FinderDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FinderDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FinderDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FinderDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FinderDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FinderDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

IR::FinderDef*
POA_IR::FinderDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::FinderDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_FinderDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::FinderDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_FinderDef::_tao_thru_poa_collocated_FinderDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_OperationDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_FinderDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::FinderDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FinderDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_FinderDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::FinderDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FinderDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_IR_HomeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_HomeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_HomeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89,  0,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89,  0,
     89, 15,  0, 45, 89, 89, 89,  0, 89, 89,
     89, 89, 89, 89, 89, 89, 89,  5,  0, 10,
     89,  0, 89,  5, 89, 89, 89, 89, 89, 89,
     89, 89, 15, 30, 89, 89, 89,  0, 55, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89,
#else
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89,  0, 89,  0, 89, 15,
      0, 45, 89, 89, 89,  0, 89, 89,  5,  0,
     10, 89,  0, 89,  5, 15, 30, 89, 89, 89,
      0, 55, 89, 89, 89, 89, 89, 89,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_HomeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 88,
      HASH_VALUE_RANGE = 85,
      DUPLICATES = 11
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a",  &POA_IR::HomeDef::is_a_skel},
      {"_is_a",  &POA_IR::HomeDef::_is_a_skel},
      {"_get_id",       &POA_IR::HomeDef::_get_id_skel},
      {"_set_id",       &POA_IR::HomeDef::_set_id_skel},
      {"lookup",        &POA_IR::HomeDef::lookup_skel},
      {"_get_def_kind",         &POA_IR::HomeDef::_get_def_kind_skel},
      {"_get_is_local",         &POA_IR::HomeDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::HomeDef::_set_is_local_skel},
      {"_get_version",  &POA_IR::HomeDef::_get_version_skel},
      {"_set_version",  &POA_IR::HomeDef::_set_version_skel},
      {"_get_defined_in",       &POA_IR::HomeDef::_get_defined_in_skel},
      {"create_enum",   &POA_IR::HomeDef::create_enum_skel},
      {"_get_finders",  &POA_IR::HomeDef::_get_finders_skel},
      {"_get_is_basic",         &POA_IR::HomeDef::_get_is_basic_skel},
      {"_get_factories",        &POA_IR::HomeDef::_get_factories_skel},
      {"create_value_box",      &POA_IR::HomeDef::create_value_box_skel},
      {"describe_contents",     &POA_IR::HomeDef::describe_contents_skel},
      {"create_finder",         &POA_IR::HomeDef::create_finder_skel},
      {"_get_base_interfaces",  &POA_IR::HomeDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::HomeDef::_set_base_interfaces_skel},
      {"create_union",  &POA_IR::HomeDef::create_union_skel},
      {"contents",      &POA_IR::HomeDef::contents_skel},
      {"create_operation",      &POA_IR::HomeDef::create_operation_skel},
      {"create_exception",      &POA_IR::HomeDef::create_exception_skel},
      {"create_alias",  &POA_IR::HomeDef::create_alias_skel},
      {"_non_existent",  &POA_IR::HomeDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::HomeDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::HomeDef::_set_is_abstract_skel},
      {"move",  &POA_IR::HomeDef::move_skel},
      {"_get_managed_component",        &POA_IR::HomeDef::_get_managed_component_skel},
      {"describe",      &POA_IR::HomeDef::describe_skel},
      {"_get_name",     &POA_IR::HomeDef::_get_name_skel},
      {"_get_type",     &POA_IR::HomeDef::_get_type_skel},
      {"_set_name",     &POA_IR::HomeDef::_set_name_skel},
      {"create_struct",         &POA_IR::HomeDef::create_struct_skel},
      {"_get_base_home",        &POA_IR::HomeDef::_get_base_home_skel},
      {"create_constant",       &POA_IR::HomeDef::create_constant_skel},
      {"lookup_name",   &POA_IR::HomeDef::lookup_name_skel},
      {"destroy",       &POA_IR::HomeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::HomeDef::_get_absolute_name_skel},
      {"_get_primary_key",      &POA_IR::HomeDef::_get_primary_key_skel},
      {"create_value",  &POA_IR::HomeDef::create_value_skel},
      {"create_module",         &POA_IR::HomeDef::create_module_skel},
      {"create_native",         &POA_IR::HomeDef::create_native_skel},
      {"create_attribute",      &POA_IR::HomeDef::create_attribute_skel},
      {"create_interface",      &POA_IR::HomeDef::create_interface_skel},
      {"_get_containing_repository",    &POA_IR::HomeDef::_get_containing_repository_skel},
      {"create_factory",        &POA_IR::HomeDef::create_factory_skel},
      {"create_primary_key",    &POA_IR::HomeDef::create_primary_key_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -6,   -2,    4,    5,   -1,  -93,   -1,   -1,   -1,    8,   -1,    9,
        -1,   -1,  -10,   -2,  -90,   -1,  -12,   -2,  -90,  -22,   -2,   14,   15,   16,
        17,   18,   -1,   19,   20,   21,   -1, -100,   -1,   24,   25,  -26,   -2,  -90,
        28,   29,  -30,   -2,  -90,   -1,   -1,   32,  -35,   -3,   33,   34,  -92,   -1,
        -1,   -1,   38,   39,   40,   41,   42,   43,   -1,   -1,   -1,   -1,   -1,  -46,
        -2,   44,   45,  -92,  -48,   -2,  -90,   -1,   -1,   -1,   -1,   50,   -1,   -1,
        51,   -1,   -1,   -1,   52,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_HomeDef_Perfect_Hash_OpTable tao_IR_HomeDef_optable;

IR::HomeDef_ptr _TAO_collocation_POA_IR_HomeDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();

  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      IR::HomeDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_IR::_tao_thru_poa_collocated_HomeDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_IR_HomeDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);

  _TAO_collocation_IR_HomeDef_Stub_Factory_function_pointer =
    _TAO_collocation_POA_IR_HomeDef_Stub_Factory;

  return 0;
}

static int _TAO_collocation_POA_IR_HomeDef_Stub_Factory_Initializer_Scarecrow =
  _TAO_collocation_POA_IR_HomeDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_IR_HomeDef_Stub_Factory_Initializer));

// skeleton constructor
POA_IR::HomeDef::HomeDef (void)
{
  this->optable_ = &tao_IR_HomeDef_optable;
}

// copy ctor
POA_IR::HomeDef::HomeDef (const HomeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::HomeDef::~HomeDef (void)
{
}

void POA_IR::HomeDef::_get_base_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR::HomeDef_var _tao_retval;

  _tao_retval = _tao_impl->base_home (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_managed_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR::ComponentDef_var _tao_retval;

  _tao_retval = _tao_impl->managed_component (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR::PrimaryKeyDef_var _tao_retval;

  _tao_retval = _tao_impl->primary_key (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_factories_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR::FactoryDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->factories (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_finders_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR::FinderDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->finders (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_basic (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::create_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR::PrimaryKeyDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_primary_key (
      id.in (),
      name.in (),
      version.in (),
      primary_key.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::create_factory_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR::FactoryDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ParDescriptionSeq params;
  IR::ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_factory (
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::create_finder_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR::FinderDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR::ParDescriptionSeq params;
  IR::ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_finder (
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::HomeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::HomeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::HomeDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/HomeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::HomeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_IR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR::HomeDef*
POA_IR::HomeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::IR::HomeDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_IR::_tao_thru_poa_collocated_HomeDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::IR::HomeDef::_unchecked_narrow (obj.in ());
    }
}

POA_IR::_tao_thru_poa_collocated_HomeDef::_tao_thru_poa_collocated_HomeDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_InterfaceDef) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_IR,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 1)
{
}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_HomeDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_IR::_tao_thru_poa_collocated_HomeDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


IR::HomeDef_ptr POA_IR::_tao_thru_poa_collocated_HomeDef::base_home  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_home",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->base_home (
      ACE_TRY_ENV
    );

}

IR::ComponentDef_ptr POA_IR::_tao_thru_poa_collocated_HomeDef::managed_component  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "managed_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->managed_component (
      ACE_TRY_ENV
    );

}

IR::PrimaryKeyDef_ptr POA_IR::_tao_thru_poa_collocated_HomeDef::primary_key  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->primary_key (
      ACE_TRY_ENV
    );

}

IR::FactoryDefSeq * POA_IR::_tao_thru_poa_collocated_HomeDef::factories  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::FactoryDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "factories",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->factories (
      ACE_TRY_ENV
    );

}

IR::FinderDefSeq * POA_IR::_tao_thru_poa_collocated_HomeDef::finders  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::FinderDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "finders",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->finders (
      ACE_TRY_ENV
    );

}

CORBA::Boolean POA_IR::_tao_thru_poa_collocated_HomeDef::is_basic  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_basic",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->is_basic (
      ACE_TRY_ENV
    );

}

IR::PrimaryKeyDef_ptr POA_IR::_tao_thru_poa_collocated_HomeDef::create_primary_key  (
    const char * id,
    const char * name,
    const char * version,
    IR::ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_primary_key (
      id,
      name,
      version,
      primary_key,
      ACE_TRY_ENV
    );

}

IR::FactoryDef_ptr POA_IR::_tao_thru_poa_collocated_HomeDef::create_factory  (
    const char * id,
    const char * name,
    const char * version,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::FactoryDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_factory",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_factory (
      id,
      name,
      version,
      params,
      exceptions,
      ACE_TRY_ENV
    );

}

IR::FinderDef_ptr POA_IR::_tao_thru_poa_collocated_HomeDef::create_finder  (
    const char * id,
    const char * name,
    const char * version,
    const IR::ParDescriptionSeq & params,
    const IR::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR::FinderDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      this->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_finder",
      forward_to.out (),
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_finder (
      id,
      name,
      version,
      params,
      exceptions,
      ACE_TRY_ENV
    );

}
