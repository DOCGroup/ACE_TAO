// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef TAO_IDL_INTERFACES_CPP
#define TAO_IDL_INTERFACES_CPP

#include "InterfaceS.h"
#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"

ACE_RCSID(IFR_Service, InterfaceS, "$Id$")

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "InterfaceS.i"
#endif /* !defined INLINE */

class TAO_CORBA_IRObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:52 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IRObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IRObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15,  0, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15,  1, 15, 15, 15, 15,  0, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,
#else
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15,  0, 15,  0, 15, 15,
      0, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,  1, 15, 15, 15,
     15,  0, 15, 15, 15, 15, 15, 15,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IRObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 4,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 14,
      HASH_VALUE_RANGE = 10,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_IRObject::_is_a_skel},
      {"",0},
      {"destroy",       &POA_CORBA_IRObject::destroy_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_CORBA_IRObject::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA_IRObject::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:05:52 */
static TAO_CORBA_IRObject_Perfect_Hash_OpTable tao_CORBA_IRObject_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_IRObject_Strategized_Proxy_Broker *
_TAO_IRObject_Strategized_Proxy_Broker::the_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  static _TAO_IRObject_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_IRObject_Strategized_Proxy_Broker::_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

_TAO_IRObject_Strategized_Proxy_Broker::~_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_IRObject_Proxy_Impl&
_TAO_IRObject_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::IRObject *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
_TAO_IRObject_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_IRObject_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_IRObject_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_IRObject_Proxy_Broker *
_TAO_IRObject_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return _TAO_IRObject_Strategized_Proxy_Broker::the_TAO_IRObject_Strategized_Proxy_Broker();
}

int
_TAO_IRObject_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_IRObject_Proxy_Broker_Factory_function_pointer =
    _TAO_IRObject_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_IRObject_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_IRObject_Proxy_Broker_Factory_Initializer (
      ACE_reinterpret_cast (
          long,
          _TAO_IRObject_Proxy_Broker_Factory_Initializer
        )
    );


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_IRObject_ThruPOA_Proxy_Impl::_TAO_IRObject_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_DefinitionKind
_TAO_IRObject_ThruPOA_Proxy_Impl::def_kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_DefinitionKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "def_kind",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->def_kind (
        ACE_TRY_ENV
      );
}

void
_TAO_IRObject_ThruPOA_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "destroy",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->destroy (
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_IRObject::POA_CORBA_IRObject (void)
{
  this->optable_ = &tao_CORBA_IRObject_optable;
}

// copy ctor
POA_CORBA_IRObject::POA_CORBA_IRObject (const POA_CORBA_IRObject& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_IRObject::~POA_CORBA_IRObject (void)
{
}

void POA_CORBA_IRObject::_get_def_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *)_tao_object_reference;

  IR_DefinitionKind _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->def_kind (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_DefinitionKind _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_IRObject::destroy_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *)_tao_object_reference;

  _tao_server_request.argument_flag (0);

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_destroy ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->destroy (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_CORBA_IRObject::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IRObject::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA_IRObject::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA_IRObject::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_IRObject::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA_IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

CORBA::IRObject*
POA_CORBA_IRObject::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return ::CORBA::IRObject::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_IRObject *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_def_kind_get::result (IR::DefinitionKind result)
{
  // Update the result.
   this->_result = result;
}

POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_destroy::TAO_ServerRequestInfo_CORBA_IRObject_destroy (
    TAO_ServerRequest &_tao_server_request,
    POA_CORBA_IRObject *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_destroy::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_destroy::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_destroy::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_destroy::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_CORBA_IRObject::TAO_ServerRequestInfo_CORBA_IRObject_destroy::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_Contained_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Contained_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Contained_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Contained_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::Contained::move_skel},
      {"_is_a",  &POA_IR::Contained::_is_a_skel},
      {"_get_id",       &POA_IR::Contained::_get_id_skel},
      {"_set_id",       &POA_IR::Contained::_set_id_skel},
      {"describe",      &POA_IR::Contained::describe_skel},
      {"_get_name",     &POA_IR::Contained::_get_name_skel},
      {"_set_name",     &POA_IR::Contained::_set_name_skel},
      {"_get_version",  &POA_IR::Contained::_get_version_skel},
      {"_set_version",  &POA_IR::Contained::_set_version_skel},
      {"_get_def_kind",         &POA_IR::Contained::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::Contained::_get_defined_in_skel},
      {"destroy",       &POA_IR::Contained::destroy_skel},
      {"_get_absolute_name",    &POA_IR::Contained::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::Contained::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::Contained::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  -1,  15,  16,  -1,  -1,  -1,  -1,  17,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  18,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Contained_Perfect_Hash_OpTable tao_IR_Contained_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_Contained_Strategized_Proxy_Broker *the_TAO_Contained_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_Contained_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_Contained_Strategized_Proxy_Broker::_TAO_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_Contained_Strategized_Proxy_Broker::~_TAO_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_Contained_Proxy_Impl&
POA_IR::_TAO_Contained_Strategized_Proxy_Broker::select_proxy (
    ::IR_Contained *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_Contained_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Contained_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_Contained_Proxy_Broker *
_TAO_Contained_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return the_TAO_Contained_Strategized_Proxy_Broker();
}

int
_TAO_Contained_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_Contained_Proxy_Broker_Factory_function_pointer =
    _TAO_Contained_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_Contained_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_Contained_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_Contained_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::_TAO_Contained_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

char * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->id (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->id (
        id,
        ACE_TRY_ENV
      );
  return;
}

char * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->name (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->name (
        name,
        ACE_TRY_ENV
      );
  return;
}

char * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->version (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->version (
        version,
        ACE_TRY_ENV
      );
  return;
}

IR_Container_ptr POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::defined_in (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Container_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "defined_in",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->defined_in (
        ACE_TRY_ENV
      );
}

char * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::absolute_name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "absolute_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->absolute_name (
        ACE_TRY_ENV
      );
}

IR_Repository_ptr POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::containing_repository (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Repository_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "containing_repository",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->containing_repository (
        ACE_TRY_ENV
      );
}

IR_Contained::Description * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::describe (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Contained::Description_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->describe (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::move (
    CORBA_Object *_collocated_tao_target_,
    IR_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "move",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->move (
        new_container,
        new_name,
        new_version,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::Contained::Contained (void)
{
  this->optable_ = &tao_IR_Contained_optable;
}

// copy ctor
POA_IR::Contained::Contained (const Contained& rhs)
  : POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Contained::~Contained (void)
{
}

void POA_IR::Contained::_get_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->id (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_set_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  _tao_server_request.argument_flag (0);
    CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_set ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->id (
          id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_get_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->name (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_set_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  _tao_server_request.argument_flag (0);
    CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_set ri (
      _tao_server_request,
      _tao_impl,
      name.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->name (
          name.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_get_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->version (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_set_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  _tao_server_request.argument_flag (0);
    CORBA::String_var version;
  if (!(
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_set ri (
      _tao_server_request,
      _tao_impl,
      version.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->version (
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_get_defined_in_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR_Container_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_defined_in_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->defined_in (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_Container_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_get_absolute_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_absolute_name_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->absolute_name (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      char * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_get_containing_repository_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR_Repository_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_containing_repository_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->containing_repository (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_Repository_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::describe_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR_Contained::Description_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_describe ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->describe (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_Contained::Description * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::move_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  _tao_server_request.argument_flag (0);
    IR_Container_var new_container;
  CORBA::String_var new_name;
  CORBA::String_var new_version;
  if (!(
    (_tao_in >> new_container.out ()) &&
    (_tao_in >> new_name.out ()) &&
    (_tao_in >> new_version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL());


#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_move ri (
      _tao_server_request,
      _tao_impl,
      new_container.in (),
      new_name.in (),
      new_version.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->move (
          new_container.in (),
          new_name.in (),
          new_version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Contained::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Contained::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Contained::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Contained::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Contained::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Contained:1.0";
}

IR_Contained*
POA_IR::Contained::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_Contained::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_get::TAO_ServerRequestInfo_IR_Contained_id_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_set::TAO_ServerRequestInfo_IR_Contained_id_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    const char * id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_id_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_get::TAO_ServerRequestInfo_IR_Contained_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_set::TAO_ServerRequestInfo_IR_Contained_name_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    const char * name,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    name_ (name)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_name_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_get::TAO_ServerRequestInfo_IR_Contained_version_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_set::TAO_ServerRequestInfo_IR_Contained_version_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    version_ (version)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_version_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_defined_in_get::TAO_ServerRequestInfo_IR_Contained_defined_in_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_defined_in_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_defined_in_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_defined_in_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_defined_in_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_defined_in_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_defined_in_get::result (IR::Container_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_absolute_name_get::TAO_ServerRequestInfo_IR_Contained_absolute_name_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_absolute_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_absolute_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_absolute_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_absolute_name_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_absolute_name_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_absolute_name_get::result (char * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_containing_repository_get::TAO_ServerRequestInfo_IR_Contained_containing_repository_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_containing_repository_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_containing_repository_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_containing_repository_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_containing_repository_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_containing_repository_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_containing_repository_get::result (IR::Repository_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_describe::TAO_ServerRequestInfo_IR_Contained_describe (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_describe::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_describe::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_describe::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_describe::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_describe::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_describe::result (IR::Contained::Description * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_move::TAO_ServerRequestInfo_IR_Contained_move (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Contained *tao_impl,
    IR_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    new_container_ (new_container),
    new_name_ (new_name),
    new_version_ (new_version)
{}

Dynamic::ParameterList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_move::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_new_container = parameter_list->length ();
  parameter_list->length (length_new_container + 1);
  (*parameter_list)[length_new_container].argument <<=  this->new_container_;

  (*parameter_list)[length_new_container].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_new_name = parameter_list->length ();
  parameter_list->length (length_new_name + 1);
  (*parameter_list)[length_new_name].argument <<= new_name_;
  (*parameter_list)[length_new_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_new_version = parameter_list->length ();
  parameter_list->length (length_new_version + 1);
  (*parameter_list)[length_new_version].argument <<= new_version_;
  (*parameter_list)[length_new_version].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_move::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_move::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_move::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Contained::TAO_ServerRequestInfo_IR_Contained_move::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_Container_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 15,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39,  0,
     39,  0,  0,  0, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39,  0, 20,  5,
     39,  0, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 10, 10, 39, 39, 39, 10,  0, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39,
#else
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 15, 39,  0, 39,  0,
      0,  0, 39, 39, 39, 39, 39, 39,  0, 20,
      5, 39,  0, 39, 39, 10, 10, 39, 39, 39,
     10,  0, 39, 39, 39, 39, 39, 39,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 19,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 17,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 38,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup",        &POA_IR::Container::lookup_skel},
      {"destroy",       &POA_IR::Container::destroy_skel},
      {"lookup_name",   &POA_IR::Container::lookup_name_skel},
      {"create_value",  &POA_IR::Container::create_value_skel},
      {"create_module",         &POA_IR::Container::create_module_skel},
      {"create_native",         &POA_IR::Container::create_native_skel},
      {"create_interface",      &POA_IR::Container::create_interface_skel},
      {"create_union",  &POA_IR::Container::create_union_skel},
      {"contents",      &POA_IR::Container::contents_skel},
      {"_is_a",  &POA_IR::Container::_is_a_skel},
      {"create_exception",      &POA_IR::Container::create_exception_skel},
      {"create_alias",  &POA_IR::Container::create_alias_skel},
      {"create_struct",         &POA_IR::Container::create_struct_skel},
      {"create_constant",       &POA_IR::Container::create_constant_skel},
      {"create_value_box",      &POA_IR::Container::create_value_box_skel},
      {"describe_contents",     &POA_IR::Container::describe_contents_skel},
      {"_get_def_kind",         &POA_IR::Container::_get_def_kind_skel},
      {"create_enum",   &POA_IR::Container::create_enum_skel},
      {"_non_existent",  &POA_IR::Container::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,   7,  -1, -10,  -2,   8,   9, -42,
       -1,  -1,  12,  13,  14,  -1,  15,  16,  17,  18,  -1,  19,  20,  21,
       22,  -1,  -1,  23,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Container_Perfect_Hash_OpTable tao_IR_Container_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_Container_Strategized_Proxy_Broker *POA_IR::_TAO_Container_Strategized_Proxy_Broker::the_TAO_Container_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_Container_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_Container_Strategized_Proxy_Broker::_TAO_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_Container_Strategized_Proxy_Broker::~_TAO_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_Container_Proxy_Impl&
POA_IR::_TAO_Container_Strategized_Proxy_Broker::select_proxy (
    IR_Container *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_Container_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Container_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Container_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_Container_Proxy_Broker *
_TAO_Container_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_Container_Strategized_Proxy_Broker::the_TAO_Container_Strategized_Proxy_Broker();
}

int
_TAO_Container_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_Container_Proxy_Broker_Factory_function_pointer =
    _TAO_Container_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_Container_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_Container_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_Container_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::_TAO_Container_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::Contained_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->lookup (
        search_name,
        ACE_TRY_ENV
      );
}

IR_ContainedSeq * POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::contents (
    CORBA_Object *_collocated_tao_target_,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->contents (
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
}

IR_ContainedSeq * POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::lookup_name (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Long levels_to_search,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->lookup_name (
        search_name,
        levels_to_search,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
}

IR_Container::DescriptionSeq * POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::describe_contents (
    CORBA_Object *_collocated_tao_target_,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Container::DescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe_contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->describe_contents (
        limit_type,
        exclude_inherited,
        max_returned_objs,
        ACE_TRY_ENV
      );
}

IR_ModuleDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_module (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ModuleDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_module",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_module (
        id,
        name,
        version,
        ACE_TRY_ENV
      );
}

IR_ConstantDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_constant (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ConstantDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_constant",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_constant (
        id,
        name,
        version,
        type,
        value,
        ACE_TRY_ENV
      );
}

IR_StructDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_struct (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_StructDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_struct",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_struct (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

IR_UnionDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_union (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr discriminator_type,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_UnionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_union",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_union (
        id,
        name,
        version,
        discriminator_type,
        members,
        ACE_TRY_ENV
      );
}

IR_EnumDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_enum (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_EnumDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_enum",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_enum (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

IR_AliasDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_alias (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_AliasDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_alias",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_alias (
        id,
        name,
        version,
        original_type,
        ACE_TRY_ENV
      );
}

IR_InterfaceDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Boolean is_abstract,
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_interface (
        id,
        name,
        version,
        base_interfaces,
        is_abstract,
        is_local,
        ACE_TRY_ENV
      );
}

IR_ValueDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_value (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    IR_ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const IR_ValueDefSeq & abstract_base_values,
    const IR_InterfaceDefSeq & supported_interfaces,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_value (
        id,
        name,
        version,
        is_custom,
        is_abstract,
        base_value,
        is_truncatable,
        abstract_base_values,
        supported_interfaces,
        initializers,
        ACE_TRY_ENV
      );
}

IR_ValueBoxDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_value_box (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueBoxDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value_box",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_value_box (
        id,
        name,
        version,
        original_type_def,
        ACE_TRY_ENV
      );
}

IR_ExceptionDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_exception (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ExceptionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_exception",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_exception (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

IR_NativeDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_native (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_NativeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_native",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_native (
        id,
        name,
        version,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::Container::Container (void)
{
  this->optable_ = &tao_IR_Container_optable;
}

// copy ctor
POA_IR::Container::Container (const Container& rhs)
  : POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Container::~Container (void)
{
}

void POA_IR::Container::lookup_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_Contained_var _tao_retval;
  CORBA::String_var search_name;
  if (!(
    (_tao_in >> search_name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup ri (
      _tao_server_request,
      _tao_impl,
      search_name.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->lookup (
          search_name.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_Contained_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ContainedSeq_var _tao_retval;
  IR_DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_contents ri (
      _tao_server_request,
      _tao_impl,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->contents (
          limit_type,
          exclude_inherited,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ContainedSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::lookup_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ContainedSeq_var _tao_retval;
  CORBA::String_var search_name;
  CORBA::Long levels_to_search;
  IR_DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> search_name.out ()) &&
    (_tao_in >> levels_to_search) &&
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup_name ri (
      _tao_server_request,
      _tao_impl,
      search_name.in (),
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->lookup_name (
          search_name.in (),
          levels_to_search,
          limit_type,
          exclude_inherited,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ContainedSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::describe_contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_Container::DescriptionSeq_var _tao_retval;
  IR_DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  CORBA::Long max_returned_objs;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited)) &&
    (_tao_in >> max_returned_objs)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_describe_contents ri (
      _tao_server_request,
      _tao_impl,
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->describe_contents (
          limit_type,
          exclude_inherited,
          max_returned_objs,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_Container::DescriptionSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_module_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ModuleDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_module ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_module (
          id.in (),
          name.in (),
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ModuleDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_constant_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ConstantDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var type;
  CORBA::Any value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_constant ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      value,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_constant (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          value,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ConstantDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_struct_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_StructDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_struct ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_struct (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_StructDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_union_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_UnionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var discriminator_type;
  IR_UnionMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> discriminator_type.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_union ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      discriminator_type.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_union (
          id.in (),
          name.in (),
          version.in (),
          discriminator_type.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_UnionDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_enum_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_EnumDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_EnumMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_enum ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_enum (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_EnumDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_alias_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_AliasDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var original_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_alias ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      original_type.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_alias (
          id.in (),
          name.in (),
          version.in (),
          original_type.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_AliasDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_InterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_InterfaceDefSeq base_interfaces;
  CORBA::Boolean is_abstract;
  CORBA::Boolean is_local;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_local))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_interface ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      is_abstract,
      is_local,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_interface (
          id.in (),
          name.in (),
          version.in (),
          base_interfaces,
          is_abstract,
          is_local,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ValueDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::Boolean is_custom;
  CORBA::Boolean is_abstract;
  IR_ValueDef_var base_value;
  CORBA::Boolean is_truncatable;
  IR_ValueDefSeq abstract_base_values;
  IR_InterfaceDefSeq supported_interfaces;
  IR_InitializerSeq initializers;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_custom)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> base_value.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable)) &&
    (_tao_in >> abstract_base_values) &&
    (_tao_in >> supported_interfaces) &&
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      is_custom,
      is_abstract,
      base_value.in (),
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_value (
          id.in (),
          name.in (),
          version.in (),
          is_custom,
          is_abstract,
          base_value.in (),
          is_truncatable,
          abstract_base_values,
          supported_interfaces,
          initializers,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_value_box_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ValueBoxDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var original_type_def;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value_box ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_value_box (
          id.in (),
          name.in (),
          version.in (),
          original_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ValueBoxDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_exception_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ExceptionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_exception ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_exception (
          id.in (),
          name.in (),
          version.in (),
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ExceptionDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::create_native_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_NativeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_native ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_native (
          id.in (),
          name.in (),
          version.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_NativeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Container::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Container::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Container *_tao_impl = (POA_IR::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Container::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Container::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Container::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Container:1.0";
}

IR::Container*
POA_IR::Container::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_Container::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup::TAO_ServerRequestInfo_IR_Container_lookup (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * search_name,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    search_name_ (search_name)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup::result (IR::Contained_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_contents::TAO_ServerRequestInfo_IR_Container_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    IR_DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;

  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_contents::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_contents::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_contents::result (IR::ContainedSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup_name::TAO_ServerRequestInfo_IR_Container_lookup_name (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    IR_DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    search_name_ (search_name),
    levels_to_search_ (levels_to_search),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup_name::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_levels_to_search = parameter_list->length ();
  parameter_list->length (length_levels_to_search + 1);
  (*parameter_list)[length_levels_to_search].argument <<= levels_to_search_;
  (*parameter_list)[length_levels_to_search].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;

  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup_name::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup_name::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup_name::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup_name::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_lookup_name::result (IR::ContainedSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_describe_contents::TAO_ServerRequestInfo_IR_Container_describe_contents (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    IR_DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited),
    max_returned_objs_ (max_returned_objs)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_describe_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;

  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_max_returned_objs = parameter_list->length ();
  parameter_list->length (length_max_returned_objs + 1);
  (*parameter_list)[length_max_returned_objs].argument <<= max_returned_objs_;
  (*parameter_list)[length_max_returned_objs].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_describe_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_describe_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_describe_contents::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_describe_contents::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_describe_contents::result (IR::Container::DescriptionSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_module::TAO_ServerRequestInfo_IR_Container_create_module (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_module::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_module::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_module::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_module::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_module::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_module::result (IR::ModuleDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_constant::TAO_ServerRequestInfo_IR_Container_create_constant (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    value_ (value)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_constant::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;

  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<= value_;
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_constant::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_constant::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_constant::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_constant::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_constant::result (IR::ConstantDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_struct::TAO_ServerRequestInfo_IR_Container_create_struct (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_struct::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;

  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_struct::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_struct::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_struct::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_struct::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_struct::result (IR::StructDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_union::TAO_ServerRequestInfo_IR_Container_create_union (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr discriminator_type,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    discriminator_type_ (discriminator_type),
    members_ (members)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_union::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_discriminator_type = parameter_list->length ();
  parameter_list->length (length_discriminator_type + 1);
  (*parameter_list)[length_discriminator_type].argument <<=  this->discriminator_type_;

  (*parameter_list)[length_discriminator_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;

  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_union::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_union::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_union::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_union::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_union::result (IR::UnionDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_enum::TAO_ServerRequestInfo_IR_Container_create_enum (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_enum::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;

  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_enum::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_enum::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_enum::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_enum::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_enum::result (IR::EnumDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_alias::TAO_ServerRequestInfo_IR_Container_create_alias (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_ (original_type)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_alias::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_original_type = parameter_list->length ();
  parameter_list->length (length_original_type + 1);
  (*parameter_list)[length_original_type].argument <<=  this->original_type_;

  (*parameter_list)[length_original_type].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_alias::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_alias::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_alias::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_alias::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_alias::result (IR::AliasDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_interface::TAO_ServerRequestInfo_IR_Container_create_interface (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const IR_InterfaceDefSeq & base_interfaces,
    const CORBA::Boolean & is_abstract,
    const CORBA::Boolean & is_local,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces),
    is_abstract_ (is_abstract),
    is_local_ (is_local)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;

  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_is_local = parameter_list->length ();
  parameter_list->length (length_is_local + 1);
  (*parameter_list)[length_is_local].argument <<= CORBA::Any::from_boolean (this->is_local_);
  (*parameter_list)[length_is_local].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_interface::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_interface::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_interface::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_interface::result (IR::InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value::TAO_ServerRequestInfo_IR_Container_create_value (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    IR_ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const IR_ValueDefSeq & abstract_base_values,
    const IR_InterfaceDefSeq & supported_interfaces,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    is_custom_ (is_custom),
    is_abstract_ (is_abstract),
    base_value_ (base_value),
    is_truncatable_ (is_truncatable),
    abstract_base_values_ (abstract_base_values),
    supported_interfaces_ (supported_interfaces),
    initializers_ (initializers)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_is_custom = parameter_list->length ();
  parameter_list->length (length_is_custom + 1);
  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_base_value = parameter_list->length ();
  parameter_list->length (length_base_value + 1);
  (*parameter_list)[length_base_value].argument <<=  this->base_value_;

  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_is_truncatable = parameter_list->length ();
  parameter_list->length (length_is_truncatable + 1);
  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_abstract_base_values = parameter_list->length ();
  parameter_list->length (length_abstract_base_values + 1);
  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;

  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;

  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_initializers = parameter_list->length ();
  parameter_list->length (length_initializers + 1);
  (*parameter_list)[length_initializers].argument <<=  this->initializers_;

  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value::result (IR::ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value_box::TAO_ServerRequestInfo_IR_Container_create_value_box (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value_box::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;

  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value_box::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value_box::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value_box::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value_box::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_value_box::result (IR::ValueBoxDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_exception::TAO_ServerRequestInfo_IR_Container_create_exception (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_exception::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;

  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_exception::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_exception::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_exception::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_exception::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_exception::result (IR::ExceptionDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_native::TAO_ServerRequestInfo_IR_Container_create_native (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Container *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_native::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_native::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_native::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_native::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_native::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Container::TAO_ServerRequestInfo_IR_Container_create_native::result (IR::NativeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_IDLType_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_IDLType_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_IDLType_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_IDLType_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::IDLType::_is_a_skel},
      {"",0},
      {"destroy",       &POA_IR::IDLType::destroy_skel},
      {"",0},
      {"_get_type",     &POA_IR::IDLType::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_IR::IDLType::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_IR::IDLType::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_IDLType_Perfect_Hash_OpTable tao_IR_IDLType_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_IDLType_Strategized_Proxy_Broker *POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::the_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_IDLType_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::~_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_IDLType_Proxy_Impl&
POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::select_proxy (
    IR_IDLType *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_IDLType_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_IDLType_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_IDLType_Proxy_Broker *
_TAO_IDLType_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::the_TAO_IDLType_Strategized_Proxy_Broker();
}

int
_TAO_IDLType_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_IDLType_Proxy_Broker_Factory_function_pointer =
    _TAO_IDLType_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_IDLType_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_IDLType_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_IDLType_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_IDLType_ThruPOA_Proxy_Impl::_TAO_IDLType_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_IDLType_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/IDLType:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::IDLType::IDLType (void)
{
  this->optable_ = &tao_IR_IDLType_optable;
}

// copy ctor
POA_IR::IDLType::IDLType (const IDLType& rhs)
  : POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::IDLType::~IDLType (void)
{
}

void POA_IR::IDLType::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::IDLType::TAO_ServerRequestInfo_IR_IDLType_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::IDLType::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::IDLType::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::IDLType::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::IDLType::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::IDLType::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/IDLType:1.0";
}

IR::IDLType*
POA_IR::IDLType::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_IDLType::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::IDLType::TAO_ServerRequestInfo_IR_IDLType_type_get::TAO_ServerRequestInfo_IR_IDLType_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::IDLType *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::IDLType::TAO_ServerRequestInfo_IR_IDLType_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::IDLType::TAO_ServerRequestInfo_IR_IDLType_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::IDLType::TAO_ServerRequestInfo_IR_IDLType_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::IDLType::TAO_ServerRequestInfo_IR_IDLType_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::IDLType::TAO_ServerRequestInfo_IR_IDLType_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::IDLType::TAO_ServerRequestInfo_IR_IDLType_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_Repository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 20,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 15,
     71,  0, 23, 10, 71,  5, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71,  0,  0, 15,
     71,  0, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 30,  0, 71, 71, 71,  0,  0, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71,
#else
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 20, 71, 15, 71,  0,
     23, 10, 71,  5, 71, 71, 71, 71,  0,  0,
     15, 71,  0, 71, 71, 30,  0, 71, 71, 71,
      0,  0, 71, 71, 71, 71, 71, 71,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 70,
      HASH_VALUE_RANGE = 65,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup",        &POA_IR::Repository::lookup_skel},
      {"create_enum",   &POA_IR::Repository::create_enum_skel},
      {"create_array",  &POA_IR::Repository::create_array_skel},
      {"create_struct",         &POA_IR::Repository::create_struct_skel},
      {"create_constant",       &POA_IR::Repository::create_constant_skel},
      {"create_value_box",      &POA_IR::Repository::create_value_box_skel},
      {"create_string",         &POA_IR::Repository::create_string_skel},
      {"create_wstring",        &POA_IR::Repository::create_wstring_skel},
      {"lookup_name",   &POA_IR::Repository::lookup_name_skel},
      {"create_value",  &POA_IR::Repository::create_value_skel},
      {"create_module",         &POA_IR::Repository::create_module_skel},
      {"create_native",         &POA_IR::Repository::create_native_skel},
      {"create_sequence",       &POA_IR::Repository::create_sequence_skel},
      {"create_interface",      &POA_IR::Repository::create_interface_skel},
      {"create_union",  &POA_IR::Repository::create_union_skel},
      {"get_primitive",         &POA_IR::Repository::get_primitive_skel},
      {"destroy",       &POA_IR::Repository::destroy_skel},
      {"create_exception",      &POA_IR::Repository::create_exception_skel},
      {"lookup_id",     &POA_IR::Repository::lookup_id_skel},
      {"_non_existent",  &POA_IR::Repository::_non_existent_skel},
      {"create_fixed",  &POA_IR::Repository::create_fixed_skel},
      {"get_canonical_typecode",        &POA_IR::Repository::get_canonical_typecode_skel},
      {"contents",      &POA_IR::Repository::contents_skel},
      {"_is_a",  &POA_IR::Repository::_is_a_skel},
      {"create_alias",  &POA_IR::Repository::create_alias_skel},
      {"_get_def_kind",         &POA_IR::Repository::_get_def_kind_skel},
      {"describe_contents",     &POA_IR::Repository::describe_contents_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,  -1,  -1, -16,  -2,   7,   8,   9,
       -1,  10,  11,  -1,  12,  13,  -1,  14,  15, -84,  -1,  18,  19,  20,
       21,  -1,  22,  23,  24,  25,  -1,  26,  -1,  27,  28,  -1,  29,  -1,
       30,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       31,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       32,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Repository_Perfect_Hash_OpTable tao_IR_Repository_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_Repository_Strategized_Proxy_Broker *POA_IR::_TAO_Repository_Strategized_Proxy_Broker::the_TAO_Repository_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_Repository_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_Repository_Strategized_Proxy_Broker::_TAO_Repository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_Repository_Strategized_Proxy_Broker::~_TAO_Repository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_Repository_Proxy_Impl&
POA_IR::_TAO_Repository_Strategized_Proxy_Broker::select_proxy (
    IR_Repository *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_Repository_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Repository_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Repository_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_Repository_Proxy_Broker *
_TAO_Repository_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_Repository_Strategized_Proxy_Broker::the_TAO_Repository_Strategized_Proxy_Broker();
}

int
_TAO_Repository_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_Repository_Proxy_Broker_Factory_function_pointer =
    _TAO_Repository_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_Repository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_Repository_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_Repository_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::_TAO_Repository_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::Contained_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::lookup_id (
    CORBA_Object *_collocated_tao_target_,
    const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup_id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->lookup_id (
        search_id,
        ACE_TRY_ENV
      );
}

CORBA::TypeCode_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::get_canonical_typecode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_canonical_typecode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->get_canonical_typecode (
        tc,
        ACE_TRY_ENV
      );
}

IR_PrimitiveDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::get_primitive (
    CORBA_Object *_collocated_tao_target_,
    IR_PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PrimitiveDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_primitive",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->get_primitive (
        kind,
        ACE_TRY_ENV
      );
}

IR_StringDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_string (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_StringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_string",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_string (
        bound,
        ACE_TRY_ENV
      );
}

IR_WstringDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_wstring (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_WstringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_wstring",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_wstring (
        bound,
        ACE_TRY_ENV
      );
}

IR_SequenceDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_sequence (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    IR_IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_SequenceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_sequence",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_sequence (
        bound,
        element_type,
        ACE_TRY_ENV
      );
}

IR_ArrayDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_array (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length,
    IR_IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ArrayDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_array",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_array (
        length,
        element_type,
        ACE_TRY_ENV
      );
}

IR_FixedDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_fixed (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FixedDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_fixed",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_fixed (
        digits,
        scale,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::Repository::Repository (void)
{
  this->optable_ = &tao_IR_Repository_optable;
}

// copy ctor
POA_IR::Repository::Repository (const Repository& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Repository::~Repository (void)
{
}

void POA_IR::Repository::lookup_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_Contained_var _tao_retval;
  CORBA::String_var search_id;
  if (!(
    (_tao_in >> search_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_lookup_id ri (
      _tao_server_request,
      _tao_impl,
      search_id.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->lookup_id (
          search_id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_Contained_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Repository::get_canonical_typecode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
  CORBA::TypeCode_var tc;
  if (!(
    (_tao_in >> tc.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode ri (
      _tao_server_request,
      _tao_impl,
      tc.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->get_canonical_typecode (
          tc.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Repository::get_primitive_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_PrimitiveDef_var _tao_retval;
  IR_PrimitiveKind kind;
  if (!(
    (_tao_in >> kind)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_primitive ri (
      _tao_server_request,
      _tao_impl,
      kind,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->get_primitive (
          kind,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_PrimitiveDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Repository::create_string_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_StringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_string ri (
      _tao_server_request,
      _tao_impl,
      bound,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_string (
          bound,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_StringDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Repository::create_wstring_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_WstringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_wstring ri (
      _tao_server_request,
      _tao_impl,
      bound,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_wstring (
          bound,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_WstringDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Repository::create_sequence_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_SequenceDef_var _tao_retval;
  CORBA::ULong bound;
  IR_IDLType_var element_type;
  if (!(
    (_tao_in >> bound) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_sequence ri (
      _tao_server_request,
      _tao_impl,
      bound,
      element_type.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_sequence (
          bound,
          element_type.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_SequenceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Repository::create_array_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_ArrayDef_var _tao_retval;
  CORBA::ULong length;
  IR_IDLType_var element_type;
  if (!(
    (_tao_in >> length) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_array ri (
      _tao_server_request,
      _tao_impl,
      length,
      element_type.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_array (
          length,
          element_type.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ArrayDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Repository::create_fixed_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_FixedDef_var _tao_retval;
  CORBA::UShort digits;
  CORBA::Short scale;
  if (!(
    (_tao_in >> digits) &&
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_fixed ri (
      _tao_server_request,
      _tao_impl,
      digits,
      scale,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_fixed (
          digits,
          scale,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_FixedDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::Repository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Repository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Repository::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Repository::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Repository:1.0") == 0)
    return ACE_static_cast (POA_IR::Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Repository::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Repository:1.0";
}

IR::Repository*
POA_IR::Repository::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_Repository::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_lookup_id::TAO_ServerRequestInfo_IR_Repository_lookup_id (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Repository *tao_impl,
    const char * search_id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    search_id_ (search_id)
{}

Dynamic::ParameterList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_lookup_id::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_search_id = parameter_list->length ();
  parameter_list->length (length_search_id + 1);
  (*parameter_list)[length_search_id].argument <<= search_id_;
  (*parameter_list)[length_search_id].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_lookup_id::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_lookup_id::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_lookup_id::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_lookup_id::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_lookup_id::result (IR::Contained_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Repository *tao_impl,
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    tc_ (tc)
{}

Dynamic::ParameterList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_tc = parameter_list->length ();
  parameter_list->length (length_tc + 1);
  (*parameter_list)[length_tc].argument <<= tc_;
  (*parameter_list)[length_tc].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_canonical_typecode::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_primitive::TAO_ServerRequestInfo_IR_Repository_get_primitive (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Repository *tao_impl,
    IR_PrimitiveKind & kind,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    kind_ (kind)
{}

Dynamic::ParameterList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_primitive::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_kind = parameter_list->length ();
  parameter_list->length (length_kind + 1);
  (*parameter_list)[length_kind].argument <<=  this->kind_;

  (*parameter_list)[length_kind].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_primitive::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_primitive::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_primitive::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_primitive::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_get_primitive::result (IR::PrimitiveDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_string::TAO_ServerRequestInfo_IR_Repository_create_string (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Repository *tao_impl,
    const CORBA::ULong & bound,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_string::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_string::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_string::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_string::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_string::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_string::result (IR::StringDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_wstring::TAO_ServerRequestInfo_IR_Repository_create_wstring (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Repository *tao_impl,
    const CORBA::ULong & bound,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_wstring::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_wstring::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_wstring::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_wstring::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_wstring::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_wstring::result (IR::WstringDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_sequence::TAO_ServerRequestInfo_IR_Repository_create_sequence (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Repository *tao_impl,
    const CORBA::ULong & bound,
    IR_IDLType_ptr element_type,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    bound_ (bound),
    element_type_ (element_type)
{}

Dynamic::ParameterList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_sequence::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_element_type = parameter_list->length ();
  parameter_list->length (length_element_type + 1);
  (*parameter_list)[length_element_type].argument <<=  this->element_type_;

  (*parameter_list)[length_element_type].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_sequence::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_sequence::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_sequence::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_sequence::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_sequence::result (IR::SequenceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_array::TAO_ServerRequestInfo_IR_Repository_create_array (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Repository *tao_impl,
    const CORBA::ULong & length,
    IR_IDLType_ptr element_type,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    length_ (length),
    element_type_ (element_type)
{}

Dynamic::ParameterList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_array::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_length = parameter_list->length ();
  parameter_list->length (length_length + 1);
  (*parameter_list)[length_length].argument <<= length_;
  (*parameter_list)[length_length].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_element_type = parameter_list->length ();
  parameter_list->length (length_element_type + 1);
  (*parameter_list)[length_element_type].argument <<=  this->element_type_;

  (*parameter_list)[length_element_type].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_array::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_array::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_array::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_array::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_array::result (IR::ArrayDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_fixed::TAO_ServerRequestInfo_IR_Repository_create_fixed (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::Repository *tao_impl,
    const CORBA::UShort & digits,
    const CORBA::Short & scale,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    digits_ (digits),
    scale_ (scale)
{}

Dynamic::ParameterList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_fixed::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_digits = parameter_list->length ();
  parameter_list->length (length_digits + 1);
  (*parameter_list)[length_digits].argument <<= digits_;
  (*parameter_list)[length_digits].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_scale = parameter_list->length ();
  parameter_list->length (length_scale + 1);
  (*parameter_list)[length_scale].argument <<= scale_;
  (*parameter_list)[length_scale].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_fixed::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_fixed::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_fixed::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_fixed::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::Repository::TAO_ServerRequestInfo_IR_Repository_create_fixed::result (IR::FixedDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ComponentRepository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentRepository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 15,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54,  5,
     54,  0, 25, 15, 54, 10, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 10,  0,  3,
     54, 25, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54,  0,  5, 54, 54, 54,  0, 20, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54,
#else
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 15, 54,  5, 54,  0,
     25, 15, 54, 10, 54, 54, 54, 54, 10,  0,
      3, 54, 25, 54, 54,  0,  5, 54, 54, 54,
      0, 20, 54, 54, 54, 54, 54, 54,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 29,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 8,
      MAX_HASH_VALUE = 53,
      HASH_VALUE_RANGE = 46,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"contents",      &POA_IR::ComponentRepository::contents_skel},
      {"create_enum",   &POA_IR::ComponentRepository::create_enum_skel},
      {"create_alias",  &POA_IR::ComponentRepository::create_alias_skel},
      {"create_union",  &POA_IR::ComponentRepository::create_union_skel},
      {"create_value_box",      &POA_IR::ComponentRepository::create_value_box_skel},
      {"create_struct",         &POA_IR::ComponentRepository::create_struct_skel},
      {"create_exception",      &POA_IR::ComponentRepository::create_exception_skel},
      {"create_constant",       &POA_IR::ComponentRepository::create_constant_skel},
      {"create_component",      &POA_IR::ComponentRepository::create_component_skel},
      {"create_string",         &POA_IR::ComponentRepository::create_string_skel},
      {"create_wstring",        &POA_IR::ComponentRepository::create_wstring_skel},
      {"_is_a",  &POA_IR::ComponentRepository::_is_a_skel},
      {"create_home",   &POA_IR::ComponentRepository::create_home_skel},
      {"create_value",  &POA_IR::ComponentRepository::create_value_skel},
      {"create_module",         &POA_IR::ComponentRepository::create_module_skel},
      {"create_native",         &POA_IR::ComponentRepository::create_native_skel},
      {"create_sequence",       &POA_IR::ComponentRepository::create_sequence_skel},
      {"create_interface",      &POA_IR::ComponentRepository::create_interface_skel},
      {"create_array",  &POA_IR::ComponentRepository::create_array_skel},
      {"_non_existent",  &POA_IR::ComponentRepository::_non_existent_skel},
      {"lookup_name",   &POA_IR::ComponentRepository::lookup_name_skel},
      {"create_fixed",  &POA_IR::ComponentRepository::create_fixed_skel},
      {"get_primitive",         &POA_IR::ComponentRepository::get_primitive_skel},
      {"lookup",        &POA_IR::ComponentRepository::lookup_skel},
      {"describe_contents",     &POA_IR::ComponentRepository::describe_contents_skel},
      {"lookup_id",     &POA_IR::ComponentRepository::lookup_id_skel},
      {"get_canonical_typecode",        &POA_IR::ComponentRepository::get_canonical_typecode_skel},
      {"destroy",       &POA_IR::ComponentRepository::destroy_skel},
      {"_get_def_kind",         &POA_IR::ComponentRepository::_get_def_kind_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,   8,  -1,  -1,   9,  10, -22,
       -2,  11,  12,  -1,  13,  14,  15,  16,  -1,  17,  18,  19,  20,  21,
      -68,  -1,  24,  25,  26,  27,  -1,  -1,  28,  29,  30,  -1,  -1,  31,
       32,  -1,  33,  -1,  -1,  34,  -1,  -1,  -1,  -1,  35,  36,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ComponentRepository_Perfect_Hash_OpTable tao_IR_ComponentRepository_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker *POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::the_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::~_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ComponentRepository_Proxy_Impl&
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::select_proxy (
    IR_ComponentRepository *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ComponentRepository_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ComponentRepository_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ComponentRepository_Proxy_Broker *
_TAO_ComponentRepository_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::the_TAO_ComponentRepository_Strategized_Proxy_Broker();
}

int
_TAO_ComponentRepository_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer =
    _TAO_ComponentRepository_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ComponentRepository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ComponentRepository_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ComponentRepository_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::_TAO_ComponentRepository_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_ComponentDef_ptr POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ComponentDef_ptr base_component,
    const IR_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_component (
        id,
        name,
        version,
        base_component,
        supports_interfaces,
        ACE_TRY_ENV
      );
}

IR_HomeDef_ptr POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::create_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_HomeDef_ptr base_home,
    IR_ComponentDef_ptr managed_component,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_home",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_home (
        id,
        name,
        version,
        base_home,
        managed_component,
        primary_key,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ComponentRepository::ComponentRepository (void)
{
  this->optable_ = &tao_IR_ComponentRepository_optable;
}

// copy ctor
POA_IR::ComponentRepository::ComponentRepository (const ComponentRepository& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Repository) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentRepository::~ComponentRepository (void)
{
}

void POA_IR::ComponentRepository::create_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *)_tao_object_reference;

  IR_ComponentDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ComponentDef_var base_component;
  IR_InterfaceDefSeq supports_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_component.out ()) &&
    (_tao_in >> supports_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_component ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_component.in (),
      supports_interfaces,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_component (
          id.in (),
          name.in (),
          version.in (),
          base_component.in (),
          supports_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentRepository::create_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *)_tao_object_reference;

  IR_HomeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_HomeDef_var base_home;
  IR_ComponentDef_var managed_component;
  IR_ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_home.out ()) &&
    (_tao_in >> managed_component.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_home ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      base_home.in (),
      managed_component.in (),
      primary_key.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_home (
          id.in (),
          name.in (),
          version.in (),
          base_home.in (),
          managed_component.in (),
          primary_key.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_HomeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentRepository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentRepository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ComponentRepository::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentRepository::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentRepository:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentRepository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Repository:1.0") == 0)
    return ACE_static_cast (POA_IR::Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentRepository::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR::ComponentRepository*
POA_IR::ComponentRepository::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ComponentRepository::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_component::TAO_ServerRequestInfo_IR_ComponentRepository_create_component (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentRepository *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_ComponentDef_ptr base_component,
    const IR_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_component_ (base_component),
    supports_interfaces_ (supports_interfaces)
{}

Dynamic::ParameterList *
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_component::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_base_component = parameter_list->length ();
  parameter_list->length (length_base_component + 1);
  (*parameter_list)[length_base_component].argument <<=  this->base_component_;

  (*parameter_list)[length_base_component].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_supports_interfaces = parameter_list->length ();
  parameter_list->length (length_supports_interfaces + 1);
  (*parameter_list)[length_supports_interfaces].argument <<=  this->supports_interfaces_;

  (*parameter_list)[length_supports_interfaces].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_component::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_component::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_component::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_component::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_component::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_home::TAO_ServerRequestInfo_IR_ComponentRepository_create_home (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentRepository *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_HomeDef_ptr base_home,
    IR_ComponentDef_ptr managed_component,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    base_home_ (base_home),
    managed_component_ (managed_component),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_home::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_base_home = parameter_list->length ();
  parameter_list->length (length_base_home + 1);
  (*parameter_list)[length_base_home].argument <<=  this->base_home_;

  (*parameter_list)[length_base_home].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_managed_component = parameter_list->length ();
  parameter_list->length (length_managed_component + 1);
  (*parameter_list)[length_managed_component].argument <<=  this->managed_component_;

  (*parameter_list)[length_managed_component].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_primary_key = parameter_list->length ();
  parameter_list->length (length_primary_key + 1);
  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;

  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_home::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_home::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_home::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_home::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentRepository::TAO_ServerRequestInfo_IR_ComponentRepository_create_home::result (IR::HomeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ModuleDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 10,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52,  0, 15,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 20,  0,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 10, 20, 52, 52, 52, 10, 15, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 10, 52,  0, 52,  0,
     15,  0, 52, 52, 52, 52, 52, 52, 20,  0,
      5, 52, 10, 52, 52, 10, 20, 52, 52, 52,
     10, 15, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 30,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 48,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ModuleDef::move_skel},
      {"create_enum",   &POA_IR::ModuleDef::create_enum_skel},
      {"create_value",  &POA_IR::ModuleDef::create_value_skel},
      {"create_module",         &POA_IR::ModuleDef::create_module_skel},
      {"create_native",         &POA_IR::ModuleDef::create_native_skel},
      {"_is_a",  &POA_IR::ModuleDef::_is_a_skel},
      {"create_interface",      &POA_IR::ModuleDef::create_interface_skel},
      {"create_union",  &POA_IR::ModuleDef::create_union_skel},
      {"contents",      &POA_IR::ModuleDef::contents_skel},
      {"_get_name",     &POA_IR::ModuleDef::_get_name_skel},
      {"_set_name",     &POA_IR::ModuleDef::_set_name_skel},
      {"create_exception",      &POA_IR::ModuleDef::create_exception_skel},
      {"create_alias",  &POA_IR::ModuleDef::create_alias_skel},
      {"describe",      &POA_IR::ModuleDef::describe_skel},
      {"create_value_box",      &POA_IR::ModuleDef::create_value_box_skel},
      {"_get_version",  &POA_IR::ModuleDef::_get_version_skel},
      {"_set_version",  &POA_IR::ModuleDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ModuleDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::ModuleDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::ModuleDef::lookup_name_skel},
      {"_get_id",       &POA_IR::ModuleDef::_get_id_skel},
      {"_set_id",       &POA_IR::ModuleDef::_set_id_skel},
      {"create_struct",         &POA_IR::ModuleDef::create_struct_skel},
      {"create_constant",       &POA_IR::ModuleDef::create_constant_skel},
      {"lookup",        &POA_IR::ModuleDef::lookup_skel},
      {"destroy",       &POA_IR::ModuleDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ModuleDef::_get_def_kind_skel},
      {"describe_contents",     &POA_IR::ModuleDef::describe_contents_skel},
      {"_non_existent",  &POA_IR::ModuleDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ModuleDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -7,  -2, -13,  -2, -19,  -2,   5,   6, -59,
       -1,   9,  10,  11,  12, -63,  -1,  15,  16,  17, -24,  -2,  18, -69,
       21,  -1,  22,  23, -59,  26,  -1,  27,  28,  29,  30,  -1,  -1,  -1,
       31,  32,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  33,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ModuleDef_Perfect_Hash_OpTable tao_IR_ModuleDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker *POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::the_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::~_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ModuleDef_Proxy_Impl&
POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::select_proxy (
    IR_ModuleDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ModuleDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ModuleDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ModuleDef_Proxy_Broker *
_TAO_ModuleDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::the_TAO_ModuleDef_Strategized_Proxy_Broker();
}

int
_TAO_ModuleDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ModuleDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ModuleDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ModuleDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ModuleDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ModuleDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ModuleDef_ThruPOA_Proxy_Impl::_TAO_ModuleDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ModuleDef::ModuleDef (void)
{
  this->optable_ = &tao_IR_ModuleDef_optable;
}

// copy ctor
POA_IR::ModuleDef::ModuleDef (const ModuleDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ModuleDef::~ModuleDef (void)
{
}

void POA_IR::ModuleDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ModuleDef *_tao_impl = (POA_IR::ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ModuleDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ModuleDef *_tao_impl = (POA_IR::ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ModuleDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ModuleDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ModuleDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ModuleDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ModuleDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ModuleDef:1.0";
}

IR::ModuleDef*
POA_IR::ModuleDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ModuleDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ConstantDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ConstantDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ConstantDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ConstantDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ConstantDef::move_skel},
      {"_is_a",  &POA_IR::ConstantDef::_is_a_skel},
      {"_get_id",       &POA_IR::ConstantDef::_get_id_skel},
      {"_set_id",       &POA_IR::ConstantDef::_set_id_skel},
      {"describe",      &POA_IR::ConstantDef::describe_skel},
      {"_get_type",     &POA_IR::ConstantDef::_get_type_skel},
      {"_set_name",     &POA_IR::ConstantDef::_set_name_skel},
      {"_get_name",     &POA_IR::ConstantDef::_get_name_skel},
      {"_get_value",    &POA_IR::ConstantDef::_get_value_skel},
      {"_set_value",    &POA_IR::ConstantDef::_set_value_skel},
      {"_get_version",  &POA_IR::ConstantDef::_get_version_skel},
      {"_set_version",  &POA_IR::ConstantDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ConstantDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ConstantDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ConstantDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ConstantDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::ConstantDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::ConstantDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::ConstantDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ConstantDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46, -46,  -1, -46,  16,
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ConstantDef_Perfect_Hash_OpTable tao_IR_ConstantDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker *POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::the_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::~_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ConstantDef_Proxy_Impl&
POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::select_proxy (
    IR_ConstantDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ConstantDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ConstantDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ConstantDef_Proxy_Broker *
_TAO_ConstantDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::the_TAO_ConstantDef_Strategized_Proxy_Broker();
}

int
_TAO_ConstantDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ConstantDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ConstantDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ConstantDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ConstantDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ConstantDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::_TAO_ConstantDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

IR_IDLType_ptr POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type_def (
        type_def,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Any * POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Any_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->value (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->value (
        value,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ConstantDef::ConstantDef (void)
{
  this->optable_ = &tao_IR_ConstantDef_optable;
}

// copy ctor
POA_IR::ConstantDef::ConstantDef (const ConstantDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ConstantDef::~ConstantDef (void)
{
}

void POA_IR::ConstantDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ConstantDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ConstantDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  IR_IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->type_def (
          type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ConstantDef::_get_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::Any_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->value (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Any * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ConstantDef::_set_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::Any value;
  if (!(
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_set ri (
      _tao_server_request,
      _tao_impl,
      value,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->value (
          value,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ConstantDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConstantDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ConstantDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ConstantDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ConstantDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ConstantDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ConstantDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConstantDef:1.0";
}

IR::ConstantDef*
POA_IR::ConstantDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ConstantDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_get::TAO_ServerRequestInfo_IR_ConstantDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ConstantDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ConstantDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_set::TAO_ServerRequestInfo_IR_ConstantDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ConstantDef *tao_impl,
    IR_IDLType_ptr type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_type_def = parameter_list->length ();
  parameter_list->length (length_type_def + 1);
  (*parameter_list)[length_type_def].argument <<=  this->type_def_;

  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_get::TAO_ServerRequestInfo_IR_ConstantDef_value_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ConstantDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_get::result (CORBA::Any * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_set::TAO_ServerRequestInfo_IR_ConstantDef_value_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ConstantDef *tao_impl,
    const CORBA::Any & value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    value_ (value)
{}

Dynamic::ParameterList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<= value_;
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ConstantDef::TAO_ServerRequestInfo_IR_ConstantDef_value_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_TypedefDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_TypedefDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_TypedefDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_TypedefDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::TypedefDef::move_skel},
      {"_is_a",  &POA_IR::TypedefDef::_is_a_skel},
      {"_get_id",       &POA_IR::TypedefDef::_get_id_skel},
      {"_set_id",       &POA_IR::TypedefDef::_set_id_skel},
      {"describe",      &POA_IR::TypedefDef::describe_skel},
      {"_get_name",     &POA_IR::TypedefDef::_get_name_skel},
      {"_get_type",     &POA_IR::TypedefDef::_get_type_skel},
      {"_set_name",     &POA_IR::TypedefDef::_set_name_skel},
      {"_get_version",  &POA_IR::TypedefDef::_get_version_skel},
      {"_set_version",  &POA_IR::TypedefDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::TypedefDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::TypedefDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::TypedefDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::TypedefDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::TypedefDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::TypedefDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_TypedefDef_Perfect_Hash_OpTable tao_IR_TypedefDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker *POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::the_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::~_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_TypedefDef_Proxy_Impl&
POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::select_proxy (
    IR_TypedefDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_TypedefDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_TypedefDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_TypedefDef_Proxy_Broker *
_TAO_TypedefDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::the_TAO_TypedefDef_Strategized_Proxy_Broker();
}

int
_TAO_TypedefDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_TypedefDef_Proxy_Broker_Factory_function_pointer =
    _TAO_TypedefDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_TypedefDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_TypedefDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_TypedefDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_TypedefDef_ThruPOA_Proxy_Impl::_TAO_TypedefDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::TypedefDef::TypedefDef (void)
{
  this->optable_ = &tao_IR_TypedefDef_optable;
}

// copy ctor
POA_IR::TypedefDef::TypedefDef (const TypedefDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::TypedefDef::~TypedefDef (void)
{
}

void POA_IR::TypedefDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::TypedefDef *_tao_impl = (POA_IR::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::TypedefDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::TypedefDef *_tao_impl = (POA_IR::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::TypedefDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::TypedefDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::TypedefDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/TypedefDef:1.0";
}

IR::TypedefDef*
POA_IR::TypedefDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_TypedefDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_StructDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_StructDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_StructDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 20,  3,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 10, 15,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 15, 15, 52, 52, 52, 15,  5, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52,  0, 52,  0, 52, 20,
      3,  0, 52, 52, 52, 52, 52, 52, 10, 15,
      5, 52, 10, 52, 52, 15, 15, 52, 52, 52,
     15,  5, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_StructDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::StructDef::_is_a_skel},
      {"_get_name",     &POA_IR::StructDef::_get_name_skel},
      {"_get_type",     &POA_IR::StructDef::_get_type_skel},
      {"_set_name",     &POA_IR::StructDef::_set_name_skel},
      {"_get_id",       &POA_IR::StructDef::_get_id_skel},
      {"_set_id",       &POA_IR::StructDef::_set_id_skel},
      {"describe",      &POA_IR::StructDef::describe_skel},
      {"destroy",       &POA_IR::StructDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::StructDef::_get_def_kind_skel},
      {"_get_version",  &POA_IR::StructDef::_get_version_skel},
      {"_set_version",  &POA_IR::StructDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::StructDef::_get_absolute_name_skel},
      {"move",  &POA_IR::StructDef::move_skel},
      {"_get_defined_in",       &POA_IR::StructDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::StructDef::lookup_name_skel},
      {"lookup",        &POA_IR::StructDef::lookup_skel},
      {"_get_members",  &POA_IR::StructDef::_get_members_skel},
      {"_set_members",  &POA_IR::StructDef::_set_members_skel},
      {"_non_existent",  &POA_IR::StructDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::StructDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::StructDef::create_value_skel},
      {"create_module",         &POA_IR::StructDef::create_module_skel},
      {"create_native",         &POA_IR::StructDef::create_native_skel},
      {"describe_contents",     &POA_IR::StructDef::describe_contents_skel},
      {"create_interface",      &POA_IR::StructDef::create_interface_skel},
      {"create_union",  &POA_IR::StructDef::create_union_skel},
      {"create_exception",      &POA_IR::StructDef::create_exception_skel},
      {"contents",      &POA_IR::StructDef::contents_skel},
      {"create_enum",   &POA_IR::StructDef::create_enum_skel},
      {"create_alias",  &POA_IR::StructDef::create_alias_skel},
      {"create_struct",         &POA_IR::StructDef::create_struct_skel},
      {"create_constant",       &POA_IR::StructDef::create_constant_skel},
      {"create_value_box",      &POA_IR::StructDef::create_value_box_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -3,   5,  -1,  -9,  -2, -57, -54,  11,  -1, -14,
       -2,  12,  13, -55,  16,  17,  18,  19,  -1,  -1, -21,  -2,  20, -54,
       23, -26,  -2,  24,  25, -55,  -1,  28,  29,  30,  -1,  -1,  -1,  31,
       -1,  32,  -1,  -1,  33,  34,  35,  -1,  36,  37,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_StructDef_Perfect_Hash_OpTable tao_IR_StructDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_StructDef_Strategized_Proxy_Broker *POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::the_TAO_StructDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_StructDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::_TAO_StructDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::~_TAO_StructDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_StructDef_Proxy_Impl&
POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::select_proxy (
    IR_StructDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_StructDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_StructDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_StructDef_Proxy_Broker *
_TAO_StructDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::the_TAO_StructDef_Strategized_Proxy_Broker();
}

int
_TAO_StructDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_StructDef_Proxy_Broker_Factory_function_pointer =
    _TAO_StructDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_StructDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_StructDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_StructDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_StructDef_ThruPOA_Proxy_Impl::_TAO_StructDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_StructMemberSeq * POA_IR::_TAO_StructDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StructDef:1.0"
        )
    )->members (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_StructDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StructDef:1.0"
        )
    )->members (
        members,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::StructDef::StructDef (void)
{
  this->optable_ = &tao_IR_StructDef_optable;
}

// copy ctor
POA_IR::StructDef::StructDef (const StructDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::StructDef::~StructDef (void)
{
}

void POA_IR::StructDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *)_tao_object_reference;

  IR_StructMemberSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->members (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_StructMemberSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::StructDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *)_tao_object_reference;

  IR_StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_set ri (
      _tao_server_request,
      _tao_impl,
      members,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::StructDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::StructDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::StructDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::StructDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/StructDef:1.0") == 0)
    return ACE_static_cast (POA_IR::StructDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::StructDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StructDef:1.0";
}

IR::StructDef*
POA_IR::StructDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_StructDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_get::TAO_ServerRequestInfo_IR_StructDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::StructDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_get::result (IR::StructMemberSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_set::TAO_ServerRequestInfo_IR_StructDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::StructDef *tao_impl,
    const IR_StructMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    members_ (members)
{}

Dynamic::ParameterList *
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;

  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::StructDef::TAO_ServerRequestInfo_IR_StructDef_members_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_UnionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_UnionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_UnionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68,  0,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68,  0,
     68, 25,  3,  0,  0, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 10,  0, 10,
     68, 10, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 30, 15, 68, 68, 68,  5,  5, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68,
#else
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68,  0, 68,  0, 68, 25,
      3,  0,  0, 68, 68, 68, 68, 68, 10,  0,
     10, 68, 10, 68, 68, 30, 15, 68, 68, 68,
      5,  5, 68, 68, 68, 68, 68, 68,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_UnionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 67,
      HASH_VALUE_RANGE = 64,
      DUPLICATES = 8
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::UnionDef::move_skel},
      {"_is_a",  &POA_IR::UnionDef::_is_a_skel},
      {"_get_name",     &POA_IR::UnionDef::_get_name_skel},
      {"_get_type",     &POA_IR::UnionDef::_get_type_skel},
      {"_set_name",     &POA_IR::UnionDef::_set_name_skel},
      {"_get_id",       &POA_IR::UnionDef::_get_id_skel},
      {"_set_id",       &POA_IR::UnionDef::_set_id_skel},
      {"describe",      &POA_IR::UnionDef::describe_skel},
      {"destroy",       &POA_IR::UnionDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::UnionDef::_get_def_kind_skel},
      {"_get_absolute_name",    &POA_IR::UnionDef::_get_absolute_name_skel},
      {"lookup_name",   &POA_IR::UnionDef::lookup_name_skel},
      {"_get_version",  &POA_IR::UnionDef::_get_version_skel},
      {"_set_version",  &POA_IR::UnionDef::_set_version_skel},
      {"_get_discriminator_type",       &POA_IR::UnionDef::_get_discriminator_type_skel},
      {"_get_defined_in",       &POA_IR::UnionDef::_get_defined_in_skel},
      {"lookup",        &POA_IR::UnionDef::lookup_skel},
      {"_get_discriminator_type_def",   &POA_IR::UnionDef::_get_discriminator_type_def_skel},
      {"_set_discriminator_type_def",   &POA_IR::UnionDef::_set_discriminator_type_def_skel},
      {"_non_existent",  &POA_IR::UnionDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::UnionDef::_get_containing_repository_skel},
      {"create_enum",   &POA_IR::UnionDef::create_enum_skel},
      {"create_value",  &POA_IR::UnionDef::create_value_skel},
      {"create_module",         &POA_IR::UnionDef::create_module_skel},
      {"create_native",         &POA_IR::UnionDef::create_native_skel},
      {"create_interface",      &POA_IR::UnionDef::create_interface_skel},
      {"_get_members",  &POA_IR::UnionDef::_get_members_skel},
      {"_set_members",  &POA_IR::UnionDef::_set_members_skel},
      {"create_value_box",      &POA_IR::UnionDef::create_value_box_skel},
      {"create_union",  &POA_IR::UnionDef::create_union_skel},
      {"describe_contents",     &POA_IR::UnionDef::describe_contents_skel},
      {"create_exception",      &POA_IR::UnionDef::create_exception_skel},
      {"create_struct",         &POA_IR::UnionDef::create_struct_skel},
      {"create_constant",       &POA_IR::UnionDef::create_constant_skel},
      {"contents",      &POA_IR::UnionDef::contents_skel},
      {"create_alias",  &POA_IR::UnionDef::create_alias_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -6,  -3,   4,   5,  -1,  -9,  -2, -74, -70,  11,  -1, -16,
       -2,  12,  13,  -1,  14, -21,  -2,  15, -76,  18,  -1,  19,  20, -75,
       23,  -1,  -1,  24,  -1,  -1, -27,  -2,  25,  26, -71, -30,  -2,  29,
      -70,  -1,  -1,  -1,  32,  33,  -1,  -1,  34,  35,  -1,  36,  -1,  37,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  38,  -1,  -1,  -1,  39,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_UnionDef_Perfect_Hash_OpTable tao_IR_UnionDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker *POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::the_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::~_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_UnionDef_Proxy_Impl&
POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::select_proxy (
    IR_UnionDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_UnionDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_UnionDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_UnionDef_Proxy_Broker *
_TAO_UnionDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::the_TAO_UnionDef_Strategized_Proxy_Broker();
}

int
_TAO_UnionDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_UnionDef_Proxy_Broker_Factory_function_pointer =
    _TAO_UnionDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_UnionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_UnionDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_UnionDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::_TAO_UnionDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::discriminator_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type (
        ACE_TRY_ENV
      );
}

IR_IDLType_ptr POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type_def (
        discriminator_type_def,
        ACE_TRY_ENV
      );
  return;
}

IR_UnionMemberSeq * POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_UnionMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->members (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->members (
        members,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::UnionDef::UnionDef (void)
{
  this->optable_ = &tao_IR_UnionDef_optable;
}

// copy ctor
POA_IR::UnionDef::UnionDef (const UnionDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::UnionDef::~UnionDef (void)
{
}

void POA_IR::UnionDef::_get_discriminator_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get ri (
      _tao_server_request,
      _tao_impl ,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->discriminator_type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UnionDef::_get_discriminator_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->discriminator_type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UnionDef::_set_discriminator_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR_IDLType_var discriminator_type_def;
  if (!(
    (_tao_in >> discriminator_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      discriminator_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->discriminator_type_def (
          discriminator_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UnionDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR_UnionMemberSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->members (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_UnionMemberSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UnionDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR_UnionMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_set ri (
      _tao_server_request,
      _tao_impl,
      members,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UnionDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UnionDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::UnionDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::UnionDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/UnionDef:1.0") == 0)
    return ACE_static_cast (POA_IR::UnionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::UnionDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UnionDef:1.0";
}

IR::UnionDef*
POA_IR::UnionDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_UnionDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UnionDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UnionDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_set::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UnionDef *tao_impl,
    IR_IDLType_ptr discriminator_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    discriminator_type_def_ (discriminator_type_def)
{}

Dynamic::ParameterList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_discriminator_type_def = parameter_list->length ();
  parameter_list->length (length_discriminator_type_def + 1);
  (*parameter_list)[length_discriminator_type_def].argument <<=  this->discriminator_type_def_;

  (*parameter_list)[length_discriminator_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_discriminator_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_get::TAO_ServerRequestInfo_IR_UnionDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UnionDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_get::result (IR::UnionMemberSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_set::TAO_ServerRequestInfo_IR_UnionDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UnionDef *tao_impl,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    members_ (members)
{}

Dynamic::ParameterList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;

  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::UnionDef::TAO_ServerRequestInfo_IR_UnionDef_members_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_EnumDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EnumDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EnumDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 10, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 10, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EnumDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EnumDef::move_skel},
      {"_is_a",  &POA_IR::EnumDef::_is_a_skel},
      {"_get_id",       &POA_IR::EnumDef::_get_id_skel},
      {"_set_id",       &POA_IR::EnumDef::_set_id_skel},
      {"describe",      &POA_IR::EnumDef::describe_skel},
      {"_get_name",     &POA_IR::EnumDef::_get_name_skel},
      {"_get_type",     &POA_IR::EnumDef::_get_type_skel},
      {"_set_name",     &POA_IR::EnumDef::_set_name_skel},
      {"_get_version",  &POA_IR::EnumDef::_get_version_skel},
      {"_set_version",  &POA_IR::EnumDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EnumDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::EnumDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EnumDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EnumDef::_get_absolute_name_skel},
      {"_get_members",  &POA_IR::EnumDef::_get_members_skel},
      {"_set_members",  &POA_IR::EnumDef::_set_members_skel},
      {"_non_existent",  &POA_IR::EnumDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EnumDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_EnumDef_Perfect_Hash_OpTable tao_IR_EnumDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker *POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::the_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::~_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_EnumDef_Proxy_Impl&
POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::select_proxy (
    IR_EnumDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EnumDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EnumDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_EnumDef_Proxy_Broker *
_TAO_EnumDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::the_TAO_EnumDef_Strategized_Proxy_Broker();
}

int
_TAO_EnumDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_EnumDef_Proxy_Broker_Factory_function_pointer =
    _TAO_EnumDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_EnumDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_EnumDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_EnumDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EnumDef_ThruPOA_Proxy_Impl::_TAO_EnumDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::EnumMemberSeq * POA_IR::_TAO_EnumDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_EnumMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EnumDef:1.0"
        )
    )->members (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_EnumDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EnumDef:1.0"
        )
    )->members (
        members,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EnumDef::EnumDef (void)
{
  this->optable_ = &tao_IR_EnumDef_optable;
}

// copy ctor
POA_IR::EnumDef::EnumDef (const EnumDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EnumDef::~EnumDef (void)
{
}

void POA_IR::EnumDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *)_tao_object_reference;

  IR_EnumMemberSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->members (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_EnumMemberSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::EnumDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *)_tao_object_reference;

  IR_EnumMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_set ri (
      _tao_server_request,
      _tao_impl,
      members,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::EnumDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EnumDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EnumDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EnumDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EnumDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EnumDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
   if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EnumDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EnumDef:1.0";
}

IR::EnumDef*
POA_IR::EnumDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_EnumDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_get::TAO_ServerRequestInfo_IR_EnumDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::EnumDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_get::result (IR::EnumMemberSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_set::TAO_ServerRequestInfo_IR_EnumDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::EnumDef *tao_impl,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    members_ (members)
{}

Dynamic::ParameterList *
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;

  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::EnumDef::TAO_ServerRequestInfo_IR_EnumDef_members_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_AliasDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_AliasDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_AliasDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_AliasDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::AliasDef::move_skel},
      {"_is_a",  &POA_IR::AliasDef::_is_a_skel},
      {"_get_id",       &POA_IR::AliasDef::_get_id_skel},
      {"_set_id",       &POA_IR::AliasDef::_set_id_skel},
      {"describe",      &POA_IR::AliasDef::describe_skel},
      {"_get_name",     &POA_IR::AliasDef::_get_name_skel},
      {"_get_type",     &POA_IR::AliasDef::_get_type_skel},
      {"_set_name",     &POA_IR::AliasDef::_set_name_skel},
      {"_get_version",  &POA_IR::AliasDef::_get_version_skel},
      {"_set_version",  &POA_IR::AliasDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::AliasDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::AliasDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::AliasDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::AliasDef::_get_absolute_name_skel},
      {"_get_original_type_def",        &POA_IR::AliasDef::_get_original_type_def_skel},
      {"_set_original_type_def",        &POA_IR::AliasDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_IR::AliasDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::AliasDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_AliasDef_Perfect_Hash_OpTable tao_IR_AliasDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker *POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::the_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::~_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_AliasDef_Proxy_Impl&
POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::select_proxy (
    IR_AliasDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_AliasDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_AliasDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_AliasDef_Proxy_Broker *
_TAO_AliasDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::the_TAO_AliasDef_Strategized_Proxy_Broker();
}

int
_TAO_AliasDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_AliasDef_Proxy_Broker_Factory_function_pointer =
    _TAO_AliasDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_AliasDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_AliasDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_AliasDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_AliasDef_ThruPOA_Proxy_Impl::_TAO_AliasDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_IDLType_ptr POA_IR::_TAO_AliasDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AliasDef:1.0"
        )
    )->original_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_AliasDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AliasDef:1.0"
        )
    )->original_type_def (
        original_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::AliasDef::AliasDef (void)
{
  this->optable_ = &tao_IR_AliasDef_optable;
}

// copy ctor
POA_IR::AliasDef::AliasDef (const AliasDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::AliasDef::~AliasDef (void)
{
}

void POA_IR::AliasDef::_get_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->original_type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::AliasDef::_set_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *)_tao_object_reference;

  IR_IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->original_type_def (
          original_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::AliasDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::AliasDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::AliasDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::AliasDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/AliasDef:1.0") == 0)
    return ACE_static_cast (POA_IR::AliasDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::AliasDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AliasDef:1.0";
}

IR::AliasDef*
POA_IR::AliasDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_AliasDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::AliasDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_set::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::AliasDef *tao_impl,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;

  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::AliasDef::TAO_ServerRequestInfo_IR_AliasDef_original_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_NativeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_NativeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_NativeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_NativeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::NativeDef::move_skel},
      {"_is_a",  &POA_IR::NativeDef::_is_a_skel},
      {"_get_id",       &POA_IR::NativeDef::_get_id_skel},
      {"_set_id",       &POA_IR::NativeDef::_set_id_skel},
      {"describe",      &POA_IR::NativeDef::describe_skel},
      {"_get_name",     &POA_IR::NativeDef::_get_name_skel},
      {"_get_type",     &POA_IR::NativeDef::_get_type_skel},
      {"_set_name",     &POA_IR::NativeDef::_set_name_skel},
      {"_get_version",  &POA_IR::NativeDef::_get_version_skel},
      {"_set_version",  &POA_IR::NativeDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::NativeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::NativeDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::NativeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::NativeDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::NativeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::NativeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_NativeDef_Perfect_Hash_OpTable tao_IR_NativeDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker *POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::the_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::~_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_NativeDef_Proxy_Impl&
POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::select_proxy (
    IR_NativeDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_NativeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_NativeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_NativeDef_Proxy_Broker *
_TAO_NativeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::the_TAO_NativeDef_Strategized_Proxy_Broker();
}

int
_TAO_NativeDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_NativeDef_Proxy_Broker_Factory_function_pointer =
    _TAO_NativeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_NativeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_NativeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_NativeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_NativeDef_ThruPOA_Proxy_Impl::_TAO_NativeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::NativeDef::NativeDef (void)
{
  this->optable_ = &tao_IR_NativeDef_optable;
}

// copy ctor
POA_IR::NativeDef::NativeDef (const NativeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::NativeDef::~NativeDef (void)
{
}

void POA_IR::NativeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::NativeDef *_tao_impl = (POA_IR::NativeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::NativeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::NativeDef *_tao_impl = (POA_IR::NativeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::NativeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/NativeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::NativeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/NativeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::NativeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::NativeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/NativeDef:1.0";
}

IR::NativeDef*
POA_IR::NativeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_NativeDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_PrimitiveDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PrimitiveDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PrimitiveDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  5, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PrimitiveDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::PrimitiveDef::_is_a_skel},
      {"",0},
      {"destroy",       &POA_IR::PrimitiveDef::destroy_skel},
      {"",0},
      {"_get_kind",     &POA_IR::PrimitiveDef::_get_kind_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_IR::PrimitiveDef::_get_def_kind_skel},
      {"_get_type",     &POA_IR::PrimitiveDef::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_non_existent",  &POA_IR::PrimitiveDef::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_PrimitiveDef_Perfect_Hash_OpTable tao_IR_PrimitiveDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker *POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::the_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::~_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_PrimitiveDef_Proxy_Impl&
POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::select_proxy (
    IR_PrimitiveDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PrimitiveDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PrimitiveDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_PrimitiveDef_Proxy_Broker *
_TAO_PrimitiveDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::the_TAO_PrimitiveDef_Strategized_Proxy_Broker();
}

int
_TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer =
    _TAO_PrimitiveDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_PrimitiveDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PrimitiveDef_ThruPOA_Proxy_Impl::_TAO_PrimitiveDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_PrimitiveKind POA_IR::_TAO_PrimitiveDef_ThruPOA_Proxy_Impl::kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PrimitiveKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "kind",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimitiveDef:1.0"
        )
    )->kind (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PrimitiveDef::PrimitiveDef (void)
{
  this->optable_ = &tao_IR_PrimitiveDef_optable;
}

// copy ctor
POA_IR::PrimitiveDef::PrimitiveDef (const PrimitiveDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PrimitiveDef::~PrimitiveDef (void)
{
}

void POA_IR::PrimitiveDef::_get_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *)_tao_object_reference;

  IR_PrimitiveKind _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::PrimitiveDef::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->kind (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_PrimitiveKind _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::PrimitiveDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimitiveDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PrimitiveDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PrimitiveDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PrimitiveDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PrimitiveDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PrimitiveDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimitiveDef:1.0";
}

IR::PrimitiveDef*
POA_IR::PrimitiveDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_PrimitiveDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::PrimitiveDef::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::PrimitiveDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::PrimitiveDef::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::PrimitiveDef::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::PrimitiveDef::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::PrimitiveDef::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::PrimitiveDef::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::PrimitiveDef::TAO_ServerRequestInfo_IR_PrimitiveDef_kind_get::result (IR::PrimitiveKind result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_StringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_StringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_StringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_StringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::StringDef::_is_a_skel},
      {"destroy",       &POA_IR::StringDef::destroy_skel},
      {"_get_type",     &POA_IR::StringDef::_get_type_skel},
      {"_get_bound",    &POA_IR::StringDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::StringDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::StringDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::StringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -25,  -1,  -1,  10,
       -1,  -1,  -1,  -1,  11,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_StringDef_Perfect_Hash_OpTable tao_IR_StringDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_StringDef_Strategized_Proxy_Broker *POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::the_TAO_StringDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_StringDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::_TAO_StringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::~_TAO_StringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_StringDef_Proxy_Impl&
POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::select_proxy (
    IR_StringDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_StringDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_StringDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_StringDef_Proxy_Broker *
_TAO_StringDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::the_TAO_StringDef_Strategized_Proxy_Broker();
}

int
_TAO_StringDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_StringDef_Proxy_Broker_Factory_function_pointer =
    _TAO_StringDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_StringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_StringDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_StringDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_StringDef_ThruPOA_Proxy_Impl::_TAO_StringDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong POA_IR::_TAO_StringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StringDef:1.0"
        )
    )->bound (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_StringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StringDef:1.0"
        )
    )->bound (
        bound,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::StringDef::StringDef (void)
{
  this->optable_ = &tao_IR_StringDef_optable;
}

// copy ctor
POA_IR::StringDef::StringDef (const StringDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::StringDef::~StringDef (void)
{
}

void POA_IR::StringDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->bound (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ULong _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::StringDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_set ri (
      _tao_server_request,
      _tao_impl,
      bound,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
          bound,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::StringDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::StringDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::StringDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::StringDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/StringDef:1.0") == 0)
    return ACE_static_cast (POA_IR::StringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::StringDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StringDef:1.0";
}

IR::StringDef*
POA_IR::StringDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_StringDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_get::TAO_ServerRequestInfo_IR_StringDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::StringDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_get::result (CORBA::ULong result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_set::TAO_ServerRequestInfo_IR_StringDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::StringDef *tao_impl,
    const CORBA::ULong & bound,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::StringDef::TAO_ServerRequestInfo_IR_StringDef_bound_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_WstringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_WstringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_WstringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_WstringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::WstringDef::_is_a_skel},
      {"destroy",       &POA_IR::WstringDef::destroy_skel},
      {"_get_type",     &POA_IR::WstringDef::_get_type_skel},
      {"_get_bound",    &POA_IR::WstringDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::WstringDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::WstringDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::WstringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -25,  -1,  -1,  10,
       -1,  -1,  -1,  -1,  11,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_WstringDef_Perfect_Hash_OpTable tao_IR_WstringDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker *POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::the_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::~_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_WstringDef_Proxy_Impl&
POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::select_proxy (
    IR_WstringDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_WstringDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_WstringDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_WstringDef_Proxy_Broker *
_TAO_WstringDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::the_TAO_WstringDef_Strategized_Proxy_Broker();
}

int
_TAO_WstringDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_WstringDef_Proxy_Broker_Factory_function_pointer =
    _TAO_WstringDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_WstringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_WstringDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_WstringDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_WstringDef_ThruPOA_Proxy_Impl::_TAO_WstringDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong POA_IR::_TAO_WstringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/WstringDef:1.0"
        )
    )->bound (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_WstringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/WstringDef:1.0"
        )
    )->bound (
        bound,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::WstringDef::WstringDef (void)
{
  this->optable_ = &tao_IR_WstringDef_optable;
}

// copy ctor
POA_IR::WstringDef::WstringDef (const WstringDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::WstringDef::~WstringDef (void)
{
}

void POA_IR::WstringDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->bound (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ULong _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::WstringDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_set ri (
      _tao_server_request,
      _tao_impl,
      bound,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
          bound,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::WstringDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::WstringDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::WstringDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::WstringDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/WstringDef:1.0") == 0)
    return ACE_static_cast (POA_IR::WstringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::WstringDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/WstringDef:1.0";
}

IR::WstringDef*
POA_IR::WstringDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_WstringDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_get::TAO_ServerRequestInfo_IR_WstringDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::WstringDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_get::result (CORBA::ULong result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_set::TAO_ServerRequestInfo_IR_WstringDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::WstringDef *tao_impl,
    const CORBA::ULong & bound,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::WstringDef::TAO_ServerRequestInfo_IR_WstringDef_bound_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_FixedDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FixedDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FixedDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19,  0,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FixedDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::FixedDef::_is_a_skel},
      {"destroy",       &POA_IR::FixedDef::destroy_skel},
      {"_get_type",     &POA_IR::FixedDef::_get_type_skel},
      {"_get_scale",    &POA_IR::FixedDef::_get_scale_skel},
      {"_set_scale",    &POA_IR::FixedDef::_set_scale_skel},
      {"_get_digits",   &POA_IR::FixedDef::_get_digits_skel},
      {"_set_digits",   &POA_IR::FixedDef::_set_digits_skel},
      {"_get_def_kind",         &POA_IR::FixedDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::FixedDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -8,  -2, -10,  -2,   5,  -1,   6,  -1,   7, -27, -26,  -1,  12,
       -1,  -1,  -1,  -1,  13,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_FixedDef_Perfect_Hash_OpTable tao_IR_FixedDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker *POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::the_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::~_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_FixedDef_Proxy_Impl&
POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::select_proxy (
    IR_FixedDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FixedDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FixedDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_FixedDef_Proxy_Broker *
_TAO_FixedDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::the_TAO_FixedDef_Strategized_Proxy_Broker();
}

int
_TAO_FixedDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_FixedDef_Proxy_Broker_Factory_function_pointer =
    _TAO_FixedDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_FixedDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_FixedDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_FixedDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::_TAO_FixedDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::UShort POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::UShort _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "digits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->digits (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "digits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->digits (
        digits,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Short POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Short _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "scale",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->scale (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "scale",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->scale (
        scale,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FixedDef::FixedDef (void)
{
  this->optable_ = &tao_IR_FixedDef_optable;
}

// copy ctor
POA_IR::FixedDef::FixedDef (const FixedDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FixedDef::~FixedDef (void)
{
}

void POA_IR::FixedDef::_get_digits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::UShort _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->digits (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::UShort _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::FixedDef::_set_digits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::UShort digits;
  if (!(
    (_tao_in >> digits)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_set ri (
      _tao_server_request,
      _tao_impl,
      digits,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->digits (
          digits,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::FixedDef::_get_scale_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::Short _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->scale (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Short _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::FixedDef::_set_scale_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::Short scale;
  if (!(
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_set ri (
      _tao_server_request,
      _tao_impl,
      scale,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->scale (
          scale,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::FixedDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FixedDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FixedDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FixedDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FixedDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FixedDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FixedDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FixedDef:1.0";
}

IR::FixedDef*
POA_IR::FixedDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_FixedDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_get::TAO_ServerRequestInfo_IR_FixedDef_digits_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::FixedDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_get::result (CORBA::UShort result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_set::TAO_ServerRequestInfo_IR_FixedDef_digits_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::FixedDef *tao_impl,
    const CORBA::UShort & digits,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    digits_ (digits)
{}

Dynamic::ParameterList *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_digits = parameter_list->length ();
  parameter_list->length (length_digits + 1);
  (*parameter_list)[length_digits].argument <<= digits_;
  (*parameter_list)[length_digits].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_digits_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_get::TAO_ServerRequestInfo_IR_FixedDef_scale_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::FixedDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_get::result (CORBA::Short result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_set::TAO_ServerRequestInfo_IR_FixedDef_scale_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::FixedDef *tao_impl,
    const CORBA::Short & scale,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    scale_ (scale)
{}

Dynamic::ParameterList *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_scale = parameter_list->length ();
  parameter_list->length (length_scale + 1);
  (*parameter_list)[length_scale].argument <<= scale_;
  (*parameter_list)[length_scale].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::FixedDef::TAO_ServerRequestInfo_IR_FixedDef_scale_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_SequenceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_SequenceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_SequenceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_SequenceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::SequenceDef::_is_a_skel},
      {"destroy",       &POA_IR::SequenceDef::destroy_skel},
      {"_get_type",     &POA_IR::SequenceDef::_get_type_skel},
      {"_get_bound",    &POA_IR::SequenceDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::SequenceDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::SequenceDef::_get_def_kind_skel},
      {"_get_element_type",     &POA_IR::SequenceDef::_get_element_type_skel},
      {"_non_existent",  &POA_IR::SequenceDef::_non_existent_skel},
      {"_get_element_type_def",         &POA_IR::SequenceDef::_get_element_type_def_skel},
      {"_set_element_type_def",         &POA_IR::SequenceDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -28,  -1,  -1,  10,
       -1,  -1,  -1,  11,  12, -13,  -2, -23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_SequenceDef_Perfect_Hash_OpTable tao_IR_SequenceDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker *POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::the_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::~_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_SequenceDef_Proxy_Impl&
POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::select_proxy (
    IR_SequenceDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_SequenceDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_SequenceDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_SequenceDef_Proxy_Broker *
_TAO_SequenceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::the_TAO_SequenceDef_Strategized_Proxy_Broker();
}

int
_TAO_SequenceDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_SequenceDef_Proxy_Broker_Factory_function_pointer =
    _TAO_SequenceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_SequenceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_SequenceDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_SequenceDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::_TAO_SequenceDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->bound (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->bound (
        bound,
        ACE_TRY_ENV
      );
  return;
}

CORBA::TypeCode_ptr POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type (
        ACE_TRY_ENV
      );
}

IR_IDLType_ptr POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type_def (
        element_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::SequenceDef::SequenceDef (void)
{
  this->optable_ = &tao_IR_SequenceDef_optable;
}

// copy ctor
POA_IR::SequenceDef::SequenceDef (const SequenceDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::SequenceDef::~SequenceDef (void)
{
}

void POA_IR::SequenceDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->bound (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ULong _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::SequenceDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_set ri (
      _tao_server_request,
      _tao_impl,
      bound,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
          bound,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::SequenceDef::_get_element_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->element_type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::SequenceDef::_get_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->element_type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::SequenceDef::_set_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  IR_IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      element_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->element_type_def (
          element_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::SequenceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::SequenceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::SequenceDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::SequenceDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/SequenceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::SequenceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::SequenceDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/SequenceDef:1.0";
}

IR::SequenceDef*
POA_IR::SequenceDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_SequenceDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_get::TAO_ServerRequestInfo_IR_SequenceDef_bound_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::SequenceDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_get::result (CORBA::ULong result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_set::TAO_ServerRequestInfo_IR_SequenceDef_bound_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::SequenceDef *tao_impl,
    const CORBA::ULong & bound,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    bound_ (bound)
{}

Dynamic::ParameterList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_bound_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::SequenceDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::SequenceDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_set::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::SequenceDef *tao_impl,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_element_type_def = parameter_list->length ();
  parameter_list->length (length_element_type_def + 1);
  (*parameter_list)[length_element_type_def].argument <<=  this->element_type_def_;

  (*parameter_list)[length_element_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::SequenceDef::TAO_ServerRequestInfo_IR_SequenceDef_element_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ArrayDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ArrayDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ArrayDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ArrayDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::ArrayDef::_is_a_skel},
      {"destroy",       &POA_IR::ArrayDef::destroy_skel},
      {"_get_type",     &POA_IR::ArrayDef::_get_type_skel},
      {"_get_length",   &POA_IR::ArrayDef::_get_length_skel},
      {"_set_length",   &POA_IR::ArrayDef::_set_length_skel},
      {"_get_def_kind",         &POA_IR::ArrayDef::_get_def_kind_skel},
      {"_get_element_type",     &POA_IR::ArrayDef::_get_element_type_skel},
      {"_non_existent",  &POA_IR::ArrayDef::_non_existent_skel},
      {"_get_element_type_def",         &POA_IR::ArrayDef::_get_element_type_def_skel},
      {"_set_element_type_def",         &POA_IR::ArrayDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7,  -1, -29,  -1,  10,
       -1,  -1,  -1,  11,  12, -13,  -2, -23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ArrayDef_Perfect_Hash_OpTable tao_IR_ArrayDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker *POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::the_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::~_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ArrayDef_Proxy_Impl&
POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::select_proxy (
    IR_ArrayDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ArrayDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ArrayDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ArrayDef_Proxy_Broker *
_TAO_ArrayDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::the_TAO_ArrayDef_Strategized_Proxy_Broker();
}

int
_TAO_ArrayDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ArrayDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ArrayDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ArrayDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ArrayDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ArrayDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::_TAO_ArrayDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "length",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->length (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "length",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->length (
        length,
        ACE_TRY_ENV
      );
  return;
}

CORBA::TypeCode_ptr POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type (
        ACE_TRY_ENV
      );
}

IR_IDLType_ptr POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type_def (
        element_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ArrayDef::ArrayDef (void)
{
  this->optable_ = &tao_IR_ArrayDef_optable;
}

// copy ctor
POA_IR::ArrayDef::ArrayDef (const ArrayDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ArrayDef::~ArrayDef (void)
{
}

void POA_IR::ArrayDef::_get_length_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->length (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::ULong _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ArrayDef::_set_length_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::ULong length;
  if (!(
    (_tao_in >> length)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_set ri (
      _tao_server_request,
      _tao_impl,
      length,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->length (
          length,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ArrayDef::_get_element_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->element_type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ArrayDef::_get_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->element_type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ArrayDef::_set_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  IR_IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      element_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->element_type_def (
          element_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ArrayDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ArrayDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ArrayDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ArrayDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ArrayDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ArrayDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ArrayDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ArrayDef:1.0";
}

IR::ArrayDef*
POA_IR::ArrayDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ArrayDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_get::TAO_ServerRequestInfo_IR_ArrayDef_length_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ArrayDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_get::result (CORBA::ULong result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_set::TAO_ServerRequestInfo_IR_ArrayDef_length_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ArrayDef *tao_impl,
    const CORBA::ULong & length,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    length_ (length)
{}

Dynamic::ParameterList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_length = parameter_list->length ();
  parameter_list->length (length_length + 1);
  (*parameter_list)[length_length].argument <<= length_;
  (*parameter_list)[length_length].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_length_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ArrayDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ArrayDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_set::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ArrayDef *tao_impl,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_element_type_def = parameter_list->length ();
  parameter_list->length (length_element_type_def + 1);
  (*parameter_list)[length_element_type_def].argument <<=  this->element_type_def_;

  (*parameter_list)[length_element_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ArrayDef::TAO_ServerRequestInfo_IR_ArrayDef_element_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ExceptionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ExceptionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ExceptionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 20,  3,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 10, 15,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 15, 15, 52, 52, 52, 15,  5, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52,  0, 52,  0, 52, 20,
      3,  0, 52, 52, 52, 52, 52, 52, 10, 15,
      5, 52, 10, 52, 52, 15, 15, 52, 52, 52,
     15,  5, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ExceptionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::ExceptionDef::_is_a_skel},
      {"_get_type",     &POA_IR::ExceptionDef::_get_type_skel},
      {"_set_name",     &POA_IR::ExceptionDef::_set_name_skel},
      {"_get_name",     &POA_IR::ExceptionDef::_get_name_skel},
      {"_get_id",       &POA_IR::ExceptionDef::_get_id_skel},
      {"_set_id",       &POA_IR::ExceptionDef::_set_id_skel},
      {"describe",      &POA_IR::ExceptionDef::describe_skel},
      {"destroy",       &POA_IR::ExceptionDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ExceptionDef::_get_def_kind_skel},
      {"_get_version",  &POA_IR::ExceptionDef::_get_version_skel},
      {"_set_version",  &POA_IR::ExceptionDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ExceptionDef::_get_absolute_name_skel},
      {"move",  &POA_IR::ExceptionDef::move_skel},
      {"_get_defined_in",       &POA_IR::ExceptionDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::ExceptionDef::lookup_name_skel},
      {"lookup",        &POA_IR::ExceptionDef::lookup_skel},
      {"_get_members",  &POA_IR::ExceptionDef::_get_members_skel},
      {"_set_members",  &POA_IR::ExceptionDef::_set_members_skel},
      {"_non_existent",  &POA_IR::ExceptionDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ExceptionDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::ExceptionDef::create_value_skel},
      {"create_module",         &POA_IR::ExceptionDef::create_module_skel},
      {"create_native",         &POA_IR::ExceptionDef::create_native_skel},
      {"describe_contents",     &POA_IR::ExceptionDef::describe_contents_skel},
      {"create_interface",      &POA_IR::ExceptionDef::create_interface_skel},
      {"create_union",  &POA_IR::ExceptionDef::create_union_skel},
      {"create_exception",      &POA_IR::ExceptionDef::create_exception_skel},
      {"contents",      &POA_IR::ExceptionDef::contents_skel},
      {"create_enum",   &POA_IR::ExceptionDef::create_enum_skel},
      {"create_alias",  &POA_IR::ExceptionDef::create_alias_skel},
      {"create_struct",         &POA_IR::ExceptionDef::create_struct_skel},
      {"create_constant",       &POA_IR::ExceptionDef::create_constant_skel},
      {"create_value_box",      &POA_IR::ExceptionDef::create_value_box_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -3,   5,  -1,  -9,  -2, -57, -54,  11,  -1, -14,
       -2,  12,  13, -55,  16,  17,  18,  19,  -1,  -1, -21,  -2,  20, -54,
       23, -26,  -2,  24,  25, -55,  -1,  28,  29,  30,  -1,  -1,  -1,  31,
       -1,  32,  -1,  -1,  33,  34,  35,  -1,  36,  37,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ExceptionDef_Perfect_Hash_OpTable tao_IR_ExceptionDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker *POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::the_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::~_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ExceptionDef_Proxy_Impl&
POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::select_proxy (
    IR_ExceptionDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ExceptionDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ExceptionDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ExceptionDef_Proxy_Broker *
_TAO_ExceptionDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::the_TAO_ExceptionDef_Strategized_Proxy_Broker();
}

int
_TAO_ExceptionDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ExceptionDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ExceptionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ExceptionDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ExceptionDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::_TAO_ExceptionDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

IR_StructMemberSeq * POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->members (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->members (
        members,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ExceptionDef::ExceptionDef (void)
{
  this->optable_ = &tao_IR_ExceptionDef_optable;
}

// copy ctor
POA_IR::ExceptionDef::ExceptionDef (const ExceptionDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ExceptionDef::~ExceptionDef (void)
{
}

void POA_IR::ExceptionDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ExceptionDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  IR_StructMemberSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->members (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_StructMemberSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ExceptionDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  IR_StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_set ri (
      _tao_server_request,
      _tao_impl,
      members,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
          members,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ExceptionDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ExceptionDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ExceptionDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ExceptionDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ExceptionDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ExceptionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ExceptionDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ExceptionDef:1.0";
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_type_get::TAO_ServerRequestInfo_IR_ExceptionDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ExceptionDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_get::TAO_ServerRequestInfo_IR_ExceptionDef_members_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ExceptionDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_get::result (IR::StructMemberSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_set::TAO_ServerRequestInfo_IR_ExceptionDef_members_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ExceptionDef *tao_impl,
    const IR_StructMemberSeq & members,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    members_ (members)
{}

Dynamic::ParameterList *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;

  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ExceptionDef::TAO_ServerRequestInfo_IR_ExceptionDef_members_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_AttributeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_AttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_AttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_AttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::AttributeDef::move_skel},
      {"_is_a",  &POA_IR::AttributeDef::_is_a_skel},
      {"_get_id",       &POA_IR::AttributeDef::_get_id_skel},
      {"_set_id",       &POA_IR::AttributeDef::_set_id_skel},
      {"describe",      &POA_IR::AttributeDef::describe_skel},
      {"_get_type",     &POA_IR::AttributeDef::_get_type_skel},
      {"_set_name",     &POA_IR::AttributeDef::_set_name_skel},
      {"_get_name",     &POA_IR::AttributeDef::_get_name_skel},
      {"_set_mode",     &POA_IR::AttributeDef::_set_mode_skel},
      {"_get_mode",     &POA_IR::AttributeDef::_get_mode_skel},
      {"_get_version",  &POA_IR::AttributeDef::_get_version_skel},
      {"_set_version",  &POA_IR::AttributeDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::AttributeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::AttributeDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::AttributeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::AttributeDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::AttributeDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::AttributeDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::AttributeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::AttributeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -5,   4,   5,  -1, -43,   8, -43, -14,  -2, -38,  16,
       -1,  17,  -1,  18,  19,  -1,  -1, -20,  -2, -38,  -1,  -1,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_AttributeDef_Perfect_Hash_OpTable tao_IR_AttributeDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker *POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::the_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::~_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_AttributeDef_Proxy_Impl&
POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::select_proxy (
    IR_AttributeDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_AttributeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_AttributeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_AttributeDef_Proxy_Broker *
_TAO_AttributeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::the_TAO_AttributeDef_Strategized_Proxy_Broker();
}

int
_TAO_AttributeDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_AttributeDef_Proxy_Broker_Factory_function_pointer =
    _TAO_AttributeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_AttributeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_AttributeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_AttributeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::_TAO_AttributeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

IR_IDLType_ptr POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type_def (
        type_def,
        ACE_TRY_ENV
      );
  return;
}

IR_AttributeMode POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_AttributeMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->mode (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    IR_AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->mode (
        mode,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::AttributeDef::AttributeDef (void)
{
  this->optable_ = &tao_IR_AttributeDef_optable;
}

// copy ctor
POA_IR::AttributeDef::AttributeDef (const AttributeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::AttributeDef::~AttributeDef (void)
{
}

void POA_IR::AttributeDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::AttributeDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::AttributeDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR_IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->type_def (
          type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::AttributeDef::_get_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR_AttributeMode _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->mode (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_AttributeMode _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::AttributeDef::_set_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR_AttributeMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_set ri (
      _tao_server_request,
      _tao_impl,
      mode,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->mode (
          mode,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::AttributeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::AttributeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::AttributeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::AttributeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/AttributeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::AttributeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::AttributeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AttributeDef:1.0";
}

IR::AttributeDef*
POA_IR::AttributeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_AttributeDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_get::TAO_ServerRequestInfo_IR_AttributeDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::AttributeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::AttributeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_set::TAO_ServerRequestInfo_IR_AttributeDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::AttributeDef *tao_impl,
    IR_IDLType_ptr type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_type_def = parameter_list->length ();
  parameter_list->length (length_type_def + 1);
  (*parameter_list)[length_type_def].argument <<=  this->type_def_;

  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_get::TAO_ServerRequestInfo_IR_AttributeDef_mode_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::AttributeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_get::result (IR::AttributeMode result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_set::TAO_ServerRequestInfo_IR_AttributeDef_mode_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::AttributeDef *tao_impl,
    IR_AttributeMode & mode,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    mode_ (mode)
{}

Dynamic::ParameterList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;

  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::AttributeDef::TAO_ServerRequestInfo_IR_AttributeDef_mode_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_OperationDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_OperationDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_OperationDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_OperationDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::OperationDef::move_skel},
      {"_is_a",  &POA_IR::OperationDef::_is_a_skel},
      {"_get_mode",     &POA_IR::OperationDef::_get_mode_skel},
      {"_set_name",     &POA_IR::OperationDef::_set_name_skel},
      {"_get_name",     &POA_IR::OperationDef::_get_name_skel},
      {"_set_mode",     &POA_IR::OperationDef::_set_mode_skel},
      {"_get_params",   &POA_IR::OperationDef::_get_params_skel},
      {"_set_params",   &POA_IR::OperationDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::OperationDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::OperationDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::OperationDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::OperationDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::OperationDef::_get_version_skel},
      {"_set_version",  &POA_IR::OperationDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::OperationDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::OperationDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::OperationDef::_get_id_skel},
      {"_set_id",       &POA_IR::OperationDef::_set_id_skel},
      {"describe",      &POA_IR::OperationDef::describe_skel},
      {"_get_result_def",       &POA_IR::OperationDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::OperationDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::OperationDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::OperationDef::_get_result_skel},
      {"destroy",       &POA_IR::OperationDef::destroy_skel},
      {"_non_existent",  &POA_IR::OperationDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::OperationDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_OperationDef_Perfect_Hash_OpTable tao_IR_OperationDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker *POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::the_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::~_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_OperationDef_Proxy_Impl&
POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::select_proxy (
    IR_OperationDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_OperationDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_OperationDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_OperationDef_Proxy_Broker *
_TAO_OperationDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::the_TAO_OperationDef_Strategized_Proxy_Broker();
}

int
_TAO_OperationDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_OperationDef_Proxy_Broker_Factory_function_pointer =
    _TAO_OperationDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_OperationDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_OperationDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_OperationDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::_TAO_OperationDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::result (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result (
        ACE_TRY_ENV
      );
}

IR_IDLType_ptr POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result_def (
        result_def,
        ACE_TRY_ENV
      );
  return;
}

IR_ParDescriptionSeq * POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ParDescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "params",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->params (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_,
    const IR_ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "params",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->params (
        params,
        ACE_TRY_ENV
      );
  return;
}

IR_OperationMode POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_OperationMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->mode (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    IR_OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->mode (
        mode,
        ACE_TRY_ENV
      );
  return;
}

IR_ContextIdSeq * POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ContextIdSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contexts",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->contexts (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contexts",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->contexts (
        contexts,
        ACE_TRY_ENV
      );
  return;
}

IR_ExceptionDefSeq * POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ExceptionDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "exceptions",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->exceptions (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "exceptions",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->exceptions (
        exceptions,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::OperationDef::OperationDef (void)
{
  this->optable_ = &tao_IR_OperationDef_optable;
}

// copy ctor
POA_IR::OperationDef::OperationDef (const OperationDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::OperationDef::~OperationDef (void)
{
}

void POA_IR::OperationDef::_get_result_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->result (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_get_result_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->result_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_set_result_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_IDLType_var result_def;
  if (!(
    (_tao_in >> result_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_set ri (
      _tao_server_request,
      _tao_impl,
      result_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->result_def (
          result_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_get_params_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ParDescriptionSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_get ri (
      _tao_server_request,
      _tao_impl ,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->params (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ParDescriptionSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_set_params_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ParDescriptionSeq params;
  if (!(
    (_tao_in >> params)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_set ri (
      _tao_server_request,
      _tao_impl,
      params,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->params (
          params,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_get_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_OperationMode _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->mode (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_OperationMode _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_set_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_OperationMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_set ri (
      _tao_server_request,
      _tao_impl,
      mode,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->mode (
          mode,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_get_contexts_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ContextIdSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->contexts (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ContextIdSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_set_contexts_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ContextIdSeq contexts;
  if (!(
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_set ri (
      _tao_server_request,
      _tao_impl,
      contexts,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->contexts (
          contexts,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_get_exceptions_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ExceptionDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->exceptions (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ExceptionDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_set_exceptions_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_set ri (
      _tao_server_request,
      _tao_impl,
      exceptions,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->exceptions (
          exceptions,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::OperationDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::OperationDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::OperationDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::OperationDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::OperationDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/OperationDef:1.0";
}

IR::OperationDef*
POA_IR::OperationDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_OperationDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_get::TAO_ServerRequestInfo_IR_OperationDef_result_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_get::TAO_ServerRequestInfo_IR_OperationDef_result_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_set::TAO_ServerRequestInfo_IR_OperationDef_result_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    IR_IDLType_ptr result_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    result_def_ (result_def)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_result_def = parameter_list->length ();
  parameter_list->length (length_result_def + 1);
  (*parameter_list)[length_result_def].argument <<=  this->result_def_;

  (*parameter_list)[length_result_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_result_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_get::TAO_ServerRequestInfo_IR_OperationDef_params_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_get::result (IR::ParDescriptionSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_set::TAO_ServerRequestInfo_IR_OperationDef_params_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    const IR_ParDescriptionSeq & params,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    params_ (params)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;

  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_params_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_get::TAO_ServerRequestInfo_IR_OperationDef_mode_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_get::result (IR::OperationMode result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_set::TAO_ServerRequestInfo_IR_OperationDef_mode_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    IR_OperationMode & mode,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    mode_ (mode)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;

  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_mode_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_get::TAO_ServerRequestInfo_IR_OperationDef_contexts_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_get::result (IR::ContextIdSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_set::TAO_ServerRequestInfo_IR_OperationDef_contexts_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_contexts = parameter_list->length ();
  parameter_list->length (length_contexts + 1);
  (*parameter_list)[length_contexts].argument <<=  this->contexts_;

  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_contexts_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_get::result (IR::ExceptionDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_set::TAO_ServerRequestInfo_IR_OperationDef_exceptions_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::OperationDef *tao_impl,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;

  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::OperationDef::TAO_ServerRequestInfo_IR_OperationDef_exceptions_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_InterfaceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_InterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_InterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66,  0,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66,  0,
     66, 20,  8,  0, 66, 66, 66, 10, 66, 66,
     66, 66, 66, 66, 66, 66, 66,  0,  0,  5,
     66,  0, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 10, 30, 66, 66, 66, 20, 25, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66,
#else
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66,  0, 66,  0, 66, 20,
      8,  0, 66, 66, 66, 10, 66, 66,  0,  0,
      5, 66,  0, 66, 66, 10, 30, 66, 66, 66,
     20, 25, 66, 66, 66, 66, 66, 66,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_InterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 40,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 65,
      HASH_VALUE_RANGE = 62,
      DUPLICATES = 11
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::InterfaceDef::move_skel},
      {"_is_a",  &POA_IR::InterfaceDef::_is_a_skel},
      {"lookup",        &POA_IR::InterfaceDef::lookup_skel},
      {"_get_name",     &POA_IR::InterfaceDef::_get_name_skel},
      {"_get_type",     &POA_IR::InterfaceDef::_get_type_skel},
      {"_set_name",     &POA_IR::InterfaceDef::_set_name_skel},
      {"lookup_name",   &POA_IR::InterfaceDef::lookup_name_skel},
      {"_get_is_local",         &POA_IR::InterfaceDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::InterfaceDef::_set_is_local_skel},
      {"is_a",  &POA_IR::InterfaceDef::is_a_skel},
      {"_get_id",       &POA_IR::InterfaceDef::_get_id_skel},
      {"_set_id",       &POA_IR::InterfaceDef::_set_id_skel},
      {"describe",      &POA_IR::InterfaceDef::describe_skel},
      {"_get_version",  &POA_IR::InterfaceDef::_get_version_skel},
      {"_set_version",  &POA_IR::InterfaceDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::InterfaceDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::InterfaceDef::_get_defined_in_skel},
      {"_get_def_kind",         &POA_IR::InterfaceDef::_get_def_kind_skel},
      {"_get_base_interfaces",  &POA_IR::InterfaceDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::InterfaceDef::_set_base_interfaces_skel},
      {"create_enum",   &POA_IR::InterfaceDef::create_enum_skel},
      {"create_value",  &POA_IR::InterfaceDef::create_value_skel},
      {"create_module",         &POA_IR::InterfaceDef::create_module_skel},
      {"create_native",         &POA_IR::InterfaceDef::create_native_skel},
      {"describe_contents",     &POA_IR::InterfaceDef::describe_contents_skel},
      {"create_attribute",      &POA_IR::InterfaceDef::create_attribute_skel},
      {"create_interface",      &POA_IR::InterfaceDef::create_interface_skel},
      {"create_union",  &POA_IR::InterfaceDef::create_union_skel},
      {"contents",      &POA_IR::InterfaceDef::contents_skel},
      {"destroy",       &POA_IR::InterfaceDef::destroy_skel},
      {"create_operation",      &POA_IR::InterfaceDef::create_operation_skel},
      {"create_exception",      &POA_IR::InterfaceDef::create_exception_skel},
      {"create_alias",  &POA_IR::InterfaceDef::create_alias_skel},
      {"_non_existent",  &POA_IR::InterfaceDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::InterfaceDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::InterfaceDef::_set_is_abstract_skel},
      {"_get_containing_repository",    &POA_IR::InterfaceDef::_get_containing_repository_skel},
      {"create_value_box",      &POA_IR::InterfaceDef::create_value_box_skel},
      {"create_struct",         &POA_IR::InterfaceDef::create_struct_skel},
      {"create_constant",       &POA_IR::InterfaceDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -11,   -2,  -14,   -2,    4,    5,    6,  -17,   -2,  103,   -1,   10,   -1,  -78,
        13,  -78,   16,  -75,   19,   -1,   20,   21,  -22,   -2,  -26,   -2,  -29,   -2,
       -34,   -2,  -73,   24,   25,  -74,   -1,   28,  -75,   31,   32,   -1,   33,  -78,
        36,   37,  -38,   -2,  -67,   -7,   -3,   -1,   -1,   40,   -1,   -1,   -1,   -1,
        41,   -1,   -1,   -1,   -1,   -1,   -1,   42,   -1,   43,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_InterfaceDef_Perfect_Hash_OpTable tao_IR_InterfaceDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker *POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::the_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::~_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_InterfaceDef_Proxy_Impl&
POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::select_proxy (
    IR_InterfaceDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_InterfaceDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_InterfaceDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_InterfaceDef_Proxy_Broker *
_TAO_InterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::the_TAO_InterfaceDef_Strategized_Proxy_Broker();
}

int
_TAO_InterfaceDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer =
    _TAO_InterfaceDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_InterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_InterfaceDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_InterfaceDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::_TAO_InterfaceDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_InterfaceDefSeq * POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->base_interfaces (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->base_interfaces (
        base_interfaces,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_abstract (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_abstract (
        is_abstract,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_local (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_local",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_local (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_local (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_local",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_local (
        is_local,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_a (
        interface_id,
        ACE_TRY_ENV
      );
}

IR_AttributeDef_ptr POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_attribute",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->create_attribute (
        id,
        name,
        version,
        type,
        mode,
        get_exceptions,
        put_exceptions,
        ACE_TRY_ENV
      );
}

IR_OperationDef_ptr POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_operation",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->create_operation (
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::InterfaceDef::InterfaceDef (void)
{
  this->optable_ = &tao_IR_InterfaceDef_optable;
}

// copy ctor
POA_IR::InterfaceDef::InterfaceDef (const InterfaceDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::InterfaceDef::~InterfaceDef (void)
{
}

void POA_IR::InterfaceDef::_get_base_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR_InterfaceDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->base_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_InterfaceDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::_set_base_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR_InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_set ri (
      _tao_server_request,
      _tao_impl,
      base_interfaces,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->base_interfaces (
          base_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::_get_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_abstract (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::_set_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean is_abstract;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_abstract))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_set ri (
      _tao_server_request,
      _tao_impl,
      is_abstract,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->is_abstract (
          is_abstract,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::_get_is_local_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_local (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::_set_is_local_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean is_local;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_local))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_set ri (
      _tao_server_request,
      _tao_impl,
      is_local,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->is_local (
          is_local,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var interface_id;
  if (!(
    (_tao_in >> interface_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_a ri (
      _tao_server_request,
      _tao_impl,
      interface_id.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_a (
          interface_id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::create_attribute_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR_AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var type;
  IR_AttributeMode mode;
  IR_ExceptionDefSeq get_exceptions;
  IR_ExceptionDefSeq put_exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> get_exceptions) &&
    (_tao_in >> put_exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_attribute (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          mode,
          get_exceptions,
          put_exceptions,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_AttributeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::create_operation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR_OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var result;
  IR_OperationMode mode;
  IR_ParDescriptionSeq params;
  IR_ExceptionDefSeq exceptions;
  IR_ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      result.in (),
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_operation (
          id.in (),
          name.in (),
          version.in (),
          result.in (),
          mode,
          params,
          exceptions,
          contexts,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_OperationDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::InterfaceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::InterfaceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::InterfaceDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::InterfaceDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::InterfaceDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/InterfaceDef:1.0";
}

IR::InterfaceDef*
POA_IR::InterfaceDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_InterfaceDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_get::result (IR::InterfaceDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_set::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;

  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_base_interfaces_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_set::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    const CORBA::Boolean & is_abstract,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    is_abstract_ (is_abstract)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_abstract_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_set::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    const CORBA::Boolean & is_local,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    is_local_ (is_local)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_is_local = parameter_list->length ();
  parameter_list->length (length_is_local + 1);
  (*parameter_list)[length_is_local].argument <<= CORBA::Any::from_boolean (this->is_local_);
  (*parameter_list)[length_is_local].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_local_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_a::TAO_ServerRequestInfo_IR_InterfaceDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    const char * interface_id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    interface_id_ (interface_id)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_interface_id = parameter_list->length ();
  parameter_list->length (length_interface_id + 1);
  (*parameter_list)[length_interface_id].argument <<= interface_id_;
  (*parameter_list)[length_interface_id].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_a::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_a::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode & mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    mode_ (mode),
    get_exceptions_ (get_exceptions),
    put_exceptions_ (put_exceptions)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;

  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;

  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_get_exceptions = parameter_list->length ();
  parameter_list->length (length_get_exceptions + 1);
  (*parameter_list)[length_get_exceptions].argument <<=  this->get_exceptions_;

  (*parameter_list)[length_get_exceptions].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_put_exceptions = parameter_list->length ();
  parameter_list->length (length_put_exceptions + 1);
  (*parameter_list)[length_put_exceptions].argument <<=  this->put_exceptions_;

  (*parameter_list)[length_put_exceptions].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_attribute::result (IR::AttributeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::InterfaceDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode & mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    result_ (result),
    mode_ (mode),
    params_ (params),
    exceptions_ (exceptions),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_result = parameter_list->length ();
  parameter_list->length (length_result + 1);
  (*parameter_list)[length_result].argument <<=  this->result_;

  (*parameter_list)[length_result].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;

  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;

  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;

  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_contexts = parameter_list->length ();
  parameter_list->length (length_contexts + 1);
  (*parameter_list)[length_contexts].argument <<=  this->contexts_;

  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::InterfaceDef::TAO_ServerRequestInfo_IR_InterfaceDef_create_operation::result (IR::OperationDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ValueMemberDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueMemberDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueMemberDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37,  0, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueMemberDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueMemberDef::move_skel},
      {"_is_a",  &POA_IR::ValueMemberDef::_is_a_skel},
      {"_get_id",       &POA_IR::ValueMemberDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueMemberDef::_set_id_skel},
      {"describe",      &POA_IR::ValueMemberDef::describe_skel},
      {"_get_type",     &POA_IR::ValueMemberDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueMemberDef::_set_name_skel},
      {"_get_name",     &POA_IR::ValueMemberDef::_get_name_skel},
      {"_get_access",   &POA_IR::ValueMemberDef::_get_access_skel},
      {"_set_access",   &POA_IR::ValueMemberDef::_set_access_skel},
      {"_get_version",  &POA_IR::ValueMemberDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueMemberDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ValueMemberDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ValueMemberDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ValueMemberDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ValueMemberDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::ValueMemberDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::ValueMemberDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::ValueMemberDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ValueMemberDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46,  -1, -47, -46,  16,
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ValueMemberDef_Perfect_Hash_OpTable tao_IR_ValueMemberDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker *POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::the_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::~_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ValueMemberDef_Proxy_Impl&
POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::select_proxy (
    IR_ValueMemberDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueMemberDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueMemberDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueMemberDef_Proxy_Broker *
_TAO_ValueMemberDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::the_TAO_ValueMemberDef_Strategized_Proxy_Broker();
}

int
_TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ValueMemberDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ValueMemberDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

IR_IDLType_ptr POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type_def (
        type_def,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Visibility POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Visibility _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "access",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->access (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "access",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->access (
        access,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ValueMemberDef::ValueMemberDef (void)
{
  this->optable_ = &tao_IR_ValueMemberDef_optable;
}

// copy ctor
POA_IR::ValueMemberDef::ValueMemberDef (const ValueMemberDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueMemberDef::~ValueMemberDef (void)
{
}

void POA_IR::ValueMemberDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::TypeCode_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueMemberDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueMemberDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  IR_IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->type_def (
          type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueMemberDef::_get_access_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::Visibility _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->access (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Visibility _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval)
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueMemberDef::_set_access_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::Visibility access;
  if (!(
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_set ri (
      _tao_server_request,
      _tao_impl ,
      access,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->access (
          access,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueMemberDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueMemberDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueMemberDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueMemberDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueMemberDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueMemberDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueMemberDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueMemberDef:1.0";
}

IR::ValueMemberDef*
POA_IR::ValueMemberDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ValueMemberDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueMemberDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueMemberDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_set::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueMemberDef *tao_impl,
    IR_IDLType_ptr type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_type_def = parameter_list->length ();
  parameter_list->length (length_type_def + 1);
  (*parameter_list)[length_type_def].argument <<=  this->type_def_;

  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueMemberDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_get::result (CORBA::Visibility result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_set::TAO_ServerRequestInfo_IR_ValueMemberDef_access_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueMemberDef *tao_impl,
    const CORBA::Visibility & access,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    access_ (access)
{}

Dynamic::ParameterList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_access = parameter_list->length ();
  parameter_list->length (length_access + 1);
  (*parameter_list)[length_access].argument <<= access_;
  (*parameter_list)[length_access].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueMemberDef::TAO_ServerRequestInfo_IR_ValueMemberDef_access_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ValueDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 50, 35,  0, 86, 86, 86, 20, 86, 86,
     86, 86, 86, 86, 86, 86, 86,  0,  0, 15,
     86,  0, 86,  0, 86, 86, 86, 86, 86, 86,
     86, 86, 20, 20, 86, 86, 86,  5,  5, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86,
#else
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86,  0, 86,  0, 86, 50,
     35,  0, 86, 86, 86, 20, 86, 86,  0,  0,
     15, 86,  0, 86,  0, 20, 20, 86, 86, 86,
      5,  5, 86, 86, 86, 86, 86, 86,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 85,
      HASH_VALUE_RANGE = 82,
      DUPLICATES = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueDef::move_skel},
      {"_is_a",  &POA_IR::ValueDef::_is_a_skel},
      {"lookup",        &POA_IR::ValueDef::lookup_skel},
      {"_get_name",     &POA_IR::ValueDef::_get_name_skel},
      {"_get_type",     &POA_IR::ValueDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueDef::_set_name_skel},
      {"lookup_name",   &POA_IR::ValueDef::lookup_name_skel},
      {"_get_is_custom",        &POA_IR::ValueDef::_get_is_custom_skel},
      {"_set_is_custom",        &POA_IR::ValueDef::_set_is_custom_skel},
      {"_get_base_value",       &POA_IR::ValueDef::_get_base_value_skel},
      {"_set_base_value",       &POA_IR::ValueDef::_set_base_value_skel},
      {"_get_absolute_name",    &POA_IR::ValueDef::_get_absolute_name_skel},
      {"_get_is_truncatable",   &POA_IR::ValueDef::_get_is_truncatable_skel},
      {"_set_is_truncatable",   &POA_IR::ValueDef::_set_is_truncatable_skel},
      {"is_a",  &POA_IR::ValueDef::is_a_skel},
      {"_get_version",  &POA_IR::ValueDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueDef::_set_version_skel},
      {"_get_defined_in",       &POA_IR::ValueDef::_get_defined_in_skel},
      {"_get_containing_repository",    &POA_IR::ValueDef::_get_containing_repository_skel},
      {"_non_existent",  &POA_IR::ValueDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::ValueDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::ValueDef::_set_is_abstract_skel},
      {"_get_initializers",     &POA_IR::ValueDef::_get_initializers_skel},
      {"_set_initializers",     &POA_IR::ValueDef::_set_initializers_skel},
      {"_get_id",       &POA_IR::ValueDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueDef::_set_id_skel},
      {"describe",      &POA_IR::ValueDef::describe_skel},
      {"_get_supported_interfaces",     &POA_IR::ValueDef::_get_supported_interfaces_skel},
      {"_set_abstract_base_values",     &POA_IR::ValueDef::_set_abstract_base_values_skel},
      {"_get_abstract_base_values",     &POA_IR::ValueDef::_get_abstract_base_values_skel},
      {"_set_supported_interfaces",     &POA_IR::ValueDef::_set_supported_interfaces_skel},
      {"destroy",       &POA_IR::ValueDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ValueDef::_get_def_kind_skel},
      {"create_enum",   &POA_IR::ValueDef::create_enum_skel},
      {"create_value",  &POA_IR::ValueDef::create_value_skel},
      {"create_module",         &POA_IR::ValueDef::create_module_skel},
      {"create_native",         &POA_IR::ValueDef::create_native_skel},
      {"create_attribute",      &POA_IR::ValueDef::create_attribute_skel},
      {"create_interface",      &POA_IR::ValueDef::create_interface_skel},
      {"create_value_member",   &POA_IR::ValueDef::create_value_member_skel},
      {"create_value_box",      &POA_IR::ValueDef::create_value_box_skel},
      {"describe_contents",     &POA_IR::ValueDef::describe_contents_skel},
      {"create_union",  &POA_IR::ValueDef::create_union_skel},
      {"contents",      &POA_IR::ValueDef::contents_skel},
      {"create_operation",      &POA_IR::ValueDef::create_operation_skel},
      {"create_exception",      &POA_IR::ValueDef::create_exception_skel},
      {"create_alias",  &POA_IR::ValueDef::create_alias_skel},
      {"create_struct",         &POA_IR::ValueDef::create_struct_skel},
      {"create_constant",       &POA_IR::ValueDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -7,  -3,   4,   5,   6, -11,  -2, -92,  -1,  10, -13,  -2,
      -92, -88, -16,  -2,  15, -88,  -1,  -1,  -1,  -1,  18, -19,  -2, -87,
      -24,  -2,  21,  22,  -1,  23, -26,  -2, -93, -88, -28,  -2, -31,  -4,
      -89,  30,  -1, -90,  -1,  35,  36,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       -1,  -1,  -1, -39,  -2,  37,  38, -89, -41,  -2, -87,  -1,  -1,  43,
       -1,  44,  45,  -1,  -1,  -1,  -1,  46,  47, -48,  -2, -87,  50,  51,
       -1,  52,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ValueDef_Perfect_Hash_OpTable tao_IR_ValueDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker *POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::the_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::~_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ValueDef_Proxy_Impl&
POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::select_proxy (
    IR_ValueDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueDef_Proxy_Broker *
_TAO_ValueDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::the_TAO_ValueDef_Strategized_Proxy_Broker();
}

int
_TAO_ValueDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ValueDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ValueDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ValueDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ValueDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ValueDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::_TAO_ValueDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_InterfaceDefSeq * POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->supported_interfaces (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->supported_interfaces (
        supported_interfaces,
        ACE_TRY_ENV
      );
  return;
}

IR_InitializerSeq * POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InitializerSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "initializers",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->initializers (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "initializers",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->initializers (
        initializers,
        ACE_TRY_ENV
      );
  return;
}

IR_ValueDef_ptr POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->base_value (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    IR_ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->base_value (
        base_value,
        ACE_TRY_ENV
      );
  return;
}

IR_ValueDefSeq * POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "abstract_base_values",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->abstract_base_values (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    const IR_ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "abstract_base_values",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->abstract_base_values (
        abstract_base_values,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_abstract (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_abstract (
        is_abstract,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_custom",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_custom (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_custom",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_custom (
        is_custom,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_truncatable",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_truncatable (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_truncatable",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_truncatable (
        is_truncatable,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_a (
        id,
        ACE_TRY_ENV
      );
}

IR_ValueMemberDef_ptr POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_value_member (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueMemberDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value_member",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_value_member (
        id,
        name,
        version,
        type,
        access,
        ACE_TRY_ENV
      );
}

IR_AttributeDef_ptr POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_attribute",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_attribute (
        id,
        name,
        version,
        type,
        mode,
        get_exceptions,
        put_exceptions,
        ACE_TRY_ENV
      );
}

IR_OperationDef_ptr POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_operation",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_operation (
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ValueDef::ValueDef (void)
{
  this->optable_ = &tao_IR_ValueDef_optable;
}

// copy ctor
POA_IR::ValueDef::ValueDef (const ValueDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueDef::~ValueDef (void)
{
}

void POA_IR::ValueDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_InterfaceDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->supported_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_InterfaceDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_set ri (
      _tao_server_request,
      _tao_impl,
      supported_interfaces,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->supported_interfaces (
          supported_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_get_initializers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_InitializerSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->initializers (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_InitializerSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_set_initializers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_InitializerSeq initializers;
  if (!(
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_set ri (
      _tao_server_request,
      _tao_impl,
      initializers,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->initializers (
          initializers,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_get_base_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->base_value (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_set_base_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueDef_var base_value;
  if (!(
    (_tao_in >> base_value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_set ri (
      _tao_server_request,
      _tao_impl,
      base_value.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->base_value (
          base_value.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_get_abstract_base_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->abstract_base_values (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ValueDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_set_abstract_base_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueDefSeq abstract_base_values;
  if (!(
    (_tao_in >> abstract_base_values)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_set ri (
      _tao_server_request,
      _tao_impl,
      abstract_base_values,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->abstract_base_values (
          abstract_base_values,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_get_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_abstract (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_set_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_abstract;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_abstract))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_set ri (
      _tao_server_request,
      _tao_impl,
      is_abstract,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->is_abstract (
          is_abstract,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_get_is_custom_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_custom (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_set_is_custom_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_custom;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_custom))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_set ri (
      _tao_server_request,
      _tao_impl,
      is_custom,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->is_custom (
          is_custom,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_get_is_truncatable_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_truncatable (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_set_is_truncatable_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_truncatable;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_set ri (
      _tao_server_request,
      _tao_impl,
      is_truncatable,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->is_truncatable (
          is_truncatable,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_a ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_a (
          id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::create_value_member_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueMemberDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var type;
  CORBA::Visibility access;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_value_member ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      access,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_value_member (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          access,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ValueMemberDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::create_attribute_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var type;
  IR_AttributeMode mode;
  IR_ExceptionDefSeq get_exceptions;
  IR_ExceptionDefSeq put_exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> get_exceptions) &&
    (_tao_in >> put_exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_attribute ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_attribute (
          id.in (),
          name.in (),
          version.in (),
          type.in (),
          mode,
          get_exceptions,
          put_exceptions,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_AttributeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::create_operation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var result;
  IR_OperationMode mode;
  IR_ParDescriptionSeq params;
  IR_ExceptionDefSeq exceptions;
  IR_ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_operation ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      result.in (),
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_operation (
          id.in (),
          name.in (),
          version.in (),
          result.in (),
          mode,
          params,
          exceptions,
          contexts,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_OperationDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueDef:1.0";
}

IR::ValueDef*
POA_IR::ValueDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ValueDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_get::result (IR::InterfaceDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_set::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;

  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_supported_interfaces_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_get::TAO_ServerRequestInfo_IR_ValueDef_initializers_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_get::result (IR::InitializerSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_set::TAO_ServerRequestInfo_IR_ValueDef_initializers_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    initializers_ (initializers)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_initializers = parameter_list->length ();
  parameter_list->length (length_initializers + 1);
  (*parameter_list)[length_initializers].argument <<=  this->initializers_;

  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_initializers_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_get::TAO_ServerRequestInfo_IR_ValueDef_base_value_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_get::result (IR::ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_set::TAO_ServerRequestInfo_IR_ValueDef_base_value_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl ,
    IR_ValueDef_ptr base_value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    base_value_ (base_value)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_base_value = parameter_list->length ();
  parameter_list->length (length_base_value + 1);
  (*parameter_list)[length_base_value].argument <<=  this->base_value_;

  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_base_value_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_get::result (IR::ValueDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_set::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const IR_ValueDefSeq & abstract_base_values,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    abstract_base_values_ (abstract_base_values)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_abstract_base_values = parameter_list->length ();
  parameter_list->length (length_abstract_base_values + 1);
  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;

  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_abstract_base_values_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_set::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const CORBA::Boolean & is_abstract,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    is_abstract_ (is_abstract)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_abstract_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_set::TAO_ServerRequestInfo_IR_ValueDef_is_custom_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const CORBA::Boolean & is_custom,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    is_custom_ (is_custom)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_is_custom = parameter_list->length ();
  parameter_list->length (length_is_custom + 1);
  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_custom_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_set::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const CORBA::Boolean & is_truncatable,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    is_truncatable_ (is_truncatable)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_is_truncatable = parameter_list->length ();
  parameter_list->length (length_is_truncatable + 1);
  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_truncatable_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_a::TAO_ServerRequestInfo_IR_ValueDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const char * id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_a::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_a::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_value_member::TAO_ServerRequestInfo_IR_ValueDef_create_value_member (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    const CORBA::Visibility & access,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    access_ (access)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_value_member::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;

  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_access = parameter_list->length ();
  parameter_list->length (length_access + 1);
  (*parameter_list)[length_access].argument <<= access_;
  (*parameter_list)[length_access].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_value_member::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_value_member::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_value_member::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_value_member::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_value_member::result (IR::ValueMemberDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_attribute::TAO_ServerRequestInfo_IR_ValueDef_create_attribute (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode & mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    mode_ (mode),
    get_exceptions_ (get_exceptions),
    put_exceptions_ (put_exceptions)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_attribute::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;

  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;

  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_get_exceptions = parameter_list->length ();
  parameter_list->length (length_get_exceptions + 1);
  (*parameter_list)[length_get_exceptions].argument <<=  this->get_exceptions_;

  (*parameter_list)[length_get_exceptions].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_put_exceptions = parameter_list->length ();
  parameter_list->length (length_put_exceptions + 1);
  (*parameter_list)[length_put_exceptions].argument <<=  this->put_exceptions_;

  (*parameter_list)[length_put_exceptions].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_attribute::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_attribute::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_attribute::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_attribute::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_attribute::result (IR::AttributeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_operation::TAO_ServerRequestInfo_IR_ValueDef_create_operation (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode & mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    result_ (result),
    mode_ (mode),
    params_ (params),
    exceptions_ (exceptions),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_operation::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_result = parameter_list->length ();
  parameter_list->length (length_result + 1);
  (*parameter_list)[length_result].argument <<=  this->result_;

  (*parameter_list)[length_result].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;

  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;

  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;

  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_contexts = parameter_list->length ();
  parameter_list->length (length_contexts + 1);
  (*parameter_list)[length_contexts].argument <<=  this->contexts_;

  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_operation::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_operation::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_operation::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_operation::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueDef::TAO_ServerRequestInfo_IR_ValueDef_create_operation::result (IR::OperationDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ValueBoxDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueBoxDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueBoxDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueBoxDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueBoxDef::move_skel},
      {"_is_a",  &POA_IR::ValueBoxDef::_is_a_skel},
      {"_get_id",       &POA_IR::ValueBoxDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueBoxDef::_set_id_skel},
      {"describe",      &POA_IR::ValueBoxDef::describe_skel},
      {"_get_name",     &POA_IR::ValueBoxDef::_get_name_skel},
      {"_get_type",     &POA_IR::ValueBoxDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueBoxDef::_set_name_skel},
      {"_get_version",  &POA_IR::ValueBoxDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueBoxDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ValueBoxDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ValueBoxDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ValueBoxDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ValueBoxDef::_get_absolute_name_skel},
      {"_get_original_type_def",        &POA_IR::ValueBoxDef::_get_original_type_def_skel},
      {"_set_original_type_def",        &POA_IR::ValueBoxDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_IR::ValueBoxDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ValueBoxDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ValueBoxDef_Perfect_Hash_OpTable tao_IR_ValueBoxDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker *POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::the_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::~_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ValueBoxDef_Proxy_Impl&
POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::select_proxy (
    IR_ValueBoxDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueBoxDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueBoxDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueBoxDef_Proxy_Broker *
_TAO_ValueBoxDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::the_TAO_ValueBoxDef_Strategized_Proxy_Broker();
}

int
_TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ValueBoxDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ValueBoxDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_IDLType_ptr POA_IR::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueBoxDef:1.0"
        )
    )->original_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueBoxDef:1.0"
        )
    )->original_type_def (
        original_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ValueBoxDef::ValueBoxDef (void)
{
  this->optable_ = &tao_IR_ValueBoxDef_optable;
}

// copy ctor
POA_IR::ValueBoxDef::ValueBoxDef (const ValueBoxDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueBoxDef::~ValueBoxDef (void)
{
}

void POA_IR::ValueBoxDef::_get_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->original_type_def (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_IDLType_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueBoxDef::_set_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *)_tao_object_reference;

  IR_IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_set ri (
      _tao_server_request,
      _tao_impl,
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->original_type_def (
          original_type_def.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ValueBoxDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueBoxDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueBoxDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueBoxDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueBoxDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueBoxDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueBoxDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueBoxDef:1.0";
}

IR::ValueBoxDef*
POA_IR::ValueBoxDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ValueBoxDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueBoxDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_get::result (IR::IDLType_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_set::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ValueBoxDef *tao_impl,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;

  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ValueBoxDef::TAO_ServerRequestInfo_IR_ValueBoxDef_original_type_def_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ProvidesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ProvidesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ProvidesDef::move_skel},
      {"_is_a",  &POA_IR::ProvidesDef::_is_a_skel},
      {"_get_id",       &POA_IR::ProvidesDef::_get_id_skel},
      {"_set_id",       &POA_IR::ProvidesDef::_set_id_skel},
      {"describe",      &POA_IR::ProvidesDef::describe_skel},
      {"_get_name",     &POA_IR::ProvidesDef::_get_name_skel},
      {"_set_name",     &POA_IR::ProvidesDef::_set_name_skel},
      {"_get_version",  &POA_IR::ProvidesDef::_get_version_skel},
      {"_set_version",  &POA_IR::ProvidesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ProvidesDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ProvidesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ProvidesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ProvidesDef::_get_absolute_name_skel},
      {"_get_interface_type",   &POA_IR::ProvidesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::ProvidesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ProvidesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  -1,  15,  16,  17,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ProvidesDef_Perfect_Hash_OpTable tao_IR_ProvidesDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker *POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::the_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::~_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ProvidesDef_Proxy_Impl&
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::select_proxy (
    IR_ProvidesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ProvidesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ProvidesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ProvidesDef_Proxy_Broker *
_TAO_ProvidesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::the_TAO_ProvidesDef_Strategized_Proxy_Broker();
}

int
_TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ProvidesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ProvidesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ProvidesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::_TAO_ProvidesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_InterfaceDef_ptr POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "interface_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ProvidesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ProvidesDef:1.0"
        )
    )->interface_type (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ProvidesDef::ProvidesDef (void)
{
  this->optable_ = &tao_IR_ProvidesDef_optable;
}

// copy ctor
POA_IR::ProvidesDef::ProvidesDef (const ProvidesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ProvidesDef::~ProvidesDef (void)
{
}

void POA_IR::ProvidesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *)_tao_object_reference;

  IR_InterfaceDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ProvidesDef::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->interface_type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ProvidesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ProvidesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ProvidesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ProvidesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ProvidesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ProvidesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ProvidesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

IR::ProvidesDef*
POA_IR::ProvidesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ProvidesDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ProvidesDef::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ProvidesDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ProvidesDef::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ProvidesDef::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ProvidesDef::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ProvidesDef::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ProvidesDef::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ProvidesDef::TAO_ServerRequestInfo_IR_ProvidesDef_interface_type_get::result (IR::InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_UsesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_UsesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_UsesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_UsesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::UsesDef::move_skel},
      {"_is_a",  &POA_IR::UsesDef::_is_a_skel},
      {"_get_id",       &POA_IR::UsesDef::_get_id_skel},
      {"_set_id",       &POA_IR::UsesDef::_set_id_skel},
      {"describe",      &POA_IR::UsesDef::describe_skel},
      {"_get_name",     &POA_IR::UsesDef::_get_name_skel},
      {"_set_name",     &POA_IR::UsesDef::_set_name_skel},
      {"_get_version",  &POA_IR::UsesDef::_get_version_skel},
      {"_set_version",  &POA_IR::UsesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::UsesDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::UsesDef::_get_defined_in_skel},
      {"_get_is_multiple",      &POA_IR::UsesDef::_get_is_multiple_skel},
      {"destroy",       &POA_IR::UsesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::UsesDef::_get_absolute_name_skel},
      {"_get_interface_type",   &POA_IR::UsesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::UsesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::UsesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  15,  16,  17,  18,  -1,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_UsesDef_Perfect_Hash_OpTable tao_IR_UsesDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker *POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::the_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::~_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_UsesDef_Proxy_Impl&
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::select_proxy (
    IR_UsesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_UsesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_UsesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_UsesDef_Proxy_Broker *
_TAO_UsesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::the_TAO_UsesDef_Strategized_Proxy_Broker();
}

int
_TAO_UsesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_UsesDef_Proxy_Broker_Factory_function_pointer =
    _TAO_UsesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_UsesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_UsesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_UsesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::_TAO_UsesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_InterfaceDef_ptr POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "interface_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->interface_type (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_multiple",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->is_multiple (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::UsesDef::UsesDef (void)
{
  this->optable_ = &tao_IR_UsesDef_optable;
}

// copy ctor
POA_IR::UsesDef::UsesDef (const UsesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::UsesDef::~UsesDef (void)
{
}

void POA_IR::UsesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *)_tao_object_reference;

  IR_InterfaceDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->interface_type (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_InterfaceDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UsesDef::_get_is_multiple_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_multiple (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::UsesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UsesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::UsesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::UsesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/UsesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::UsesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::UsesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

IR::UsesDef*
POA_IR::UsesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_UsesDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UsesDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_interface_type_get::result (IR::InterfaceDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::UsesDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::UsesDef::TAO_ServerRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_EventDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EventDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EventDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EventDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EventDef::move_skel},
      {"_is_a",  &POA_IR::EventDef::_is_a_skel},
      {"_get_id",       &POA_IR::EventDef::_get_id_skel},
      {"_set_id",       &POA_IR::EventDef::_set_id_skel},
      {"describe",      &POA_IR::EventDef::describe_skel},
      {"_get_name",     &POA_IR::EventDef::_get_name_skel},
      {"_set_name",     &POA_IR::EventDef::_set_name_skel},
      {"_get_version",  &POA_IR::EventDef::_get_version_skel},
      {"_set_version",  &POA_IR::EventDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EventDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::EventDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::EventDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EventDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EventDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::EventDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EventDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EventDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_EventDef_Perfect_Hash_OpTable tao_IR_EventDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker *POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::the_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EventDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::~_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_EventDef_Proxy_Impl&
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::select_proxy (
    IR_EventDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EventDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EventDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_EventDef_Proxy_Broker *
_TAO_EventDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::the_TAO_EventDef_Strategized_Proxy_Broker();
}

int
_TAO_EventDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_EventDef_Proxy_Broker_Factory_function_pointer =
    _TAO_EventDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_EventDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_EventDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_EventDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::_TAO_EventDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->is_a (
        event_id,
        ACE_TRY_ENV
      );
}

IR_ValueDef_ptr POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "event",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->event (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EventDef::EventDef (void)
{
  this->optable_ = &tao_IR_EventDef_optable;
}

// copy ctor
POA_IR::EventDef::EventDef (const EventDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EventDef::~EventDef (void)
{
}

void POA_IR::EventDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var event_id;
  if (!(
    (_tao_in >> event_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_is_a ri (
      _tao_server_request,
      _tao_impl,
      event_id.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_a (
          event_id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::EventDef::_get_event_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *)_tao_object_reference;

  IR_ValueDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_event_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->event (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::EventDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EventDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EventDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EventDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EventDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

IR::EventDef*
POA_IR::EventDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_EventDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_is_a::TAO_ServerRequestInfo_IR_EventDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::EventDef *tao_impl,
    const char * event_id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    event_id_ (event_id)
{}

Dynamic::ParameterList *
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_event_id = parameter_list->length ();
  parameter_list->length (length_event_id + 1);
  (*parameter_list)[length_event_id].argument <<= event_id_;
  (*parameter_list)[length_event_id].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_is_a::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_is_a::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_event_get::TAO_ServerRequestInfo_IR_EventDef_event_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::EventDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_event_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_event_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_event_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_event_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_event_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::EventDef::TAO_ServerRequestInfo_IR_EventDef_event_get::result (IR::ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_EmitsDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EmitsDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EmitsDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EmitsDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EmitsDef::move_skel},
      {"_is_a",  &POA_IR::EmitsDef::_is_a_skel},
      {"_get_id",       &POA_IR::EmitsDef::_get_id_skel},
      {"_set_id",       &POA_IR::EmitsDef::_set_id_skel},
      {"describe",      &POA_IR::EmitsDef::describe_skel},
      {"_get_name",     &POA_IR::EmitsDef::_get_name_skel},
      {"_set_name",     &POA_IR::EmitsDef::_set_name_skel},
      {"_get_version",  &POA_IR::EmitsDef::_get_version_skel},
      {"_set_version",  &POA_IR::EmitsDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EmitsDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::EmitsDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::EmitsDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EmitsDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EmitsDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::EmitsDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EmitsDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EmitsDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_EmitsDef_Perfect_Hash_OpTable tao_IR_EmitsDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker *POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::the_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::~_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_EmitsDef_Proxy_Impl&
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::select_proxy (
    IR_EmitsDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EmitsDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EmitsDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_EmitsDef_Proxy_Broker *
_TAO_EmitsDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::the_TAO_EmitsDef_Strategized_Proxy_Broker();
}

int
_TAO_EmitsDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_EmitsDef_Proxy_Broker_Factory_function_pointer =
    _TAO_EmitsDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_EmitsDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_EmitsDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_EmitsDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EmitsDef_ThruPOA_Proxy_Impl::_TAO_EmitsDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EmitsDef::EmitsDef (void)
{
  this->optable_ = &tao_IR_EmitsDef_optable;
}

// copy ctor
POA_IR::EmitsDef::EmitsDef (const EmitsDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EmitsDef::~EmitsDef (void)
{
}

void POA_IR::EmitsDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EmitsDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EmitsDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EmitsDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EmitsDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EmitsDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EmitsDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

IR::EmitsDef*
POA_IR::EmitsDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_EmitsDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_PublishesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PublishesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PublishesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PublishesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::PublishesDef::move_skel},
      {"_is_a",  &POA_IR::PublishesDef::_is_a_skel},
      {"_get_id",       &POA_IR::PublishesDef::_get_id_skel},
      {"_set_id",       &POA_IR::PublishesDef::_set_id_skel},
      {"describe",      &POA_IR::PublishesDef::describe_skel},
      {"_get_name",     &POA_IR::PublishesDef::_get_name_skel},
      {"_set_name",     &POA_IR::PublishesDef::_set_name_skel},
      {"_get_version",  &POA_IR::PublishesDef::_get_version_skel},
      {"_set_version",  &POA_IR::PublishesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::PublishesDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::PublishesDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::PublishesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::PublishesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::PublishesDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::PublishesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::PublishesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::PublishesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_PublishesDef_Perfect_Hash_OpTable tao_IR_PublishesDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker *POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::the_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::~_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_PublishesDef_Proxy_Impl&
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::select_proxy (
    IR_PublishesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PublishesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PublishesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_PublishesDef_Proxy_Broker *
_TAO_PublishesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::the_TAO_PublishesDef_Strategized_Proxy_Broker();
}

int
_TAO_PublishesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_PublishesDef_Proxy_Broker_Factory_function_pointer =
    _TAO_PublishesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_PublishesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_PublishesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_PublishesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PublishesDef_ThruPOA_Proxy_Impl::_TAO_PublishesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PublishesDef::PublishesDef (void)
{
  this->optable_ = &tao_IR_PublishesDef_optable;
}

// copy ctor
POA_IR::PublishesDef::PublishesDef (const PublishesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PublishesDef::~PublishesDef (void)
{
}

void POA_IR::PublishesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PublishesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PublishesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PublishesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PublishesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PublishesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PublishesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

IR::PublishesDef*
POA_IR::PublishesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_PublishesDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ConsumesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ConsumesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ConsumesDef::move_skel},
      {"_is_a",  &POA_IR::ConsumesDef::_is_a_skel},
      {"_get_id",       &POA_IR::ConsumesDef::_get_id_skel},
      {"_set_id",       &POA_IR::ConsumesDef::_set_id_skel},
      {"describe",      &POA_IR::ConsumesDef::describe_skel},
      {"_get_name",     &POA_IR::ConsumesDef::_get_name_skel},
      {"_set_name",     &POA_IR::ConsumesDef::_set_name_skel},
      {"_get_version",  &POA_IR::ConsumesDef::_get_version_skel},
      {"_set_version",  &POA_IR::ConsumesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ConsumesDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::ConsumesDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::ConsumesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ConsumesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ConsumesDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::ConsumesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::ConsumesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ConsumesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ConsumesDef_Perfect_Hash_OpTable tao_IR_ConsumesDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker *POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::the_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::~_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ConsumesDef_Proxy_Impl&
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::select_proxy (
    IR_ConsumesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ConsumesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ConsumesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ConsumesDef_Proxy_Broker *
_TAO_ConsumesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::the_TAO_ConsumesDef_Strategized_Proxy_Broker();
}

int
_TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ConsumesDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ConsumesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ConsumesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ConsumesDef_ThruPOA_Proxy_Impl::_TAO_ConsumesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ConsumesDef::ConsumesDef (void)
{
  this->optable_ = &tao_IR_ConsumesDef_optable;
}

// copy ctor
POA_IR::ConsumesDef::ConsumesDef (const ConsumesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ConsumesDef::~ConsumesDef (void)
{
}

void POA_IR::ConsumesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConsumesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ConsumesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ConsumesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ConsumesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ConsumesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ConsumesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

IR::ConsumesDef*
POA_IR::ConsumesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ConsumesDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_ComponentDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82,  0,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82,  0,
     82, 30,  5, 10, 82, 82, 82,  0, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 45, 30, 15,
     82, 30, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82,  0, 20, 82, 82, 82, 30, 25, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82,
#else
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82,  0, 82,  0, 82, 30,
      5, 10, 82, 82, 82,  0, 82, 82, 45, 30,
     15, 82, 30, 82, 82,  0, 20, 82, 82, 82,
     30, 25, 82, 82, 82, 82, 82, 82,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 54,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 81,
      HASH_VALUE_RANGE = 78,
      DUPLICATES = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a",  &POA_IR::ComponentDef::is_a_skel},
      {"_is_a",  &POA_IR::ComponentDef::_is_a_skel},
      {"_get_id",       &POA_IR::ComponentDef::_get_id_skel},
      {"_set_id",       &POA_IR::ComponentDef::_set_id_skel},
      {"_get_emits_events",     &POA_IR::ComponentDef::_get_emits_events_skel},
      {"_get_def_kind",         &POA_IR::ComponentDef::_get_def_kind_skel},
      {"_get_name",     &POA_IR::ComponentDef::_get_name_skel},
      {"_get_type",     &POA_IR::ComponentDef::_get_type_skel},
      {"_set_name",     &POA_IR::ComponentDef::_set_name_skel},
      {"_get_uses_interfaces",  &POA_IR::ComponentDef::_get_uses_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::ComponentDef::_set_base_interfaces_skel},
      {"_get_base_interfaces",  &POA_IR::ComponentDef::_get_base_interfaces_skel},
      {"_get_consumes_events",  &POA_IR::ComponentDef::_get_consumes_events_skel},
      {"_get_publishes_events",         &POA_IR::ComponentDef::_get_publishes_events_skel},
      {"describe_contents",     &POA_IR::ComponentDef::describe_contents_skel},
      {"describe",      &POA_IR::ComponentDef::describe_skel},
      {"_get_provides_interfaces",      &POA_IR::ComponentDef::_get_provides_interfaces_skel},
      {"_get_supported_interfaces",     &POA_IR::ComponentDef::_get_supported_interfaces_skel},
      {"_set_supported_interfaces",     &POA_IR::ComponentDef::_set_supported_interfaces_skel},
      {"_get_version",  &POA_IR::ComponentDef::_get_version_skel},
      {"_set_version",  &POA_IR::ComponentDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ComponentDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::ComponentDef::_get_defined_in_skel},
      {"_non_existent",  &POA_IR::ComponentDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::ComponentDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::ComponentDef::_set_is_abstract_skel},
      {"destroy",       &POA_IR::ComponentDef::destroy_skel},
      {"contents",      &POA_IR::ComponentDef::contents_skel},
      {"_get_base_component",   &POA_IR::ComponentDef::_get_base_component_skel},
      {"create_uses",   &POA_IR::ComponentDef::create_uses_skel},
      {"create_emits",  &POA_IR::ComponentDef::create_emits_skel},
      {"create_alias",  &POA_IR::ComponentDef::create_alias_skel},
      {"_get_is_basic",         &POA_IR::ComponentDef::_get_is_basic_skel},
      {"move",  &POA_IR::ComponentDef::move_skel},
      {"create_provides",       &POA_IR::ComponentDef::create_provides_skel},
      {"create_consumes",       &POA_IR::ComponentDef::create_consumes_skel},
      {"create_publishes",      &POA_IR::ComponentDef::create_publishes_skel},
      {"_get_containing_repository",    &POA_IR::ComponentDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::ComponentDef::create_value_skel},
      {"create_module",         &POA_IR::ComponentDef::create_module_skel},
      {"create_native",         &POA_IR::ComponentDef::create_native_skel},
      {"create_attribute",      &POA_IR::ComponentDef::create_attribute_skel},
      {"create_interface",      &POA_IR::ComponentDef::create_interface_skel},
      {"create_union",  &POA_IR::ComponentDef::create_union_skel},
      {"_get_is_local",         &POA_IR::ComponentDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::ComponentDef::_set_is_local_skel},
      {"create_operation",      &POA_IR::ComponentDef::create_operation_skel},
      {"create_exception",      &POA_IR::ComponentDef::create_exception_skel},
      {"create_struct",         &POA_IR::ComponentDef::create_struct_skel},
      {"create_constant",       &POA_IR::ComponentDef::create_constant_skel},
      {"lookup_name",   &POA_IR::ComponentDef::lookup_name_skel},
      {"create_enum",   &POA_IR::ComponentDef::create_enum_skel},
      {"create_value_box",      &POA_IR::ComponentDef::create_value_box_skel},
      {"lookup",        &POA_IR::ComponentDef::lookup_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -6,   -2,    4,    5,  -10,   -3,  -13,   -4,  -21,   -2,  -91,  -23,
        -2,  -28,   -2,    8,    9,  -94,  -93,   17,   18,   19,   20,  -96,   -1,  -95,
        25,   -1,   26,  -34,   -2,   27,  -38,   -2, -102,   30,   31,   32,   -1,   33,
       -92,   36,   37,  -92,   40,  -43,   -2,  -45,   -2,   41,   42,  -87,  -48,   -2,
       -88,   47,  -85,  -50,   -2,  -83,   -1,   52,   -1,   53,   54,   -1,   -1,   -1,
        -1,   55,   -1,   -1,   -1,   -1,   56,   -1,   -1,   -1,   -1,   57,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ComponentDef_Perfect_Hash_OpTable tao_IR_ComponentDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker *POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::the_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::~_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_ComponentDef_Proxy_Impl&
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::select_proxy (
    IR_ComponentDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ComponentDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ComponentDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ComponentDef_Proxy_Broker *
_TAO_ComponentDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::the_TAO_ComponentDef_Strategized_Proxy_Broker();
}

int
_TAO_ComponentDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_ComponentDef_Proxy_Broker_Factory_function_pointer =
    _TAO_ComponentDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_ComponentDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_ComponentDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ComponentDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::_TAO_ComponentDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_InterfaceDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
        supported_interfaces,
        ACE_TRY_ENV
      );
  return;
}

IR_ComponentDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->base_component (
        ACE_TRY_ENV
      );
}

IR_ProvidesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::provides_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ProvidesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "provides_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->provides_interfaces (
        ACE_TRY_ENV
      );
}

IR_UsesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::uses_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_UsesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "uses_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->uses_interfaces (
        ACE_TRY_ENV
      );
}

IR_EmitsDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::emits_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_EmitsDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "emits_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->emits_events (
        ACE_TRY_ENV
      );
}

IR_PublishesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::publishes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PublishesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "publishes_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->publishes_events (
        ACE_TRY_ENV
      );
}

IR_ConsumesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::consumes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ConsumesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "consumes_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->consumes_events (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_basic",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->is_basic (
        ACE_TRY_ENV
      );
}

IR_ProvidesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_provides (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ProvidesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_provides",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_provides (
        id,
        name,
        version,
        interface_type,
        ACE_TRY_ENV
      );
}

IR_UsesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_uses (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_UsesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_uses",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_uses (
        id,
        name,
        version,
        interface_type,
        is_multiple,
        ACE_TRY_ENV
      );
}

IR_EmitsDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_emits (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_EmitsDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_emits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_emits (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

IR_PublishesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_publishes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PublishesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_publishes",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_publishes (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

IR_ConsumesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_consumes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ConsumesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_consumes",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_consumes (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ComponentDef::ComponentDef (void)
{
  this->optable_ = &tao_IR_ComponentDef_optable;
}

// copy ctor
POA_IR::ComponentDef::ComponentDef (const ComponentDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentDef::~ComponentDef (void)
{
}

void POA_IR::ComponentDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_InterfaceDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->supported_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_InterfaceDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set ri (
      _tao_server_request,
      _tao_impl,
      supported_interfaces,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->supported_interfaces (
          supported_interfaces,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_base_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ComponentDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->base_component (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_provides_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ProvidesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->provides_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ProvidesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_uses_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_UsesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->uses_interfaces (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_UsesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_emits_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_EmitsDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->emits_events (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_EmitsDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_publishes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_PublishesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->publishes_events (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_PublishesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_consumes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ConsumesDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->consumes_events (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ConsumesDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_basic (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_provides_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ProvidesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_InterfaceDef_var interface_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_provides ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_provides (
          id.in (),
          name.in (),
          version.in (),
          interface_type.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ProvidesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_uses_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_UsesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_InterfaceDef_var interface_type;
  CORBA::Boolean is_multiple;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_multiple))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_uses ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      is_multiple,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_uses (
          id.in (),
          name.in (),
          version.in (),
          interface_type.in (),
          is_multiple,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_UsesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_emits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_EmitsDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_emits ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_emits (
          id.in (),
          name.in (),
          version.in (),
          value.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_EmitsDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_publishes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_PublishesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_publishes (
          id.in (),
          name.in (),
          version.in (),
          value.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_PublishesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::create_consumes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ConsumesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_consumes (
          id.in (),
          name.in (),
          version.in (),
          value.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ConsumesDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::ComponentDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ComponentDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

IR::ComponentDef*
POA_IR::ComponentDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_ComponentDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_get::result (IR::InterfaceDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;

  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return result_any;
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_supported_interfaces_set::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_base_component_get::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_provides_interfaces_get::result (IR::ProvidesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_uses_interfaces_get::result (IR::UsesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_emits_events_get::result (IR::EmitsDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_publishes_events_get::result (IR::PublishesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_consumes_events_get::result (IR::ConsumesDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_provides::TAO_ServerRequestInfo_IR_ComponentDef_create_provides (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_provides::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_interface_type = parameter_list->length ();
  parameter_list->length (length_interface_type + 1);
  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;

  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_provides::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_provides::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_provides::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_provides::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_provides::result (IR::ProvidesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_uses::TAO_ServerRequestInfo_IR_ComponentDef_create_uses (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    const CORBA::Boolean & is_multiple,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type),
    is_multiple_ (is_multiple)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_uses::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_interface_type = parameter_list->length ();
  parameter_list->length (length_interface_type + 1);
  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;

  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_is_multiple = parameter_list->length ();
  parameter_list->length (length_is_multiple + 1);
  (*parameter_list)[length_is_multiple].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
  (*parameter_list)[length_is_multiple].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_uses::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_uses::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_uses::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_uses::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_uses::result (IR::UsesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_emits::TAO_ServerRequestInfo_IR_ComponentDef_create_emits (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_emits::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;

  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_emits::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_emits::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_emits::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_emits::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_emits::result (IR::EmitsDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;

  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_publishes::result (IR::PublishesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::ComponentDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;

  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::ComponentDef::TAO_ServerRequestInfo_IR_ComponentDef_create_consumes::result (IR::ConsumesDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32,  0,  0, 32, 32, 32, 10, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,  0,  5,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 10, 32, 32, 32, 32,  5, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,
#else
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32,  0, 32,  0, 32, 32,
      0,  0, 32, 32, 32, 10, 32, 32, 32,  0,
      5, 32, 32, 32, 32, 32, 10, 32, 32, 32,
     32,  5, 32, 32, 32, 32, 32, 32,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 31,
      HASH_VALUE_RANGE = 28,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::PrimaryKeyDef::move_skel},
      {"_is_a",  &POA_IR::PrimaryKeyDef::_is_a_skel},
      {"_get_id",       &POA_IR::PrimaryKeyDef::_get_id_skel},
      {"_set_id",       &POA_IR::PrimaryKeyDef::_set_id_skel},
      {"describe",      &POA_IR::PrimaryKeyDef::describe_skel},
      {"_get_name",     &POA_IR::PrimaryKeyDef::_get_name_skel},
      {"_set_name",     &POA_IR::PrimaryKeyDef::_set_name_skel},
      {"destroy",       &POA_IR::PrimaryKeyDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::PrimaryKeyDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::PrimaryKeyDef::is_a_skel},
      {"_get_version",  &POA_IR::PrimaryKeyDef::_get_version_skel},
      {"_set_version",  &POA_IR::PrimaryKeyDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::PrimaryKeyDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::PrimaryKeyDef::_get_defined_in_skel},
      {"_get_primary_key",      &POA_IR::PrimaryKeyDef::_get_primary_key_skel},
      {"_non_existent",  &POA_IR::PrimaryKeyDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::PrimaryKeyDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -38,   8, -38,  -1,  -1,  11,  12,
       13, -14,  -2, -33,  16,  -1,  17,  18,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable tao_IR_PrimaryKeyDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker *POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::the_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::~_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_PrimaryKeyDef_Proxy_Impl&
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::select_proxy (
    IR_PrimaryKeyDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PrimaryKeyDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_PrimaryKeyDef_Proxy_Broker *
_TAO_PrimaryKeyDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::the_TAO_PrimaryKeyDef_Strategized_Proxy_Broker();
}

int
_TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer =
    _TAO_PrimaryKeyDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_PrimaryKeyDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->is_a (
        primary_key_id,
        ACE_TRY_ENV
      );
}

IR_ValueDef_ptr POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->primary_key (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (void)
{
  this->optable_ = &tao_IR_PrimaryKeyDef_optable;
}

// copy ctor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (const PrimaryKeyDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PrimaryKeyDef::~PrimaryKeyDef (void)
{
}

void POA_IR::PrimaryKeyDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var primary_key_id;
  if (!(
    (_tao_in >> primary_key_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a ri (
      _tao_server_request,
      _tao_impl,
      primary_key_id.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_a (
          primary_key_id.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::PrimaryKeyDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *)_tao_object_reference;

  IR_ValueDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->primary_key (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ValueDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::PrimaryKeyDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimaryKeyDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PrimaryKeyDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PrimaryKeyDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PrimaryKeyDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PrimaryKeyDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PrimaryKeyDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

IR::PrimaryKeyDef*
POA_IR::PrimaryKeyDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_PrimaryKeyDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::PrimaryKeyDef *tao_impl,
    const char * primary_key_id,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    primary_key_id_ (primary_key_id)
{}

Dynamic::ParameterList *
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_primary_key_id = parameter_list->length ();
  parameter_list->length (length_primary_key_id + 1);
  (*parameter_list)[length_primary_key_id].argument <<= primary_key_id_;
  (*parameter_list)[length_primary_key_id].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::PrimaryKeyDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::PrimaryKeyDef::TAO_ServerRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (IR::ValueDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_FactoryDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FactoryDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FactoryDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FactoryDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::FactoryDef::move_skel},
      {"_is_a",  &POA_IR::FactoryDef::_is_a_skel},
      {"_get_mode",     &POA_IR::FactoryDef::_get_mode_skel},
      {"_set_name",     &POA_IR::FactoryDef::_set_name_skel},
      {"_get_name",     &POA_IR::FactoryDef::_get_name_skel},
      {"_set_mode",     &POA_IR::FactoryDef::_set_mode_skel},
      {"_get_params",   &POA_IR::FactoryDef::_get_params_skel},
      {"_set_params",   &POA_IR::FactoryDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::FactoryDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::FactoryDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::FactoryDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::FactoryDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::FactoryDef::_get_version_skel},
      {"_set_version",  &POA_IR::FactoryDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::FactoryDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::FactoryDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::FactoryDef::_get_id_skel},
      {"_set_id",       &POA_IR::FactoryDef::_set_id_skel},
      {"describe",      &POA_IR::FactoryDef::describe_skel},
      {"_get_result_def",       &POA_IR::FactoryDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::FactoryDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::FactoryDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::FactoryDef::_get_result_skel},
      {"destroy",       &POA_IR::FactoryDef::destroy_skel},
      {"_non_existent",  &POA_IR::FactoryDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::FactoryDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_FactoryDef_Perfect_Hash_OpTable tao_IR_FactoryDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker *POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::the_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::~_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_FactoryDef_Proxy_Impl&
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::select_proxy (
    IR_FactoryDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FactoryDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FactoryDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_FactoryDef_Proxy_Broker *
_TAO_FactoryDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::the_TAO_FactoryDef_Strategized_Proxy_Broker();
}

int
_TAO_FactoryDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_FactoryDef_Proxy_Broker_Factory_function_pointer =
    _TAO_FactoryDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_FactoryDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_FactoryDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_FactoryDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FactoryDef_ThruPOA_Proxy_Impl::_TAO_FactoryDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FactoryDef::FactoryDef (void)
{
  this->optable_ = &tao_IR_FactoryDef_optable;
}

// copy ctor
POA_IR::FactoryDef::FactoryDef (const FactoryDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,OperationDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FactoryDef::~FactoryDef (void)
{
}

void POA_IR::FactoryDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FactoryDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FactoryDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FactoryDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FactoryDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FactoryDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FactoryDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

IR::FactoryDef*
POA_IR::FactoryDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_FactoryDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_FinderDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FinderDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FinderDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FinderDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::FinderDef::move_skel},
      {"_is_a",  &POA_IR::FinderDef::_is_a_skel},
      {"_get_mode",     &POA_IR::FinderDef::_get_mode_skel},
      {"_set_name",     &POA_IR::FinderDef::_set_name_skel},
      {"_get_name",     &POA_IR::FinderDef::_get_name_skel},
      {"_set_mode",     &POA_IR::FinderDef::_set_mode_skel},
      {"_get_params",   &POA_IR::FinderDef::_get_params_skel},
      {"_set_params",   &POA_IR::FinderDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::FinderDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::FinderDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::FinderDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::FinderDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::FinderDef::_get_version_skel},
      {"_set_version",  &POA_IR::FinderDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::FinderDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::FinderDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::FinderDef::_get_id_skel},
      {"_set_id",       &POA_IR::FinderDef::_set_id_skel},
      {"describe",      &POA_IR::FinderDef::describe_skel},
      {"_get_result_def",       &POA_IR::FinderDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::FinderDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::FinderDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::FinderDef::_get_result_skel},
      {"destroy",       &POA_IR::FinderDef::destroy_skel},
      {"_non_existent",  &POA_IR::FinderDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::FinderDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_FinderDef_Perfect_Hash_OpTable tao_IR_FinderDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker *POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::the_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::~_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_FinderDef_Proxy_Impl&
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::select_proxy (
    IR_FinderDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FinderDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FinderDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_FinderDef_Proxy_Broker *
_TAO_FinderDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::the_TAO_FinderDef_Strategized_Proxy_Broker();
}

int
_TAO_FinderDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_FinderDef_Proxy_Broker_Factory_function_pointer =
    _TAO_FinderDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_FinderDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_FinderDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_FinderDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FinderDef_ThruPOA_Proxy_Impl::_TAO_FinderDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FinderDef::FinderDef (void)
{
  this->optable_ = &tao_IR_FinderDef_optable;
}

// copy ctor
POA_IR::FinderDef::FinderDef (const FinderDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,OperationDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FinderDef::~FinderDef (void)
{
}

void POA_IR::FinderDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FinderDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FinderDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FinderDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FinderDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FinderDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FinderDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

IR::FinderDef*
POA_IR::FinderDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_FinderDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
#endif /* TAO_HAS_INTERCEPTORS */

class TAO_IR_HomeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_HomeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_HomeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89,  0,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89,  0,
     89, 15,  0, 45, 89, 89, 89,  0, 89, 89,
     89, 89, 89, 89, 89, 89, 89,  5,  0, 10,
     89,  0, 89,  5, 89, 89, 89, 89, 89, 89,
     89, 89, 15, 30, 89, 89, 89,  0, 55, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89,
#else
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89,  0, 89,  0, 89, 15,
      0, 45, 89, 89, 89,  0, 89, 89,  5,  0,
     10, 89,  0, 89,  5, 15, 30, 89, 89, 89,
      0, 55, 89, 89, 89, 89, 89, 89,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_HomeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 88,
      HASH_VALUE_RANGE = 85,
      DUPLICATES = 11
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a",  &POA_IR::HomeDef::is_a_skel},
      {"_is_a",  &POA_IR::HomeDef::_is_a_skel},
      {"_get_id",       &POA_IR::HomeDef::_get_id_skel},
      {"_set_id",       &POA_IR::HomeDef::_set_id_skel},
      {"lookup",        &POA_IR::HomeDef::lookup_skel},
      {"_get_def_kind",         &POA_IR::HomeDef::_get_def_kind_skel},
      {"_get_is_local",         &POA_IR::HomeDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::HomeDef::_set_is_local_skel},
      {"_get_version",  &POA_IR::HomeDef::_get_version_skel},
      {"_set_version",  &POA_IR::HomeDef::_set_version_skel},
      {"_get_defined_in",       &POA_IR::HomeDef::_get_defined_in_skel},
      {"create_enum",   &POA_IR::HomeDef::create_enum_skel},
      {"_get_finders",  &POA_IR::HomeDef::_get_finders_skel},
      {"_get_is_basic",         &POA_IR::HomeDef::_get_is_basic_skel},
      {"_get_factories",        &POA_IR::HomeDef::_get_factories_skel},
      {"create_value_box",      &POA_IR::HomeDef::create_value_box_skel},
      {"describe_contents",     &POA_IR::HomeDef::describe_contents_skel},
      {"create_finder",         &POA_IR::HomeDef::create_finder_skel},
      {"_get_base_interfaces",  &POA_IR::HomeDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::HomeDef::_set_base_interfaces_skel},
      {"create_union",  &POA_IR::HomeDef::create_union_skel},
      {"contents",      &POA_IR::HomeDef::contents_skel},
      {"create_operation",      &POA_IR::HomeDef::create_operation_skel},
      {"create_exception",      &POA_IR::HomeDef::create_exception_skel},
      {"create_alias",  &POA_IR::HomeDef::create_alias_skel},
      {"_non_existent",  &POA_IR::HomeDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::HomeDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::HomeDef::_set_is_abstract_skel},
      {"move",  &POA_IR::HomeDef::move_skel},
      {"_get_managed_component",        &POA_IR::HomeDef::_get_managed_component_skel},
      {"describe",      &POA_IR::HomeDef::describe_skel},
      {"_get_name",     &POA_IR::HomeDef::_get_name_skel},
      {"_get_type",     &POA_IR::HomeDef::_get_type_skel},
      {"_set_name",     &POA_IR::HomeDef::_set_name_skel},
      {"create_struct",         &POA_IR::HomeDef::create_struct_skel},
      {"_get_base_home",        &POA_IR::HomeDef::_get_base_home_skel},
      {"create_constant",       &POA_IR::HomeDef::create_constant_skel},
      {"lookup_name",   &POA_IR::HomeDef::lookup_name_skel},
      {"destroy",       &POA_IR::HomeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::HomeDef::_get_absolute_name_skel},
      {"_get_primary_key",      &POA_IR::HomeDef::_get_primary_key_skel},
      {"create_value",  &POA_IR::HomeDef::create_value_skel},
      {"create_module",         &POA_IR::HomeDef::create_module_skel},
      {"create_native",         &POA_IR::HomeDef::create_native_skel},
      {"create_attribute",      &POA_IR::HomeDef::create_attribute_skel},
      {"create_interface",      &POA_IR::HomeDef::create_interface_skel},
      {"_get_containing_repository",    &POA_IR::HomeDef::_get_containing_repository_skel},
      {"create_factory",        &POA_IR::HomeDef::create_factory_skel},
      {"create_primary_key",    &POA_IR::HomeDef::create_primary_key_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -6,   -2,    4,    5,   -1,  -93,   -1,   -1,   -1,    8,   -1,    9,
        -1,   -1,  -10,   -2,  -90,   -1,  -12,   -2,  -90,  -22,   -2,   14,   15,   16,
        17,   18,   -1,   19,   20,   21,   -1, -100,   -1,   24,   25,  -26,   -2,  -90,
        28,   29,  -30,   -2,  -90,   -1,   -1,   32,  -35,   -3,   33,   34,  -92,   -1,
        -1,   -1,   38,   39,   40,   41,   42,   43,   -1,   -1,   -1,   -1,   -1,  -46,
        -2,   44,   45,  -92,  -48,   -2,  -90,   -1,   -1,   -1,   -1,   50,   -1,   -1,
        51,   -1,   -1,   -1,   52,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_HomeDef_Perfect_Hash_OpTable tao_IR_HomeDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker *POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::the_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    this->proxy_cache_[i] = 0;

}

POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::~_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_Collocation_Strategies::CS_LAST; ++i)
    delete this->proxy_cache_[i];

}

_TAO_HomeDef_Proxy_Impl&
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::select_proxy (
    IR_HomeDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  int strategy =
    TAO_ORB_Core::collocation_strategy (object);

  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];

  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);

  return *this->proxy_cache_[strategy];

}

void
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::create_proxy (
    int strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (TAO_SYNCH_MUTEX, guard, this->mutex_);

  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_Collocation_Strategies::CS_THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_HomeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

        case TAO_Collocation_Strategies::CS_REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_HomeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;

      }

  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_HomeDef_Proxy_Broker *
_TAO_HomeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::the_TAO_HomeDef_Strategized_Proxy_Broker();
}

int
_TAO_HomeDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);

  _TAO_HomeDef_Proxy_Broker_Factory_function_pointer =
    _TAO_HomeDef_Proxy_Broker_Factory_function;

  return 0;
}

static int _TAO_HomeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  _TAO_HomeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_HomeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::_TAO_HomeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_HomeDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_home",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->base_home (
        ACE_TRY_ENV
      );
}

IR_ComponentDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "managed_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->managed_component (
        ACE_TRY_ENV
      );
}

IR_PrimaryKeyDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->primary_key (
        ACE_TRY_ENV
      );
}

IR_FactoryDefSeq * POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::factories (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FactoryDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "factories",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->factories (
        ACE_TRY_ENV
      );
}

IR_FinderDefSeq * POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::finders (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FinderDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "finders",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->finders (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_basic",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->is_basic (
        ACE_TRY_ENV
      );
}

IR_PrimaryKeyDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_primary_key (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_primary_key (
        id,
        name,
        version,
        primary_key,
        ACE_TRY_ENV
      );
}

IR_FactoryDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_factory (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FactoryDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_factory",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_factory (
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
}

IR_FinderDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_finder (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FinderDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_finder",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_finder (
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::HomeDef::HomeDef (void)
{
  this->optable_ = &tao_IR_HomeDef_optable;
}

// copy ctor
POA_IR::HomeDef::HomeDef (const HomeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::HomeDef::~HomeDef (void)
{
}

void POA_IR::HomeDef::_get_base_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_HomeDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_base_home_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->base_home (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_HomeDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_managed_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_ComponentDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->managed_component (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_ComponentDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_PrimaryKeyDef_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->primary_key (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_PrimaryKeyDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_factories_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_FactoryDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_factories_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->factories (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_FactoryDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_finders_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_FinderDefSeq_var _tao_retval;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_finders_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->finders (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_FinderDefSeq * _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get ri (
      _tao_server_request,
      _tao_impl,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->is_basic (
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      CORBA::Boolean _tao_retval_info = _tao_retval;
      ri.result (_tao_retval_info);
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << CORBA::Any::from_boolean (_tao_retval))
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::create_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_PrimaryKeyDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      primary_key.in (),
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_primary_key (
          id.in (),
          name.in (),
          version.in (),
          primary_key.in (),
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_PrimaryKeyDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::create_factory_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_FactoryDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ParDescriptionSeq params;
  IR_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_factory ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_factory (
          id.in (),
          name.in (),
          version.in (),
          params,
          exceptions,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_FactoryDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::create_finder_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_FinderDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ParDescriptionSeq params;
  IR_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter _tao_vfr (
      _tao_server_request.orb_core ()->server_request_interceptors (),
      _tao_server_request.interceptor_count ()
    );

  POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_finder ri (
      _tao_server_request,
      _tao_impl,
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions,
      ACE_TRY_ENV
    );

  ACE_TRY
    {
      _tao_vfr.receive_request (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;

#endif /* TAO_HAS_INTERCEPTORS */
      _tao_retval =
      _tao_impl->create_finder (
          id.in (),
          name.in (),
          version.in (),
          params,
          exceptions,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      IR_FinderDef_ptr _tao_retval_info = _tao_retval._retn ();
      ri.result (_tao_retval_info);
      _tao_retval = _tao_retval_info;
      ri.reply_status (PortableInterceptor::SUCCESSFUL);
      _tao_vfr.send_reply (&ri, ACE_TRY_ENV);
      ACE_TRY_CHECK;
    }
  ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
    {
      ri.forward_reference (exc);
      _tao_vfr.send_other (
        &ri,
        ACE_TRY_ENV
      );
      ACE_TRY_CHECK;
      _tao_server_request.forward_location (exc.forward.in ());
    }
  ACE_CATCHANY
    {
      ri.exception (&ACE_ANY_EXCEPTION);
      _tao_vfr.send_exception (
          &ri,
          ACE_TRY_ENV
        );
      ACE_TRY_CHECK;
      ACE_RE_THROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply ();

  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();

  if (!(
      (_tao_out << _tao_retval.in ())
    ))
    ACE_THROW (CORBA::MARSHAL());

  // In case ACE_TRY_ENV is not used in this function
  ACE_UNUSED_ARG (ACE_TRY_ENV);
}

void POA_IR::HomeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::HomeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::HomeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::HomeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/HomeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::HomeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::HomeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR::HomeDef*
POA_IR::HomeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Object_ptr tmp = CORBA::Object::_nil ();

  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);

  CORBA::Object_var obj = tmp;
  return IR_HomeDef::_unchecked_narrow (obj.in ());
}

#if (TAO_HAS_INTERCEPTORS == 1)
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_base_home_get::TAO_ServerRequestInfo_IR_HomeDef_base_home_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_base_home_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_base_home_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_base_home_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_base_home_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_base_home_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_base_home_get::result (IR::HomeDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_managed_component_get::result (IR::ComponentDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_primary_key_get::result (IR::PrimaryKeyDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_factories_get::TAO_ServerRequestInfo_IR_HomeDef_factories_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_factories_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_factories_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_factories_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_factories_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_factories_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_factories_get::result (IR::FactoryDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_finders_get::TAO_ServerRequestInfo_IR_HomeDef_finders_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_finders_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_finders_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_finders_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_finders_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_finders_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_finders_get::result (IR::FinderDefSeq * result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return parameter_list;
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= CORBA::Any::from_boolean (this->_result);

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Boolean result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_primary_key = parameter_list->length ();
  parameter_list->length (length_primary_key + 1);
  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;

  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_primary_key::result (IR::PrimaryKeyDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_factory::TAO_ServerRequestInfo_IR_HomeDef_create_factory (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_factory::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;

  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;

  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_factory::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_factory::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_factory::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_factory::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_factory::result (IR::FactoryDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_finder::TAO_ServerRequestInfo_IR_HomeDef_create_finder (
    TAO_ServerRequest &_tao_server_request,
    POA_IR::HomeDef *tao_impl,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &
  )
  : TAO_ServerRequestInfo (_tao_server_request),
    _tao_impl (tao_impl),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_finder::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  Dynamic::ParameterList_var safe_parameter_list = parameter_list;

  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;

  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;

  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;

  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;

  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_finder::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  return exception_list;
}

CORBA::Any *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_finder::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  CORBA::Any_var safe_result_any = result_any;

  (*result_any) <<= this->_result;

  return safe_result_any._retn ();
}

char *
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_finder::target_most_derived_interface (
    CORBA::Environment &)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return
    CORBA::string_dup (this->_tao_impl->_interface_repository_id ());
}

CORBA::Boolean
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_finder::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  return this->_tao_impl->_is_a (id, ACE_TRY_ENV);
}

void
POA_IR::HomeDef::TAO_ServerRequestInfo_IR_HomeDef_create_finder::result (IR::FinderDef_ptr result)
{
  // Update the result.
   this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

#endif /* ifndef TAO_IDL_INTERFACES_CPP */
