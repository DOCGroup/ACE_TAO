// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "InterfaceS.h"
#include "tao/PortableServer/Object_Adapter.h"
#include "tao/PortableServer/Operation_Table.h"

ACE_RCSID(IFR_Service, InterfaceS, "$Id$")

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "InterfaceS.i"
#endif /* !defined INLINE */

class TAO_CORBA_IRObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:52 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IRObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IRObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15,  0, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15,  1, 15, 15, 15, 15,  0, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,
#else
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15,  0, 15,  0, 15, 15,
      0, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,  1, 15, 15, 15,
     15,  0, 15, 15, 15, 15, 15, 15,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IRObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 4,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 14,
      HASH_VALUE_RANGE = 10,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA_IRObject::_is_a_skel},
      {"",0},
      {"destroy",       &POA_CORBA_IRObject::destroy_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_CORBA_IRObject::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA_IRObject::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:05:52 */
static TAO_CORBA_IRObject_Perfect_Hash_OpTable tao_CORBA_IRObject_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
_TAO_IRObject_Strategized_Proxy_Broker *
_TAO_IRObject_Strategized_Proxy_Broker::the_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  static _TAO_IRObject_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

_TAO_IRObject_Strategized_Proxy_Broker::_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

_TAO_IRObject_Strategized_Proxy_Broker::~_TAO_IRObject_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_IRObject_Proxy_Impl&
_TAO_IRObject_Strategized_Proxy_Broker::select_proxy (
    ::CORBA::IRObject *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
_TAO_IRObject_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_IRObject_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              ::_TAO_IRObject_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_IRObject_Proxy_Broker *
_TAO_IRObject_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return _TAO_IRObject_Strategized_Proxy_Broker::the_TAO_IRObject_Strategized_Proxy_Broker();
}

int
_TAO_IRObject_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_IRObject_Proxy_Broker_Factory_function_pointer = 
    _TAO_IRObject_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_IRObject_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_IRObject_Proxy_Broker_Factory_Initializer (
      ACE_reinterpret_cast (
          long, 
          _TAO_IRObject_Proxy_Broker_Factory_Initializer
        )
    );


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

_TAO_IRObject_ThruPOA_Proxy_Impl::_TAO_IRObject_ThruPOA_Proxy_Impl (void)
{}

_TAO_IRObject_ThruPOA_Proxy_Impl::~_TAO_IRObject_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR_DefinitionKind 
_TAO_IRObject_ThruPOA_Proxy_Impl::def_kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_DefinitionKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "def_kind",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_CORBA_IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->def_kind (
        ACE_TRY_ENV
      );
}

void 
_TAO_IRObject_ThruPOA_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "destroy",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_CORBA_IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->destroy (
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_CORBA_IRObject::POA_CORBA_IRObject (void)
{
  this->optable_ = &tao_CORBA_IRObject_optable;
}

// copy ctor
POA_CORBA_IRObject::POA_CORBA_IRObject (const POA_CORBA_IRObject& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA_IRObject::~POA_CORBA_IRObject (void)
{
}

void POA_CORBA_IRObject::_get_def_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *)_tao_object_reference;

  IR_DefinitionKind _tao_retval;

  _tao_retval = _tao_impl->def_kind (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_CORBA_IRObject::destroy_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *)_tao_object_reference;

  _tao_impl->destroy (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_CORBA_IRObject::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA_IRObject::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA_IRObject *_tao_impl = (POA_CORBA_IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA_IRObject::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA_IRObject::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA_IRObject::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_CORBA_IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

CORBA::IRObject*
POA_CORBA_IRObject::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return ::CORBA::IRObject::_unchecked_narrow (obj.in ());
}

class TAO_IR_Contained_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Contained_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Contained_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Contained_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::Contained::move_skel},
      {"_is_a",  &POA_IR::Contained::_is_a_skel},
      {"_get_id",       &POA_IR::Contained::_get_id_skel},
      {"_set_id",       &POA_IR::Contained::_set_id_skel},
      {"describe",      &POA_IR::Contained::describe_skel},
      {"_get_name",     &POA_IR::Contained::_get_name_skel},
      {"_set_name",     &POA_IR::Contained::_set_name_skel},
      {"_get_version",  &POA_IR::Contained::_get_version_skel},
      {"_set_version",  &POA_IR::Contained::_set_version_skel},
      {"_get_def_kind",         &POA_IR::Contained::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::Contained::_get_defined_in_skel},
      {"destroy",       &POA_IR::Contained::destroy_skel},
      {"_get_absolute_name",    &POA_IR::Contained::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::Contained::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::Contained::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  -1,  15,  16,  -1,  -1,  -1,  -1,  17,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  18,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Contained_Perfect_Hash_OpTable tao_IR_Contained_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_Contained_Strategized_Proxy_Broker *the_TAO_Contained_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_Contained_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_Contained_Strategized_Proxy_Broker::_TAO_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_Contained_Strategized_Proxy_Broker::~_TAO_Contained_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_Contained_Proxy_Impl&
POA_IR::_TAO_Contained_Strategized_Proxy_Broker::select_proxy (
    ::IR_Contained *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_Contained_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Contained_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_Contained_Proxy_Broker *
_TAO_Contained_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return the_TAO_Contained_Strategized_Proxy_Broker();
}

int
_TAO_Contained_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_Contained_Proxy_Broker_Factory_function_pointer = 
    _TAO_Contained_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_Contained_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_Contained_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_Contained_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::_TAO_Contained_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::~_TAO_Contained_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

char * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->id (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->id (
        id,
        ACE_TRY_ENV
      );
  return;
}

char * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->name (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->name (
        name,
        ACE_TRY_ENV
      );
  return;
}

char * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->version (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "version",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->version (
        version,
        ACE_TRY_ENV
      );
  return;
}

IR::Container_ptr POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::defined_in (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Container_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "defined_in",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->defined_in (
        ACE_TRY_ENV
      );
}

char * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::absolute_name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "absolute_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->absolute_name (
        ACE_TRY_ENV
      );
}

IR::Repository_ptr POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::containing_repository (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Repository_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "containing_repository",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->containing_repository (
        ACE_TRY_ENV
      );
}

IR::Contained::Description * POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::describe (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Contained::Description_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->describe (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_Contained_ThruPOA_Proxy_Impl::move (
    CORBA_Object *_collocated_tao_target_,
    IR_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "move",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Contained:1.0"
        )
    )->move (
        new_container,
        new_name,
        new_version,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::Contained::Contained (void)
{
  this->optable_ = &tao_IR_Contained_optable;
}

// copy ctor
POA_IR::Contained::Contained (const Contained& rhs)
  : POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Contained::~Contained (void)
{
}

void POA_IR::Contained::_get_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

  _tao_retval = _tao_impl->id (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_set_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->id (
      id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::Contained::_get_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

  _tao_retval = _tao_impl->name (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_set_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->name (
      name.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::Contained::_get_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

  _tao_retval = _tao_impl->version (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_set_version_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var version;
  if (!(
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->version (
      version.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::Contained::_get_defined_in_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR_Container_var _tao_retval;

  _tao_retval = _tao_impl->defined_in (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_get_absolute_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;

  _tao_retval = _tao_impl->absolute_name (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::_get_containing_repository_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR_Repository_var _tao_retval;

  _tao_retval = _tao_impl->containing_repository (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::describe_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR_Contained::Description_var _tao_retval;

  _tao_retval = _tao_impl->describe (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Contained::move_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *)_tao_object_reference;

  IR_Container_var new_container;
  CORBA::String_var new_name;
  CORBA::String_var new_version;
  if (!(
    (_tao_in >> new_container.out ()) &&
    (_tao_in >> new_name.out ()) &&
    (_tao_in >> new_version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->move (
      new_container.in (),
      new_name.in (),
      new_version.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::Contained::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Contained::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Contained *_tao_impl = (POA_IR::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Contained::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Contained::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Contained::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Contained:1.0";
}

IR::Contained*
POA_IR::Contained::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_Contained::_unchecked_narrow (obj.in ());
}

class TAO_IR_Container_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 15,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39,  0,
     39,  0,  0,  0, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39,  0, 20,  5,
     39,  0, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 10, 10, 39, 39, 39, 10,  0, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39,
#else
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 15, 39,  0, 39,  0,
      0,  0, 39, 39, 39, 39, 39, 39,  0, 20,
      5, 39,  0, 39, 39, 10, 10, 39, 39, 39,
     10,  0, 39, 39, 39, 39, 39, 39,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 19,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 17,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 38,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup",        &POA_IR::Container::lookup_skel},
      {"destroy",       &POA_IR::Container::destroy_skel},
      {"lookup_name",   &POA_IR::Container::lookup_name_skel},
      {"create_value",  &POA_IR::Container::create_value_skel},
      {"create_module",         &POA_IR::Container::create_module_skel},
      {"create_native",         &POA_IR::Container::create_native_skel},
      {"create_interface",      &POA_IR::Container::create_interface_skel},
      {"create_union",  &POA_IR::Container::create_union_skel},
      {"contents",      &POA_IR::Container::contents_skel},
      {"_is_a",  &POA_IR::Container::_is_a_skel},
      {"create_exception",      &POA_IR::Container::create_exception_skel},
      {"create_alias",  &POA_IR::Container::create_alias_skel},
      {"create_struct",         &POA_IR::Container::create_struct_skel},
      {"create_constant",       &POA_IR::Container::create_constant_skel},
      {"create_value_box",      &POA_IR::Container::create_value_box_skel},
      {"describe_contents",     &POA_IR::Container::describe_contents_skel},
      {"_get_def_kind",         &POA_IR::Container::_get_def_kind_skel},
      {"create_enum",   &POA_IR::Container::create_enum_skel},
      {"_non_existent",  &POA_IR::Container::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,   7,  -1, -10,  -2,   8,   9, -42,
       -1,  -1,  12,  13,  14,  -1,  15,  16,  17,  18,  -1,  19,  20,  21,
       22,  -1,  -1,  23,  -1,  -1,  -1,  -1,  -1,  -1,  24,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Container_Perfect_Hash_OpTable tao_IR_Container_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_Container_Strategized_Proxy_Broker *POA_IR::_TAO_Container_Strategized_Proxy_Broker::the_TAO_Container_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_Container_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_Container_Strategized_Proxy_Broker::_TAO_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_Container_Strategized_Proxy_Broker::~_TAO_Container_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_Container_Proxy_Impl&
POA_IR::_TAO_Container_Strategized_Proxy_Broker::select_proxy (
    IR_Container *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_Container_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Container_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Container_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_Container_Proxy_Broker *
_TAO_Container_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_Container_Strategized_Proxy_Broker::the_TAO_Container_Strategized_Proxy_Broker();
}

int
_TAO_Container_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_Container_Proxy_Broker_Factory_function_pointer = 
    _TAO_Container_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_Container_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_Container_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_Container_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::_TAO_Container_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::~_TAO_Container_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::Contained_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->lookup (
        search_name,
        ACE_TRY_ENV
      );
}

IR::ContainedSeq * POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::contents (
    CORBA_Object *_collocated_tao_target_,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->contents (
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
}

IR::ContainedSeq * POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::lookup_name (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Long levels_to_search,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup_name",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->lookup_name (
        search_name,
        levels_to_search,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
}

IR::Container::DescriptionSeq * POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::describe_contents (
    CORBA_Object *_collocated_tao_target_,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Container::DescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "describe_contents",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->describe_contents (
        limit_type,
        exclude_inherited,
        max_returned_objs,
        ACE_TRY_ENV
      );
}

IR::ModuleDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_module (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ModuleDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_module",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_module (
        id,
        name,
        version,
        ACE_TRY_ENV
      );
}

IR::ConstantDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_constant (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ConstantDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_constant",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_constant (
        id,
        name,
        version,
        type,
        value,
        ACE_TRY_ENV
      );
}

IR::StructDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_struct (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_StructDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_struct",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_struct (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

IR::UnionDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_union (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr discriminator_type,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_UnionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_union",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_union (
        id,
        name,
        version,
        discriminator_type,
        members,
        ACE_TRY_ENV
      );
}

IR::EnumDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_enum (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_EnumDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_enum",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_enum (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

IR::AliasDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_alias (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_AliasDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_alias",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_alias (
        id,
        name,
        version,
        original_type,
        ACE_TRY_ENV
      );
}

IR::InterfaceDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Boolean is_abstract,
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_interface",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_interface (
        id,
        name,
        version,
        base_interfaces,
        is_abstract,
        is_local,
        ACE_TRY_ENV
      );
}

IR::ValueDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_value (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    IR_ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const IR_ValueDefSeq & abstract_base_values,
    const IR_InterfaceDefSeq & supported_interfaces,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_value (
        id,
        name,
        version,
        is_custom,
        is_abstract,
        base_value,
        is_truncatable,
        abstract_base_values,
        supported_interfaces,
        initializers,
        ACE_TRY_ENV
      );
}

IR::ValueBoxDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_value_box (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueBoxDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value_box",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_value_box (
        id,
        name,
        version,
        original_type_def,
        ACE_TRY_ENV
      );
}

IR::ExceptionDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_exception (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ExceptionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_exception",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_exception (
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
}

IR::NativeDef_ptr POA_IR::_TAO_Container_ThruPOA_Proxy_Impl::create_native (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_NativeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_native",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Container:1.0"
        )
    )->create_native (
        id,
        name,
        version,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::Container::Container (void)
{
  this->optable_ = &tao_IR_Container_optable;
}

// copy ctor
POA_IR::Container::Container (const Container& rhs)
  : POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Container::~Container (void)
{
}

void POA_IR::Container::lookup_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_Contained_var _tao_retval;
  CORBA::String_var search_name;
  if (!(
    (_tao_in >> search_name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->lookup (
      search_name.in (),
      ACE_TRY_ENV
    );

      ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ContainedSeq_var _tao_retval;
  IR_DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->contents (
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::lookup_name_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ContainedSeq_var _tao_retval;
  CORBA::String_var search_name;
  CORBA::Long levels_to_search;
  IR_DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> search_name.out ()) &&
    (_tao_in >> levels_to_search) &&
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->lookup_name (
      search_name.in (),
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::describe_contents_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_Container::DescriptionSeq_var _tao_retval;
  IR_DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  CORBA::Long max_returned_objs;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited)) &&
    (_tao_in >> max_returned_objs)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->describe_contents (
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_module_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ModuleDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_module (
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_constant_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ConstantDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var type;
  CORBA::Any value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_constant (
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      value,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_struct_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_StructDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_struct (
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_union_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_UnionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var discriminator_type;
  IR_UnionMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> discriminator_type.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_union (
      id.in (),
      name.in (),
      version.in (),
      discriminator_type.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_enum_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_EnumDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_EnumMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_enum (
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_alias_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_AliasDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var original_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_alias (
      id.in (),
      name.in (),
      version.in (),
      original_type.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_interface_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_InterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_InterfaceDefSeq base_interfaces;
  CORBA::Boolean is_abstract;
  CORBA::Boolean is_local;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_local))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_interface (
      id.in (),
      name.in (),
      version.in (),
      base_interfaces,
      is_abstract,
      is_local,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ValueDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::Boolean is_custom;
  CORBA::Boolean is_abstract;
  IR_ValueDef_var base_value;
  CORBA::Boolean is_truncatable;
  IR_ValueDefSeq abstract_base_values;
  IR_InterfaceDefSeq supported_interfaces;
  IR_InitializerSeq initializers;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_custom)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> base_value.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable)) &&
    (_tao_in >> abstract_base_values) &&
    (_tao_in >> supported_interfaces) &&
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_value (
      id.in (),
      name.in (),
      version.in (),
      is_custom,
      is_abstract,
      base_value.in (),
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_value_box_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ValueBoxDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var original_type_def;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_value_box (
      id.in (),
      name.in (),
      version.in (),
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_exception_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_ExceptionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_exception (
      id.in (),
      name.in (),
      version.in (),
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::create_native_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *)_tao_object_reference;

  IR_NativeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_native (
      id.in (),
      name.in (),
      version.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Container::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Container *_tao_impl = (POA_IR::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Container::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Container *_tao_impl = (POA_IR::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Container::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Container::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Container::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Container:1.0";
}

IR::Container*
POA_IR::Container::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_Container::_unchecked_narrow (obj.in ());
}

class TAO_IR_IDLType_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_IDLType_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_IDLType_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_IDLType_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::IDLType::_is_a_skel},
      {"",0},
      {"destroy",       &POA_IR::IDLType::destroy_skel},
      {"",0},
      {"_get_type",     &POA_IR::IDLType::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_IR::IDLType::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_IR::IDLType::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_IDLType_Perfect_Hash_OpTable tao_IR_IDLType_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_IDLType_Strategized_Proxy_Broker *POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::the_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_IDLType_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::~_TAO_IDLType_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_IDLType_Proxy_Impl&
POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::select_proxy (
    IR_IDLType *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_IDLType_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_IDLType_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_IDLType_Proxy_Broker *
_TAO_IDLType_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_IDLType_Strategized_Proxy_Broker::the_TAO_IDLType_Strategized_Proxy_Broker();
}

int
_TAO_IDLType_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_IDLType_Proxy_Broker_Factory_function_pointer = 
    _TAO_IDLType_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_IDLType_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_IDLType_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_IDLType_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_IDLType_ThruPOA_Proxy_Impl::_TAO_IDLType_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_IDLType_ThruPOA_Proxy_Impl::~_TAO_IDLType_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_IDLType_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/IDLType:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::IDLType::IDLType (void)
{
  this->optable_ = &tao_IR_IDLType_optable;
}

// copy ctor
POA_IR::IDLType::IDLType (const IDLType& rhs)
  : POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::IDLType::~IDLType (void)
{
}

void POA_IR::IDLType::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::IDLType::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::IDLType::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::IDLType *_tao_impl = (POA_IR::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::IDLType::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::IDLType::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::IDLType::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/IDLType:1.0";
}

IR::IDLType*
POA_IR::IDLType::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_IDLType::_unchecked_narrow (obj.in ());
}

class TAO_IR_Repository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 20,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 15,
     71,  0, 23, 10, 71,  5, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71,  0,  0, 15,
     71,  0, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 30,  0, 71, 71, 71,  0,  0, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71,
#else
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 20, 71, 15, 71,  0,
     23, 10, 71,  5, 71, 71, 71, 71,  0,  0,
     15, 71,  0, 71, 71, 30,  0, 71, 71, 71,
      0,  0, 71, 71, 71, 71, 71, 71,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 70,
      HASH_VALUE_RANGE = 65,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup",        &POA_IR::Repository::lookup_skel},
      {"create_enum",   &POA_IR::Repository::create_enum_skel},
      {"create_array",  &POA_IR::Repository::create_array_skel},
      {"create_struct",         &POA_IR::Repository::create_struct_skel},
      {"create_constant",       &POA_IR::Repository::create_constant_skel},
      {"create_value_box",      &POA_IR::Repository::create_value_box_skel},
      {"create_string",         &POA_IR::Repository::create_string_skel},
      {"create_wstring",        &POA_IR::Repository::create_wstring_skel},
      {"lookup_name",   &POA_IR::Repository::lookup_name_skel},
      {"create_value",  &POA_IR::Repository::create_value_skel},
      {"create_module",         &POA_IR::Repository::create_module_skel},
      {"create_native",         &POA_IR::Repository::create_native_skel},
      {"create_sequence",       &POA_IR::Repository::create_sequence_skel},
      {"create_interface",      &POA_IR::Repository::create_interface_skel},
      {"create_union",  &POA_IR::Repository::create_union_skel},
      {"get_primitive",         &POA_IR::Repository::get_primitive_skel},
      {"destroy",       &POA_IR::Repository::destroy_skel},
      {"create_exception",      &POA_IR::Repository::create_exception_skel},
      {"lookup_id",     &POA_IR::Repository::lookup_id_skel},
      {"_non_existent",  &POA_IR::Repository::_non_existent_skel},
      {"create_fixed",  &POA_IR::Repository::create_fixed_skel},
      {"get_canonical_typecode",        &POA_IR::Repository::get_canonical_typecode_skel},
      {"contents",      &POA_IR::Repository::contents_skel},
      {"_is_a",  &POA_IR::Repository::_is_a_skel},
      {"create_alias",  &POA_IR::Repository::create_alias_skel},
      {"_get_def_kind",         &POA_IR::Repository::_get_def_kind_skel},
      {"describe_contents",     &POA_IR::Repository::describe_contents_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,   6,  -1,  -1, -16,  -2,   7,   8,   9,
       -1,  10,  11,  -1,  12,  13,  -1,  14,  15, -84,  -1,  18,  19,  20,
       21,  -1,  22,  23,  24,  25,  -1,  26,  -1,  27,  28,  -1,  29,  -1,
       30,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       31,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       32,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_Repository_Perfect_Hash_OpTable tao_IR_Repository_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_Repository_Strategized_Proxy_Broker *POA_IR::_TAO_Repository_Strategized_Proxy_Broker::the_TAO_Repository_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_Repository_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_Repository_Strategized_Proxy_Broker::_TAO_Repository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_Repository_Strategized_Proxy_Broker::~_TAO_Repository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_Repository_Proxy_Impl&
POA_IR::_TAO_Repository_Strategized_Proxy_Broker::select_proxy (
    IR_Repository *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_Repository_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Repository_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_Repository_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_Repository_Proxy_Broker *
_TAO_Repository_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_Repository_Strategized_Proxy_Broker::the_TAO_Repository_Strategized_Proxy_Broker();
}

int
_TAO_Repository_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_Repository_Proxy_Broker_Factory_function_pointer = 
    _TAO_Repository_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_Repository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_Repository_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_Repository_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::_TAO_Repository_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::~_TAO_Repository_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::Contained_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::lookup_id (
    CORBA_Object *_collocated_tao_target_,
    const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "lookup_id",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->lookup_id (
        search_id,
        ACE_TRY_ENV
      );
}

CORBA::TypeCode_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::get_canonical_typecode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_canonical_typecode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->get_canonical_typecode (
        tc,
        ACE_TRY_ENV
      );
}

IR::PrimitiveDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::get_primitive (
    CORBA_Object *_collocated_tao_target_,
    IR_PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PrimitiveDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "get_primitive",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->get_primitive (
        kind,
        ACE_TRY_ENV
      );
}

IR::StringDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_string (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_StringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_string",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_string (
        bound,
        ACE_TRY_ENV
      );
}

IR::WstringDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_wstring (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_WstringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_wstring",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_wstring (
        bound,
        ACE_TRY_ENV
      );
}

IR::SequenceDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_sequence (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    IR_IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_SequenceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_sequence",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_sequence (
        bound,
        element_type,
        ACE_TRY_ENV
      );
}

IR::ArrayDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_array (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length,
    IR_IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ArrayDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_array",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_array (
        length,
        element_type,
        ACE_TRY_ENV
      );
}

IR::FixedDef_ptr POA_IR::_TAO_Repository_ThruPOA_Proxy_Impl::create_fixed (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FixedDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_fixed",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/Repository:1.0"
        )
    )->create_fixed (
        digits,
        scale,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::Repository::Repository (void)
{
  this->optable_ = &tao_IR_Repository_optable;
}

// copy ctor
POA_IR::Repository::Repository (const Repository& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::Repository::~Repository (void)
{
}

void POA_IR::Repository::lookup_id_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_Contained_var _tao_retval;
  CORBA::String_var search_id;
  if (!(
    (_tao_in >> search_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->lookup_id (
      search_id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::get_canonical_typecode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
  CORBA::TypeCode_var tc;
  if (!(
    (_tao_in >> tc.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->get_canonical_typecode (
      tc.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::get_primitive_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_PrimitiveDef_var _tao_retval;
  IR_PrimitiveKind kind;
  if (!(
    (_tao_in >> kind)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->get_primitive (
      kind,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_string_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_StringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_string (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_wstring_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_WstringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_wstring (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_sequence_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_SequenceDef_var _tao_retval;
  CORBA::ULong bound;
  IR_IDLType_var element_type;
  if (!(
    (_tao_in >> bound) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_sequence (
      bound,
      element_type.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_array_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_ArrayDef_var _tao_retval;
  CORBA::ULong length;
  IR_IDLType_var element_type;
  if (!(
    (_tao_in >> length) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

   _tao_retval = _tao_impl->create_array (
      length,
      element_type.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::create_fixed_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *)_tao_object_reference;

  IR_FixedDef_var _tao_retval;
  CORBA::UShort digits;
  CORBA::Short scale;
  if (!(
    (_tao_in >> digits) &&
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_fixed (
      digits,
      scale,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::Repository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::Repository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::Repository *_tao_impl = (POA_IR::Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::Repository::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::Repository::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Repository:1.0") == 0)
    return ACE_static_cast (POA_IR::Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::Repository::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Repository:1.0";
}

IR::Repository*
POA_IR::Repository::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_Repository::_unchecked_narrow (obj.in ());
}

class TAO_IR_ComponentRepository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentRepository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 15,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54,  5,
     54,  0, 25, 15, 54, 10, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 10,  0,  3,
     54, 25, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54,  0,  5, 54, 54, 54,  0, 20, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54,
#else
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 54, 54, 54, 54, 54,
     54, 54, 54, 54, 54, 15, 54,  5, 54,  0,
     25, 15, 54, 10, 54, 54, 54, 54, 10,  0,
      3, 54, 25, 54, 54,  0,  5, 54, 54, 54,
      0, 20, 54, 54, 54, 54, 54, 54,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentRepository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 29,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 8,
      MAX_HASH_VALUE = 53,
      HASH_VALUE_RANGE = 46,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"contents",      &POA_IR::ComponentRepository::contents_skel},
      {"create_enum",   &POA_IR::ComponentRepository::create_enum_skel},
      {"create_alias",  &POA_IR::ComponentRepository::create_alias_skel},
      {"create_union",  &POA_IR::ComponentRepository::create_union_skel},
      {"create_value_box",      &POA_IR::ComponentRepository::create_value_box_skel},
      {"create_struct",         &POA_IR::ComponentRepository::create_struct_skel},
      {"create_exception",      &POA_IR::ComponentRepository::create_exception_skel},
      {"create_constant",       &POA_IR::ComponentRepository::create_constant_skel},
      {"create_component",      &POA_IR::ComponentRepository::create_component_skel},
      {"create_string",         &POA_IR::ComponentRepository::create_string_skel},
      {"create_wstring",        &POA_IR::ComponentRepository::create_wstring_skel},
      {"_is_a",  &POA_IR::ComponentRepository::_is_a_skel},
      {"create_home",   &POA_IR::ComponentRepository::create_home_skel},
      {"create_value",  &POA_IR::ComponentRepository::create_value_skel},
      {"create_module",         &POA_IR::ComponentRepository::create_module_skel},
      {"create_native",         &POA_IR::ComponentRepository::create_native_skel},
      {"create_sequence",       &POA_IR::ComponentRepository::create_sequence_skel},
      {"create_interface",      &POA_IR::ComponentRepository::create_interface_skel},
      {"create_array",  &POA_IR::ComponentRepository::create_array_skel},
      {"_non_existent",  &POA_IR::ComponentRepository::_non_existent_skel},
      {"lookup_name",   &POA_IR::ComponentRepository::lookup_name_skel},
      {"create_fixed",  &POA_IR::ComponentRepository::create_fixed_skel},
      {"get_primitive",         &POA_IR::ComponentRepository::get_primitive_skel},
      {"lookup",        &POA_IR::ComponentRepository::lookup_skel},
      {"describe_contents",     &POA_IR::ComponentRepository::describe_contents_skel},
      {"lookup_id",     &POA_IR::ComponentRepository::lookup_id_skel},
      {"get_canonical_typecode",        &POA_IR::ComponentRepository::get_canonical_typecode_skel},
      {"destroy",       &POA_IR::ComponentRepository::destroy_skel},
      {"_get_def_kind",         &POA_IR::ComponentRepository::_get_def_kind_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,   8,  -1,  -1,   9,  10, -22,
       -2,  11,  12,  -1,  13,  14,  15,  16,  -1,  17,  18,  19,  20,  21,
      -68,  -1,  24,  25,  26,  27,  -1,  -1,  28,  29,  30,  -1,  -1,  31,
       32,  -1,  33,  -1,  -1,  34,  -1,  -1,  -1,  -1,  35,  36,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ComponentRepository_Perfect_Hash_OpTable tao_IR_ComponentRepository_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker *POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::the_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::~_TAO_ComponentRepository_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ComponentRepository_Proxy_Impl&
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::select_proxy (
    IR_ComponentRepository *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ComponentRepository_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ComponentRepository_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ComponentRepository_Proxy_Broker *
_TAO_ComponentRepository_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ComponentRepository_Strategized_Proxy_Broker::the_TAO_ComponentRepository_Strategized_Proxy_Broker();
}

int
_TAO_ComponentRepository_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer = 
    _TAO_ComponentRepository_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ComponentRepository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ComponentRepository_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ComponentRepository_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::_TAO_ComponentRepository_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::~_TAO_ComponentRepository_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::ComponentDef_ptr POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ComponentDef_ptr base_component,
    const IR_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_component (
        id,
        name,
        version,
        base_component,
        supports_interfaces,
        ACE_TRY_ENV
      );
}

IR::HomeDef_ptr POA_IR::_TAO_ComponentRepository_ThruPOA_Proxy_Impl::create_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_HomeDef_ptr base_home,
    IR_ComponentDef_ptr managed_component,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_home",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentRepository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentRepository:1.0"
        )
    )->create_home (
        id,
        name,
        version,
        base_home,
        managed_component,
        primary_key,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ComponentRepository::ComponentRepository (void)
{
  this->optable_ = &tao_IR_ComponentRepository_optable;
}

// copy ctor
POA_IR::ComponentRepository::ComponentRepository (const ComponentRepository& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Repository) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentRepository::~ComponentRepository (void)
{
}

void POA_IR::ComponentRepository::create_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *)_tao_object_reference;

  IR_ComponentDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ComponentDef_var base_component;
  IR_InterfaceDefSeq supports_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_component.out ()) &&
    (_tao_in >> supports_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_component (
      id.in (),
      name.in (),
      version.in (),
      base_component.in (),
      supports_interfaces,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentRepository::create_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *)_tao_object_reference;

  IR_HomeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_HomeDef_var base_home;
  IR_ComponentDef_var managed_component;
  IR_ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_home.out ()) &&
    (_tao_in >> managed_component.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_home (
      id.in (),
      name.in (),
      version.in (),
      base_home.in (),
      managed_component.in (),
      primary_key.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentRepository::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentRepository::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentRepository *_tao_impl = (POA_IR::ComponentRepository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ComponentRepository::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentRepository::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentRepository:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentRepository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Repository:1.0") == 0)
    return ACE_static_cast (POA_IR::Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentRepository::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR::ComponentRepository*
POA_IR::ComponentRepository::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ComponentRepository::_unchecked_narrow (obj.in ());
}

class TAO_IR_ModuleDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 10,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52,  0, 15,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 20,  0,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 10, 20, 52, 52, 52, 10, 15, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 10, 52,  0, 52,  0,
     15,  0, 52, 52, 52, 52, 52, 52, 20,  0,
      5, 52, 10, 52, 52, 10, 20, 52, 52, 52,
     10, 15, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 30,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 48,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ModuleDef::move_skel},
      {"create_enum",   &POA_IR::ModuleDef::create_enum_skel},
      {"create_value",  &POA_IR::ModuleDef::create_value_skel},
      {"create_module",         &POA_IR::ModuleDef::create_module_skel},
      {"create_native",         &POA_IR::ModuleDef::create_native_skel},
      {"_is_a",  &POA_IR::ModuleDef::_is_a_skel},
      {"create_interface",      &POA_IR::ModuleDef::create_interface_skel},
      {"create_union",  &POA_IR::ModuleDef::create_union_skel},
      {"contents",      &POA_IR::ModuleDef::contents_skel},
      {"_get_name",     &POA_IR::ModuleDef::_get_name_skel},
      {"_set_name",     &POA_IR::ModuleDef::_set_name_skel},
      {"create_exception",      &POA_IR::ModuleDef::create_exception_skel},
      {"create_alias",  &POA_IR::ModuleDef::create_alias_skel},
      {"describe",      &POA_IR::ModuleDef::describe_skel},
      {"create_value_box",      &POA_IR::ModuleDef::create_value_box_skel},
      {"_get_version",  &POA_IR::ModuleDef::_get_version_skel},
      {"_set_version",  &POA_IR::ModuleDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ModuleDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::ModuleDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::ModuleDef::lookup_name_skel},
      {"_get_id",       &POA_IR::ModuleDef::_get_id_skel},
      {"_set_id",       &POA_IR::ModuleDef::_set_id_skel},
      {"create_struct",         &POA_IR::ModuleDef::create_struct_skel},
      {"create_constant",       &POA_IR::ModuleDef::create_constant_skel},
      {"lookup",        &POA_IR::ModuleDef::lookup_skel},
      {"destroy",       &POA_IR::ModuleDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ModuleDef::_get_def_kind_skel},
      {"describe_contents",     &POA_IR::ModuleDef::describe_contents_skel},
      {"_non_existent",  &POA_IR::ModuleDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ModuleDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -7,  -2, -13,  -2, -19,  -2,   5,   6, -59,
       -1,   9,  10,  11,  12, -63,  -1,  15,  16,  17, -24,  -2,  18, -69,
       21,  -1,  22,  23, -59,  26,  -1,  27,  28,  29,  30,  -1,  -1,  -1,
       31,  32,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  33,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ModuleDef_Perfect_Hash_OpTable tao_IR_ModuleDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker *POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::the_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::~_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ModuleDef_Proxy_Impl&
POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::select_proxy (
    IR_ModuleDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ModuleDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ModuleDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ModuleDef_Proxy_Broker *
_TAO_ModuleDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ModuleDef_Strategized_Proxy_Broker::the_TAO_ModuleDef_Strategized_Proxy_Broker();
}

int
_TAO_ModuleDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ModuleDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ModuleDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ModuleDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ModuleDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ModuleDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ModuleDef_ThruPOA_Proxy_Impl::_TAO_ModuleDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ModuleDef_ThruPOA_Proxy_Impl::~_TAO_ModuleDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ModuleDef::ModuleDef (void)
{
  this->optable_ = &tao_IR_ModuleDef_optable;
}

// copy ctor
POA_IR::ModuleDef::ModuleDef (const ModuleDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ModuleDef::~ModuleDef (void)
{
}

void POA_IR::ModuleDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ModuleDef *_tao_impl = (POA_IR::ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ModuleDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ModuleDef *_tao_impl = (POA_IR::ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ModuleDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ModuleDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ModuleDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ModuleDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ModuleDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ModuleDef:1.0";
}

IR::ModuleDef*
POA_IR::ModuleDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ModuleDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ConstantDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ConstantDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ConstantDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ConstantDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ConstantDef::move_skel},
      {"_is_a",  &POA_IR::ConstantDef::_is_a_skel},
      {"_get_id",       &POA_IR::ConstantDef::_get_id_skel},
      {"_set_id",       &POA_IR::ConstantDef::_set_id_skel},
      {"describe",      &POA_IR::ConstantDef::describe_skel},
      {"_get_type",     &POA_IR::ConstantDef::_get_type_skel},
      {"_set_name",     &POA_IR::ConstantDef::_set_name_skel},
      {"_get_name",     &POA_IR::ConstantDef::_get_name_skel},
      {"_get_value",    &POA_IR::ConstantDef::_get_value_skel},
      {"_set_value",    &POA_IR::ConstantDef::_set_value_skel},
      {"_get_version",  &POA_IR::ConstantDef::_get_version_skel},
      {"_set_version",  &POA_IR::ConstantDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ConstantDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ConstantDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ConstantDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ConstantDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::ConstantDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::ConstantDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::ConstantDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ConstantDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46, -46,  -1, -46,  16,
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_ConstantDef_Perfect_Hash_OpTable tao_IR_ConstantDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker *POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::the_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::~_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ConstantDef_Proxy_Impl&
POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::select_proxy (
    IR_ConstantDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ConstantDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ConstantDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ConstantDef_Proxy_Broker *
_TAO_ConstantDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ConstantDef_Strategized_Proxy_Broker::the_TAO_ConstantDef_Strategized_Proxy_Broker();
}

int
_TAO_ConstantDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ConstantDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ConstantDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ConstantDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ConstantDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ConstantDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::_TAO_ConstantDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::~_TAO_ConstantDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

IR::IDLType_ptr POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->type_def (
        type_def,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Any * POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Any_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->value (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ConstantDef_ThruPOA_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ConstantDef:1.0"
        )
    )->value (
        value,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ConstantDef::ConstantDef (void)
{
  this->optable_ = &tao_IR_ConstantDef_optable;
}

// copy ctor
POA_IR::ConstantDef::ConstantDef (const ConstantDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ConstantDef::~ConstantDef (void)
{
}

void POA_IR::ConstantDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ConstantDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ConstantDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  IR_IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->type_def (
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ConstantDef::_get_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::Any_var _tao_retval;

  _tao_retval = _tao_impl->value (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ConstantDef::_set_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *)_tao_object_reference;

  CORBA::Any value;
  if (!(
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->value (
      value,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ConstantDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConstantDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ConstantDef *_tao_impl = (POA_IR::ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ConstantDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ConstantDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ConstantDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ConstantDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ConstantDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConstantDef:1.0";
}

IR::ConstantDef*
POA_IR::ConstantDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ConstantDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_TypedefDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_TypedefDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_TypedefDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_TypedefDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::TypedefDef::move_skel},
      {"_is_a",  &POA_IR::TypedefDef::_is_a_skel},
      {"_get_id",       &POA_IR::TypedefDef::_get_id_skel},
      {"_set_id",       &POA_IR::TypedefDef::_set_id_skel},
      {"describe",      &POA_IR::TypedefDef::describe_skel},
      {"_get_name",     &POA_IR::TypedefDef::_get_name_skel},
      {"_get_type",     &POA_IR::TypedefDef::_get_type_skel},
      {"_set_name",     &POA_IR::TypedefDef::_set_name_skel},
      {"_get_version",  &POA_IR::TypedefDef::_get_version_skel},
      {"_set_version",  &POA_IR::TypedefDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::TypedefDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::TypedefDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::TypedefDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::TypedefDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::TypedefDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::TypedefDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_TypedefDef_Perfect_Hash_OpTable tao_IR_TypedefDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker *POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::the_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::~_TAO_TypedefDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_TypedefDef_Proxy_Impl&
POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::select_proxy (
    IR_TypedefDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_TypedefDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_TypedefDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_TypedefDef_Proxy_Broker *
_TAO_TypedefDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_TypedefDef_Strategized_Proxy_Broker::the_TAO_TypedefDef_Strategized_Proxy_Broker();
}

int
_TAO_TypedefDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_TypedefDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_TypedefDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_TypedefDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_TypedefDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_TypedefDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_TypedefDef_ThruPOA_Proxy_Impl::_TAO_TypedefDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_TypedefDef_ThruPOA_Proxy_Impl::~_TAO_TypedefDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::TypedefDef::TypedefDef (void)
{
  this->optable_ = &tao_IR_TypedefDef_optable;
}

// copy ctor
POA_IR::TypedefDef::TypedefDef (const TypedefDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::TypedefDef::~TypedefDef (void)
{
}

void POA_IR::TypedefDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::TypedefDef *_tao_impl = (POA_IR::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::TypedefDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::TypedefDef *_tao_impl = (POA_IR::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::TypedefDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::TypedefDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::TypedefDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/TypedefDef:1.0";
}

IR::TypedefDef*
POA_IR::TypedefDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_TypedefDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_StructDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_StructDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_StructDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 20,  3,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 10, 15,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 15, 15, 52, 52, 52, 15,  5, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52,  0, 52,  0, 52, 20,
      3,  0, 52, 52, 52, 52, 52, 52, 10, 15,
      5, 52, 10, 52, 52, 15, 15, 52, 52, 52,
     15,  5, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_StructDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::StructDef::_is_a_skel},
      {"_get_name",     &POA_IR::StructDef::_get_name_skel},
      {"_get_type",     &POA_IR::StructDef::_get_type_skel},
      {"_set_name",     &POA_IR::StructDef::_set_name_skel},
      {"_get_id",       &POA_IR::StructDef::_get_id_skel},
      {"_set_id",       &POA_IR::StructDef::_set_id_skel},
      {"describe",      &POA_IR::StructDef::describe_skel},
      {"destroy",       &POA_IR::StructDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::StructDef::_get_def_kind_skel},
      {"_get_version",  &POA_IR::StructDef::_get_version_skel},
      {"_set_version",  &POA_IR::StructDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::StructDef::_get_absolute_name_skel},
      {"move",  &POA_IR::StructDef::move_skel},
      {"_get_defined_in",       &POA_IR::StructDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::StructDef::lookup_name_skel},
      {"lookup",        &POA_IR::StructDef::lookup_skel},
      {"_get_members",  &POA_IR::StructDef::_get_members_skel},
      {"_set_members",  &POA_IR::StructDef::_set_members_skel},
      {"_non_existent",  &POA_IR::StructDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::StructDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::StructDef::create_value_skel},
      {"create_module",         &POA_IR::StructDef::create_module_skel},
      {"create_native",         &POA_IR::StructDef::create_native_skel},
      {"describe_contents",     &POA_IR::StructDef::describe_contents_skel},
      {"create_interface",      &POA_IR::StructDef::create_interface_skel},
      {"create_union",  &POA_IR::StructDef::create_union_skel},
      {"create_exception",      &POA_IR::StructDef::create_exception_skel},
      {"contents",      &POA_IR::StructDef::contents_skel},
      {"create_enum",   &POA_IR::StructDef::create_enum_skel},
      {"create_alias",  &POA_IR::StructDef::create_alias_skel},
      {"create_struct",         &POA_IR::StructDef::create_struct_skel},
      {"create_constant",       &POA_IR::StructDef::create_constant_skel},
      {"create_value_box",      &POA_IR::StructDef::create_value_box_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -3,   5,  -1,  -9,  -2, -57, -54,  11,  -1, -14,
       -2,  12,  13, -55,  16,  17,  18,  19,  -1,  -1, -21,  -2,  20, -54,
       23, -26,  -2,  24,  25, -55,  -1,  28,  29,  30,  -1,  -1,  -1,  31,
       -1,  32,  -1,  -1,  33,  34,  35,  -1,  36,  37,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_StructDef_Perfect_Hash_OpTable tao_IR_StructDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_StructDef_Strategized_Proxy_Broker *POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::the_TAO_StructDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_StructDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::_TAO_StructDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::~_TAO_StructDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_StructDef_Proxy_Impl&
POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::select_proxy (
    IR_StructDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_StructDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_StructDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_StructDef_Proxy_Broker *
_TAO_StructDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_StructDef_Strategized_Proxy_Broker::the_TAO_StructDef_Strategized_Proxy_Broker();
}

int
_TAO_StructDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_StructDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_StructDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_StructDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_StructDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_StructDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_StructDef_ThruPOA_Proxy_Impl::_TAO_StructDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_StructDef_ThruPOA_Proxy_Impl::~_TAO_StructDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::StructMemberSeq * POA_IR::_TAO_StructDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StructDef:1.0"
        )
    )->members (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_StructDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StructDef:1.0"
        )
    )->members (
        members,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::StructDef::StructDef (void)
{
  this->optable_ = &tao_IR_StructDef_optable;
}

// copy ctor
POA_IR::StructDef::StructDef (const StructDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::StructDef::~StructDef (void)
{
}

void POA_IR::StructDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *)_tao_object_reference;

  IR_StructMemberSeq_var _tao_retval;

  _tao_retval = _tao_impl->members (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::StructDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *)_tao_object_reference;

  IR_StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->members (
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::StructDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::StructDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::StructDef *_tao_impl = (POA_IR::StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::StructDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::StructDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/StructDef:1.0") == 0)
    return ACE_static_cast (POA_IR::StructDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::StructDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StructDef:1.0";
}

IR::StructDef*
POA_IR::StructDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_StructDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_UnionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:09 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_UnionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_UnionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68,  0,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68,  0,
     68, 25,  3,  0,  0, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 10,  0, 10,
     68, 10, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 30, 15, 68, 68, 68,  5,  5, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68,
#else
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68,  0, 68,  0, 68, 25,
      3,  0,  0, 68, 68, 68, 68, 68, 10,  0,
     10, 68, 10, 68, 68, 30, 15, 68, 68, 68,
      5,  5, 68, 68, 68, 68, 68, 68,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_UnionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 67,
      HASH_VALUE_RANGE = 64,
      DUPLICATES = 8
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::UnionDef::move_skel},
      {"_is_a",  &POA_IR::UnionDef::_is_a_skel},
      {"_get_name",     &POA_IR::UnionDef::_get_name_skel},
      {"_get_type",     &POA_IR::UnionDef::_get_type_skel},
      {"_set_name",     &POA_IR::UnionDef::_set_name_skel},
      {"_get_id",       &POA_IR::UnionDef::_get_id_skel},
      {"_set_id",       &POA_IR::UnionDef::_set_id_skel},
      {"describe",      &POA_IR::UnionDef::describe_skel},
      {"destroy",       &POA_IR::UnionDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::UnionDef::_get_def_kind_skel},
      {"_get_absolute_name",    &POA_IR::UnionDef::_get_absolute_name_skel},
      {"lookup_name",   &POA_IR::UnionDef::lookup_name_skel},
      {"_get_version",  &POA_IR::UnionDef::_get_version_skel},
      {"_set_version",  &POA_IR::UnionDef::_set_version_skel},
      {"_get_discriminator_type",       &POA_IR::UnionDef::_get_discriminator_type_skel},
      {"_get_defined_in",       &POA_IR::UnionDef::_get_defined_in_skel},
      {"lookup",        &POA_IR::UnionDef::lookup_skel},
      {"_get_discriminator_type_def",   &POA_IR::UnionDef::_get_discriminator_type_def_skel},
      {"_set_discriminator_type_def",   &POA_IR::UnionDef::_set_discriminator_type_def_skel},
      {"_non_existent",  &POA_IR::UnionDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::UnionDef::_get_containing_repository_skel},
      {"create_enum",   &POA_IR::UnionDef::create_enum_skel},
      {"create_value",  &POA_IR::UnionDef::create_value_skel},
      {"create_module",         &POA_IR::UnionDef::create_module_skel},
      {"create_native",         &POA_IR::UnionDef::create_native_skel},
      {"create_interface",      &POA_IR::UnionDef::create_interface_skel},
      {"_get_members",  &POA_IR::UnionDef::_get_members_skel},
      {"_set_members",  &POA_IR::UnionDef::_set_members_skel},
      {"create_value_box",      &POA_IR::UnionDef::create_value_box_skel},
      {"create_union",  &POA_IR::UnionDef::create_union_skel},
      {"describe_contents",     &POA_IR::UnionDef::describe_contents_skel},
      {"create_exception",      &POA_IR::UnionDef::create_exception_skel},
      {"create_struct",         &POA_IR::UnionDef::create_struct_skel},
      {"create_constant",       &POA_IR::UnionDef::create_constant_skel},
      {"contents",      &POA_IR::UnionDef::contents_skel},
      {"create_alias",  &POA_IR::UnionDef::create_alias_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -6,  -3,   4,   5,  -1,  -9,  -2, -74, -70,  11,  -1, -16,
       -2,  12,  13,  -1,  14, -21,  -2,  15, -76,  18,  -1,  19,  20, -75,
       23,  -1,  -1,  24,  -1,  -1, -27,  -2,  25,  26, -71, -30,  -2,  29,
      -70,  -1,  -1,  -1,  32,  33,  -1,  -1,  34,  35,  -1,  36,  -1,  37,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  38,  -1,  -1,  -1,  39,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:09 */
static TAO_IR_UnionDef_Perfect_Hash_OpTable tao_IR_UnionDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker *POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::the_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::~_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_UnionDef_Proxy_Impl&
POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::select_proxy (
    IR_UnionDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_UnionDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_UnionDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_UnionDef_Proxy_Broker *
_TAO_UnionDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_UnionDef_Strategized_Proxy_Broker::the_TAO_UnionDef_Strategized_Proxy_Broker();
}

int
_TAO_UnionDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_UnionDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_UnionDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_UnionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_UnionDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_UnionDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::_TAO_UnionDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::~_TAO_UnionDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::discriminator_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type (
        ACE_TRY_ENV
      );
}

IR::IDLType_ptr POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "discriminator_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->discriminator_type_def (
        discriminator_type_def,
        ACE_TRY_ENV
      );
  return;
}

IR::UnionMemberSeq * POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_UnionMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->members (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_UnionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UnionDef:1.0"
        )
    )->members (
        members,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::UnionDef::UnionDef (void)
{
  this->optable_ = &tao_IR_UnionDef_optable;
}

// copy ctor
POA_IR::UnionDef::UnionDef (const UnionDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::UnionDef::~UnionDef (void)
{
}

void POA_IR::UnionDef::_get_discriminator_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->discriminator_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UnionDef::_get_discriminator_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->discriminator_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UnionDef::_set_discriminator_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR_IDLType_var discriminator_type_def;
  if (!(
    (_tao_in >> discriminator_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->discriminator_type_def (
      discriminator_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::UnionDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR_UnionMemberSeq_var _tao_retval;

  _tao_retval = _tao_impl->members (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UnionDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *)_tao_object_reference;

  IR_UnionMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->members (
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::UnionDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UnionDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UnionDef *_tao_impl = (POA_IR::UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::UnionDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::UnionDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/UnionDef:1.0") == 0)
    return ACE_static_cast (POA_IR::UnionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::UnionDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UnionDef:1.0";
}

IR::UnionDef*
POA_IR::UnionDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_UnionDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_EnumDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EnumDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EnumDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 10, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 10, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EnumDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EnumDef::move_skel},
      {"_is_a",  &POA_IR::EnumDef::_is_a_skel},
      {"_get_id",       &POA_IR::EnumDef::_get_id_skel},
      {"_set_id",       &POA_IR::EnumDef::_set_id_skel},
      {"describe",      &POA_IR::EnumDef::describe_skel},
      {"_get_name",     &POA_IR::EnumDef::_get_name_skel},
      {"_get_type",     &POA_IR::EnumDef::_get_type_skel},
      {"_set_name",     &POA_IR::EnumDef::_set_name_skel},
      {"_get_version",  &POA_IR::EnumDef::_get_version_skel},
      {"_set_version",  &POA_IR::EnumDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EnumDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::EnumDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EnumDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EnumDef::_get_absolute_name_skel},
      {"_get_members",  &POA_IR::EnumDef::_get_members_skel},
      {"_set_members",  &POA_IR::EnumDef::_set_members_skel},
      {"_non_existent",  &POA_IR::EnumDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EnumDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_EnumDef_Perfect_Hash_OpTable tao_IR_EnumDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker *POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::the_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::~_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_EnumDef_Proxy_Impl&
POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::select_proxy (
    IR_EnumDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EnumDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EnumDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_EnumDef_Proxy_Broker *
_TAO_EnumDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EnumDef_Strategized_Proxy_Broker::the_TAO_EnumDef_Strategized_Proxy_Broker();
}

int
_TAO_EnumDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_EnumDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_EnumDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_EnumDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_EnumDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_EnumDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EnumDef_ThruPOA_Proxy_Impl::_TAO_EnumDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_EnumDef_ThruPOA_Proxy_Impl::~_TAO_EnumDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::EnumMemberSeq * POA_IR::_TAO_EnumDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_EnumMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EnumDef:1.0"
        )
    )->members (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_EnumDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EnumDef:1.0"
        )
    )->members (
        members,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EnumDef::EnumDef (void)
{
  this->optable_ = &tao_IR_EnumDef_optable;
}

// copy ctor
POA_IR::EnumDef::EnumDef (const EnumDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EnumDef::~EnumDef (void)
{
}

void POA_IR::EnumDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *)_tao_object_reference;

  IR_EnumMemberSeq_var _tao_retval;

  _tao_retval = _tao_impl->members (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::EnumDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *)_tao_object_reference;

  IR_EnumMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->members (
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::EnumDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EnumDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EnumDef *_tao_impl = (POA_IR::EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EnumDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EnumDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EnumDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EnumDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
   if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EnumDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EnumDef:1.0";
}

IR::EnumDef*
POA_IR::EnumDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_EnumDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_AliasDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_AliasDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_AliasDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_AliasDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::AliasDef::move_skel},
      {"_is_a",  &POA_IR::AliasDef::_is_a_skel},
      {"_get_id",       &POA_IR::AliasDef::_get_id_skel},
      {"_set_id",       &POA_IR::AliasDef::_set_id_skel},
      {"describe",      &POA_IR::AliasDef::describe_skel},
      {"_get_name",     &POA_IR::AliasDef::_get_name_skel},
      {"_get_type",     &POA_IR::AliasDef::_get_type_skel},
      {"_set_name",     &POA_IR::AliasDef::_set_name_skel},
      {"_get_version",  &POA_IR::AliasDef::_get_version_skel},
      {"_set_version",  &POA_IR::AliasDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::AliasDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::AliasDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::AliasDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::AliasDef::_get_absolute_name_skel},
      {"_get_original_type_def",        &POA_IR::AliasDef::_get_original_type_def_skel},
      {"_set_original_type_def",        &POA_IR::AliasDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_IR::AliasDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::AliasDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_AliasDef_Perfect_Hash_OpTable tao_IR_AliasDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker *POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::the_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::~_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_AliasDef_Proxy_Impl&
POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::select_proxy (
    IR_AliasDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_AliasDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_AliasDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_AliasDef_Proxy_Broker *
_TAO_AliasDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_AliasDef_Strategized_Proxy_Broker::the_TAO_AliasDef_Strategized_Proxy_Broker();
}

int
_TAO_AliasDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_AliasDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_AliasDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_AliasDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_AliasDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_AliasDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_AliasDef_ThruPOA_Proxy_Impl::_TAO_AliasDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_AliasDef_ThruPOA_Proxy_Impl::~_TAO_AliasDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::IDLType_ptr POA_IR::_TAO_AliasDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AliasDef:1.0"
        )
    )->original_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_AliasDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AliasDef:1.0"
        )
    )->original_type_def (
        original_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::AliasDef::AliasDef (void)
{
  this->optable_ = &tao_IR_AliasDef_optable;
}

// copy ctor
POA_IR::AliasDef::AliasDef (const AliasDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::AliasDef::~AliasDef (void)
{
}

void POA_IR::AliasDef::_get_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->original_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::AliasDef::_set_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *)_tao_object_reference;

  IR_IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->original_type_def (
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::AliasDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::AliasDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::AliasDef *_tao_impl = (POA_IR::AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::AliasDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::AliasDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/AliasDef:1.0") == 0)
    return ACE_static_cast (POA_IR::AliasDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::AliasDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AliasDef:1.0";
}

IR::AliasDef*
POA_IR::AliasDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_AliasDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_NativeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_NativeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_NativeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_NativeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::NativeDef::move_skel},
      {"_is_a",  &POA_IR::NativeDef::_is_a_skel},
      {"_get_id",       &POA_IR::NativeDef::_get_id_skel},
      {"_set_id",       &POA_IR::NativeDef::_set_id_skel},
      {"describe",      &POA_IR::NativeDef::describe_skel},
      {"_get_name",     &POA_IR::NativeDef::_get_name_skel},
      {"_get_type",     &POA_IR::NativeDef::_get_type_skel},
      {"_set_name",     &POA_IR::NativeDef::_set_name_skel},
      {"_get_version",  &POA_IR::NativeDef::_get_version_skel},
      {"_set_version",  &POA_IR::NativeDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::NativeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::NativeDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::NativeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::NativeDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_IR::NativeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::NativeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_NativeDef_Perfect_Hash_OpTable tao_IR_NativeDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker *POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::the_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::~_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_NativeDef_Proxy_Impl&
POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::select_proxy (
    IR_NativeDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_NativeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_NativeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_NativeDef_Proxy_Broker *
_TAO_NativeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_NativeDef_Strategized_Proxy_Broker::the_TAO_NativeDef_Strategized_Proxy_Broker();
}

int
_TAO_NativeDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_NativeDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_NativeDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_NativeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_NativeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_NativeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_NativeDef_ThruPOA_Proxy_Impl::_TAO_NativeDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_NativeDef_ThruPOA_Proxy_Impl::~_TAO_NativeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::NativeDef::NativeDef (void)
{
  this->optable_ = &tao_IR_NativeDef_optable;
}

// copy ctor
POA_IR::NativeDef::NativeDef (const NativeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::NativeDef::~NativeDef (void)
{
}

void POA_IR::NativeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::NativeDef *_tao_impl = (POA_IR::NativeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::NativeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::NativeDef *_tao_impl = (POA_IR::NativeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::NativeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/NativeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::NativeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/NativeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::NativeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::NativeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/NativeDef:1.0";
}

IR::NativeDef*
POA_IR::NativeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_NativeDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_PrimitiveDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PrimitiveDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PrimitiveDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  5, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PrimitiveDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::PrimitiveDef::_is_a_skel},
      {"",0},
      {"destroy",       &POA_IR::PrimitiveDef::destroy_skel},
      {"",0},
      {"_get_kind",     &POA_IR::PrimitiveDef::_get_kind_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind",         &POA_IR::PrimitiveDef::_get_def_kind_skel},
      {"_get_type",     &POA_IR::PrimitiveDef::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_non_existent",  &POA_IR::PrimitiveDef::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_PrimitiveDef_Perfect_Hash_OpTable tao_IR_PrimitiveDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker *POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::the_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::~_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_PrimitiveDef_Proxy_Impl&
POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::select_proxy (
    IR_PrimitiveDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PrimitiveDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PrimitiveDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_PrimitiveDef_Proxy_Broker *
_TAO_PrimitiveDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PrimitiveDef_Strategized_Proxy_Broker::the_TAO_PrimitiveDef_Strategized_Proxy_Broker();
}

int
_TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_PrimitiveDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_PrimitiveDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PrimitiveDef_ThruPOA_Proxy_Impl::_TAO_PrimitiveDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_PrimitiveDef_ThruPOA_Proxy_Impl::~_TAO_PrimitiveDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::PrimitiveKind POA_IR::_TAO_PrimitiveDef_ThruPOA_Proxy_Impl::kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PrimitiveKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "kind",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimitiveDef:1.0"
        )
    )->kind (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PrimitiveDef::PrimitiveDef (void)
{
  this->optable_ = &tao_IR_PrimitiveDef_optable;
}

// copy ctor
POA_IR::PrimitiveDef::PrimitiveDef (const PrimitiveDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PrimitiveDef::~PrimitiveDef (void)
{
}

void POA_IR::PrimitiveDef::_get_kind_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *)_tao_object_reference;

  IR_PrimitiveKind _tao_retval;

  _tao_retval = _tao_impl->kind (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::PrimitiveDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimitiveDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimitiveDef *_tao_impl = (POA_IR::PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PrimitiveDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PrimitiveDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PrimitiveDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PrimitiveDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PrimitiveDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimitiveDef:1.0";
}

IR::PrimitiveDef*
POA_IR::PrimitiveDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_PrimitiveDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_StringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_StringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_StringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_StringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::StringDef::_is_a_skel},
      {"destroy",       &POA_IR::StringDef::destroy_skel},
      {"_get_type",     &POA_IR::StringDef::_get_type_skel},
      {"_get_bound",    &POA_IR::StringDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::StringDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::StringDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::StringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -25,  -1,  -1,  10,
       -1,  -1,  -1,  -1,  11,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_StringDef_Perfect_Hash_OpTable tao_IR_StringDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_StringDef_Strategized_Proxy_Broker *POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::the_TAO_StringDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_StringDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::_TAO_StringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::~_TAO_StringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_StringDef_Proxy_Impl&
POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::select_proxy (
    IR_StringDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_StringDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_StringDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_StringDef_Proxy_Broker *
_TAO_StringDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_StringDef_Strategized_Proxy_Broker::the_TAO_StringDef_Strategized_Proxy_Broker();
}

int
_TAO_StringDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_StringDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_StringDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_StringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_StringDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_StringDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_StringDef_ThruPOA_Proxy_Impl::_TAO_StringDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_StringDef_ThruPOA_Proxy_Impl::~_TAO_StringDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong POA_IR::_TAO_StringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StringDef:1.0"
        )
    )->bound (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_StringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/StringDef:1.0"
        )
    )->bound (
        bound,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::StringDef::StringDef (void)
{
  this->optable_ = &tao_IR_StringDef_optable;
}

// copy ctor
POA_IR::StringDef::StringDef (const StringDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::StringDef::~StringDef (void)
{
}

void POA_IR::StringDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

  _tao_retval = _tao_impl->bound (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::StringDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->bound (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::StringDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::StringDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::StringDef *_tao_impl = (POA_IR::StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::StringDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::StringDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/StringDef:1.0") == 0)
    return ACE_static_cast (POA_IR::StringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::StringDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StringDef:1.0";
}

IR::StringDef*
POA_IR::StringDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_StringDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_WstringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_WstringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_WstringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_WstringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::WstringDef::_is_a_skel},
      {"destroy",       &POA_IR::WstringDef::destroy_skel},
      {"_get_type",     &POA_IR::WstringDef::_get_type_skel},
      {"_get_bound",    &POA_IR::WstringDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::WstringDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::WstringDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::WstringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -25,  -1,  -1,  10,
       -1,  -1,  -1,  -1,  11,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_WstringDef_Perfect_Hash_OpTable tao_IR_WstringDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker *POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::the_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::~_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_WstringDef_Proxy_Impl&
POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::select_proxy (
    IR_WstringDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_WstringDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_WstringDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_WstringDef_Proxy_Broker *
_TAO_WstringDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_WstringDef_Strategized_Proxy_Broker::the_TAO_WstringDef_Strategized_Proxy_Broker();
}

int
_TAO_WstringDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_WstringDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_WstringDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_WstringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_WstringDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_WstringDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_WstringDef_ThruPOA_Proxy_Impl::_TAO_WstringDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_WstringDef_ThruPOA_Proxy_Impl::~_TAO_WstringDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong POA_IR::_TAO_WstringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/WstringDef:1.0"
        )
    )->bound (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_WstringDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/WstringDef:1.0"
        )
    )->bound (
        bound,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::WstringDef::WstringDef (void)
{
  this->optable_ = &tao_IR_WstringDef_optable;
}

// copy ctor
POA_IR::WstringDef::WstringDef (const WstringDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::WstringDef::~WstringDef (void)
{
}

void POA_IR::WstringDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

  _tao_retval = _tao_impl->bound (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::WstringDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->bound (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::WstringDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::WstringDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::WstringDef *_tao_impl = (POA_IR::WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::WstringDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::WstringDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/WstringDef:1.0") == 0)
    return ACE_static_cast (POA_IR::WstringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::WstringDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/WstringDef:1.0";
}

IR::WstringDef*
POA_IR::WstringDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_WstringDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_FixedDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FixedDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FixedDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19,  0,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FixedDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::FixedDef::_is_a_skel},
      {"destroy",       &POA_IR::FixedDef::destroy_skel},
      {"_get_type",     &POA_IR::FixedDef::_get_type_skel},
      {"_get_scale",    &POA_IR::FixedDef::_get_scale_skel},
      {"_set_scale",    &POA_IR::FixedDef::_set_scale_skel},
      {"_get_digits",   &POA_IR::FixedDef::_get_digits_skel},
      {"_set_digits",   &POA_IR::FixedDef::_set_digits_skel},
      {"_get_def_kind",         &POA_IR::FixedDef::_get_def_kind_skel},
      {"_non_existent",  &POA_IR::FixedDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -8,  -2, -10,  -2,   5,  -1,   6,  -1,   7, -27, -26,  -1,  12,
       -1,  -1,  -1,  -1,  13,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_FixedDef_Perfect_Hash_OpTable tao_IR_FixedDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker *POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::the_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::~_TAO_FixedDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_FixedDef_Proxy_Impl&
POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::select_proxy (
    IR_FixedDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FixedDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FixedDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_FixedDef_Proxy_Broker *
_TAO_FixedDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FixedDef_Strategized_Proxy_Broker::the_TAO_FixedDef_Strategized_Proxy_Broker();
}

int
_TAO_FixedDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_FixedDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_FixedDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_FixedDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_FixedDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_FixedDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::_TAO_FixedDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::~_TAO_FixedDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::UShort POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::UShort _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "digits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->digits (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "digits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->digits (
        digits,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Short POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Short _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "scale",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->scale (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_FixedDef_ThruPOA_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "scale",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/FixedDef:1.0"
        )
    )->scale (
        scale,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FixedDef::FixedDef (void)
{
  this->optable_ = &tao_IR_FixedDef_optable;
}

// copy ctor
POA_IR::FixedDef::FixedDef (const FixedDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FixedDef::~FixedDef (void)
{
}

void POA_IR::FixedDef::_get_digits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::UShort _tao_retval = 0;

  _tao_retval = _tao_impl->digits (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::FixedDef::_set_digits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::UShort digits;
  if (!(
    (_tao_in >> digits)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->digits (
      digits,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::FixedDef::_get_scale_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::Short _tao_retval = 0;

  _tao_retval = _tao_impl->scale (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::FixedDef::_set_scale_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *)_tao_object_reference;

  CORBA::Short scale;
  if (!(
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->scale (
      scale,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::FixedDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FixedDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FixedDef *_tao_impl = (POA_IR::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FixedDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FixedDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FixedDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FixedDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FixedDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FixedDef:1.0";
}

IR::FixedDef*
POA_IR::FixedDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_FixedDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_SequenceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_SequenceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_SequenceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_SequenceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::SequenceDef::_is_a_skel},
      {"destroy",       &POA_IR::SequenceDef::destroy_skel},
      {"_get_type",     &POA_IR::SequenceDef::_get_type_skel},
      {"_get_bound",    &POA_IR::SequenceDef::_get_bound_skel},
      {"_set_bound",    &POA_IR::SequenceDef::_set_bound_skel},
      {"_get_def_kind",         &POA_IR::SequenceDef::_get_def_kind_skel},
      {"_get_element_type",     &POA_IR::SequenceDef::_get_element_type_skel},
      {"_non_existent",  &POA_IR::SequenceDef::_non_existent_skel},
      {"_get_element_type_def",         &POA_IR::SequenceDef::_get_element_type_def_skel},
      {"_set_element_type_def",         &POA_IR::SequenceDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -28,  -1,  -1,  10,
       -1,  -1,  -1,  11,  12, -13,  -2, -23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_SequenceDef_Perfect_Hash_OpTable tao_IR_SequenceDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker *POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::the_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::~_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_SequenceDef_Proxy_Impl&
POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::select_proxy (
    IR_SequenceDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_SequenceDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_SequenceDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_SequenceDef_Proxy_Broker *
_TAO_SequenceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_SequenceDef_Strategized_Proxy_Broker::the_TAO_SequenceDef_Strategized_Proxy_Broker();
}

int
_TAO_SequenceDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_SequenceDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_SequenceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_SequenceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_SequenceDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_SequenceDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::_TAO_SequenceDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::~_TAO_SequenceDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->bound (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "bound",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->bound (
        bound,
        ACE_TRY_ENV
      );
  return;
}

CORBA::TypeCode_ptr POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type (
        ACE_TRY_ENV
      );
}

IR::IDLType_ptr POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_SequenceDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/SequenceDef:1.0"
        )
    )->element_type_def (
        element_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::SequenceDef::SequenceDef (void)
{
  this->optable_ = &tao_IR_SequenceDef_optable;
}

// copy ctor
POA_IR::SequenceDef::SequenceDef (const SequenceDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::SequenceDef::~SequenceDef (void)
{
}

void POA_IR::SequenceDef::_get_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

  _tao_retval = _tao_impl->bound (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::SequenceDef::_set_bound_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->bound (
      bound,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::SequenceDef::_get_element_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->element_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::SequenceDef::_get_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->element_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::SequenceDef::_set_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *)_tao_object_reference;

  IR_IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->element_type_def (
      element_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::SequenceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::SequenceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::SequenceDef *_tao_impl = (POA_IR::SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::SequenceDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::SequenceDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/SequenceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::SequenceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::SequenceDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/SequenceDef:1.0";
}

IR::SequenceDef*
POA_IR::SequenceDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_SequenceDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ArrayDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ArrayDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ArrayDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ArrayDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::ArrayDef::_is_a_skel},
      {"destroy",       &POA_IR::ArrayDef::destroy_skel},
      {"_get_type",     &POA_IR::ArrayDef::_get_type_skel},
      {"_get_length",   &POA_IR::ArrayDef::_get_length_skel},
      {"_set_length",   &POA_IR::ArrayDef::_set_length_skel},
      {"_get_def_kind",         &POA_IR::ArrayDef::_get_def_kind_skel},
      {"_get_element_type",     &POA_IR::ArrayDef::_get_element_type_skel},
      {"_non_existent",  &POA_IR::ArrayDef::_non_existent_skel},
      {"_get_element_type_def",         &POA_IR::ArrayDef::_get_element_type_def_skel},
      {"_set_element_type_def",         &POA_IR::ArrayDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7,  -1, -29,  -1,  10,
       -1,  -1,  -1,  11,  12, -13,  -2, -23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ArrayDef_Perfect_Hash_OpTable tao_IR_ArrayDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker *POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::the_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::~_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ArrayDef_Proxy_Impl&
POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::select_proxy (
    IR_ArrayDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ArrayDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ArrayDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ArrayDef_Proxy_Broker *
_TAO_ArrayDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ArrayDef_Strategized_Proxy_Broker::the_TAO_ArrayDef_Strategized_Proxy_Broker();
}

int
_TAO_ArrayDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ArrayDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ArrayDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ArrayDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ArrayDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ArrayDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::_TAO_ArrayDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::~_TAO_ArrayDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::ULong POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "length",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->length (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "length",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->length (
        length,
        ACE_TRY_ENV
      );
  return;
}

CORBA::TypeCode_ptr POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type (
        ACE_TRY_ENV
      );
}

IR::IDLType_ptr POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ArrayDef_ThruPOA_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "element_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ArrayDef:1.0"
        )
    )->element_type_def (
        element_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ArrayDef::ArrayDef (void)
{
  this->optable_ = &tao_IR_ArrayDef_optable;
}

// copy ctor
POA_IR::ArrayDef::ArrayDef (const ArrayDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ArrayDef::~ArrayDef (void)
{
}

void POA_IR::ArrayDef::_get_length_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;

  _tao_retval = _tao_impl->length (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ArrayDef::_set_length_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::ULong length;
  if (!(
    (_tao_in >> length)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->length (
      length,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ArrayDef::_get_element_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->element_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ArrayDef::_get_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->element_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ArrayDef::_set_element_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *)_tao_object_reference;

  IR_IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->element_type_def (
      element_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ArrayDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ArrayDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ArrayDef *_tao_impl = (POA_IR::ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ArrayDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ArrayDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ArrayDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ArrayDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ArrayDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ArrayDef:1.0";
}

IR::ArrayDef*
POA_IR::ArrayDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ArrayDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ExceptionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ExceptionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ExceptionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 20,  3,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 10, 15,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 15, 15, 52, 52, 52, 15,  5, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52,  0, 52,  0, 52, 20,
      3,  0, 52, 52, 52, 52, 52, 52, 10, 15,
      5, 52, 10, 52, 52, 15, 15, 52, 52, 52,
     15,  5, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ExceptionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 33,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_IR::ExceptionDef::_is_a_skel},
      {"_get_type",     &POA_IR::ExceptionDef::_get_type_skel},
      {"_set_name",     &POA_IR::ExceptionDef::_set_name_skel},
      {"_get_name",     &POA_IR::ExceptionDef::_get_name_skel},
      {"_get_id",       &POA_IR::ExceptionDef::_get_id_skel},
      {"_set_id",       &POA_IR::ExceptionDef::_set_id_skel},
      {"describe",      &POA_IR::ExceptionDef::describe_skel},
      {"destroy",       &POA_IR::ExceptionDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ExceptionDef::_get_def_kind_skel},
      {"_get_version",  &POA_IR::ExceptionDef::_get_version_skel},
      {"_set_version",  &POA_IR::ExceptionDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ExceptionDef::_get_absolute_name_skel},
      {"move",  &POA_IR::ExceptionDef::move_skel},
      {"_get_defined_in",       &POA_IR::ExceptionDef::_get_defined_in_skel},
      {"lookup_name",   &POA_IR::ExceptionDef::lookup_name_skel},
      {"lookup",        &POA_IR::ExceptionDef::lookup_skel},
      {"_get_members",  &POA_IR::ExceptionDef::_get_members_skel},
      {"_set_members",  &POA_IR::ExceptionDef::_set_members_skel},
      {"_non_existent",  &POA_IR::ExceptionDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ExceptionDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::ExceptionDef::create_value_skel},
      {"create_module",         &POA_IR::ExceptionDef::create_module_skel},
      {"create_native",         &POA_IR::ExceptionDef::create_native_skel},
      {"describe_contents",     &POA_IR::ExceptionDef::describe_contents_skel},
      {"create_interface",      &POA_IR::ExceptionDef::create_interface_skel},
      {"create_union",  &POA_IR::ExceptionDef::create_union_skel},
      {"create_exception",      &POA_IR::ExceptionDef::create_exception_skel},
      {"contents",      &POA_IR::ExceptionDef::contents_skel},
      {"create_enum",   &POA_IR::ExceptionDef::create_enum_skel},
      {"create_alias",  &POA_IR::ExceptionDef::create_alias_skel},
      {"create_struct",         &POA_IR::ExceptionDef::create_struct_skel},
      {"create_constant",       &POA_IR::ExceptionDef::create_constant_skel},
      {"create_value_box",      &POA_IR::ExceptionDef::create_value_box_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -3,   5,  -1,  -9,  -2, -57, -54,  11,  -1, -14,
       -2,  12,  13, -55,  16,  17,  18,  19,  -1,  -1, -21,  -2,  20, -54,
       23, -26,  -2,  24,  25, -55,  -1,  28,  29,  30,  -1,  -1,  -1,  31,
       -1,  32,  -1,  -1,  33,  34,  35,  -1,  36,  37,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ExceptionDef_Perfect_Hash_OpTable tao_IR_ExceptionDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker *POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::the_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::~_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ExceptionDef_Proxy_Impl&
POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::select_proxy (
    IR_ExceptionDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ExceptionDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ExceptionDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ExceptionDef_Proxy_Broker *
_TAO_ExceptionDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ExceptionDef_Strategized_Proxy_Broker::the_TAO_ExceptionDef_Strategized_Proxy_Broker();
}

int
_TAO_ExceptionDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ExceptionDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ExceptionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ExceptionDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ExceptionDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::_TAO_ExceptionDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::~_TAO_ExceptionDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

IR::StructMemberSeq * POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->members (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ExceptionDef_ThruPOA_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "members",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ExceptionDef:1.0"
        )
    )->members (
        members,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ExceptionDef::ExceptionDef (void)
{
  this->optable_ = &tao_IR_ExceptionDef_optable;
}

// copy ctor
POA_IR::ExceptionDef::ExceptionDef (const ExceptionDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ExceptionDef::~ExceptionDef (void)
{
}

void POA_IR::ExceptionDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ExceptionDef::_get_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  IR_StructMemberSeq_var _tao_retval;

  _tao_retval = _tao_impl->members (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ExceptionDef::_set_members_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *)_tao_object_reference;

  IR_StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->members (
      members,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ExceptionDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ExceptionDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ExceptionDef *_tao_impl = (POA_IR::ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ExceptionDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ExceptionDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ExceptionDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ExceptionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ExceptionDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ExceptionDef:1.0";
}

class TAO_IR_AttributeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_AttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_AttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_AttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::AttributeDef::move_skel},
      {"_is_a",  &POA_IR::AttributeDef::_is_a_skel},
      {"_get_id",       &POA_IR::AttributeDef::_get_id_skel},
      {"_set_id",       &POA_IR::AttributeDef::_set_id_skel},
      {"describe",      &POA_IR::AttributeDef::describe_skel},
      {"_get_type",     &POA_IR::AttributeDef::_get_type_skel},
      {"_set_name",     &POA_IR::AttributeDef::_set_name_skel},
      {"_get_name",     &POA_IR::AttributeDef::_get_name_skel},
      {"_set_mode",     &POA_IR::AttributeDef::_set_mode_skel},
      {"_get_mode",     &POA_IR::AttributeDef::_get_mode_skel},
      {"_get_version",  &POA_IR::AttributeDef::_get_version_skel},
      {"_set_version",  &POA_IR::AttributeDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::AttributeDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::AttributeDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::AttributeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::AttributeDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::AttributeDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::AttributeDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::AttributeDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::AttributeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -5,   4,   5,  -1, -43,   8, -43, -14,  -2, -38,  16,
       -1,  17,  -1,  18,  19,  -1,  -1, -20,  -2, -38,  -1,  -1,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_AttributeDef_Perfect_Hash_OpTable tao_IR_AttributeDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker *POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::the_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::~_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_AttributeDef_Proxy_Impl&
POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::select_proxy (
    IR_AttributeDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_AttributeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_AttributeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_AttributeDef_Proxy_Broker *
_TAO_AttributeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_AttributeDef_Strategized_Proxy_Broker::the_TAO_AttributeDef_Strategized_Proxy_Broker();
}

int
_TAO_AttributeDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_AttributeDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_AttributeDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_AttributeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_AttributeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_AttributeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::_TAO_AttributeDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::~_TAO_AttributeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

IR::IDLType_ptr POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->type_def (
        type_def,
        ACE_TRY_ENV
      );
  return;
}

IR::AttributeMode POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_AttributeMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->mode (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_AttributeDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    IR_AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/AttributeDef:1.0"
        )
    )->mode (
        mode,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::AttributeDef::AttributeDef (void)
{
  this->optable_ = &tao_IR_AttributeDef_optable;
}

// copy ctor
POA_IR::AttributeDef::AttributeDef (const AttributeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::AttributeDef::~AttributeDef (void)
{
}

void POA_IR::AttributeDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::AttributeDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::AttributeDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR_IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->type_def (
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::AttributeDef::_get_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR_AttributeMode _tao_retval;

  _tao_retval = _tao_impl->mode (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::AttributeDef::_set_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *)_tao_object_reference;

  IR_AttributeMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );


  _tao_impl->mode (
      mode,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::AttributeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::AttributeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::AttributeDef *_tao_impl = (POA_IR::AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::AttributeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::AttributeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/AttributeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::AttributeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::AttributeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AttributeDef:1.0";
}

IR::AttributeDef*
POA_IR::AttributeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_AttributeDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_OperationDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_OperationDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_OperationDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_OperationDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::OperationDef::move_skel},
      {"_is_a",  &POA_IR::OperationDef::_is_a_skel},
      {"_get_mode",     &POA_IR::OperationDef::_get_mode_skel},
      {"_set_name",     &POA_IR::OperationDef::_set_name_skel},
      {"_get_name",     &POA_IR::OperationDef::_get_name_skel},
      {"_set_mode",     &POA_IR::OperationDef::_set_mode_skel},
      {"_get_params",   &POA_IR::OperationDef::_get_params_skel},
      {"_set_params",   &POA_IR::OperationDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::OperationDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::OperationDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::OperationDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::OperationDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::OperationDef::_get_version_skel},
      {"_set_version",  &POA_IR::OperationDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::OperationDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::OperationDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::OperationDef::_get_id_skel},
      {"_set_id",       &POA_IR::OperationDef::_set_id_skel},
      {"describe",      &POA_IR::OperationDef::describe_skel},
      {"_get_result_def",       &POA_IR::OperationDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::OperationDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::OperationDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::OperationDef::_get_result_skel},
      {"destroy",       &POA_IR::OperationDef::destroy_skel},
      {"_non_existent",  &POA_IR::OperationDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::OperationDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_OperationDef_Perfect_Hash_OpTable tao_IR_OperationDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker *POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::the_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::~_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_OperationDef_Proxy_Impl&
POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::select_proxy (
    IR_OperationDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_OperationDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_OperationDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_OperationDef_Proxy_Broker *
_TAO_OperationDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_OperationDef_Strategized_Proxy_Broker::the_TAO_OperationDef_Strategized_Proxy_Broker();
}

int
_TAO_OperationDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_OperationDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_OperationDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_OperationDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_OperationDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_OperationDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::_TAO_OperationDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::~_TAO_OperationDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::result (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result (
        ACE_TRY_ENV
      );
}

IR::IDLType_ptr POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "result_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->result_def (
        result_def,
        ACE_TRY_ENV
      );
  return;
}

IR::ParDescriptionSeq * POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ParDescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "params",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->params (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_,
    const IR_ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "params",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->params (
        params,
        ACE_TRY_ENV
      );
  return;
}

IR::OperationMode POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_OperationMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->mode (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    IR_OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "mode",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->mode (
        mode,
        ACE_TRY_ENV
      );
  return;
}

IR::ContextIdSeq * POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ContextIdSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contexts",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->contexts (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "contexts",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->contexts (
        contexts,
        ACE_TRY_ENV
      );
  return;
}

IR::ExceptionDefSeq * POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ExceptionDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "exceptions",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->exceptions (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_OperationDef_ThruPOA_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "exceptions",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/OperationDef:1.0"
        )
    )->exceptions (
        exceptions,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::OperationDef::OperationDef (void)
{
  this->optable_ = &tao_IR_OperationDef_optable;
}

// copy ctor
POA_IR::OperationDef::OperationDef (const OperationDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::OperationDef::~OperationDef (void)
{
}

void POA_IR::OperationDef::_get_result_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->result (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_get_result_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->result_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_result_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_IDLType_var result_def;
  if (!(
    (_tao_in >> result_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->result_def (
      result_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::OperationDef::_get_params_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ParDescriptionSeq_var _tao_retval;

  _tao_retval = _tao_impl->params (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_params_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ParDescriptionSeq params;
  if (!(
    (_tao_in >> params)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->params (
      params,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::OperationDef::_get_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_OperationMode _tao_retval;

  _tao_retval = _tao_impl->mode (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_mode_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_OperationMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->mode (
      mode,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::OperationDef::_get_contexts_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ContextIdSeq_var _tao_retval;

  _tao_retval = _tao_impl->contexts (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_contexts_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ContextIdSeq contexts;
  if (!(
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->contexts (
      contexts,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::OperationDef::_get_exceptions_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ExceptionDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->exceptions (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::OperationDef::_set_exceptions_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *)_tao_object_reference;

  IR_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->exceptions (
      exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::OperationDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::OperationDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::OperationDef *_tao_impl = (POA_IR::OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::OperationDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::OperationDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::OperationDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/OperationDef:1.0";
}

IR::OperationDef*
POA_IR::OperationDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_OperationDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_InterfaceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_InterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_InterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66,  0,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66,  0,
     66, 20,  8,  0, 66, 66, 66, 10, 66, 66,
     66, 66, 66, 66, 66, 66, 66,  0,  0,  5,
     66,  0, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 10, 30, 66, 66, 66, 20, 25, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66,
#else
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66,  0, 66,  0, 66, 20,
      8,  0, 66, 66, 66, 10, 66, 66,  0,  0,
      5, 66,  0, 66, 66, 10, 30, 66, 66, 66,
     20, 25, 66, 66, 66, 66, 66, 66,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_InterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 40,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 65,
      HASH_VALUE_RANGE = 62,
      DUPLICATES = 11
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::InterfaceDef::move_skel},
      {"_is_a",  &POA_IR::InterfaceDef::_is_a_skel},
      {"lookup",        &POA_IR::InterfaceDef::lookup_skel},
      {"_get_name",     &POA_IR::InterfaceDef::_get_name_skel},
      {"_get_type",     &POA_IR::InterfaceDef::_get_type_skel},
      {"_set_name",     &POA_IR::InterfaceDef::_set_name_skel},
      {"lookup_name",   &POA_IR::InterfaceDef::lookup_name_skel},
      {"_get_is_local",         &POA_IR::InterfaceDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::InterfaceDef::_set_is_local_skel},
      {"is_a",  &POA_IR::InterfaceDef::is_a_skel},
      {"_get_id",       &POA_IR::InterfaceDef::_get_id_skel},
      {"_set_id",       &POA_IR::InterfaceDef::_set_id_skel},
      {"describe",      &POA_IR::InterfaceDef::describe_skel},
      {"_get_version",  &POA_IR::InterfaceDef::_get_version_skel},
      {"_set_version",  &POA_IR::InterfaceDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::InterfaceDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::InterfaceDef::_get_defined_in_skel},
      {"_get_def_kind",         &POA_IR::InterfaceDef::_get_def_kind_skel},
      {"_get_base_interfaces",  &POA_IR::InterfaceDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::InterfaceDef::_set_base_interfaces_skel},
      {"create_enum",   &POA_IR::InterfaceDef::create_enum_skel},
      {"create_value",  &POA_IR::InterfaceDef::create_value_skel},
      {"create_module",         &POA_IR::InterfaceDef::create_module_skel},
      {"create_native",         &POA_IR::InterfaceDef::create_native_skel},
      {"describe_contents",     &POA_IR::InterfaceDef::describe_contents_skel},
      {"create_attribute",      &POA_IR::InterfaceDef::create_attribute_skel},
      {"create_interface",      &POA_IR::InterfaceDef::create_interface_skel},
      {"create_union",  &POA_IR::InterfaceDef::create_union_skel},
      {"contents",      &POA_IR::InterfaceDef::contents_skel},
      {"destroy",       &POA_IR::InterfaceDef::destroy_skel},
      {"create_operation",      &POA_IR::InterfaceDef::create_operation_skel},
      {"create_exception",      &POA_IR::InterfaceDef::create_exception_skel},
      {"create_alias",  &POA_IR::InterfaceDef::create_alias_skel},
      {"_non_existent",  &POA_IR::InterfaceDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::InterfaceDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::InterfaceDef::_set_is_abstract_skel},
      {"_get_containing_repository",    &POA_IR::InterfaceDef::_get_containing_repository_skel},
      {"create_value_box",      &POA_IR::InterfaceDef::create_value_box_skel},
      {"create_struct",         &POA_IR::InterfaceDef::create_struct_skel},
      {"create_constant",       &POA_IR::InterfaceDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -11,   -2,  -14,   -2,    4,    5,    6,  -17,   -2,  103,   -1,   10,   -1,  -78,
        13,  -78,   16,  -75,   19,   -1,   20,   21,  -22,   -2,  -26,   -2,  -29,   -2,
       -34,   -2,  -73,   24,   25,  -74,   -1,   28,  -75,   31,   32,   -1,   33,  -78,
        36,   37,  -38,   -2,  -67,   -7,   -3,   -1,   -1,   40,   -1,   -1,   -1,   -1,
        41,   -1,   -1,   -1,   -1,   -1,   -1,   42,   -1,   43,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_InterfaceDef_Perfect_Hash_OpTable tao_IR_InterfaceDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker *POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::the_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::~_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_InterfaceDef_Proxy_Impl&
POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::select_proxy (
    IR_InterfaceDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_InterfaceDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_InterfaceDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_InterfaceDef_Proxy_Broker *
_TAO_InterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_InterfaceDef_Strategized_Proxy_Broker::the_TAO_InterfaceDef_Strategized_Proxy_Broker();
}

int
_TAO_InterfaceDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_InterfaceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_InterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_InterfaceDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_InterfaceDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::_TAO_InterfaceDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::~_TAO_InterfaceDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::InterfaceDefSeq * POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->base_interfaces (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->base_interfaces (
        base_interfaces,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_abstract (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_abstract (
        is_abstract,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_local (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_local",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_local (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_local (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_local",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_local (
        is_local,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->is_a (
        interface_id,
        ACE_TRY_ENV
      );
}

IR::AttributeDef_ptr POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_attribute",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->create_attribute (
        id,
        name,
        version,
        type,
        mode,
        get_exceptions,
        put_exceptions,
        ACE_TRY_ENV
      );
}

IR::OperationDef_ptr POA_IR::_TAO_InterfaceDef_ThruPOA_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_operation",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/InterfaceDef:1.0"
        )
    )->create_operation (
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::InterfaceDef::InterfaceDef (void)
{
  this->optable_ = &tao_IR_InterfaceDef_optable;
}

// copy ctor
POA_IR::InterfaceDef::InterfaceDef (const InterfaceDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::InterfaceDef::~InterfaceDef (void)
{
}

void POA_IR::InterfaceDef::_get_base_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR_InterfaceDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->base_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::_set_base_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR_InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->base_interfaces (
      base_interfaces,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::InterfaceDef::_get_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_abstract (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::_set_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean is_abstract;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_abstract))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::InterfaceDef::_get_is_local_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_local (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::_set_is_local_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean is_local;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_local))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_local (
      is_local,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::InterfaceDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var interface_id;
  if (!(
    (_tao_in >> interface_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->is_a (
      interface_id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::create_attribute_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR_AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var type;
  IR_AttributeMode mode;
  IR_ExceptionDefSeq get_exceptions;
  IR_ExceptionDefSeq put_exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> get_exceptions) &&
    (_tao_in >> put_exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_attribute (
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::create_operation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *)_tao_object_reference;

  IR_OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var result;
  IR_OperationMode mode;
  IR_ParDescriptionSeq params;
  IR_ExceptionDefSeq exceptions;
  IR_ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_operation (
      id.in (),
      name.in (),
      version.in (),
      result.in (),
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::InterfaceDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::InterfaceDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::InterfaceDef *_tao_impl = (POA_IR::InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::InterfaceDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::InterfaceDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::InterfaceDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/InterfaceDef:1.0";
}

IR::InterfaceDef*
POA_IR::InterfaceDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_InterfaceDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ValueMemberDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:10 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueMemberDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueMemberDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37,  0, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueMemberDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueMemberDef::move_skel},
      {"_is_a",  &POA_IR::ValueMemberDef::_is_a_skel},
      {"_get_id",       &POA_IR::ValueMemberDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueMemberDef::_set_id_skel},
      {"describe",      &POA_IR::ValueMemberDef::describe_skel},
      {"_get_type",     &POA_IR::ValueMemberDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueMemberDef::_set_name_skel},
      {"_get_name",     &POA_IR::ValueMemberDef::_get_name_skel},
      {"_get_access",   &POA_IR::ValueMemberDef::_get_access_skel},
      {"_set_access",   &POA_IR::ValueMemberDef::_set_access_skel},
      {"_get_version",  &POA_IR::ValueMemberDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueMemberDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ValueMemberDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ValueMemberDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ValueMemberDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ValueMemberDef::_get_absolute_name_skel},
      {"_get_type_def",         &POA_IR::ValueMemberDef::_get_type_def_skel},
      {"_set_type_def",         &POA_IR::ValueMemberDef::_set_type_def_skel},
      {"_non_existent",  &POA_IR::ValueMemberDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ValueMemberDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46,  -1, -47, -46,  16,
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1,
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:10 */
static TAO_IR_ValueMemberDef_Perfect_Hash_OpTable tao_IR_ValueMemberDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker *POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::the_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::~_TAO_ValueMemberDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ValueMemberDef_Proxy_Impl&
POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::select_proxy (
    IR_ValueMemberDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueMemberDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueMemberDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueMemberDef_Proxy_Broker *
_TAO_ValueMemberDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ValueMemberDef_Strategized_Proxy_Broker::the_TAO_ValueMemberDef_Strategized_Proxy_Broker();
}

int
_TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ValueMemberDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ValueMemberDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ValueMemberDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::~_TAO_ValueMemberDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::TypeCode_ptr POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type (
        ACE_TRY_ENV
      );
}

IR::IDLType_ptr POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->type_def (
        type_def,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Visibility POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Visibility _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "access",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->access (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueMemberDef_ThruPOA_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "access",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueMemberDef:1.0"
        )
    )->access (
        access,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ValueMemberDef::ValueMemberDef (void)
{
  this->optable_ = &tao_IR_ValueMemberDef_optable;
}

// copy ctor
POA_IR::ValueMemberDef::ValueMemberDef (const ValueMemberDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueMemberDef::~ValueMemberDef (void)
{
}

void POA_IR::ValueMemberDef::_get_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;

  _tao_retval = _tao_impl->type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueMemberDef::_get_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueMemberDef::_set_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  IR_IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->type_def (
      type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueMemberDef::_get_access_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::Visibility _tao_retval = 0;

  _tao_retval = _tao_impl->access (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueMemberDef::_set_access_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *)_tao_object_reference;

  CORBA::Visibility access;
  if (!(
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->access (
      access,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueMemberDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueMemberDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueMemberDef *_tao_impl = (POA_IR::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueMemberDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueMemberDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueMemberDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueMemberDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueMemberDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueMemberDef:1.0";
}

IR::ValueMemberDef*
POA_IR::ValueMemberDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ValueMemberDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ValueDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 50, 35,  0, 86, 86, 86, 20, 86, 86,
     86, 86, 86, 86, 86, 86, 86,  0,  0, 15,
     86,  0, 86,  0, 86, 86, 86, 86, 86, 86,
     86, 86, 20, 20, 86, 86, 86,  5,  5, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86,
#else
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86,  0, 86,  0, 86, 50,
     35,  0, 86, 86, 86, 20, 86, 86,  0,  0,
     15, 86,  0, 86,  0, 20, 20, 86, 86, 86,
      5,  5, 86, 86, 86, 86, 86, 86,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 85,
      HASH_VALUE_RANGE = 82,
      DUPLICATES = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueDef::move_skel},
      {"_is_a",  &POA_IR::ValueDef::_is_a_skel},
      {"lookup",        &POA_IR::ValueDef::lookup_skel},
      {"_get_name",     &POA_IR::ValueDef::_get_name_skel},
      {"_get_type",     &POA_IR::ValueDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueDef::_set_name_skel},
      {"lookup_name",   &POA_IR::ValueDef::lookup_name_skel},
      {"_get_is_custom",        &POA_IR::ValueDef::_get_is_custom_skel},
      {"_set_is_custom",        &POA_IR::ValueDef::_set_is_custom_skel},
      {"_get_base_value",       &POA_IR::ValueDef::_get_base_value_skel},
      {"_set_base_value",       &POA_IR::ValueDef::_set_base_value_skel},
      {"_get_absolute_name",    &POA_IR::ValueDef::_get_absolute_name_skel},
      {"_get_is_truncatable",   &POA_IR::ValueDef::_get_is_truncatable_skel},
      {"_set_is_truncatable",   &POA_IR::ValueDef::_set_is_truncatable_skel},
      {"is_a",  &POA_IR::ValueDef::is_a_skel},
      {"_get_version",  &POA_IR::ValueDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueDef::_set_version_skel},
      {"_get_defined_in",       &POA_IR::ValueDef::_get_defined_in_skel},
      {"_get_containing_repository",    &POA_IR::ValueDef::_get_containing_repository_skel},
      {"_non_existent",  &POA_IR::ValueDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::ValueDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::ValueDef::_set_is_abstract_skel},
      {"_get_initializers",     &POA_IR::ValueDef::_get_initializers_skel},
      {"_set_initializers",     &POA_IR::ValueDef::_set_initializers_skel},
      {"_get_id",       &POA_IR::ValueDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueDef::_set_id_skel},
      {"describe",      &POA_IR::ValueDef::describe_skel},
      {"_get_supported_interfaces",     &POA_IR::ValueDef::_get_supported_interfaces_skel},
      {"_set_abstract_base_values",     &POA_IR::ValueDef::_set_abstract_base_values_skel},
      {"_get_abstract_base_values",     &POA_IR::ValueDef::_get_abstract_base_values_skel},
      {"_set_supported_interfaces",     &POA_IR::ValueDef::_set_supported_interfaces_skel},
      {"destroy",       &POA_IR::ValueDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::ValueDef::_get_def_kind_skel},
      {"create_enum",   &POA_IR::ValueDef::create_enum_skel},
      {"create_value",  &POA_IR::ValueDef::create_value_skel},
      {"create_module",         &POA_IR::ValueDef::create_module_skel},
      {"create_native",         &POA_IR::ValueDef::create_native_skel},
      {"create_attribute",      &POA_IR::ValueDef::create_attribute_skel},
      {"create_interface",      &POA_IR::ValueDef::create_interface_skel},
      {"create_value_member",   &POA_IR::ValueDef::create_value_member_skel},
      {"create_value_box",      &POA_IR::ValueDef::create_value_box_skel},
      {"describe_contents",     &POA_IR::ValueDef::describe_contents_skel},
      {"create_union",  &POA_IR::ValueDef::create_union_skel},
      {"contents",      &POA_IR::ValueDef::contents_skel},
      {"create_operation",      &POA_IR::ValueDef::create_operation_skel},
      {"create_exception",      &POA_IR::ValueDef::create_exception_skel},
      {"create_alias",  &POA_IR::ValueDef::create_alias_skel},
      {"create_struct",         &POA_IR::ValueDef::create_struct_skel},
      {"create_constant",       &POA_IR::ValueDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -7,  -3,   4,   5,   6, -11,  -2, -92,  -1,  10, -13,  -2,
      -92, -88, -16,  -2,  15, -88,  -1,  -1,  -1,  -1,  18, -19,  -2, -87,
      -24,  -2,  21,  22,  -1,  23, -26,  -2, -93, -88, -28,  -2, -31,  -4,
      -89,  30,  -1, -90,  -1,  35,  36,  -1,  -1,  -1,  -1,  -1,  -1,  -1,
       -1,  -1,  -1, -39,  -2,  37,  38, -89, -41,  -2, -87,  -1,  -1,  43,
       -1,  44,  45,  -1,  -1,  -1,  -1,  46,  47, -48,  -2, -87,  50,  51,
       -1,  52,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ValueDef_Perfect_Hash_OpTable tao_IR_ValueDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker *POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::the_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::~_TAO_ValueDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ValueDef_Proxy_Impl&
POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::select_proxy (
    IR_ValueDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueDef_Proxy_Broker *
_TAO_ValueDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ValueDef_Strategized_Proxy_Broker::the_TAO_ValueDef_Strategized_Proxy_Broker();
}

int
_TAO_ValueDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ValueDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ValueDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ValueDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ValueDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ValueDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::_TAO_ValueDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::~_TAO_ValueDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::InterfaceDefSeq * POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->supported_interfaces (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->supported_interfaces (
        supported_interfaces,
        ACE_TRY_ENV
      );
  return;
}

IR::InitializerSeq * POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InitializerSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "initializers",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->initializers (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "initializers",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->initializers (
        initializers,
        ACE_TRY_ENV
      );
  return;
}

IR::ValueDef_ptr POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->base_value (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    IR_ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_value",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->base_value (
        base_value,
        ACE_TRY_ENV
      );
  return;
}

IR::ValueDefSeq * POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "abstract_base_values",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->abstract_base_values (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    const IR_ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "abstract_base_values",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->abstract_base_values (
        abstract_base_values,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_abstract (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_abstract",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_abstract (
        is_abstract,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_custom",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_custom (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_custom",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_custom (
        is_custom,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_truncatable",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_truncatable (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_truncatable",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_truncatable (
        is_truncatable,
        ACE_TRY_ENV
      );
  return;
}

CORBA::Boolean POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->is_a (
        id,
        ACE_TRY_ENV
      );
}

IR::ValueMemberDef_ptr POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_value_member (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueMemberDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_value_member",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_value_member (
        id,
        name,
        version,
        type,
        access,
        ACE_TRY_ENV
      );
}

IR::AttributeDef_ptr POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_attribute",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_attribute (
        id,
        name,
        version,
        type,
        mode,
        get_exceptions,
        put_exceptions,
        ACE_TRY_ENV
      );
}

IR::OperationDef_ptr POA_IR::_TAO_ValueDef_ThruPOA_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_operation",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueDef:1.0"
        )
    )->create_operation (
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ValueDef::ValueDef (void)
{
  this->optable_ = &tao_IR_ValueDef_optable;
}

// copy ctor
POA_IR::ValueDef::ValueDef (const ValueDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueDef::~ValueDef (void)
{
}

void POA_IR::ValueDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_InterfaceDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->supported_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->supported_interfaces (
      supported_interfaces,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueDef::_get_initializers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_InitializerSeq_var _tao_retval;

  _tao_retval = _tao_impl->initializers (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_initializers_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_InitializerSeq initializers;
  if (!(
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->initializers (
      initializers,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueDef::_get_base_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueDef_var _tao_retval;

  _tao_retval = _tao_impl->base_value (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_base_value_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueDef_var base_value;
  if (!(
    (_tao_in >> base_value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->base_value (
      base_value.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueDef::_get_abstract_base_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->abstract_base_values (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_abstract_base_values_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueDefSeq abstract_base_values;
  if (!(
    (_tao_in >> abstract_base_values)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->abstract_base_values (
      abstract_base_values,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueDef::_get_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_abstract (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_is_abstract_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_abstract;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_abstract))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueDef::_get_is_custom_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_custom (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_is_custom_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_custom;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_custom))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_custom (
      is_custom,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueDef::_get_is_truncatable_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_truncatable (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_set_is_truncatable_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_truncatable;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->is_truncatable (
      is_truncatable,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->is_a (
      id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::create_value_member_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_ValueMemberDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var type;
  CORBA::Visibility access;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_value_member (
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      access,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::create_attribute_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var type;
  IR_AttributeMode mode;
  IR_ExceptionDefSeq get_exceptions;
  IR_ExceptionDefSeq put_exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> get_exceptions) &&
    (_tao_in >> put_exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_attribute (
      id.in (),
      name.in (),
      version.in (),
      type.in (),
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::create_operation_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *)_tao_object_reference;

  IR_OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_IDLType_var result;
  IR_OperationMode mode;
  IR_ParDescriptionSeq params;
  IR_ExceptionDefSeq exceptions;
  IR_ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_operation (
      id.in (),
      name.in (),
      version.in (),
      result.in (),
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueDef *_tao_impl = (POA_IR::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueDef:1.0";
}

IR::ValueDef*
POA_IR::ValueDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ValueDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ValueBoxDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ValueBoxDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ValueBoxDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ValueBoxDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ValueBoxDef::move_skel},
      {"_is_a",  &POA_IR::ValueBoxDef::_is_a_skel},
      {"_get_id",       &POA_IR::ValueBoxDef::_get_id_skel},
      {"_set_id",       &POA_IR::ValueBoxDef::_set_id_skel},
      {"describe",      &POA_IR::ValueBoxDef::describe_skel},
      {"_get_name",     &POA_IR::ValueBoxDef::_get_name_skel},
      {"_get_type",     &POA_IR::ValueBoxDef::_get_type_skel},
      {"_set_name",     &POA_IR::ValueBoxDef::_set_name_skel},
      {"_get_version",  &POA_IR::ValueBoxDef::_get_version_skel},
      {"_set_version",  &POA_IR::ValueBoxDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ValueBoxDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ValueBoxDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ValueBoxDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ValueBoxDef::_get_absolute_name_skel},
      {"_get_original_type_def",        &POA_IR::ValueBoxDef::_get_original_type_def_skel},
      {"_set_original_type_def",        &POA_IR::ValueBoxDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_IR::ValueBoxDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ValueBoxDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14,
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ValueBoxDef_Perfect_Hash_OpTable tao_IR_ValueBoxDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker *POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::the_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::~_TAO_ValueBoxDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ValueBoxDef_Proxy_Impl&
POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::select_proxy (
    IR_ValueBoxDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueBoxDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ValueBoxDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ValueBoxDef_Proxy_Broker *
_TAO_ValueBoxDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ValueBoxDef_Strategized_Proxy_Broker::the_TAO_ValueBoxDef_Strategized_Proxy_Broker();
}

int
_TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ValueBoxDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ValueBoxDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ValueBoxDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::~_TAO_ValueBoxDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::IDLType_ptr POA_IR::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueBoxDef:1.0"
        )
    )->original_type_def (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ValueBoxDef_ThruPOA_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "original_type_def",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ValueBoxDef:1.0"
        )
    )->original_type_def (
        original_type_def,
        ACE_TRY_ENV
      );
  return;
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ValueBoxDef::ValueBoxDef (void)
{
  this->optable_ = &tao_IR_ValueBoxDef_optable;
}

// copy ctor
POA_IR::ValueBoxDef::ValueBoxDef (const ValueBoxDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ValueBoxDef::~ValueBoxDef (void)
{
}

void POA_IR::ValueBoxDef::_get_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *)_tao_object_reference;

  IR_IDLType_var _tao_retval;

  _tao_retval = _tao_impl->original_type_def (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ValueBoxDef::_set_original_type_def_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *)_tao_object_reference;

  IR_IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->original_type_def (
      original_type_def.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ValueBoxDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ValueBoxDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ValueBoxDef *_tao_impl = (POA_IR::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ValueBoxDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ValueBoxDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ValueBoxDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ValueBoxDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_IR::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ValueBoxDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueBoxDef:1.0";
}

IR::ValueBoxDef*
POA_IR::ValueBoxDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ValueBoxDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ProvidesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ProvidesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ProvidesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ProvidesDef::move_skel},
      {"_is_a",  &POA_IR::ProvidesDef::_is_a_skel},
      {"_get_id",       &POA_IR::ProvidesDef::_get_id_skel},
      {"_set_id",       &POA_IR::ProvidesDef::_set_id_skel},
      {"describe",      &POA_IR::ProvidesDef::describe_skel},
      {"_get_name",     &POA_IR::ProvidesDef::_get_name_skel},
      {"_set_name",     &POA_IR::ProvidesDef::_set_name_skel},
      {"_get_version",  &POA_IR::ProvidesDef::_get_version_skel},
      {"_set_version",  &POA_IR::ProvidesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ProvidesDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::ProvidesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ProvidesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ProvidesDef::_get_absolute_name_skel},
      {"_get_interface_type",   &POA_IR::ProvidesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::ProvidesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ProvidesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  -1,  15,  16,  17,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ProvidesDef_Perfect_Hash_OpTable tao_IR_ProvidesDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker *POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::the_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::~_TAO_ProvidesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ProvidesDef_Proxy_Impl&
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::select_proxy (
    IR_ProvidesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ProvidesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ProvidesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ProvidesDef_Proxy_Broker *
_TAO_ProvidesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ProvidesDef_Strategized_Proxy_Broker::the_TAO_ProvidesDef_Strategized_Proxy_Broker();
}

int
_TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ProvidesDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ProvidesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ProvidesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ProvidesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::_TAO_ProvidesDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::~_TAO_ProvidesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::InterfaceDef_ptr POA_IR::_TAO_ProvidesDef_ThruPOA_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "interface_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ProvidesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ProvidesDef:1.0"
        )
    )->interface_type (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ProvidesDef::ProvidesDef (void)
{
  this->optable_ = &tao_IR_ProvidesDef_optable;
}

// copy ctor
POA_IR::ProvidesDef::ProvidesDef (const ProvidesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ProvidesDef::~ProvidesDef (void)
{
}

void POA_IR::ProvidesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *)_tao_object_reference;

  IR_InterfaceDef_var _tao_retval;

  _tao_retval = _tao_impl->interface_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ProvidesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ProvidesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ProvidesDef *_tao_impl = (POA_IR::ProvidesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ProvidesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ProvidesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ProvidesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ProvidesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ProvidesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

IR::ProvidesDef*
POA_IR::ProvidesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ProvidesDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_UsesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_UsesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_UsesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_UsesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::UsesDef::move_skel},
      {"_is_a",  &POA_IR::UsesDef::_is_a_skel},
      {"_get_id",       &POA_IR::UsesDef::_get_id_skel},
      {"_set_id",       &POA_IR::UsesDef::_set_id_skel},
      {"describe",      &POA_IR::UsesDef::describe_skel},
      {"_get_name",     &POA_IR::UsesDef::_get_name_skel},
      {"_set_name",     &POA_IR::UsesDef::_set_name_skel},
      {"_get_version",  &POA_IR::UsesDef::_get_version_skel},
      {"_set_version",  &POA_IR::UsesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::UsesDef::_get_def_kind_skel},
      {"_get_defined_in",       &POA_IR::UsesDef::_get_defined_in_skel},
      {"_get_is_multiple",      &POA_IR::UsesDef::_get_is_multiple_skel},
      {"destroy",       &POA_IR::UsesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::UsesDef::_get_absolute_name_skel},
      {"_get_interface_type",   &POA_IR::UsesDef::_get_interface_type_skel},
      {"_non_existent",  &POA_IR::UsesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::UsesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       -1,  14,  15,  16,  17,  18,  -1,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_UsesDef_Perfect_Hash_OpTable tao_IR_UsesDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker *POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::the_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::~_TAO_UsesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_UsesDef_Proxy_Impl&
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::select_proxy (
    IR_UsesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_UsesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_UsesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_UsesDef_Proxy_Broker *
_TAO_UsesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_UsesDef_Strategized_Proxy_Broker::the_TAO_UsesDef_Strategized_Proxy_Broker();
}

int
_TAO_UsesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_UsesDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_UsesDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_UsesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_UsesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_UsesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::_TAO_UsesDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::~_TAO_UsesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::InterfaceDef_ptr POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "interface_type",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->interface_type (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_UsesDef_ThruPOA_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_multiple",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::UsesDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/UsesDef:1.0"
        )
    )->is_multiple (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::UsesDef::UsesDef (void)
{
  this->optable_ = &tao_IR_UsesDef_optable;
}

// copy ctor
POA_IR::UsesDef::UsesDef (const UsesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::UsesDef::~UsesDef (void)
{
}

void POA_IR::UsesDef::_get_interface_type_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *)_tao_object_reference;

  IR_InterfaceDef_var _tao_retval;

  _tao_retval = _tao_impl->interface_type (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UsesDef::_get_is_multiple_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_multiple (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::UsesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::UsesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::UsesDef *_tao_impl = (POA_IR::UsesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::UsesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::UsesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/UsesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::UsesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::UsesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

IR::UsesDef*
POA_IR::UsesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_UsesDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_EventDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EventDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EventDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EventDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EventDef::move_skel},
      {"_is_a",  &POA_IR::EventDef::_is_a_skel},
      {"_get_id",       &POA_IR::EventDef::_get_id_skel},
      {"_set_id",       &POA_IR::EventDef::_set_id_skel},
      {"describe",      &POA_IR::EventDef::describe_skel},
      {"_get_name",     &POA_IR::EventDef::_get_name_skel},
      {"_set_name",     &POA_IR::EventDef::_set_name_skel},
      {"_get_version",  &POA_IR::EventDef::_get_version_skel},
      {"_set_version",  &POA_IR::EventDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EventDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::EventDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::EventDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EventDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EventDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::EventDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EventDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EventDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_EventDef_Perfect_Hash_OpTable tao_IR_EventDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker *POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::the_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EventDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::~_TAO_EventDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_EventDef_Proxy_Impl&
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::select_proxy (
    IR_EventDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EventDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EventDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_EventDef_Proxy_Broker *
_TAO_EventDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EventDef_Strategized_Proxy_Broker::the_TAO_EventDef_Strategized_Proxy_Broker();
}

int
_TAO_EventDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_EventDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_EventDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_EventDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_EventDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_EventDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::_TAO_EventDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::~_TAO_EventDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->is_a (
        event_id,
        ACE_TRY_ENV
      );
}

IR::ValueDef_ptr POA_IR::_TAO_EventDef_ThruPOA_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "event",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::EventDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/EventDef:1.0"
        )
    )->event (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EventDef::EventDef (void)
{
  this->optable_ = &tao_IR_EventDef_optable;
}

// copy ctor
POA_IR::EventDef::EventDef (const EventDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EventDef::~EventDef (void)
{
}

void POA_IR::EventDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var event_id;
  if (!(
    (_tao_in >> event_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->is_a (
      event_id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::EventDef::_get_event_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *)_tao_object_reference;

  IR_ValueDef_var _tao_retval;

  _tao_retval = _tao_impl->event (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::EventDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EventDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EventDef *_tao_impl = (POA_IR::EventDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EventDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EventDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EventDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

IR::EventDef*
POA_IR::EventDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_EventDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_EmitsDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_EmitsDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_EmitsDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_EmitsDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::EmitsDef::move_skel},
      {"_is_a",  &POA_IR::EmitsDef::_is_a_skel},
      {"_get_id",       &POA_IR::EmitsDef::_get_id_skel},
      {"_set_id",       &POA_IR::EmitsDef::_set_id_skel},
      {"describe",      &POA_IR::EmitsDef::describe_skel},
      {"_get_name",     &POA_IR::EmitsDef::_get_name_skel},
      {"_set_name",     &POA_IR::EmitsDef::_set_name_skel},
      {"_get_version",  &POA_IR::EmitsDef::_get_version_skel},
      {"_set_version",  &POA_IR::EmitsDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::EmitsDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::EmitsDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::EmitsDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::EmitsDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::EmitsDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::EmitsDef::_get_event_skel},
      {"_non_existent",  &POA_IR::EmitsDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::EmitsDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_EmitsDef_Perfect_Hash_OpTable tao_IR_EmitsDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker *POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::the_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::~_TAO_EmitsDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_EmitsDef_Proxy_Impl&
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::select_proxy (
    IR_EmitsDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EmitsDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_EmitsDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_EmitsDef_Proxy_Broker *
_TAO_EmitsDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_EmitsDef_Strategized_Proxy_Broker::the_TAO_EmitsDef_Strategized_Proxy_Broker();
}

int
_TAO_EmitsDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_EmitsDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_EmitsDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_EmitsDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_EmitsDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_EmitsDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_EmitsDef_ThruPOA_Proxy_Impl::_TAO_EmitsDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_EmitsDef_ThruPOA_Proxy_Impl::~_TAO_EmitsDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::EmitsDef::EmitsDef (void)
{
  this->optable_ = &tao_IR_EmitsDef_optable;
}

// copy ctor
POA_IR::EmitsDef::EmitsDef (const EmitsDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::EmitsDef::~EmitsDef (void)
{
}

void POA_IR::EmitsDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::EmitsDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::EmitsDef *_tao_impl = (POA_IR::EmitsDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::EmitsDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::EmitsDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EmitsDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EmitsDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::EmitsDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

IR::EmitsDef*
POA_IR::EmitsDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_EmitsDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_PublishesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PublishesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PublishesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PublishesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::PublishesDef::move_skel},
      {"_is_a",  &POA_IR::PublishesDef::_is_a_skel},
      {"_get_id",       &POA_IR::PublishesDef::_get_id_skel},
      {"_set_id",       &POA_IR::PublishesDef::_set_id_skel},
      {"describe",      &POA_IR::PublishesDef::describe_skel},
      {"_get_name",     &POA_IR::PublishesDef::_get_name_skel},
      {"_set_name",     &POA_IR::PublishesDef::_set_name_skel},
      {"_get_version",  &POA_IR::PublishesDef::_get_version_skel},
      {"_set_version",  &POA_IR::PublishesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::PublishesDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::PublishesDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::PublishesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::PublishesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::PublishesDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::PublishesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::PublishesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::PublishesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_PublishesDef_Perfect_Hash_OpTable tao_IR_PublishesDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker *POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::the_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::~_TAO_PublishesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_PublishesDef_Proxy_Impl&
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::select_proxy (
    IR_PublishesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PublishesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PublishesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_PublishesDef_Proxy_Broker *
_TAO_PublishesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PublishesDef_Strategized_Proxy_Broker::the_TAO_PublishesDef_Strategized_Proxy_Broker();
}

int
_TAO_PublishesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_PublishesDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_PublishesDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_PublishesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_PublishesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_PublishesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PublishesDef_ThruPOA_Proxy_Impl::_TAO_PublishesDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_PublishesDef_ThruPOA_Proxy_Impl::~_TAO_PublishesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PublishesDef::PublishesDef (void)
{
  this->optable_ = &tao_IR_PublishesDef_optable;
}

// copy ctor
POA_IR::PublishesDef::PublishesDef (const PublishesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PublishesDef::~PublishesDef (void)
{
}

void POA_IR::PublishesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PublishesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PublishesDef *_tao_impl = (POA_IR::PublishesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PublishesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PublishesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PublishesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PublishesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PublishesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

IR::PublishesDef*
POA_IR::PublishesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_PublishesDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ConsumesDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ConsumesDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 10, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 10, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ConsumesDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::ConsumesDef::move_skel},
      {"_is_a",  &POA_IR::ConsumesDef::_is_a_skel},
      {"_get_id",       &POA_IR::ConsumesDef::_get_id_skel},
      {"_set_id",       &POA_IR::ConsumesDef::_set_id_skel},
      {"describe",      &POA_IR::ConsumesDef::describe_skel},
      {"_get_name",     &POA_IR::ConsumesDef::_get_name_skel},
      {"_set_name",     &POA_IR::ConsumesDef::_set_name_skel},
      {"_get_version",  &POA_IR::ConsumesDef::_get_version_skel},
      {"_set_version",  &POA_IR::ConsumesDef::_set_version_skel},
      {"_get_def_kind",         &POA_IR::ConsumesDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::ConsumesDef::is_a_skel},
      {"_get_defined_in",       &POA_IR::ConsumesDef::_get_defined_in_skel},
      {"destroy",       &POA_IR::ConsumesDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::ConsumesDef::_get_absolute_name_skel},
      {"_get_event",    &POA_IR::ConsumesDef::_get_event_skel},
      {"_non_existent",  &POA_IR::ConsumesDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::ConsumesDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13,
       14,  15,  -1,  16,  17,  -1,  18,  -1,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ConsumesDef_Perfect_Hash_OpTable tao_IR_ConsumesDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker *POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::the_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::~_TAO_ConsumesDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ConsumesDef_Proxy_Impl&
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::select_proxy (
    IR_ConsumesDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ConsumesDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ConsumesDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ConsumesDef_Proxy_Broker *
_TAO_ConsumesDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ConsumesDef_Strategized_Proxy_Broker::the_TAO_ConsumesDef_Strategized_Proxy_Broker();
}

int
_TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ConsumesDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ConsumesDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ConsumesDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ConsumesDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ConsumesDef_ThruPOA_Proxy_Impl::_TAO_ConsumesDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ConsumesDef_ThruPOA_Proxy_Impl::~_TAO_ConsumesDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ConsumesDef::ConsumesDef (void)
{
  this->optable_ = &tao_IR_ConsumesDef_optable;
}

// copy ctor
POA_IR::ConsumesDef::ConsumesDef (const ConsumesDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,EventDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ConsumesDef::~ConsumesDef (void)
{
}

void POA_IR::ConsumesDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ConsumesDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ConsumesDef *_tao_impl = (POA_IR::ConsumesDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ConsumesDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ConsumesDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ConsumesDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ConsumesDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/EventDef:1.0") == 0)
    return ACE_static_cast (POA_IR::EventDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ConsumesDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

IR::ConsumesDef*
POA_IR::ConsumesDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ConsumesDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_ComponentDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_ComponentDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_ComponentDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82,  0,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82,  0,
     82, 30,  5, 10, 82, 82, 82,  0, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 45, 30, 15,
     82, 30, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82,  0, 20, 82, 82, 82, 30, 25, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82,
#else
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82, 82, 82, 82, 82, 82,
     82, 82, 82, 82, 82,  0, 82,  0, 82, 30,
      5, 10, 82, 82, 82,  0, 82, 82, 45, 30,
     15, 82, 30, 82, 82,  0, 20, 82, 82, 82,
     30, 25, 82, 82, 82, 82, 82, 82,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_ComponentDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 54,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 81,
      HASH_VALUE_RANGE = 78,
      DUPLICATES = 16
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a",  &POA_IR::ComponentDef::is_a_skel},
      {"_is_a",  &POA_IR::ComponentDef::_is_a_skel},
      {"_get_id",       &POA_IR::ComponentDef::_get_id_skel},
      {"_set_id",       &POA_IR::ComponentDef::_set_id_skel},
      {"_get_emits_events",     &POA_IR::ComponentDef::_get_emits_events_skel},
      {"_get_def_kind",         &POA_IR::ComponentDef::_get_def_kind_skel},
      {"_get_name",     &POA_IR::ComponentDef::_get_name_skel},
      {"_get_type",     &POA_IR::ComponentDef::_get_type_skel},
      {"_set_name",     &POA_IR::ComponentDef::_set_name_skel},
      {"_get_uses_interfaces",  &POA_IR::ComponentDef::_get_uses_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::ComponentDef::_set_base_interfaces_skel},
      {"_get_base_interfaces",  &POA_IR::ComponentDef::_get_base_interfaces_skel},
      {"_get_consumes_events",  &POA_IR::ComponentDef::_get_consumes_events_skel},
      {"_get_publishes_events",         &POA_IR::ComponentDef::_get_publishes_events_skel},
      {"describe_contents",     &POA_IR::ComponentDef::describe_contents_skel},
      {"describe",      &POA_IR::ComponentDef::describe_skel},
      {"_get_provides_interfaces",      &POA_IR::ComponentDef::_get_provides_interfaces_skel},
      {"_get_supported_interfaces",     &POA_IR::ComponentDef::_get_supported_interfaces_skel},
      {"_set_supported_interfaces",     &POA_IR::ComponentDef::_set_supported_interfaces_skel},
      {"_get_version",  &POA_IR::ComponentDef::_get_version_skel},
      {"_set_version",  &POA_IR::ComponentDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::ComponentDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::ComponentDef::_get_defined_in_skel},
      {"_non_existent",  &POA_IR::ComponentDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::ComponentDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::ComponentDef::_set_is_abstract_skel},
      {"destroy",       &POA_IR::ComponentDef::destroy_skel},
      {"contents",      &POA_IR::ComponentDef::contents_skel},
      {"_get_base_component",   &POA_IR::ComponentDef::_get_base_component_skel},
      {"create_uses",   &POA_IR::ComponentDef::create_uses_skel},
      {"create_emits",  &POA_IR::ComponentDef::create_emits_skel},
      {"create_alias",  &POA_IR::ComponentDef::create_alias_skel},
      {"_get_is_basic",         &POA_IR::ComponentDef::_get_is_basic_skel},
      {"move",  &POA_IR::ComponentDef::move_skel},
      {"create_provides",       &POA_IR::ComponentDef::create_provides_skel},
      {"create_consumes",       &POA_IR::ComponentDef::create_consumes_skel},
      {"create_publishes",      &POA_IR::ComponentDef::create_publishes_skel},
      {"_get_containing_repository",    &POA_IR::ComponentDef::_get_containing_repository_skel},
      {"create_value",  &POA_IR::ComponentDef::create_value_skel},
      {"create_module",         &POA_IR::ComponentDef::create_module_skel},
      {"create_native",         &POA_IR::ComponentDef::create_native_skel},
      {"create_attribute",      &POA_IR::ComponentDef::create_attribute_skel},
      {"create_interface",      &POA_IR::ComponentDef::create_interface_skel},
      {"create_union",  &POA_IR::ComponentDef::create_union_skel},
      {"_get_is_local",         &POA_IR::ComponentDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::ComponentDef::_set_is_local_skel},
      {"create_operation",      &POA_IR::ComponentDef::create_operation_skel},
      {"create_exception",      &POA_IR::ComponentDef::create_exception_skel},
      {"create_struct",         &POA_IR::ComponentDef::create_struct_skel},
      {"create_constant",       &POA_IR::ComponentDef::create_constant_skel},
      {"lookup_name",   &POA_IR::ComponentDef::lookup_name_skel},
      {"create_enum",   &POA_IR::ComponentDef::create_enum_skel},
      {"create_value_box",      &POA_IR::ComponentDef::create_value_box_skel},
      {"lookup",        &POA_IR::ComponentDef::lookup_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -6,   -2,    4,    5,  -10,   -3,  -13,   -4,  -21,   -2,  -91,  -23,
        -2,  -28,   -2,    8,    9,  -94,  -93,   17,   18,   19,   20,  -96,   -1,  -95,
        25,   -1,   26,  -34,   -2,   27,  -38,   -2, -102,   30,   31,   32,   -1,   33,
       -92,   36,   37,  -92,   40,  -43,   -2,  -45,   -2,   41,   42,  -87,  -48,   -2,
       -88,   47,  -85,  -50,   -2,  -83,   -1,   52,   -1,   53,   54,   -1,   -1,   -1,
        -1,   55,   -1,   -1,   -1,   -1,   56,   -1,   -1,   -1,   -1,   57,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_ComponentDef_Perfect_Hash_OpTable tao_IR_ComponentDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker *POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::the_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::~_TAO_ComponentDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_ComponentDef_Proxy_Impl&
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::select_proxy (
    IR_ComponentDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ComponentDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_ComponentDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_ComponentDef_Proxy_Broker *
_TAO_ComponentDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_ComponentDef_Strategized_Proxy_Broker::the_TAO_ComponentDef_Strategized_Proxy_Broker();
}

int
_TAO_ComponentDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_ComponentDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_ComponentDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_ComponentDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_ComponentDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_ComponentDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::_TAO_ComponentDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::~_TAO_ComponentDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::InterfaceDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
        ACE_TRY_ENV
      );
}

void POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "supported_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK;
    ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->supported_interfaces (
        supported_interfaces,
        ACE_TRY_ENV
      );
  return;
}

IR::ComponentDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->base_component (
        ACE_TRY_ENV
      );
}

IR::ProvidesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::provides_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ProvidesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "provides_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->provides_interfaces (
        ACE_TRY_ENV
      );
}

IR::UsesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::uses_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_UsesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "uses_interfaces",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->uses_interfaces (
        ACE_TRY_ENV
      );
}

IR::EmitsDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::emits_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_EmitsDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "emits_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->emits_events (
        ACE_TRY_ENV
      );
}

IR::PublishesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::publishes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PublishesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "publishes_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->publishes_events (
        ACE_TRY_ENV
      );
}

IR::ConsumesDefSeq * POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::consumes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ConsumesDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "consumes_events",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->consumes_events (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_basic",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->is_basic (
        ACE_TRY_ENV
      );
}

IR::ProvidesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_provides (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ProvidesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_provides",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_provides (
        id,
        name,
        version,
        interface_type,
        ACE_TRY_ENV
      );
}

IR::UsesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_uses (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_UsesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_uses",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_uses (
        id,
        name,
        version,
        interface_type,
        is_multiple,
        ACE_TRY_ENV
      );
}

IR::EmitsDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_emits (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_EmitsDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_emits",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_emits (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

IR::PublishesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_publishes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PublishesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_publishes",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_publishes (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

IR::ConsumesDef_ptr POA_IR::_TAO_ComponentDef_ThruPOA_Proxy_Impl::create_consumes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ConsumesDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_consumes",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::ComponentDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/ComponentDef:1.0"
        )
    )->create_consumes (
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::ComponentDef::ComponentDef (void)
{
  this->optable_ = &tao_IR_ComponentDef_optable;
}

// copy ctor
POA_IR::ComponentDef::ComponentDef (const ComponentDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::ComponentDef::~ComponentDef (void)
{
}

void POA_IR::ComponentDef::_get_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_InterfaceDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->supported_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_set_supported_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_InterfaceDefSeq supported_interfaces;
  if (!(
    (_tao_in >> supported_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_impl->supported_interfaces (
      supported_interfaces,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
}

void POA_IR::ComponentDef::_get_base_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ComponentDef_var _tao_retval;

  _tao_retval = _tao_impl->base_component (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_provides_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ProvidesDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->provides_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_uses_interfaces_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_UsesDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->uses_interfaces (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_emits_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_EmitsDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->emits_events (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_publishes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_PublishesDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->publishes_events (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_consumes_events_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ConsumesDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->consumes_events (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_basic (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_provides_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ProvidesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_InterfaceDef_var interface_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_provides (
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_uses_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_UsesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_InterfaceDef_var interface_type;
  CORBA::Boolean is_multiple;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> interface_type.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_multiple))
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_uses (
      id.in (),
      name.in (),
      version.in (),
      interface_type.in (),
      is_multiple,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_emits_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_EmitsDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_emits (
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_publishes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_PublishesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_publishes (
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

 _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::create_consumes_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *)_tao_object_reference;

  IR_ConsumesDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ValueDef_var value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_consumes (
      id.in (),
      name.in (),
      version.in (),
      value.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::ComponentDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::ComponentDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::ComponentDef *_tao_impl = (POA_IR::ComponentDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::ComponentDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::ComponentDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/ComponentDef:1.0") == 0)
    return ACE_static_cast (POA_IR::ComponentDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::ComponentDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

IR::ComponentDef*
POA_IR::ComponentDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_ComponentDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32,  0,
     32, 32,  0,  0, 32, 32, 32, 10, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32,  0,  5,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 10, 32, 32, 32, 32,  5, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32,
#else
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
     32, 32, 32, 32, 32,  0, 32,  0, 32, 32,
      0,  0, 32, 32, 32, 10, 32, 32, 32,  0,
      5, 32, 32, 32, 32, 32, 10, 32, 32, 32,
     32,  5, 32, 32, 32, 32, 32, 32,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 17,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 31,
      HASH_VALUE_RANGE = 28,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::PrimaryKeyDef::move_skel},
      {"_is_a",  &POA_IR::PrimaryKeyDef::_is_a_skel},
      {"_get_id",       &POA_IR::PrimaryKeyDef::_get_id_skel},
      {"_set_id",       &POA_IR::PrimaryKeyDef::_set_id_skel},
      {"describe",      &POA_IR::PrimaryKeyDef::describe_skel},
      {"_get_name",     &POA_IR::PrimaryKeyDef::_get_name_skel},
      {"_set_name",     &POA_IR::PrimaryKeyDef::_set_name_skel},
      {"destroy",       &POA_IR::PrimaryKeyDef::destroy_skel},
      {"_get_def_kind",         &POA_IR::PrimaryKeyDef::_get_def_kind_skel},
      {"is_a",  &POA_IR::PrimaryKeyDef::is_a_skel},
      {"_get_version",  &POA_IR::PrimaryKeyDef::_get_version_skel},
      {"_set_version",  &POA_IR::PrimaryKeyDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::PrimaryKeyDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::PrimaryKeyDef::_get_defined_in_skel},
      {"_get_primary_key",      &POA_IR::PrimaryKeyDef::_get_primary_key_skel},
      {"_non_existent",  &POA_IR::PrimaryKeyDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::PrimaryKeyDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -38,   8, -38,  -1,  -1,  11,  12,
       13, -14,  -2, -33,  16,  -1,  17,  18,  -1,  19,  -1,  -1,  -1,  -1,
       -1,  -1,  -1,  20,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_PrimaryKeyDef_Perfect_Hash_OpTable tao_IR_PrimaryKeyDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker *POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::the_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::~_TAO_PrimaryKeyDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_PrimaryKeyDef_Proxy_Impl&
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::select_proxy (
    IR_PrimaryKeyDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_PrimaryKeyDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_PrimaryKeyDef_Proxy_Broker *
_TAO_PrimaryKeyDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_PrimaryKeyDef_Strategized_Proxy_Broker::the_TAO_PrimaryKeyDef_Strategized_Proxy_Broker();
}

int
_TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_PrimaryKeyDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_PrimaryKeyDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_PrimaryKeyDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::~_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

CORBA::Boolean POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_a",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->is_a (
        primary_key_id,
        ACE_TRY_ENV
      );
}

IR::ValueDef_ptr POA_IR::_TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::PrimaryKeyDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/PrimaryKeyDef:1.0"
        )
    )->primary_key (
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (void)
{
  this->optable_ = &tao_IR_PrimaryKeyDef_optable;
}

// copy ctor
POA_IR::PrimaryKeyDef::PrimaryKeyDef (const PrimaryKeyDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::PrimaryKeyDef::~PrimaryKeyDef (void)
{
}

void POA_IR::PrimaryKeyDef::is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var primary_key_id;
  if (!(
    (_tao_in >> primary_key_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->is_a (
      primary_key_id.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::PrimaryKeyDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *)_tao_object_reference;

  IR_ValueDef_var _tao_retval;

  _tao_retval = _tao_impl->primary_key (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::PrimaryKeyDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::PrimaryKeyDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::PrimaryKeyDef *_tao_impl = (POA_IR::PrimaryKeyDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::PrimaryKeyDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::PrimaryKeyDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/PrimaryKeyDef:1.0") == 0)
    return ACE_static_cast (POA_IR::PrimaryKeyDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::PrimaryKeyDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

IR::PrimaryKeyDef*
POA_IR::PrimaryKeyDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_PrimaryKeyDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_FactoryDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FactoryDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FactoryDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FactoryDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::FactoryDef::move_skel},
      {"_is_a",  &POA_IR::FactoryDef::_is_a_skel},
      {"_get_mode",     &POA_IR::FactoryDef::_get_mode_skel},
      {"_set_name",     &POA_IR::FactoryDef::_set_name_skel},
      {"_get_name",     &POA_IR::FactoryDef::_get_name_skel},
      {"_set_mode",     &POA_IR::FactoryDef::_set_mode_skel},
      {"_get_params",   &POA_IR::FactoryDef::_get_params_skel},
      {"_set_params",   &POA_IR::FactoryDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::FactoryDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::FactoryDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::FactoryDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::FactoryDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::FactoryDef::_get_version_skel},
      {"_set_version",  &POA_IR::FactoryDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::FactoryDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::FactoryDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::FactoryDef::_get_id_skel},
      {"_set_id",       &POA_IR::FactoryDef::_set_id_skel},
      {"describe",      &POA_IR::FactoryDef::describe_skel},
      {"_get_result_def",       &POA_IR::FactoryDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::FactoryDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::FactoryDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::FactoryDef::_get_result_skel},
      {"destroy",       &POA_IR::FactoryDef::destroy_skel},
      {"_non_existent",  &POA_IR::FactoryDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::FactoryDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_FactoryDef_Perfect_Hash_OpTable tao_IR_FactoryDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker *POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::the_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::~_TAO_FactoryDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_FactoryDef_Proxy_Impl&
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::select_proxy (
    IR_FactoryDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FactoryDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FactoryDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_FactoryDef_Proxy_Broker *
_TAO_FactoryDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FactoryDef_Strategized_Proxy_Broker::the_TAO_FactoryDef_Strategized_Proxy_Broker();
}

int
_TAO_FactoryDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_FactoryDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_FactoryDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_FactoryDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_FactoryDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_FactoryDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FactoryDef_ThruPOA_Proxy_Impl::_TAO_FactoryDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_FactoryDef_ThruPOA_Proxy_Impl::~_TAO_FactoryDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FactoryDef::FactoryDef (void)
{
  this->optable_ = &tao_IR_FactoryDef_optable;
}

// copy ctor
POA_IR::FactoryDef::FactoryDef (const FactoryDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,OperationDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FactoryDef::~FactoryDef (void)
{
}

void POA_IR::FactoryDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FactoryDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FactoryDef *_tao_impl = (POA_IR::FactoryDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FactoryDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FactoryDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FactoryDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FactoryDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FactoryDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

IR::FactoryDef*
POA_IR::FactoryDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_FactoryDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_FinderDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_FinderDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_FinderDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_FinderDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move",  &POA_IR::FinderDef::move_skel},
      {"_is_a",  &POA_IR::FinderDef::_is_a_skel},
      {"_get_mode",     &POA_IR::FinderDef::_get_mode_skel},
      {"_set_name",     &POA_IR::FinderDef::_set_name_skel},
      {"_get_name",     &POA_IR::FinderDef::_get_name_skel},
      {"_set_mode",     &POA_IR::FinderDef::_set_mode_skel},
      {"_get_params",   &POA_IR::FinderDef::_get_params_skel},
      {"_set_params",   &POA_IR::FinderDef::_set_params_skel},
      {"_get_contexts",         &POA_IR::FinderDef::_get_contexts_skel},
      {"_set_contexts",         &POA_IR::FinderDef::_set_contexts_skel},
      {"_get_exceptions",       &POA_IR::FinderDef::_get_exceptions_skel},
      {"_set_exceptions",       &POA_IR::FinderDef::_set_exceptions_skel},
      {"_get_version",  &POA_IR::FinderDef::_get_version_skel},
      {"_set_version",  &POA_IR::FinderDef::_set_version_skel},
      {"_get_absolute_name",    &POA_IR::FinderDef::_get_absolute_name_skel},
      {"_get_defined_in",       &POA_IR::FinderDef::_get_defined_in_skel},
      {"_get_id",       &POA_IR::FinderDef::_get_id_skel},
      {"_set_id",       &POA_IR::FinderDef::_set_id_skel},
      {"describe",      &POA_IR::FinderDef::describe_skel},
      {"_get_result_def",       &POA_IR::FinderDef::_get_result_def_skel},
      {"_set_result_def",       &POA_IR::FinderDef::_set_result_def_skel},
      {"_get_def_kind",         &POA_IR::FinderDef::_get_def_kind_skel},
      {"_get_result",   &POA_IR::FinderDef::_get_result_skel},
      {"destroy",       &POA_IR::FinderDef::destroy_skel},
      {"_non_existent",  &POA_IR::FinderDef::_non_existent_skel},
      {"_get_containing_repository",    &POA_IR::FinderDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword;

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_FinderDef_Perfect_Hash_OpTable tao_IR_FinderDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker *POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::the_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::~_TAO_FinderDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_FinderDef_Proxy_Impl&
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::select_proxy (
    IR_FinderDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FinderDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_FinderDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_FinderDef_Proxy_Broker *
_TAO_FinderDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_FinderDef_Strategized_Proxy_Broker::the_TAO_FinderDef_Strategized_Proxy_Broker();
}

int
_TAO_FinderDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_FinderDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_FinderDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_FinderDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_FinderDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_FinderDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_FinderDef_ThruPOA_Proxy_Impl::_TAO_FinderDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_FinderDef_ThruPOA_Proxy_Impl::~_TAO_FinderDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::FinderDef::FinderDef (void)
{
  this->optable_ = &tao_IR_FinderDef_optable;
}

// copy ctor
POA_IR::FinderDef::FinderDef (const FinderDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,OperationDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::FinderDef::~FinderDef (void)
{
}

void POA_IR::FinderDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::FinderDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::FinderDef *_tao_impl = (POA_IR::FinderDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::FinderDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::FinderDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/FinderDef:1.0") == 0)
    return ACE_static_cast (POA_IR::FinderDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_IR::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::FinderDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

IR::FinderDef*
POA_IR::FinderDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_FinderDef::_unchecked_narrow (obj.in ());
}

class TAO_IR_HomeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 11:23:11 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_IR_HomeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_IR_HomeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89,  0,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89,  0,
     89, 15,  0, 45, 89, 89, 89,  0, 89, 89,
     89, 89, 89, 89, 89, 89, 89,  5,  0, 10,
     89,  0, 89,  5, 89, 89, 89, 89, 89, 89,
     89, 89, 15, 30, 89, 89, 89,  0, 55, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89,
#else
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
     89, 89, 89, 89, 89,  0, 89,  0, 89, 15,
      0, 45, 89, 89, 89,  0, 89, 89,  5,  0,
     10, 89,  0, 89,  5, 15, 30, 89, 89, 89,
      0, 55, 89, 89, 89, 89, 89, 89,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_IR_HomeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 88,
      HASH_VALUE_RANGE = 85,
      DUPLICATES = 11
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"is_a",  &POA_IR::HomeDef::is_a_skel},
      {"_is_a",  &POA_IR::HomeDef::_is_a_skel},
      {"_get_id",       &POA_IR::HomeDef::_get_id_skel},
      {"_set_id",       &POA_IR::HomeDef::_set_id_skel},
      {"lookup",        &POA_IR::HomeDef::lookup_skel},
      {"_get_def_kind",         &POA_IR::HomeDef::_get_def_kind_skel},
      {"_get_is_local",         &POA_IR::HomeDef::_get_is_local_skel},
      {"_set_is_local",         &POA_IR::HomeDef::_set_is_local_skel},
      {"_get_version",  &POA_IR::HomeDef::_get_version_skel},
      {"_set_version",  &POA_IR::HomeDef::_set_version_skel},
      {"_get_defined_in",       &POA_IR::HomeDef::_get_defined_in_skel},
      {"create_enum",   &POA_IR::HomeDef::create_enum_skel},
      {"_get_finders",  &POA_IR::HomeDef::_get_finders_skel},
      {"_get_is_basic",         &POA_IR::HomeDef::_get_is_basic_skel},
      {"_get_factories",        &POA_IR::HomeDef::_get_factories_skel},
      {"create_value_box",      &POA_IR::HomeDef::create_value_box_skel},
      {"describe_contents",     &POA_IR::HomeDef::describe_contents_skel},
      {"create_finder",         &POA_IR::HomeDef::create_finder_skel},
      {"_get_base_interfaces",  &POA_IR::HomeDef::_get_base_interfaces_skel},
      {"_set_base_interfaces",  &POA_IR::HomeDef::_set_base_interfaces_skel},
      {"create_union",  &POA_IR::HomeDef::create_union_skel},
      {"contents",      &POA_IR::HomeDef::contents_skel},
      {"create_operation",      &POA_IR::HomeDef::create_operation_skel},
      {"create_exception",      &POA_IR::HomeDef::create_exception_skel},
      {"create_alias",  &POA_IR::HomeDef::create_alias_skel},
      {"_non_existent",  &POA_IR::HomeDef::_non_existent_skel},
      {"_get_is_abstract",      &POA_IR::HomeDef::_get_is_abstract_skel},
      {"_set_is_abstract",      &POA_IR::HomeDef::_set_is_abstract_skel},
      {"move",  &POA_IR::HomeDef::move_skel},
      {"_get_managed_component",        &POA_IR::HomeDef::_get_managed_component_skel},
      {"describe",      &POA_IR::HomeDef::describe_skel},
      {"_get_name",     &POA_IR::HomeDef::_get_name_skel},
      {"_get_type",     &POA_IR::HomeDef::_get_type_skel},
      {"_set_name",     &POA_IR::HomeDef::_set_name_skel},
      {"create_struct",         &POA_IR::HomeDef::create_struct_skel},
      {"_get_base_home",        &POA_IR::HomeDef::_get_base_home_skel},
      {"create_constant",       &POA_IR::HomeDef::create_constant_skel},
      {"lookup_name",   &POA_IR::HomeDef::lookup_name_skel},
      {"destroy",       &POA_IR::HomeDef::destroy_skel},
      {"_get_absolute_name",    &POA_IR::HomeDef::_get_absolute_name_skel},
      {"_get_primary_key",      &POA_IR::HomeDef::_get_primary_key_skel},
      {"create_value",  &POA_IR::HomeDef::create_value_skel},
      {"create_module",         &POA_IR::HomeDef::create_module_skel},
      {"create_native",         &POA_IR::HomeDef::create_native_skel},
      {"create_attribute",      &POA_IR::HomeDef::create_attribute_skel},
      {"create_interface",      &POA_IR::HomeDef::create_interface_skel},
      {"_get_containing_repository",    &POA_IR::HomeDef::_get_containing_repository_skel},
      {"create_factory",        &POA_IR::HomeDef::create_factory_skel},
      {"create_primary_key",    &POA_IR::HomeDef::create_primary_key_skel},
    };

  static const signed char lookup[] =
    {
        -1,   -1,   -6,   -2,    4,    5,   -1,  -93,   -1,   -1,   -1,    8,   -1,    9,
        -1,   -1,  -10,   -2,  -90,   -1,  -12,   -2,  -90,  -22,   -2,   14,   15,   16,
        17,   18,   -1,   19,   20,   21,   -1, -100,   -1,   24,   25,  -26,   -2,  -90,
        28,   29,  -30,   -2,  -90,   -1,   -1,   32,  -35,   -3,   33,   34,  -92,   -1,
        -1,   -1,   38,   39,   40,   41,   42,   43,   -1,   -1,   -1,   -1,   -1,  -46,
        -2,   44,   45,  -92,  -48,   -2,  -90,   -1,   -1,   -1,   -1,   50,   -1,   -1,
        51,   -1,   -1,   -1,   52,
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 11:23:11 */
static TAO_IR_HomeDef_Perfect_Hash_OpTable tao_IR_HomeDef_optable;

///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// Factory function Implementation.
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker *POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::the_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  static POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker strategized_proxy_broker;
  return &strategized_proxy_broker;
}

POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    this->proxy_cache_[i] = 0;
  
}

POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::~_TAO_HomeDef_Strategized_Proxy_Broker (void)
{
  for (int i = 0; i < TAO_ORB_Core::COLLOCATION_STRATEGIES_NUM; ++i)
    delete this->proxy_cache_[i];
  
}

_TAO_HomeDef_Proxy_Impl&
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::select_proxy (
    IR_HomeDef *object,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_ORB_Core::TAO_Collocation_Strategies strategy =
    TAO_ORB_Core::collocation_strategy (object);
  
  if (this->proxy_cache_[strategy] != 0)
    return *this->proxy_cache_[strategy];
  
  this->create_proxy (strategy, ACE_TRY_ENV);
  ACE_CHECK_RETURN (*this->proxy_cache_[strategy]);
  
  return *this->proxy_cache_[strategy];
  
}

void 
POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::create_proxy (
    TAO_ORB_Core::TAO_Collocation_Strategies strategy,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  ACE_GUARD (ACE_SYNCH_MUTEX, guard, this->mutex_);
  
  if (this->proxy_cache_[strategy] == 0)
    {
      switch (strategy)
        {
        case TAO_ORB_Core::THRU_POA_STRATEGY:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_HomeDef_ThruPOA_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
          
        case TAO_ORB_Core::REMOTE_STRATEGY:
        default:
          ACE_NEW_THROW_EX (
              this->proxy_cache_[strategy],
              _TAO_HomeDef_Remote_Proxy_Impl,
              CORBA::NO_MEMORY ()
          );
          ACE_CHECK;
          break;
        
      }
    
  }
}


//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


_TAO_HomeDef_Proxy_Broker *
_TAO_HomeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr obj)
{
  ACE_UNUSED_ARG (obj);
  return ::POA_IR::_TAO_HomeDef_Strategized_Proxy_Broker::the_TAO_HomeDef_Strategized_Proxy_Broker();
}

int
_TAO_HomeDef_Proxy_Broker_Factory_Initializer (long _dummy_)
{
  ACE_UNUSED_ARG (_dummy_);
  
  _TAO_HomeDef_Proxy_Broker_Factory_function_pointer = 
    _TAO_HomeDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int _TAO_HomeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow = 
  _TAO_HomeDef_Proxy_Broker_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_HomeDef_Proxy_Broker_Factory_Initializer));


///////////////////////////////////////////////////////////////////////
//                 ThruPOA Proxy  Implementation
//

POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::_TAO_HomeDef_ThruPOA_Proxy_Impl (void)
{}

POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::~_TAO_HomeDef_ThruPOA_Proxy_Impl (void)
{}

// ThruPOA Implementation of the IDL interface methods

IR::HomeDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_HomeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "base_home",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->base_home (
        ACE_TRY_ENV
      );
}

IR::ComponentDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_ComponentDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "managed_component",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->managed_component (
        ACE_TRY_ENV
      );
}

IR::PrimaryKeyDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->primary_key (
        ACE_TRY_ENV
      );
}

IR::FactoryDefSeq * POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::factories (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FactoryDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "factories",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->factories (
        ACE_TRY_ENV
      );
}

IR::FinderDefSeq * POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::finders (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FinderDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "finders",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->finders (
        ACE_TRY_ENV
      );
}

CORBA::Boolean POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "is_basic",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN  (_tao_retval);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->is_basic (
        ACE_TRY_ENV
      );
}

IR::PrimaryKeyDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_primary_key (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_PrimaryKeyDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_primary_key",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_primary_key (
        id,
        name,
        version,
        primary_key,
        ACE_TRY_ENV
      );
}

IR::FactoryDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_factory (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FactoryDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_factory",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_factory (
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
}

IR::FinderDef_ptr POA_IR::_TAO_HomeDef_ThruPOA_Proxy_Impl::create_finder (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    IR_FinderDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      _collocated_tao_target_->_stubobj ()->servant_orb_var ()->orb_core ()
    );
  CORBA::Object_var forward_to;
  servant_upcall.prepare_for_upcall (
      _collocated_tao_target_->_object_key (),
      "create_finder",
      forward_to.out (),
      ACE_TRY_ENV
    );
      ACE_CHECK_RETURN (0);
    return ACE_reinterpret_cast (
      POA_IR::HomeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/IR/HomeDef:1.0"
        )
    )->create_finder (
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
}

//
//           End ThruPOA Proxy Implementation
///////////////////////////////////////////////////////////////////////

// skeleton constructor
POA_IR::HomeDef::HomeDef (void)
{
  this->optable_ = &tao_IR_HomeDef_optable;
}

// copy ctor
POA_IR::HomeDef::HomeDef (const HomeDef& rhs)
  :   ACE_NESTED_CLASS (POA_IR,InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_IR,Container) (rhs),
    ACE_NESTED_CLASS (POA_IR,Contained) (rhs),
    ACE_NESTED_CLASS (POA_IR,IDLType) (rhs),
  POA_CORBA_IRObject (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_IR::HomeDef::~HomeDef (void)
{
}

void POA_IR::HomeDef::_get_base_home_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_HomeDef_var _tao_retval;

  _tao_retval = _tao_impl->base_home (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_managed_component_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_ComponentDef_var _tao_retval;

  _tao_retval = _tao_impl->managed_component (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_PrimaryKeyDef_var _tao_retval;

  _tao_retval = _tao_impl->primary_key (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_factories_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_FactoryDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->factories (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_finders_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_FinderDefSeq_var _tao_retval;

  _tao_retval = _tao_impl->finders (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_get_is_basic_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;

  _tao_retval = _tao_impl->is_basic (
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::create_primary_key_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_PrimaryKeyDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ValueDef_var primary_key;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> primary_key.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_primary_key (
      id.in (),
      name.in (),
      version.in (),
      primary_key.in (),
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::create_factory_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_FactoryDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ParDescriptionSeq params;
  IR_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_factory (
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::create_finder_skel (
    TAO_ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *)_tao_object_reference;

  IR_FinderDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  IR_ParDescriptionSeq params;
  IR_ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

  _tao_retval = _tao_impl->create_finder (
      id.in (),
      name.in (),
      version.in (),
      params,
      exceptions,
      ACE_TRY_ENV
    );

  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_IR::HomeDef::_is_a_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());

  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_IR::HomeDef::_non_existent_skel (
    TAO_ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_IR::HomeDef *_tao_impl = (POA_IR::HomeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;

  _tao_server_request.init_reply ();
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_IR::HomeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_IR::HomeDef::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/HomeDef:1.0") == 0)
    return ACE_static_cast (POA_IR::HomeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_IR::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Container:1.0") == 0)
    return ACE_static_cast (POA_IR::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/Contained:1.0") == 0)
    return ACE_static_cast (POA_IR::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/IR/IDLType:1.0") == 0)
    return ACE_static_cast (POA_IR::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA_IRObject_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_IR::HomeDef::_dispatch (TAO_ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  this->synchronous_upcall_dispatch(req, context, this, ACE_TRY_ENV);
}

const char* POA_IR::HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR::HomeDef*
POA_IR::HomeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 1, this), 0);
  else
    ACE_NEW_RETURN (tmp, CORBA::Object (stub, 0, this), 0);
  
  CORBA::Object_var obj = tmp;
  return IR_HomeDef::_unchecked_narrow (obj.in ());
}

