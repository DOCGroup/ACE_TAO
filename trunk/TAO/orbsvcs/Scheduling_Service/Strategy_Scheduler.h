/* -*- C++ -*- */
// $Id$
//
// ============================================================================
//
// = LIBRARY
//    sched
//
// = FILENAME
//    Strategy_Scheduler.h
//
// = CREATION DATE
//    22 December 1997
//
// = AUTHOR
//    Chris Gill
//
// ============================================================================

#if ! defined (STRATEGY_SCHEDULER_H)
#define STRATEGY_SCHEDULER_H

#include "DynSched.h"

// forward declaration of the abstract base class for scheduler strategies
class ACE_Scheduler_Strategy;

/////////////////////////////////
// Strategized scheduler class //
/////////////////////////////////

class ACE_Strategy_Scheduler : public ACE_Scheduler
  // = TITLE
  //    ACE_Strategy_Scheduler
  //
  // = DESCRIPTION
  //    Strategized scheduler implementation.  Provides an implementation 
  //    of all strategy specific scheduling mechanisms, which relies on the
  //    methods of the associated strategy class.
{
// public interface
public:

  ACE_Strategy_Scheduler (ACE_Scheduler_Strategy &strategy);
    // = strategized ctor

  virtual ~ACE_Strategy_Scheduler ();
    // = virtual dtor

  virtual status_t schedule_i (void);
    // = sets up the schedule in the order generated by the strategy

  status_t assign_priorities (void);
    // = assigns priorities and sub-priorities to the sorted schedule, 
    //   according to the strategy's priority comparison operator.

private:

  ACE_Scheduler_Strategy &strategy_;
    // = strategy for comparison, sorting of task entries

  ACE_UNIMPLEMENTED_FUNC (ACE_Strategy_Scheduler (const ACE_Strategy_Scheduler &))
  ACE_UNIMPLEMENTED_FUNC (ACE_Strategy_Scheduler &operator= (
    const ACE_Strategy_Scheduler &))  
};



////////////////////////////////////////
// Factory for strategized schedulers //
////////////////////////////////////////

template <class STRATEGY>
class ACE_Strategy_Scheduler_Factory
  // = TITLE
  //    ACE_Strategy_Scheduler_Factory
  //
  // = DESCRIPTION
  //    Provides a type parameterized factory method that constructs 
  //    and returns a scheduler that uses the given scheduling strategy
{
  static ACE_Strategy_Scheduler * create ();
    // construct and return a scheduler strategized with
    // an instance of the the parameterized strategy type
};


//////////////////////////
// Scheduler Strategies //
//////////////////////////

class ACE_Scheduler_Strategy
  // = TITLE
  //    ACE_Scheduler_Strategy
  //
  // = DESCRIPTION
  //    Abstract Base Class for scheduling strategies: each derived class
  //    must define an ordering strategy for task entries based on a specific 
  //    scheduling algorithm.
{
public:

  virtual int priority_comp (const ACE_Scheduler::Task_Entry &first_info, 
                             const ACE_Scheduler::Task_Entry &second_info) = 0;
    // = comparison of two task entries in strategy specific high to low priority
    //   ordering: returns -1 if the first Task_Entry is greater in the order,
    //   0 if they are equivalent, or 1 if the second Task_Entry is greater in 
    //   the order

  virtual void sort (ACE_Scheduler::Task_Entry **ordered_task_entries_,
                     u_int tasks) = 0;
    // = sort the task entry pointer array according to 
    //   the specific sort order defined by the strategy

protected:

  virtual int dynamic_subpriority_comp (const ACE_Scheduler::Task_Entry &first_entry, 
                                        const ACE_Scheduler::Task_Entry &second_entry) = 0;
    // = comparison of two task entries in strategy specific high to low 
    //   dynamic subpriority ordering: returns -1 if the first Task_Entry
    //   is greater in the order, 0 if they are equivalent, or 1 if the
    //   second Task_Entry is greater in the order

  virtual int static_subpriority_comp (const ACE_Scheduler::Task_Entry &first_entry, 
                                       const ACE_Scheduler::Task_Entry &second_entry);
    // = provide a lowest level ordering based first on importance (descending),
    //   and then on the dependency topological sort finishing time (ascending).

  int sort_comp (const ACE_Scheduler::Task_Entry &first_info, 
                 const ACE_Scheduler::Task_Entry &second_info);
    // = comparison of two task entries using the specific priority, dynamic
    //   subpriority, and static subpriority method definitions provided by 
    //   the derived strategy class to produce the strategy specific sort 
    //   ordering: returns -1 if the first Task_Entry is greater in the order,
    //   0 if they are equivalent, or 1 if the second Task_Entry is greater in
    //   the order.  This is an example of the Template Method pattern (and also
    //   of Pree's Unification Metapattern), in which derived classes provide
    //   definitions of the methods on which the sort_comp Template Method relies.
};



class ACE_MUF_Scheduler_Strategy : public ACE_Scheduler_Strategy
  // = TITLE
  //    ACE_MUF_Scheduler_Strategy
  //
  // = DESCRIPTION
  //    Defines "schedule" method using Maximum Urgency First 
  //    scheduling algorithm.
{
public:

  static ACE_MUF_Scheduler_Strategy *instance ();
    // returns an instance of the strategy
  
  virtual int priority_comp (const ACE_Scheduler::Task_Entry &first_info, 
                             const ACE_Scheduler::Task_Entry &second_info);
    // = comparison of two task entries by maximum criticality: returns -1 if the
    //   first Task_Entry is greater in the order, 0 if they're equivalent, or
    //   1 if the second Task_Entry is greater in the order.

  virtual void sort (ACE_Scheduler::Task_Entry **ordered_task_entries_,
                     u_int tasks);
    // = sort the task entry pointer array in descending urgency order

protected:

  ACE_MUF_Scheduler_Strategy ();
    // = default ctor

  virtual ~ACE_MUF_Scheduler_Strategy ();
    // = virtual dtor

  virtual int dynamic_subpriority_comp (
    const ACE_Scheduler::Task_Entry &first_info, 
    const ACE_Scheduler::Task_Entry &second_info);
    // = orders of two task entries by ascending laxity: returns -1 if the 
    //   first Task_Entry is greater in the order, 0 if they're equivalent,
    //   1 if the second Task_Entry is greater in the order.

private:

  static int sort_function (void *arg1, void *arg2);
    // comparison function to pass to qsort: calls instance ()->sort_comp ();

  static ACE_MUF_Scheduler_Strategy *instance_;
    // instance of the strategy

};


class ACE_RMS_Scheduler_Strategy : public ACE_Scheduler_Strategy
  // = TITLE
  //    ACE_RMS_Scheduler_Strategy
  //
  // = DESCRIPTION
  //    Defines "schedule" method using Rate Monotonic
  //    Scheduling algorithm.
{
public:

  static ACE_RMS_Scheduler_Strategy *instance ();
    // returns an instance of the strategy
  
  virtual int priority_comp (const ACE_Scheduler::Task_Entry &first_info, 
                             const ACE_Scheduler::Task_Entry &second_info);
    // = comparison of two task entries by minimum period: returns -1 if the
    //   first Task_Entry is greater in the order, 0 if they're equivalent,
    //   or 1 if the second Task_Entry is greater in the order.

  virtual void sort (ACE_Scheduler::Task_Entry **ordered_task_entries_,
                     u_int tasks);
    // = sort the task entry pointer array in descending RMS (rate) order

protected:

  ACE_RMS_Scheduler_Strategy ();
    // = default ctor

  virtual ~ACE_RMS_Scheduler_Strategy ();
    // = virtual dtor

  virtual int dynamic_subpriority_comp
    (const ACE_Scheduler::Task_Entry &first_info, 
     const ACE_Scheduler::Task_Entry &second_info);
    // = all tasks in a given priority level have the same dynamic
    //   subpriority under RMS: just returns 0

private:

  static int sort_function (void *arg1, void *arg2);
    // comparison function to pass to qsort: calls instance ()->sort_comp ();

  static ACE_RMS_Scheduler_Strategy *instance_;
    // instance of the strategy

};





class ACE_MLF_Scheduler_Strategy : public ACE_Scheduler_Strategy
  // = TITLE
  //    ACE_MLF_Scheduler_Strategy
  //
  // = DESCRIPTION
  //    Defines "schedule" method using Minimum Laxity First
  //    scheduling algorithm.
{
public:

  static ACE_MLF_Scheduler_Strategy *instance ();
    // returns an instance of the strategy
  
  virtual int priority_comp (const ACE_Scheduler::Task_Entry &first_info, 
                             const ACE_Scheduler::Task_Entry &second_info);
    // = just returns 0, as all task entries are of equivalent priority under MLF.

  virtual void sort (ACE_Scheduler::Task_Entry **ordered_task_entries_,
                     u_int tasks);
    // = sort the task entry pointer array in ascending laxity order

protected:

  ACE_MLF_Scheduler_Strategy ();
    // = default ctor

  virtual ~ACE_MLF_Scheduler_Strategy ();
    // = virtual dtor

  virtual int dynamic_subpriority_comp
    (const ACE_Scheduler::Task_Entry &first_info, 
     const ACE_Scheduler::Task_Entry &second_info);
    // = orders two task entries by ascending laxity: returns -1 if the
    //   first Task_Entry is greater in the order, 0 if they're equivalent,
    //   or 1 if the second Task_Entry is greater in the order.

private:

  static int sort_function (void *arg1, void *arg2);
    // comparison function to pass to qsort: calls instance ()->sort_comp ();

  static ACE_MLF_Scheduler_Strategy *instance_;
    // instance of the strategy

};


class ACE_EDF_Scheduler_Strategy : public ACE_Scheduler_Strategy
  // = TITLE
  //    ACE_EDF_Scheduler_Strategy
  //
  // = DESCRIPTION
  //    Defines "schedule" method using Earliest Deadline First
  //    scheduling algorithm.
{
public:

  static ACE_EDF_Scheduler_Strategy *instance ();
    // returns an instance of the strategy
  
  virtual int priority_comp (const ACE_Scheduler::Task_Entry &first_info, 
                             const ACE_Scheduler::Task_Entry &second_info);
    // = returns 0, as all task entries are of equivalent priority under EDF.

  virtual void sort (ACE_Scheduler::Task_Entry **ordered_task_entries_,
                     u_int tasks);
    // = sort the task entry pointer array in ascending deadline (period) order

protected:

  ACE_EDF_Scheduler_Strategy ();
    // = default ctor

  virtual ~ACE_EDF_Scheduler_Strategy ();
    // = virtual dtor

  virtual int dynamic_subpriority_comp
    (const ACE_Scheduler::Task_Entry &first_info, 
     const ACE_Scheduler::Task_Entry &second_info);
    // = orders two task entries by ascending time to deadline: returns -1 if
    //   the first Task_Entry is greater in the order, 0 if they're equivalent,
    //   or 1 if the second Task_Entry is greater in the order.

private:

  static int sort_function (void *arg1, void *arg2);
    // comparison function to pass to qsort: calls instance ()->sort_comp ();

  static ACE_EDF_Scheduler_Strategy *instance_;
    // instance of the strategy

};


class ACE_RMS_Dyn_Scheduler_Strategy : public ACE_Scheduler_Strategy
  // = TITLE
  //    ACE_RMS_Dyn_Scheduler_Strategy
  //
  // = DESCRIPTION
  //    Defines "schedule" method using Rate Monotonic priority assignment for 
  //    the critical set, single priority for the dynamic (non-critical) set.
{
public:

  static ACE_RMS_Dyn_Scheduler_Strategy *instance ();
    // returns an instance of the strategy
  
  virtual int priority_comp (const ACE_Scheduler::Task_Entry &first_info, 
                             const ACE_Scheduler::Task_Entry &second_info);
    // = comparison of two task entries by maximum criticality: returns -1 
    //   if the first Task_Entry is greater in the order, 0 if they're
    //   equivalent, or 1 if the second Task_Entry is greater in the order.

  virtual void sort (ACE_Scheduler::Task_Entry **ordered_task_entries_,
                     u_int tasks);
    // = sort the task entry pointer array in descending priority order

protected:

  ACE_RMS_Dyn_Scheduler_Strategy ();
    // = default ctor

  virtual ~ACE_RMS_Dyn_Scheduler_Strategy ();
    // = virtual dtor

  virtual int dynamic_subpriority_comp
    (const ACE_Scheduler::Task_Entry &first_info, 
     const ACE_Scheduler::Task_Entry &second_info);
    // = comparison of two task entries within the very high and high 
    //   criticality sets by minimum period (RMS) or of two task entries
    //   within the medium, low, and very low criticality sets by minimum 
    //   laxity: returns -1 if the first Task_Entry is greater in the order,
    //   0 if they're equivalent, or 1 if the second Task_Entry is greater 
    //   in the order.

private:

  static int sort_function (void *arg1, void *arg2);
    // comparison function to pass to qsort: calls instance ()->sort_comp ();

  static ACE_RMS_Dyn_Scheduler_Strategy *instance_;
    // instance of the strategy

};


#if defined (__ACE_INLINE__)
#include "Strategy_Scheduler.i"
#endif /* __ACE_INLINE__ */

#endif /* STRATEGY_SCHEDULER_H */

// EOF
