// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington 
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#if !defined (_TAO_IDL_COSNAMINGC_H_)
#define _TAO_IDL_COSNAMINGC_H_

#include "tao/corba.h"
 
class CosNaming : public virtual CORBA::Object{
public:
  typedef CORBA::String Istring;
  typedef CORBA::String_var Istring_var;

  static CORBA::TypeCode_ptr _tc_Istring;
  static CORBA::TypeCode_ptr _tc_Name;
  static CORBA::TypeCode_ptr _tc_BindingList;

  struct NameComponent
  {
    ACE_NESTED_CLASS (CosNaming,Istring_var) id;

    ACE_NESTED_CLASS (CosNaming,Istring_var) kind;

  };

  class NameComponent_var
  {
  public:
    NameComponent_var (void); // default constructor
    NameComponent_var (NameComponent *);
    NameComponent_var (const NameComponent_var &); // copy constructor
    ~NameComponent_var (void); // destructor
    
    NameComponent_var &operator= (NameComponent *);
    NameComponent_var &operator= (const NameComponent_var &);
    NameComponent *operator-> (void);
    const NameComponent *operator-> (void) const;
    
    operator const NameComponent &() const;
    operator NameComponent &();
    operator NameComponent &() const;
    // in, inout, out, _retn 
    const NameComponent &in (void) const;
    NameComponent &inout (void);
    NameComponent *&out (void);
    NameComponent *_retn (void);
    NameComponent *ptr(void) const;

  private:
    NameComponent *ptr_;
  };

  class NameComponent_out
  {
  public:
    NameComponent_out (NameComponent *&);
    NameComponent_out (NameComponent_var &);
    NameComponent_out (NameComponent_out &);
    NameComponent_out &operator= (NameComponent_out &);
    NameComponent_out &operator= (NameComponent *);
    operator NameComponent *&();
    NameComponent *&ptr (void);
    NameComponent *&operator-> (void);
    
  private:
    NameComponent *&ptr_;
    // assignment from T_var not allowed
    void operator= (const NameComponent_var &);
  };

  static CORBA::TypeCode_ptr _tc_NameComponent;

  typedef CosNaming::NameComponent Name;
  typedef CosNaming::NameComponent_var Name_var;
  typedef CosNaming::NameComponent_out Name_out;

  enum BindingType
  {
    nobject, 
    ncontext
  };
  typedef BindingType &BindingType_out;
  static CORBA::TypeCode_ptr _tc_BindingType;

  struct Binding
  {
    ACE_NESTED_CLASS (CosNaming,Name) binding_name;

    ACE_NESTED_CLASS (CosNaming,BindingType) binding_type;

  };

  class Binding_var
  {
  public:
    Binding_var (void); // default constructor
    Binding_var (Binding *);
    Binding_var (const Binding_var &); // copy constructor
    ~Binding_var (void); // destructor
    
    Binding_var &operator= (Binding *);
    Binding_var &operator= (const Binding_var &);
    Binding *operator-> (void);
    const Binding *operator-> (void) const;
    
    operator const Binding &() const;
    operator Binding &();
    operator Binding &() const;
    // in, inout, out, _retn 
    const Binding &in (void) const;
    Binding &inout (void);
    Binding *&out (void);
    Binding *_retn (void);
    Binding *ptr(void) const;

  private:
    Binding *ptr_;
  };

  class Binding_out
  {
  public:
    Binding_out (Binding *&);
    Binding_out (Binding_var &);
    Binding_out (Binding_out &);
    Binding_out &operator= (Binding_out &);
    Binding_out &operator= (Binding *);
    operator Binding *&();
    Binding *&ptr (void);
    Binding *&operator-> (void);
    
  private:
    Binding *&ptr_;
    // assignment from T_var not allowed
    void operator= (const Binding_var &);
  };

  static CORBA::TypeCode_ptr _tc_Binding;

  typedef CosNaming::Binding BindingList;
  typedef CosNaming::Binding_var BindingList_var;
  typedef CosNaming::Binding_out BindingList_out;


#if !defined (_COSNAMING_BINDINGITERATOR_DEFN_)
#define _COSNAMING_BINDINGITERATOR_DEFN_
  class BindingIterator;
  typedef BindingIterator *BindingIterator_ptr;
  
#endif // !defined (_COSNAMING_BINDINGITERATOR// _DEFN_)

  class BindingIterator_out;
  class NamingContext;
  typedef NamingContext *NamingContext_ptr;
  class NamingContext: public virtual CORBA::Object
  {
  public:
    // the static operations
    static NamingContext_ptr _duplicate (NamingContext_ptr obj);
    static NamingContext_ptr _narrow (CORBA::Object_ptr obj);
    static NamingContext_ptr _nil (void);
    static NamingContext_ptr _bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env);

    enum NotFoundReason
    {
      missing_node, 
      not_context, 
      not_object
    };
    typedef NotFoundReason &NotFoundReason_out;
    static CORBA::TypeCode_ptr _tc_NotFoundReason;

    static CORBA::TypeCode_ptr _tc_NotFound;
    static CORBA::TypeCode_ptr _tc_CannotProceed;
    static CORBA::TypeCode_ptr _tc_InvalidName;
    static CORBA::TypeCode_ptr _tc_AlreadyBound;
    static CORBA::TypeCode_ptr _tc_NotEmpty;

    virtual void bind (const ACE_NESTED_CLASS (CosNaming,Name) & n, CORBA::Object_ptr  obj, CORBA::Environment &env);
    virtual void rebind (const ACE_NESTED_CLASS (CosNaming,Name) & n, CORBA::Object_ptr  obj, CORBA::Environment &env);
    virtual void bind_context (const ACE_NESTED_CLASS (CosNaming,Name) & n, ACE_NESTED_CLASS (CosNaming,NamingContext_ptr)  nc, CORBA::Environment &env);
    virtual void rebind_context (const ACE_NESTED_CLASS (CosNaming,Name) & n, ACE_NESTED_CLASS (CosNaming,NamingContext_ptr)  nc, CORBA::Environment &env);
    virtual CORBA::Object_ptr resolve (const ACE_NESTED_CLASS (CosNaming,Name) & n, CORBA::Environment &env);
    virtual void unbind (const ACE_NESTED_CLASS (CosNaming,Name) & n, CORBA::Environment &env);
    virtual ACE_NESTED_CLASS (CosNaming,NamingContext_ptr)  new_context (CORBA::Environment &env);
    virtual ACE_NESTED_CLASS (CosNaming,NamingContext_ptr)  bind_new_context (const ACE_NESTED_CLASS (CosNaming,Name) & n, CORBA::Environment &env);
    virtual void destroy (CORBA::Environment &env);
    virtual void list (CORBA::ULong how_many, ACE_NESTED_CLASS (CosNaming,BindingList_out)  bl, ACE_NESTED_CLASS (CosNaming,BindingIterator_out)  bi, CORBA::Environment &env);
  protected:
    NamingContext (void); // default constructor
    NamingContext (STUB_Object *objref);
    virtual ~NamingContext (void);
  private:
    NamingContext (const NamingContext&);
    void operator= (const NamingContext&);
  };

  class NamingContext_var
  {
  public:
    NamingContext_var (void); // default constructor
    NamingContext_var (NamingContext_ptr);
    NamingContext_var (const NamingContext_var &); // copy constructor
    ~NamingContext_var (void); // destructor
    
    NamingContext_var &operator= (NamingContext_ptr);
    NamingContext_var &operator= (const NamingContext_var &);
    NamingContext_ptr operator-> (void) const;
    
    operator const NamingContext_ptr &() const;
    operator NamingContext_ptr &();
    // in, inout, out, _retn 
    NamingContext_ptr in (void) const;
    NamingContext_ptr &inout (void);
    NamingContext_ptr &out (void);
    NamingContext_ptr _retn (void);
    NamingContext_ptr ptr (void) const;

  private:
    NamingContext_ptr ptr_;
  };

  class NamingContext_out
  {
  public:
    NamingContext_out (NamingContext_ptr &);
    NamingContext_out (NamingContext_var &);
    NamingContext_out (NamingContext_out &);
    NamingContext_out &operator= (NamingContext_out &);
    NamingContext_out &operator= (const NamingContext_var &);
    NamingContext_out &operator= (NamingContext_ptr);
    operator NamingContext_ptr &();
    NamingContext_ptr &ptr (void);
    NamingContext_ptr operator-> (void);
    
  private:
    NamingContext_ptr &ptr_;
  };

  static CORBA::TypeCode_ptr _tc_NamingContext;

  //  class BindingIterator;
  //typedef BindingIterator *BindingIterator_ptr;
  class BindingIterator: public virtual CORBA::Object
  {
  public:
    // the static operations
    static BindingIterator_ptr _duplicate (BindingIterator_ptr obj);
    static BindingIterator_ptr _narrow (CORBA::Object_ptr obj);
    static BindingIterator_ptr _nil (void);
    static BindingIterator_ptr _bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env);

    virtual CORBA::Boolean next_one (ACE_NESTED_CLASS (CosNaming,Binding_out)  b, CORBA::Environment &env);
    virtual CORBA::Boolean next_n (CORBA::ULong how_many, ACE_NESTED_CLASS (CosNaming,BindingList_out)  bl, CORBA::Environment &env);
    virtual void destroy (CORBA::Environment &env);
  protected:
    BindingIterator (void); // default constructor
    BindingIterator (STUB_Object *objref);
    virtual ~BindingIterator (void);
  private:
    BindingIterator (const BindingIterator&);
    void operator= (const BindingIterator&);
  };

  class BindingIterator_var
  {
  public:
    BindingIterator_var (void); // default constructor
    BindingIterator_var (BindingIterator_ptr);
    BindingIterator_var (const BindingIterator_var &); // copy constructor
    ~BindingIterator_var (void); // destructor
    
    BindingIterator_var &operator= (BindingIterator_ptr);
    BindingIterator_var &operator= (const BindingIterator_var &);
    BindingIterator_ptr operator-> (void) const;
    
    operator const BindingIterator_ptr &() const;
    operator BindingIterator_ptr &();
    // in, inout, out, _retn 
    BindingIterator_ptr in (void) const;
    BindingIterator_ptr &inout (void);
    BindingIterator_ptr &out (void);
    BindingIterator_ptr _retn (void);
    BindingIterator_ptr ptr (void) const;

  private:
    BindingIterator_ptr ptr_;
  };

  class BindingIterator_out
  {
  public:
    BindingIterator_out (BindingIterator_ptr &);
    BindingIterator_out (BindingIterator_var &);
    BindingIterator_out (BindingIterator_out &);
    BindingIterator_out &operator= (BindingIterator_out &);
    BindingIterator_out &operator= (const BindingIterator_var &);
    BindingIterator_out &operator= (BindingIterator_ptr);
    operator BindingIterator_ptr &();
    BindingIterator_ptr &ptr (void);
    BindingIterator_ptr operator-> (void);
    
  private:
    BindingIterator_ptr &ptr_;
  };

  static CORBA::TypeCode_ptr _tc_BindingIterator;

};


#if defined (__ACE_INLINE__)
#include "CosNamingC.i"
#endif // defined INLINE


#endif // if !defined
