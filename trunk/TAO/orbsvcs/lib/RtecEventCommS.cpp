// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington 
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "RtecEventCommS.h"

#if !defined (__ACE_INLINE__)
#include "RtecEventCommS.i"
#endif // !defined INLINE

static const TAO_operation_db_entry PushConsumer_operations [] = {
  {"push", &POA_RtecEventComm::PushConsumer::push_skel},
  {"disconnect_push_consumer", &POA_RtecEventComm::PushConsumer::disconnect_push_consumer_skel},
  {"_is_a", &POA_RtecEventComm::PushConsumer::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PushConsumer_optable (PushConsumer_operations, 3, 6);
// skeleton constructor
POA_RtecEventComm::PushConsumer::PushConsumer (const char *obj_name)
{
  const CORBA::String repoID = "IDL:RtecEventComm/PushConsumer:1.0"; // repository ID
  IIOP_Object *data; // Actual object reference
  TAO_ORB_Core *ocp = TAO_ORB_Core_instance (); // underlying ORB core instance
  CORBA::POA_ptr oa = TAO_ORB_Core_instance ()->root_poa (); // underlying OA
  const ACE_INET_Addr &addr = ocp->orb_params ()->addr ();
  this->optable_ = &tao_PushConsumer_optable;
  
  // set up an IIOP object
  data = new IIOP_Object (CORBA::string_dup (repoID), addr, obj_name);
  this->set_parent (data); // store the IIOP obj ref with us
  this->sub_ = this; // set the most derived type to be us
  if (oa) oa->bind (data->profile.object_key, this); // register ourselves
}

void POA_RtecEventComm::PushConsumer::push_skel (CORBA::ServerRequest &_tao_server_request, CORBA::Object_ptr _tao_object_reference, CORBA::Environment &_tao_environment)
{
  CORBA::NVList_ptr 	 nvlist;
  POA_RtecEventComm::PushConsumer_ptr 	 impl;
  RtecEventComm::EventSet data;
  CORBA::NamedValue_ptr nv_data;
  CORBA::Any 	 any_data (RtecEventComm::_tc_EventSet, &data); // ORB does not own
  
  // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  nv_data = nvlist->add_value ("data", any_data, CORBA::ARG_IN, _tao_environment);
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl = (POA_RtecEventComm::PushConsumer_ptr) _tao_object_reference->get_subclass ();
  impl->push(data, _tao_environment);
  
}

void POA_RtecEventComm::PushConsumer::disconnect_push_consumer_skel (CORBA::ServerRequest &_tao_server_request, CORBA::Object_ptr _tao_object_reference, CORBA::Environment &_tao_environment)
{
  CORBA::NVList_ptr 	 nvlist;
  POA_RtecEventComm::PushConsumer_ptr 	 impl;
  
  // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl = (POA_RtecEventComm::PushConsumer_ptr) _tao_object_reference->get_subclass ();
  impl->disconnect_push_consumer(_tao_environment);
  
}

void POA_RtecEventComm::PushConsumer::_is_a_skel (CORBA::ServerRequest &req, CORBA::Object_ptr obj, CORBA::Environment &env)
{
  ACE_UNUSED_ARG (obj); // argument not used
  const CORBA::String type_id = "IDL:RtecEventComm/PushConsumer:1.0"; // repository ID
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, env);
  req.params (nvlist, env); // parse the args
  if (env.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  if (ACE_OS::strcmp ((char *)value, (char *)type_id) == 0
    || ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env)) == 0)

  	retval = new CORBA::Boolean (CORBA::B_TRUE);
  else
  	retval = new CORBA::Boolean (CORBA::B_FALSE);
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, env);
}

static const TAO_operation_db_entry PushSupplier_operations [] = {
  {"disconnect_push_supplier", &POA_RtecEventComm::PushSupplier::disconnect_push_supplier_skel},
  {"_is_a", &POA_RtecEventComm::PushSupplier::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PushSupplier_optable (PushSupplier_operations, 2, 4);
// skeleton constructor
POA_RtecEventComm::PushSupplier::PushSupplier (const char *obj_name)
{
  const CORBA::String repoID = "IDL:RtecEventComm/PushSupplier:1.0"; // repository ID
  IIOP_Object *data; // Actual object reference
  TAO_ORB_Core *ocp = TAO_ORB_Core_instance (); // underlying ORB core instance
  CORBA::POA_ptr oa = TAO_ORB_Core_instance ()->root_poa (); // underlying OA
  const ACE_INET_Addr &addr = ocp->orb_params ()->addr ();
  this->optable_ = &tao_PushSupplier_optable;
  
  // set up an IIOP object
  data = new IIOP_Object (CORBA::string_dup (repoID), addr, obj_name);
  this->set_parent (data); // store the IIOP obj ref with us
  this->sub_ = this; // set the most derived type to be us
  if (oa) oa->bind (data->profile.object_key, this); // register ourselves
}

void POA_RtecEventComm::PushSupplier::disconnect_push_supplier_skel (CORBA::ServerRequest &_tao_server_request, CORBA::Object_ptr _tao_object_reference, CORBA::Environment &_tao_environment)
{
  CORBA::NVList_ptr 	 nvlist;
  POA_RtecEventComm::PushSupplier_ptr 	 impl;
  
  // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl = (POA_RtecEventComm::PushSupplier_ptr) _tao_object_reference->get_subclass ();
  impl->disconnect_push_supplier(_tao_environment);
  
}

void POA_RtecEventComm::PushSupplier::_is_a_skel (CORBA::ServerRequest &req, CORBA::Object_ptr obj, CORBA::Environment &env)
{
  ACE_UNUSED_ARG (obj); // argument not used
  const CORBA::String type_id = "IDL:RtecEventComm/PushSupplier:1.0"; // repository ID
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, env);
  req.params (nvlist, env); // parse the args
  if (env.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  if (ACE_OS::strcmp ((char *)value, (char *)type_id) == 0
    || ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env)) == 0)

  	retval = new CORBA::Boolean (CORBA::B_TRUE);
  else
  	retval = new CORBA::Boolean (CORBA::B_FALSE);
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, env);
}

static const TAO_operation_db_entry PullSupplier_operations [] = {
  {"pull", &POA_RtecEventComm::PullSupplier::pull_skel},
  {"try_pull", &POA_RtecEventComm::PullSupplier::try_pull_skel},
  {"disconnect_pull_supplier", &POA_RtecEventComm::PullSupplier::disconnect_pull_supplier_skel},
  {"_is_a", &POA_RtecEventComm::PullSupplier::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PullSupplier_optable (PullSupplier_operations, 4, 8);
// skeleton constructor
POA_RtecEventComm::PullSupplier::PullSupplier (const char *obj_name)
{
  const CORBA::String repoID = "IDL:RtecEventComm/PullSupplier:1.0"; // repository ID
  IIOP_Object *data; // Actual object reference
  TAO_ORB_Core *ocp = TAO_ORB_Core_instance (); // underlying ORB core instance
  CORBA::POA_ptr oa = TAO_ORB_Core_instance ()->root_poa (); // underlying OA
  const ACE_INET_Addr &addr = ocp->orb_params ()->addr ();
  this->optable_ = &tao_PullSupplier_optable;
  
  // set up an IIOP object
  data = new IIOP_Object (CORBA::string_dup (repoID), addr, obj_name);
  this->set_parent (data); // store the IIOP obj ref with us
  this->sub_ = this; // set the most derived type to be us
  if (oa) oa->bind (data->profile.object_key, this); // register ourselves
}

void POA_RtecEventComm::PullSupplier::pull_skel (CORBA::ServerRequest &_tao_server_request, CORBA::Object_ptr _tao_object_reference, CORBA::Environment &_tao_environment)
{
  CORBA::NVList_ptr 	 nvlist;
  POA_RtecEventComm::PullSupplier_ptr 	 impl;
  CORBA::Any *result;
  RtecEventComm::Event *retval = new RtecEventComm::Event;
  
  // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl = (POA_RtecEventComm::PullSupplier_ptr) _tao_object_reference->get_subclass ();
  *retval = impl->pull(_tao_environment);
  result = new CORBA::Any (RtecEventComm::_tc_Event, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_RtecEventComm::PullSupplier::try_pull_skel (CORBA::ServerRequest &_tao_server_request, CORBA::Object_ptr _tao_object_reference, CORBA::Environment &_tao_environment)
{
  CORBA::NVList_ptr 	 nvlist;
  POA_RtecEventComm::PullSupplier_ptr 	 impl;
  CORBA::Any *result;
  RtecEventComm::Event *retval = new RtecEventComm::Event;
  CORBA::Boolean has_event;
  CORBA::NamedValue_ptr nv_has_event;
  CORBA::Any 	 any_has_event (CORBA::_tc_boolean, &has_event, 1); // ORB owns
  
  // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  nv_has_event = nvlist->add_value ("has_event", any_has_event, CORBA::ARG_OUT, _tao_environment);
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl = (POA_RtecEventComm::PullSupplier_ptr) _tao_object_reference->get_subclass ();
  *retval = impl->try_pull(has_event, _tao_environment);
  result = new CORBA::Any (RtecEventComm::_tc_Event, retval, 1); // ORB owns
  _tao_server_request.result (result, _tao_environment);
  
}

void POA_RtecEventComm::PullSupplier::disconnect_pull_supplier_skel (CORBA::ServerRequest &_tao_server_request, CORBA::Object_ptr _tao_object_reference, CORBA::Environment &_tao_environment)
{
  CORBA::NVList_ptr 	 nvlist;
  POA_RtecEventComm::PullSupplier_ptr 	 impl;
  
  // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl = (POA_RtecEventComm::PullSupplier_ptr) _tao_object_reference->get_subclass ();
  impl->disconnect_pull_supplier(_tao_environment);
  
}

void POA_RtecEventComm::PullSupplier::_is_a_skel (CORBA::ServerRequest &req, CORBA::Object_ptr obj, CORBA::Environment &env)
{
  ACE_UNUSED_ARG (obj); // argument not used
  const CORBA::String type_id = "IDL:RtecEventComm/PullSupplier:1.0"; // repository ID
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, env);
  req.params (nvlist, env); // parse the args
  if (env.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  if (ACE_OS::strcmp ((char *)value, (char *)type_id) == 0
    || ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env)) == 0)

  	retval = new CORBA::Boolean (CORBA::B_TRUE);
  else
  	retval = new CORBA::Boolean (CORBA::B_FALSE);
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, env);
}

static const TAO_operation_db_entry PullConsumer_operations [] = {
  {"disconnect_pull_consumer", &POA_RtecEventComm::PullConsumer::disconnect_pull_consumer_skel},
  {"_is_a", &POA_RtecEventComm::PullConsumer::_is_a_skel}
};

TAO_Dynamic_Hash_OpTable tao_PullConsumer_optable (PullConsumer_operations, 2, 4);
// skeleton constructor
POA_RtecEventComm::PullConsumer::PullConsumer (const char *obj_name)
{
  const CORBA::String repoID = "IDL:RtecEventComm/PullConsumer:1.0"; // repository ID
  IIOP_Object *data; // Actual object reference
  TAO_ORB_Core *ocp = TAO_ORB_Core_instance (); // underlying ORB core instance
  CORBA::POA_ptr oa = TAO_ORB_Core_instance ()->root_poa (); // underlying OA
  const ACE_INET_Addr &addr = ocp->orb_params ()->addr ();
  this->optable_ = &tao_PullConsumer_optable;
  
  // set up an IIOP object
  data = new IIOP_Object (CORBA::string_dup (repoID), addr, obj_name);
  this->set_parent (data); // store the IIOP obj ref with us
  this->sub_ = this; // set the most derived type to be us
  if (oa) oa->bind (data->profile.object_key, this); // register ourselves
}

void POA_RtecEventComm::PullConsumer::disconnect_pull_consumer_skel (CORBA::ServerRequest &_tao_server_request, CORBA::Object_ptr _tao_object_reference, CORBA::Environment &_tao_environment)
{
  CORBA::NVList_ptr 	 nvlist;
  POA_RtecEventComm::PullConsumer_ptr 	 impl;
  
  // create an NV list and populate it with typecodes
  _tao_server_request.orb ()->create_list (0, nvlist); // initialize a list
  // add each argument according to the in, out, inout semantics
  // parse the arguments
  _tao_server_request.params (nvlist, _tao_environment);
  if (_tao_environment.exception ()) return;
  impl = (POA_RtecEventComm::PullConsumer_ptr) _tao_object_reference->get_subclass ();
  impl->disconnect_pull_consumer(_tao_environment);
  
}

void POA_RtecEventComm::PullConsumer::_is_a_skel (CORBA::ServerRequest &req, CORBA::Object_ptr obj, CORBA::Environment &env)
{
  ACE_UNUSED_ARG (obj); // argument not used
  const CORBA::String type_id = "IDL:RtecEventComm/PullConsumer:1.0"; // repository ID
  CORBA::NVList_ptr nvlist;
  CORBA::NamedValue_ptr nv;
  CORBA::Any temp_value (CORBA::_tc_string);
  CORBA::Any *any;
  CORBA::Boolean *retval;
  CORBA::String value;
  
  req.orb()->create_list (0, nvlist);
  nv = nvlist->add_value (0, temp_value, CORBA::ARG_IN, env);
  req.params (nvlist, env); // parse the args
  if (env.exception () != 0) return;
  value = *(CORBA::String *)nv->value ()->value ();
  if (ACE_OS::strcmp ((char *)value, (char *)type_id) == 0
    || ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env)) == 0)

  	retval = new CORBA::Boolean (CORBA::B_TRUE);
  else
  	retval = new CORBA::Boolean (CORBA::B_FALSE);
  any = new CORBA::Any (CORBA::_tc_boolean, retval, CORBA::B_TRUE);
  req.result (any, env);
}

