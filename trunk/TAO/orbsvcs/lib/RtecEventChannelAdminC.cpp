// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington 
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "RtecEventChannelAdminC.h"

#if !defined (__ACE_INLINE__)
#include "RtecEventChannelAdminC.i"
#endif // !defined INLINE

static const CORBA::Long _oc_RtecEventChannelAdmin_AlreadyConnected[] =
{
  0, // byte order
  47, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f416c, 0x72656164, 0x79436f6e, 0x6e656374, 0x65643a31, 0x2e300000,  // repository ID = IDL:RtecEventChannelAdmin/AlreadyConnected:1.0
  17, 0x416c7265, 0x61647943, 0x6f6e6e65, 0x63746564, 0x0,  // name = AlreadyConnected
  0, // member count
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_AlreadyConnected (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_AlreadyConnected), (unsigned char *) &_oc_RtecEventChannelAdmin_AlreadyConnected, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_AlreadyConnected = &_tc__tc_RtecEventChannelAdmin_AlreadyConnected;

static const CORBA::Long _oc_RtecEventChannelAdmin_TypeError[] =
{
  0, // byte order
  40, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5479, 0x70654572, 0x726f723a, 0x312e3000,  // repository ID = IDL:RtecEventChannelAdmin/TypeError:1.0
  10, 0x54797065, 0x4572726f, 0x72000000,  // name = TypeError
  0, // member count
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_TypeError (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_TypeError), (unsigned char *) &_oc_RtecEventChannelAdmin_TypeError, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_TypeError = &_tc__tc_RtecEventChannelAdmin_TypeError;

static const CORBA::Long _oc_RtecEventChannelAdmin_Dependency[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f4465, 0x70656e64, 0x656e6379, 0x3a312e30, 0x0,  // repository ID = IDL:RtecEventChannelAdmin/Dependency:1.0
  11, 0x44657065, 0x6e64656e, 0x63790000,  // name = Dependency
  2, // member count
    7, 0x6576656e, 0x745f0000,  // name = event_
    CORBA::tk_struct, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436f6d, 0x6d2f4576, 0x656e743a, 0x312e3000,  // repository ID = IDL:RtecEventComm/Event:1.0
      6, 0x4576656e, 0x74000000,  // name = Event
      0, // member count
        8, 0x72745f69, 0x6e666f00,  // name = rt_info
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_Dependency (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_Dependency), (unsigned char *) &_oc_RtecEventChannelAdmin_Dependency, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_Dependency = &_tc__tc_RtecEventChannelAdmin_Dependency;

// *************************************************************
// class RtecEventChannelAdmin::DependencySet
// *************************************************************

// copy constructor
RtecEventChannelAdmin::DependencySet::DependencySet (const RtecEventChannelAdmin::DependencySet &seq)
	: maximum_ (seq.maximum_),
	  length_ (seq.length_),
	  buffer_ (RtecEventChannelAdmin::DependencySet::allocbuf (seq.maximum_)),
	  release_ (1) // we always own it
{
  for (CORBA::ULong i=0; i < seq.length_; i++)
  	this->buffer_[i] = seq.buffer_[i];
}

// destructor
RtecEventChannelAdmin::DependencySet::~DependencySet (void)
{
  if (this->release_) // we own the buffer
  {
    RtecEventChannelAdmin::DependencySet::freebuf (this->buffer_);
  }
}

// assignment operator
RtecEventChannelAdmin::DependencySet& 
RtecEventChannelAdmin::DependencySet::operator= (const RtecEventChannelAdmin::DependencySet &seq)
{
  if (this == &seq) return *this;
  if (this->release_)
  {
    RtecEventChannelAdmin::DependencySet::freebuf (this->buffer_);
  }
  this->length_ = seq.length_;
  this->maximum_ = seq.maximum_;
  this->buffer_ = RtecEventChannelAdmin::DependencySet::allocbuf (seq.maximum_),
  this->release_ =1; // we always own it
  for (CORBA::ULong i=0; i < seq.length_; i++)
  	this->buffer_[i] = seq.buffer_[i];
  return *this;
}

static const CORBA::Long _oc_RtecEventChannelAdmin_DependencySet[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f4465, 0x70656e64, 0x656e6379, 0x3a312e30, 0x0,  // repository ID = IDL:RtecEventChannelAdmin/Dependency:1.0
    11, 0x44657065, 0x6e64656e, 0x63790000,  // name = Dependency
    2, // member count
      7, 0x6576656e, 0x745f0000,  // name = event_
      CORBA::tk_struct, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        28, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436f6d, 0x6d2f4576, 0x656e743a, 0x312e3000,  // repository ID = IDL:RtecEventComm/Event:1.0
        6, 0x4576656e, 0x74000000,  // name = Event
        0, // member count
            8, 0x72745f69, 0x6e666f00,  // name = rt_info
    0,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_DependencySet (CORBA::tk_sequence, sizeof (_oc_RtecEventChannelAdmin_DependencySet), (unsigned char *) &_oc_RtecEventChannelAdmin_DependencySet, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_DependencySet = &_tc__tc_RtecEventChannelAdmin_DependencySet;

static const CORBA::Long _oc_RtecEventChannelAdmin_ConsumerQOS[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f436f, 0x6e73756d, 0x6572514f, 0x533a312e, 0x30000000,  // repository ID = IDL:RtecEventChannelAdmin/ConsumerQOS:1.0
  12, 0x436f6e73, 0x756d6572, 0x514f5300,  // name = ConsumerQOS
  2, // member count
    13, 0x64657065, 0x6e64656e, 0x63696573, 0x0,  // name = dependencies
    14, 0x666f7277, 0x6172645f, 0x6576656e, 0x74000000,  // name = forward_event
    CORBA::tk_struct, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436f6d, 0x6d2f4576, 0x656e743a, 0x312e3000,  // repository ID = IDL:RtecEventComm/Event:1.0
      6, 0x4576656e, 0x74000000,  // name = Event
      0, // member count
    };
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_ConsumerQOS (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_ConsumerQOS), (unsigned char *) &_oc_RtecEventChannelAdmin_ConsumerQOS, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_ConsumerQOS = &_tc__tc_RtecEventChannelAdmin_ConsumerQOS;

static const CORBA::Long _oc_RtecEventChannelAdmin_Publication[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5075, 0x626c6963, 0x6174696f, 0x6e3a312e, 0x30000000,  // repository ID = IDL:RtecEventChannelAdmin/Publication:1.0
  12, 0x5075626c, 0x69636174, 0x696f6e00,  // name = Publication
  2, // member count
    7, 0x6576656e, 0x745f0000,  // name = event_
    CORBA::tk_struct, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436f6d, 0x6d2f4576, 0x656e743a, 0x312e3000,  // repository ID = IDL:RtecEventComm/Event:1.0
      6, 0x4576656e, 0x74000000,  // name = Event
      0, // member count
        17, 0x64657065, 0x6e64656e, 0x63795f69, 0x6e666f5f, 0x0,  // name = dependency_info_
    CORBA::tk_struct, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      38, 0x49444c3a, 0x52746563, 0x53636865, 0x64756c65, 0x722f4465, 0x70656e64, 0x656e6379, 0x5f496e66, 0x6f3a312e, 0x30000000,  // repository ID = IDL:RtecScheduler/Dependency_Info:1.0
      16, 0x44657065, 0x6e64656e, 0x63795f49, 0x6e666f00,  // name = Dependency_Info
      0, // member count
    };
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_Publication (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_Publication), (unsigned char *) &_oc_RtecEventChannelAdmin_Publication, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_Publication = &_tc__tc_RtecEventChannelAdmin_Publication;

// *************************************************************
// class RtecEventChannelAdmin::PublicationSet
// *************************************************************

// copy constructor
RtecEventChannelAdmin::PublicationSet::PublicationSet (const RtecEventChannelAdmin::PublicationSet &seq)
	: maximum_ (seq.maximum_),
	  length_ (seq.length_),
	  buffer_ (RtecEventChannelAdmin::PublicationSet::allocbuf (seq.maximum_)),
	  release_ (1) // we always own it
{
  for (CORBA::ULong i=0; i < seq.length_; i++)
  	this->buffer_[i] = seq.buffer_[i];
}

// destructor
RtecEventChannelAdmin::PublicationSet::~PublicationSet (void)
{
  if (this->release_) // we own the buffer
  {
    RtecEventChannelAdmin::PublicationSet::freebuf (this->buffer_);
  }
}

// assignment operator
RtecEventChannelAdmin::PublicationSet& 
RtecEventChannelAdmin::PublicationSet::operator= (const RtecEventChannelAdmin::PublicationSet &seq)
{
  if (this == &seq) return *this;
  if (this->release_)
  {
    RtecEventChannelAdmin::PublicationSet::freebuf (this->buffer_);
  }
  this->length_ = seq.length_;
  this->maximum_ = seq.maximum_;
  this->buffer_ = RtecEventChannelAdmin::PublicationSet::allocbuf (seq.maximum_),
  this->release_ =1; // we always own it
  for (CORBA::ULong i=0; i < seq.length_; i++)
  	this->buffer_[i] = seq.buffer_[i];
  return *this;
}

static const CORBA::Long _oc_RtecEventChannelAdmin_PublicationSet[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
  248, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    42, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5075, 0x626c6963, 0x6174696f, 0x6e3a312e, 0x30000000,  // repository ID = IDL:RtecEventChannelAdmin/Publication:1.0
    12, 0x5075626c, 0x69636174, 0x696f6e00,  // name = Publication
    2, // member count
      7, 0x6576656e, 0x745f0000,  // name = event_
      CORBA::tk_struct, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        28, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436f6d, 0x6d2f4576, 0x656e743a, 0x312e3000,  // repository ID = IDL:RtecEventComm/Event:1.0
        6, 0x4576656e, 0x74000000,  // name = Event
        0, // member count
            17, 0x64657065, 0x6e64656e, 0x63795f69, 0x6e666f5f, 0x0,  // name = dependency_info_
      CORBA::tk_struct, // typecode kind
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        38, 0x49444c3a, 0x52746563, 0x53636865, 0x64756c65, 0x722f4465, 0x70656e64, 0x656e6379, 0x5f496e66, 0x6f3a312e, 0x30000000,  // repository ID = IDL:RtecScheduler/Dependency_Info:1.0
        16, 0x44657065, 0x6e64656e, 0x63795f49, 0x6e666f00,  // name = Dependency_Info
        0, // member count
          0,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_PublicationSet (CORBA::tk_sequence, sizeof (_oc_RtecEventChannelAdmin_PublicationSet), (unsigned char *) &_oc_RtecEventChannelAdmin_PublicationSet, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_PublicationSet = &_tc__tc_RtecEventChannelAdmin_PublicationSet;

static const CORBA::Long _oc_RtecEventChannelAdmin_SupplierQOS[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5375, 0x70706c69, 0x6572514f, 0x533a312e, 0x30000000,  // repository ID = IDL:RtecEventChannelAdmin/SupplierQOS:1.0
  12, 0x53757070, 0x6c696572, 0x514f5300,  // name = SupplierQOS
  1, // member count
    14, 0x7075626c, 0x69636174, 0x696f6e73, 0x5f000000,  // name = publications_
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_SupplierQOS (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_SupplierQOS), (unsigned char *) &_oc_RtecEventChannelAdmin_SupplierQOS, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_SupplierQOS = &_tc__tc_RtecEventChannelAdmin_SupplierQOS;

RtecEventChannelAdmin::ProxyPushConsumer_ptr RtecEventChannelAdmin::ProxyPushConsumer::_duplicate (RtecEventChannelAdmin::ProxyPushConsumer_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

RtecEventChannelAdmin::ProxyPushConsumer_ptr RtecEventChannelAdmin::ProxyPushConsumer::_narrow (CORBA::Object_ptr obj, CORBA::Environment &env)
{
  if (CORBA::is_nil (obj)) return RtecEventChannelAdmin::ProxyPushConsumer::_nil ();
  if (obj->_is_a ("IDL:RtecEventChannelAdmin/ProxyPushConsumer:1.0", env))
  {
    STUB_Object *istub;
    RtecEventChannelAdmin::ProxyPushConsumer_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
      return RtecEventChannelAdmin::ProxyPushConsumer::_nil ();
    
    obj->Release (); // need this since QueryIntf bumped our refcount
    new_obj = new RtecEventChannelAdmin::ProxyPushConsumer (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if
  return RtecEventChannelAdmin::ProxyPushConsumer::_nil (); // _narrow failed
} // end of _narrow

RtecEventChannelAdmin::ProxyPushConsumer_ptr RtecEventChannelAdmin::ProxyPushConsumer::_nil (void)
{
  return (RtecEventChannelAdmin::ProxyPushConsumer_ptr)NULL;
} // end of _nil

RtecEventChannelAdmin::ProxyPushConsumer_ptr RtecEventChannelAdmin::ProxyPushConsumer::_bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return RtecEventChannelAdmin::ProxyPushConsumer::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return RtecEventChannelAdmin::ProxyPushConsumer::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return RtecEventChannelAdmin::ProxyPushConsumer::_nil ();
  else // narrow it
  	return RtecEventChannelAdmin::ProxyPushConsumer::_narrow (objref, env);
}

static const TAO_Param_Data RtecEventChannelAdmin_ProxyPushConsumer_connect_push_supplier_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {RtecEventComm::_tc_PushSupplier, PARAM_IN, 0},
  {RtecEventChannelAdmin::_tc_SupplierQOS, PARAM_IN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_ProxyPushConsumer_connect_push_supplier_calldata = 
{"connect_push_supplier", 1, 3, RtecEventChannelAdmin_ProxyPushConsumer_connect_push_supplier_paramdata, 0, 0};

void  RtecEventChannelAdmin::ProxyPushConsumer::connect_push_supplier (RtecEventComm::PushSupplier_ptr  push_supplier, const RtecEventChannelAdmin::SupplierQOS & qos, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_ProxyPushConsumer_connect_push_supplier_calldata, 0, &push_supplier, &qos);
  return; // no value
  
}

static const CORBA::Long _oc_RtecEventChannelAdmin_ProxyPushConsumer[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5072, 0x6f787950, 0x75736843, 0x6f6e7375, 0x6d65723a, 0x312e3000,  // repository ID = IDL:RtecEventChannelAdmin/ProxyPushConsumer:1.0
  18, 0x50726f78, 0x79507573, 0x68436f6e, 0x73756d65, 0x72000000,  // name = ProxyPushConsumer,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_ProxyPushConsumer (CORBA::tk_objref, sizeof (_oc_RtecEventChannelAdmin_ProxyPushConsumer), (unsigned char *) &_oc_RtecEventChannelAdmin_ProxyPushConsumer, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_ProxyPushConsumer = &_tc__tc_RtecEventChannelAdmin_ProxyPushConsumer;

RtecEventChannelAdmin::ProxyPullSupplier_ptr RtecEventChannelAdmin::ProxyPullSupplier::_duplicate (RtecEventChannelAdmin::ProxyPullSupplier_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

RtecEventChannelAdmin::ProxyPullSupplier_ptr RtecEventChannelAdmin::ProxyPullSupplier::_narrow (CORBA::Object_ptr obj, CORBA::Environment &env)
{
  if (CORBA::is_nil (obj)) return RtecEventChannelAdmin::ProxyPullSupplier::_nil ();
  if (obj->_is_a ("IDL:RtecEventChannelAdmin/ProxyPullSupplier:1.0", env))
  {
    STUB_Object *istub;
    RtecEventChannelAdmin::ProxyPullSupplier_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
      return RtecEventChannelAdmin::ProxyPullSupplier::_nil ();
    
    obj->Release (); // need this since QueryIntf bumped our refcount
    new_obj = new RtecEventChannelAdmin::ProxyPullSupplier (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if
  return RtecEventChannelAdmin::ProxyPullSupplier::_nil (); // _narrow failed
} // end of _narrow

RtecEventChannelAdmin::ProxyPullSupplier_ptr RtecEventChannelAdmin::ProxyPullSupplier::_nil (void)
{
  return (RtecEventChannelAdmin::ProxyPullSupplier_ptr)NULL;
} // end of _nil

RtecEventChannelAdmin::ProxyPullSupplier_ptr RtecEventChannelAdmin::ProxyPullSupplier::_bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return RtecEventChannelAdmin::ProxyPullSupplier::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return RtecEventChannelAdmin::ProxyPullSupplier::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return RtecEventChannelAdmin::ProxyPullSupplier::_nil ();
  else // narrow it
  	return RtecEventChannelAdmin::ProxyPullSupplier::_narrow (objref, env);
}

static const TAO_Param_Data RtecEventChannelAdmin_ProxyPullSupplier_connect_pull_consumer_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {RtecEventComm::_tc_PullConsumer, PARAM_IN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_ProxyPullSupplier_connect_pull_consumer_calldata = 
{"connect_pull_consumer", 1, 2, RtecEventChannelAdmin_ProxyPullSupplier_connect_pull_consumer_paramdata, 0, 0};

void  RtecEventChannelAdmin::ProxyPullSupplier::connect_pull_consumer (RtecEventComm::PullConsumer_ptr  pull_consumer, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_ProxyPullSupplier_connect_pull_consumer_calldata, 0, &pull_consumer);
  return; // no value
  
}

static const CORBA::Long _oc_RtecEventChannelAdmin_ProxyPullSupplier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5072, 0x6f787950, 0x756c6c53, 0x7570706c, 0x6965723a, 0x312e3000,  // repository ID = IDL:RtecEventChannelAdmin/ProxyPullSupplier:1.0
  18, 0x50726f78, 0x7950756c, 0x6c537570, 0x706c6965, 0x72000000,  // name = ProxyPullSupplier,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_ProxyPullSupplier (CORBA::tk_objref, sizeof (_oc_RtecEventChannelAdmin_ProxyPullSupplier), (unsigned char *) &_oc_RtecEventChannelAdmin_ProxyPullSupplier, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_ProxyPullSupplier = &_tc__tc_RtecEventChannelAdmin_ProxyPullSupplier;

RtecEventChannelAdmin::ProxyPullConsumer_ptr RtecEventChannelAdmin::ProxyPullConsumer::_duplicate (RtecEventChannelAdmin::ProxyPullConsumer_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

RtecEventChannelAdmin::ProxyPullConsumer_ptr RtecEventChannelAdmin::ProxyPullConsumer::_narrow (CORBA::Object_ptr obj, CORBA::Environment &env)
{
  if (CORBA::is_nil (obj)) return RtecEventChannelAdmin::ProxyPullConsumer::_nil ();
  if (obj->_is_a ("IDL:RtecEventChannelAdmin/ProxyPullConsumer:1.0", env))
  {
    STUB_Object *istub;
    RtecEventChannelAdmin::ProxyPullConsumer_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
      return RtecEventChannelAdmin::ProxyPullConsumer::_nil ();
    
    obj->Release (); // need this since QueryIntf bumped our refcount
    new_obj = new RtecEventChannelAdmin::ProxyPullConsumer (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if
  return RtecEventChannelAdmin::ProxyPullConsumer::_nil (); // _narrow failed
} // end of _narrow

RtecEventChannelAdmin::ProxyPullConsumer_ptr RtecEventChannelAdmin::ProxyPullConsumer::_nil (void)
{
  return (RtecEventChannelAdmin::ProxyPullConsumer_ptr)NULL;
} // end of _nil

RtecEventChannelAdmin::ProxyPullConsumer_ptr RtecEventChannelAdmin::ProxyPullConsumer::_bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return RtecEventChannelAdmin::ProxyPullConsumer::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return RtecEventChannelAdmin::ProxyPullConsumer::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return RtecEventChannelAdmin::ProxyPullConsumer::_nil ();
  else // narrow it
  	return RtecEventChannelAdmin::ProxyPullConsumer::_narrow (objref, env);
}

static const TAO_Param_Data RtecEventChannelAdmin_ProxyPullConsumer_connect_pull_supplier_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {RtecEventComm::_tc_PullSupplier, PARAM_IN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_ProxyPullConsumer_connect_pull_supplier_calldata = 
{"connect_pull_supplier", 1, 2, RtecEventChannelAdmin_ProxyPullConsumer_connect_pull_supplier_paramdata, 0, 0};

void  RtecEventChannelAdmin::ProxyPullConsumer::connect_pull_supplier (RtecEventComm::PullSupplier_ptr  pull_supplier, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_ProxyPullConsumer_connect_pull_supplier_calldata, 0, &pull_supplier);
  return; // no value
  
}

static const CORBA::Long _oc_RtecEventChannelAdmin_ProxyPullConsumer[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5072, 0x6f787950, 0x756c6c43, 0x6f6e7375, 0x6d65723a, 0x312e3000,  // repository ID = IDL:RtecEventChannelAdmin/ProxyPullConsumer:1.0
  18, 0x50726f78, 0x7950756c, 0x6c436f6e, 0x73756d65, 0x72000000,  // name = ProxyPullConsumer,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_ProxyPullConsumer (CORBA::tk_objref, sizeof (_oc_RtecEventChannelAdmin_ProxyPullConsumer), (unsigned char *) &_oc_RtecEventChannelAdmin_ProxyPullConsumer, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_ProxyPullConsumer = &_tc__tc_RtecEventChannelAdmin_ProxyPullConsumer;

RtecEventChannelAdmin::ProxyPushSupplier_ptr RtecEventChannelAdmin::ProxyPushSupplier::_duplicate (RtecEventChannelAdmin::ProxyPushSupplier_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

RtecEventChannelAdmin::ProxyPushSupplier_ptr RtecEventChannelAdmin::ProxyPushSupplier::_narrow (CORBA::Object_ptr obj, CORBA::Environment &env)
{
  if (CORBA::is_nil (obj)) return RtecEventChannelAdmin::ProxyPushSupplier::_nil ();
  if (obj->_is_a ("IDL:RtecEventChannelAdmin/ProxyPushSupplier:1.0", env))
  {
    STUB_Object *istub;
    RtecEventChannelAdmin::ProxyPushSupplier_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
      return RtecEventChannelAdmin::ProxyPushSupplier::_nil ();
    
    obj->Release (); // need this since QueryIntf bumped our refcount
    new_obj = new RtecEventChannelAdmin::ProxyPushSupplier (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if
  return RtecEventChannelAdmin::ProxyPushSupplier::_nil (); // _narrow failed
} // end of _narrow

RtecEventChannelAdmin::ProxyPushSupplier_ptr RtecEventChannelAdmin::ProxyPushSupplier::_nil (void)
{
  return (RtecEventChannelAdmin::ProxyPushSupplier_ptr)NULL;
} // end of _nil

RtecEventChannelAdmin::ProxyPushSupplier_ptr RtecEventChannelAdmin::ProxyPushSupplier::_bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return RtecEventChannelAdmin::ProxyPushSupplier::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return RtecEventChannelAdmin::ProxyPushSupplier::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return RtecEventChannelAdmin::ProxyPushSupplier::_nil ();
  else // narrow it
  	return RtecEventChannelAdmin::ProxyPushSupplier::_narrow (objref, env);
}

static const TAO_Param_Data RtecEventChannelAdmin_ProxyPushSupplier_connect_push_consumer_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0},
  {RtecEventComm::_tc_PushConsumer, PARAM_IN, 0},
  {RtecEventChannelAdmin::_tc_ConsumerQOS, PARAM_IN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_ProxyPushSupplier_connect_push_consumer_calldata = 
{"connect_push_consumer", 1, 3, RtecEventChannelAdmin_ProxyPushSupplier_connect_push_consumer_paramdata, 0, 0};

void  RtecEventChannelAdmin::ProxyPushSupplier::connect_push_consumer (RtecEventComm::PushConsumer_ptr  push_consumer, const RtecEventChannelAdmin::ConsumerQOS & qos, CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_ProxyPushSupplier_connect_push_consumer_calldata, 0, &push_consumer, &qos);
  return; // no value
  
}

static const CORBA::Long _oc_RtecEventChannelAdmin_ProxyPushSupplier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5072, 0x6f787950, 0x75736853, 0x7570706c, 0x6965723a, 0x312e3000,  // repository ID = IDL:RtecEventChannelAdmin/ProxyPushSupplier:1.0
  18, 0x50726f78, 0x79507573, 0x68537570, 0x706c6965, 0x72000000,  // name = ProxyPushSupplier,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_ProxyPushSupplier (CORBA::tk_objref, sizeof (_oc_RtecEventChannelAdmin_ProxyPushSupplier), (unsigned char *) &_oc_RtecEventChannelAdmin_ProxyPushSupplier, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_ProxyPushSupplier = &_tc__tc_RtecEventChannelAdmin_ProxyPushSupplier;

RtecEventChannelAdmin::ConsumerAdmin_ptr RtecEventChannelAdmin::ConsumerAdmin::_duplicate (RtecEventChannelAdmin::ConsumerAdmin_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

RtecEventChannelAdmin::ConsumerAdmin_ptr RtecEventChannelAdmin::ConsumerAdmin::_narrow (CORBA::Object_ptr obj, CORBA::Environment &env)
{
  if (CORBA::is_nil (obj)) return RtecEventChannelAdmin::ConsumerAdmin::_nil ();
  if (obj->_is_a ("IDL:RtecEventChannelAdmin/ConsumerAdmin:1.0", env))
  {
    STUB_Object *istub;
    RtecEventChannelAdmin::ConsumerAdmin_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
      return RtecEventChannelAdmin::ConsumerAdmin::_nil ();
    
    obj->Release (); // need this since QueryIntf bumped our refcount
    new_obj = new RtecEventChannelAdmin::ConsumerAdmin (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if
  return RtecEventChannelAdmin::ConsumerAdmin::_nil (); // _narrow failed
} // end of _narrow

RtecEventChannelAdmin::ConsumerAdmin_ptr RtecEventChannelAdmin::ConsumerAdmin::_nil (void)
{
  return (RtecEventChannelAdmin::ConsumerAdmin_ptr)NULL;
} // end of _nil

RtecEventChannelAdmin::ConsumerAdmin_ptr RtecEventChannelAdmin::ConsumerAdmin::_bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return RtecEventChannelAdmin::ConsumerAdmin::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return RtecEventChannelAdmin::ConsumerAdmin::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return RtecEventChannelAdmin::ConsumerAdmin::_nil ();
  else // narrow it
  	return RtecEventChannelAdmin::ConsumerAdmin::_narrow (objref, env);
}

static const TAO_Param_Data RtecEventChannelAdmin_ConsumerAdmin_obtain_push_supplier_paramdata [] = 
{
  {RtecEventChannelAdmin::_tc_ProxyPushSupplier, PARAM_RETURN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_ConsumerAdmin_obtain_push_supplier_calldata = 
{"obtain_push_supplier", 1, 1, RtecEventChannelAdmin_ConsumerAdmin_obtain_push_supplier_paramdata, 0, 0};

RtecEventChannelAdmin::ProxyPushSupplier_ptr  RtecEventChannelAdmin::ConsumerAdmin::obtain_push_supplier (CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return RtecEventChannelAdmin::ProxyPushSupplier::_nil ();
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_ConsumerAdmin_obtain_push_supplier_calldata, &retval);
  return RtecEventChannelAdmin::ProxyPushSupplier::_narrow (retval, env);
  
}

static const CORBA::Long _oc_RtecEventChannelAdmin_ConsumerAdmin[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f436f, 0x6e73756d, 0x65724164, 0x6d696e3a, 0x312e3000,  // repository ID = IDL:RtecEventChannelAdmin/ConsumerAdmin:1.0
  14, 0x436f6e73, 0x756d6572, 0x41646d69, 0x6e000000,  // name = ConsumerAdmin,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_ConsumerAdmin (CORBA::tk_objref, sizeof (_oc_RtecEventChannelAdmin_ConsumerAdmin), (unsigned char *) &_oc_RtecEventChannelAdmin_ConsumerAdmin, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_ConsumerAdmin = &_tc__tc_RtecEventChannelAdmin_ConsumerAdmin;

RtecEventChannelAdmin::SupplierAdmin_ptr RtecEventChannelAdmin::SupplierAdmin::_duplicate (RtecEventChannelAdmin::SupplierAdmin_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

RtecEventChannelAdmin::SupplierAdmin_ptr RtecEventChannelAdmin::SupplierAdmin::_narrow (CORBA::Object_ptr obj, CORBA::Environment &env)
{
  if (CORBA::is_nil (obj)) return RtecEventChannelAdmin::SupplierAdmin::_nil ();
  if (obj->_is_a ("IDL:RtecEventChannelAdmin/SupplierAdmin:1.0", env))
  {
    STUB_Object *istub;
    RtecEventChannelAdmin::SupplierAdmin_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
      return RtecEventChannelAdmin::SupplierAdmin::_nil ();
    
    obj->Release (); // need this since QueryIntf bumped our refcount
    new_obj = new RtecEventChannelAdmin::SupplierAdmin (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if
  return RtecEventChannelAdmin::SupplierAdmin::_nil (); // _narrow failed
} // end of _narrow

RtecEventChannelAdmin::SupplierAdmin_ptr RtecEventChannelAdmin::SupplierAdmin::_nil (void)
{
  return (RtecEventChannelAdmin::SupplierAdmin_ptr)NULL;
} // end of _nil

RtecEventChannelAdmin::SupplierAdmin_ptr RtecEventChannelAdmin::SupplierAdmin::_bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return RtecEventChannelAdmin::SupplierAdmin::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return RtecEventChannelAdmin::SupplierAdmin::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return RtecEventChannelAdmin::SupplierAdmin::_nil ();
  else // narrow it
  	return RtecEventChannelAdmin::SupplierAdmin::_narrow (objref, env);
}

static const TAO_Param_Data RtecEventChannelAdmin_SupplierAdmin_obtain_push_consumer_paramdata [] = 
{
  {RtecEventChannelAdmin::_tc_ProxyPushConsumer, PARAM_RETURN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_SupplierAdmin_obtain_push_consumer_calldata = 
{"obtain_push_consumer", 1, 1, RtecEventChannelAdmin_SupplierAdmin_obtain_push_consumer_paramdata, 0, 0};

RtecEventChannelAdmin::ProxyPushConsumer_ptr  RtecEventChannelAdmin::SupplierAdmin::obtain_push_consumer (CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return RtecEventChannelAdmin::ProxyPushConsumer::_nil ();
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_SupplierAdmin_obtain_push_consumer_calldata, &retval);
  return RtecEventChannelAdmin::ProxyPushConsumer::_narrow (retval, env);
  
}

static const CORBA::Long _oc_RtecEventChannelAdmin_SupplierAdmin[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f5375, 0x70706c69, 0x65724164, 0x6d696e3a, 0x312e3000,  // repository ID = IDL:RtecEventChannelAdmin/SupplierAdmin:1.0
  14, 0x53757070, 0x6c696572, 0x41646d69, 0x6e000000,  // name = SupplierAdmin,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_SupplierAdmin (CORBA::tk_objref, sizeof (_oc_RtecEventChannelAdmin_SupplierAdmin), (unsigned char *) &_oc_RtecEventChannelAdmin_SupplierAdmin, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_SupplierAdmin = &_tc__tc_RtecEventChannelAdmin_SupplierAdmin;

RtecEventChannelAdmin::EventChannel_ptr RtecEventChannelAdmin::EventChannel::_duplicate (RtecEventChannelAdmin::EventChannel_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->AddRef ();
  
  return obj;
} // end of _duplicate

RtecEventChannelAdmin::EventChannel_ptr RtecEventChannelAdmin::EventChannel::_narrow (CORBA::Object_ptr obj, CORBA::Environment &env)
{
  if (CORBA::is_nil (obj)) return RtecEventChannelAdmin::EventChannel::_nil ();
  if (obj->_is_a ("IDL:RtecEventChannelAdmin/EventChannel:1.0", env))
  {
    STUB_Object *istub;
    RtecEventChannelAdmin::EventChannel_ptr new_obj; // to be returned 
    if (obj->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
      return RtecEventChannelAdmin::EventChannel::_nil ();
    
    obj->Release (); // need this since QueryIntf bumped our refcount
    new_obj = new RtecEventChannelAdmin::EventChannel (istub); // construct obj ref using the stub object
    return new_obj;
  } // end of if
  return RtecEventChannelAdmin::EventChannel::_nil (); // _narrow failed
} // end of _narrow

RtecEventChannelAdmin::EventChannel_ptr RtecEventChannelAdmin::EventChannel::_nil (void)
{
  return (RtecEventChannelAdmin::EventChannel_ptr)NULL;
} // end of _nil

RtecEventChannelAdmin::EventChannel_ptr RtecEventChannelAdmin::EventChannel::_bind (const char *host, CORBA::ULong port, const char *key, CORBA::Environment &env)
{
  CORBA::Object_ptr objref = CORBA::Object::_nil ();
  IIOP_Object *data = new IIOP_Object (host, port, key);
  if (!data) return RtecEventChannelAdmin::EventChannel::_nil ();
  // get the object_ptr using Query Interface
  if (data->QueryInterface (IID_CORBA_Object, (void **)&objref) != NOERROR)
  {
  	env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
  	return RtecEventChannelAdmin::EventChannel::_nil ();
  }
  data->Release (); // QueryInterface had bumped up our count
  if (CORBA::is_nil (objref))
  	return RtecEventChannelAdmin::EventChannel::_nil ();
  else // narrow it
  	return RtecEventChannelAdmin::EventChannel::_narrow (objref, env);
}

static const CORBA::Long _oc_RtecEventChannelAdmin_EventChannel_SYNCHRONIZATION_ERROR[] =
{
  0, // byte order
  65, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f4576, 0x656e7443, 0x68616e6e, 0x656c2f53, 0x594e4348, 0x524f4e49, 0x5a415449, 0x4f4e5f45, 0x52524f52, 0x3a312e30, 0x0,  // repository ID = IDL:RtecEventChannelAdmin/EventChannel/SYNCHRONIZATION_ERROR:1.0
  22, 0x53594e43, 0x48524f4e, 0x495a4154, 0x494f4e5f, 0x4552524f, 0x52000000,  // name = SYNCHRONIZATION_ERROR
  3, // member count
    6, 0x6d696e6f, 0x72000000,  // name = minor
    CORBA::tk_long,

    7, 0x73746174, 0x75730000,  // name = status
    CORBA::tk_long,

    5, 0x6e616d65, 0x0,  // name = name
    CORBA::tk_string, 
    0, // string length
    };
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_EventChannel_SYNCHRONIZATION_ERROR (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_EventChannel_SYNCHRONIZATION_ERROR), (unsigned char *) &_oc_RtecEventChannelAdmin_EventChannel_SYNCHRONIZATION_ERROR, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::EventChannel::_tc_SYNCHRONIZATION_ERROR = &_tc__tc_RtecEventChannelAdmin_EventChannel_SYNCHRONIZATION_ERROR;

static const CORBA::Long _oc_RtecEventChannelAdmin_EventChannel_QOS_ERROR[] =
{
  0, // byte order
  53, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f4576, 0x656e7443, 0x68616e6e, 0x656c2f51, 0x4f535f45, 0x52524f52, 0x3a312e30, 0x0,  // repository ID = IDL:RtecEventChannelAdmin/EventChannel/QOS_ERROR:1.0
  10, 0x514f535f, 0x4552524f, 0x52000000,  // name = QOS_ERROR
  3, // member count
    6, 0x6d696e6f, 0x72000000,  // name = minor
    CORBA::tk_long,

    7, 0x73746174, 0x75730000,  // name = status
    CORBA::tk_long,

    5, 0x6e616d65, 0x0,  // name = name
    CORBA::tk_string, 
    0, // string length
    };
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_EventChannel_QOS_ERROR (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_EventChannel_QOS_ERROR), (unsigned char *) &_oc_RtecEventChannelAdmin_EventChannel_QOS_ERROR, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::EventChannel::_tc_QOS_ERROR = &_tc__tc_RtecEventChannelAdmin_EventChannel_QOS_ERROR;

static const CORBA::Long _oc_RtecEventChannelAdmin_EventChannel_SUBSCRIPTION_ERROR[] =
{
  0, // byte order
  62, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f4576, 0x656e7443, 0x68616e6e, 0x656c2f53, 0x55425343, 0x52495054, 0x494f4e5f, 0x4552524f, 0x523a312e, 0x30000000,  // repository ID = IDL:RtecEventChannelAdmin/EventChannel/SUBSCRIPTION_ERROR:1.0
  19, 0x53554253, 0x43524950, 0x54494f4e, 0x5f455252, 0x4f520000,  // name = SUBSCRIPTION_ERROR
  3, // member count
    6, 0x6d696e6f, 0x72000000,  // name = minor
    CORBA::tk_long,

    7, 0x73746174, 0x75730000,  // name = status
    CORBA::tk_long,

    5, 0x6e616d65, 0x0,  // name = name
    CORBA::tk_string, 
    0, // string length
    };
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_EventChannel_SUBSCRIPTION_ERROR (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_EventChannel_SUBSCRIPTION_ERROR), (unsigned char *) &_oc_RtecEventChannelAdmin_EventChannel_SUBSCRIPTION_ERROR, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::EventChannel::_tc_SUBSCRIPTION_ERROR = &_tc__tc_RtecEventChannelAdmin_EventChannel_SUBSCRIPTION_ERROR;

static const CORBA::Long _oc_RtecEventChannelAdmin_EventChannel_CORRELATION_ERROR[] =
{
  0, // byte order
  61, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f4576, 0x656e7443, 0x68616e6e, 0x656c2f43, 0x4f525245, 0x4c415449, 0x4f4e5f45, 0x52524f52, 0x3a312e30, 0x0,  // repository ID = IDL:RtecEventChannelAdmin/EventChannel/CORRELATION_ERROR:1.0
  18, 0x434f5252, 0x454c4154, 0x494f4e5f, 0x4552524f, 0x52000000,  // name = CORRELATION_ERROR
  3, // member count
    6, 0x6d696e6f, 0x72000000,  // name = minor
    CORBA::tk_long,

    7, 0x73746174, 0x75730000,  // name = status
    CORBA::tk_long,

    5, 0x6e616d65, 0x0,  // name = name
    CORBA::tk_string, 
    0, // string length
    };
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_EventChannel_CORRELATION_ERROR (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_EventChannel_CORRELATION_ERROR), (unsigned char *) &_oc_RtecEventChannelAdmin_EventChannel_CORRELATION_ERROR, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::EventChannel::_tc_CORRELATION_ERROR = &_tc__tc_RtecEventChannelAdmin_EventChannel_CORRELATION_ERROR;

static const CORBA::Long _oc_RtecEventChannelAdmin_EventChannel_DISPATCH_ERROR[] =
{
  0, // byte order
  58, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f4576, 0x656e7443, 0x68616e6e, 0x656c2f44, 0x49535041, 0x5443485f, 0x4552524f, 0x523a312e, 0x30000000,  // repository ID = IDL:RtecEventChannelAdmin/EventChannel/DISPATCH_ERROR:1.0
  15, 0x44495350, 0x41544348, 0x5f455252, 0x4f520000,  // name = DISPATCH_ERROR
  3, // member count
    6, 0x6d696e6f, 0x72000000,  // name = minor
    CORBA::tk_long,

    7, 0x73746174, 0x75730000,  // name = status
    CORBA::tk_long,

    5, 0x6e616d65, 0x0,  // name = name
    CORBA::tk_string, 
    0, // string length
    };
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_EventChannel_DISPATCH_ERROR (CORBA::tk_struct, sizeof (_oc_RtecEventChannelAdmin_EventChannel_DISPATCH_ERROR), (unsigned char *) &_oc_RtecEventChannelAdmin_EventChannel_DISPATCH_ERROR, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::EventChannel::_tc_DISPATCH_ERROR = &_tc__tc_RtecEventChannelAdmin_EventChannel_DISPATCH_ERROR;

static const TAO_Param_Data RtecEventChannelAdmin_EventChannel_for_consumers_paramdata [] = 
{
  {RtecEventChannelAdmin::_tc_ConsumerAdmin, PARAM_RETURN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_EventChannel_for_consumers_calldata = 
{"for_consumers", 1, 1, RtecEventChannelAdmin_EventChannel_for_consumers_paramdata, 0, 0};

RtecEventChannelAdmin::ConsumerAdmin_ptr  RtecEventChannelAdmin::EventChannel::for_consumers (CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return RtecEventChannelAdmin::ConsumerAdmin::_nil ();
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_EventChannel_for_consumers_calldata, &retval);
  return RtecEventChannelAdmin::ConsumerAdmin::_narrow (retval, env);
  
}

static const TAO_Param_Data RtecEventChannelAdmin_EventChannel_for_suppliers_paramdata [] = 
{
  {RtecEventChannelAdmin::_tc_SupplierAdmin, PARAM_RETURN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_EventChannel_for_suppliers_calldata = 
{"for_suppliers", 1, 1, RtecEventChannelAdmin_EventChannel_for_suppliers_paramdata, 0, 0};

RtecEventChannelAdmin::SupplierAdmin_ptr  RtecEventChannelAdmin::EventChannel::for_suppliers (CORBA::Environment &env)
{
  CORBA::Object_ptr retval = CORBA::Object::_nil ();
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return RtecEventChannelAdmin::SupplierAdmin::_nil ();
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_EventChannel_for_suppliers_calldata, &retval);
  return RtecEventChannelAdmin::SupplierAdmin::_narrow (retval, env);
  
}

static const TAO_Param_Data RtecEventChannelAdmin_EventChannel_destroy_paramdata [] = 
{
  {CORBA::_tc_void, PARAM_RETURN, 0}
};

static const TAO_Call_Data RtecEventChannelAdmin_EventChannel_destroy_calldata = 
{"destroy", 1, 1, RtecEventChannelAdmin_EventChannel_destroy_paramdata, 0, 0};

void  RtecEventChannelAdmin::EventChannel::destroy (CORBA::Environment &env)
{
  STUB_Object *istub;

  if (this->QueryInterface (IID_STUB_Object, (void **)&istub) != NOERROR)
  {
    env.exception (new CORBA::DATA_CONVERSION (CORBA::COMPLETED_NO));
    return;
    }
  this->Release (); // QueryInterface has bumped up our refcount
  istub->do_call (env, &RtecEventChannelAdmin_EventChannel_destroy_calldata, 0);
  return; // no value
  
}

static const CORBA::Long _oc_RtecEventChannelAdmin_EventChannel[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, 0x49444c3a, 0x52746563, 0x4576656e, 0x74436861, 0x6e6e656c, 0x41646d69, 0x6e2f4576, 0x656e7443, 0x68616e6e, 0x656c3a31, 0x2e300000,  // repository ID = IDL:RtecEventChannelAdmin/EventChannel:1.0
  13, 0x4576656e, 0x74436861, 0x6e6e656c, 0x0,  // name = EventChannel,
};
static CORBA::TypeCode _tc__tc_RtecEventChannelAdmin_EventChannel (CORBA::tk_objref, sizeof (_oc_RtecEventChannelAdmin_EventChannel), (unsigned char *) &_oc_RtecEventChannelAdmin_EventChannel, CORBA::B_FALSE);
CORBA::TypeCode_ptr RtecEventChannelAdmin::_tc_EventChannel = &_tc__tc_RtecEventChannelAdmin_EventChannel;

