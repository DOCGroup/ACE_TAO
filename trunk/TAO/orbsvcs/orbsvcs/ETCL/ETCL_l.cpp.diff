--- ETCL_l.cpp	Wed Sep 26 17:40:34 2001
+++ ETCL_l.cpp.final	Wed Sep 26 17:33:38 2001
@@ -1,19 +1,3 @@
-#define yy_create_buffer TAO_ETCL__create_buffer
-#define yy_delete_buffer TAO_ETCL__delete_buffer
-#define yy_scan_buffer TAO_ETCL__scan_buffer
-#define yy_scan_string TAO_ETCL__scan_string
-#define yy_scan_bytes TAO_ETCL__scan_bytes
-#define yy_flex_debug TAO_ETCL__flex_debug
-#define yy_init_buffer TAO_ETCL__init_buffer
-#define yy_flush_buffer TAO_ETCL__flush_buffer
-#define yy_load_buffer_state TAO_ETCL__load_buffer_state
-#define yy_switch_to_buffer TAO_ETCL__switch_to_buffer
-#define yyin TAO_ETCL_in
-#define yyleng TAO_ETCL_leng
-#define yylex TAO_ETCL_lex
-#define yyout TAO_ETCL_out
-#define yyrestart TAO_ETCL_restart
-#define yytext TAO_ETCL_text
 
 /* A lexical scanner generated by flex */
 
@@ -25,8 +9,6 @@
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
 
-#include <stdio.h>
-
 
 /* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
 #ifdef c_plusplus
@@ -38,7 +20,6 @@
 
 #ifdef __cplusplus
 
-#include <stdlib.h>
 #include "ace/OS.h"
 
 /* Use prototypes in function declarations. */
@@ -279,8 +260,8 @@
 #define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
 
 
-#define yywrap() 1
-#define YY_SKIP_YYWRAP
+//#define yywrap() 1
+//#define YY_SKIP_YYWRAP
 typedef unsigned char YY_CHAR;
 FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
 typedef int yy_state_type;
@@ -469,7 +450,7 @@
 //
 // = LIBRARY
 //   orbsvcs/ECTL
-// 
+//
 // = FILENAME
 //   ETCL.ll
 //
@@ -479,12 +460,12 @@
 //
 // ========================================================================
 
-#include "ace/OS.h"
-
+#include "ETCL_Interpreter.h"
 #include "ETCL_Constraint.h"
 #include "ETCL_y.h"
 
-static const char * extract_string(char*);
+static const char* extract_string(char*);
+//static const char * extract_string(char*);
 
 #define TAO_YY_LEX_DEBUG
 
@@ -492,7 +473,7 @@
 #define TAO_YY_LEX_DEBUG TAO_OS::fprintf(stderr, "%s\n", yytext)
 #endif /* TAO_CONSTRAINT_DEBUG */
 
-#define YY_DECL int TAO_ETCL_yylex (TAO_ETCL_YYSTYPE *lvalp, void* state)
+//#define YY_DECL int TAO_ETCL_yylex (TAO_ETCL_YYSTYPE *lvalp, void* state)
 
 #define YY_BREAK
 #define YY_NO_UNPUT
@@ -510,10 +491,6 @@
 #endif
 #endif
 
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
-#endif
-
 #ifndef yytext_ptr
 static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
 #endif
@@ -572,11 +549,11 @@
 
 /* Copy whatever the last rule matched to the standard output. */
 
-#ifndef ECHO
+#ifndef TAO_ETCL_ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define TAO_ETCL_ECHO (void) fwrite( yytext, yyleng, 1, yyout )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -649,8 +626,6 @@
 
 #line 50 "ETCL/ETCL.ll"
 
-
-
 	if ( yy_init )
 		{
 		yy_init = 0;
@@ -895,8 +870,8 @@
 case 33:
 YY_RULE_SETUP
 #line 84 "ETCL/ETCL.ll"
-{ 
-		  lvalp->constraint = 
+{
+		  yylval.constraint =
 		    new TAO_ETCL_Literal_Constraint ((CORBA::Boolean) 1);
 		  TAO_YY_LEX_DEBUG; return TAO_ETCL_BOOLEAN;
 		}
@@ -904,8 +879,8 @@
 case 34:
 YY_RULE_SETUP
 #line 89 "ETCL/ETCL.ll"
-{ 
-		  lvalp->constraint = 
+{
+		  yylval.constraint =
 		    new TAO_ETCL_Literal_Constraint ((CORBA::Boolean) 0);
 		  TAO_YY_LEX_DEBUG; return TAO_ETCL_BOOLEAN;
 		}
@@ -913,10 +888,10 @@
 case 35:
 YY_RULE_SETUP
 #line 94 "ETCL/ETCL.ll"
-{ 
-		  lvalp->constraint = 
+{
+		  yylval.constraint =
 		    new TAO_ETCL_Literal_Constraint (ACE_OS::atoi (yytext));
-		  TAO_YY_LEX_DEBUG; return TAO_ETCL_INTEGER; 
+		  TAO_YY_LEX_DEBUG; return TAO_ETCL_INTEGER;
 		}
 	YY_BREAK
 case 36:
@@ -924,48 +899,48 @@
 #line 99 "ETCL/ETCL.ll"
 {
 		  double v;
-		  sscanf (yytext, "%lf", &v); 
-		  lvalp->constraint = 
+		  sscanf (yytext, "%lf", &v);
+		  yylval.constraint =
 		    new TAO_ETCL_Literal_Constraint (v);
-		  TAO_YY_LEX_DEBUG; return TAO_ETCL_FLOAT; 
+		  TAO_YY_LEX_DEBUG; return TAO_ETCL_FLOAT;
 		}
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
 #line 106 "ETCL/ETCL.ll"
-{ 
-		  lvalp->constraint =
-		    new TAO_ETCL_Literal_Constraint (extract_string (yytext));
-		  TAO_YY_LEX_DEBUG; return TAO_ETCL_STRING; 
+{
+		  yylval.constraint =
+		    new TAO_ETCL_Literal_Constraint (extract_string(yytext));
+		  TAO_YY_LEX_DEBUG; return TAO_ETCL_STRING;
 		}
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
 #line 111 "ETCL/ETCL.ll"
-{ 
-		  lvalp->constraint = 
+{
+		  yylval.constraint =
 		    new TAO_ETCL_Identifier (yytext);
-		  TAO_YY_LEX_DEBUG; return TAO_ETCL_IDENT; 
+		  TAO_YY_LEX_DEBUG; return TAO_ETCL_IDENT;
 		}
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
 #line 116 "ETCL/ETCL.ll"
-{ 
+{
                   TAO_YY_LEX_DEBUG; break; // Ignore
                 }
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
 #line 119 "ETCL/ETCL.ll"
-{ 
+{
                   TAO_YY_LEX_DEBUG; break; // @@ TODO
                 }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
 #line 122 "ETCL/ETCL.ll"
-ECHO;
+TAO_ETCL_ECHO;
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
 	yyterminate();
@@ -1302,7 +1277,7 @@
 	return yy_is_jam ? 0 : yy_current_state;
 	}
 
-
+#if 0
 #ifndef YY_NO_UNPUT
 #ifdef YY_USE_PROTOS
 static void yyunput( int c, register char *yy_bp )
@@ -1346,7 +1321,7 @@
 	yy_c_buf_p = yy_cp;
 	}
 #endif	/* ifndef YY_NO_UNPUT */
-
+#endif /* 0 */
 
 #ifdef __cplusplus
 static int yyinput()
@@ -1530,11 +1505,6 @@
 	}
 
 
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
 
 #ifdef YY_USE_PROTOS
 void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
@@ -1551,15 +1521,8 @@
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
 
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
 	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
+
 	}
 
