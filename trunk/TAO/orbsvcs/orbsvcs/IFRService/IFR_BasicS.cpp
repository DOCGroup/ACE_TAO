// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from 
// be\be_codegen.cpp:609

#ifndef _TAO_IDL_ORIG_IFR_BASICS_CPP_
#define _TAO_IDL_ORIG_IFR_BASICS_CPP_


#include "IFR_BasicS.h"
#include "tao/PortableServer/ForwardRequestC.h"
#include "tao/PortableServer/Operation_Table.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/PortableServer/Basic_SArguments.h"
#include "tao/PortableServer/Object_SArgument_T.h"
#include "tao/PortableServer/Special_Basic_SArguments.h"
#include "tao/PortableServer/UB_String_SArguments.h"
#include "tao/PortableServer/Var_Size_SArgument_T.h"
#include "tao/PortableServer/Any_SArg_Traits.h"
#include "tao/PortableServer/TypeCode_SArg_Traits.h"
#include "tao/PortableServer/Object_SArg_Traits.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/Typecode.h"
#include "tao/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "tao/Basic_Arguments.h"
#include "tao/Object_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Var_Size_Argument_T.h"
#include "tao/Any_Arg_Traits.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "IFR_BasicS.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be\be_visitor_arg_traits.cpp:69

// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:690

#if !defined (_CORBA_DEFINITIONKIND__SARG_TRAITS_SS_)
#define _CORBA_DEFINITIONKIND__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::DefinitionKind>
    : public
        Basic_SArg_Traits_T<
            CORBA::DefinitionKind
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_CONTAINED__SARG_TRAITS_SS_)
#define _CORBA_CONTAINED__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::Contained>
    : public
        Object_SArg_Traits_T<
            CORBA::Contained_ptr,
            CORBA::Contained_var,
            CORBA::Contained_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_REPOSITORY__SARG_TRAITS_SS_)
#define _CORBA_REPOSITORY__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::Repository>
    : public
        Object_SArg_Traits_T<
            CORBA::Repository_ptr,
            CORBA::Repository_var,
            CORBA::Repository_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_CONTAINER__SARG_TRAITS_SS_)
#define _CORBA_CONTAINER__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::Container>
    : public
        Object_SArg_Traits_T<
            CORBA::Container_ptr,
            CORBA::Container_var,
            CORBA::Container_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_IDLTYPE__SARG_TRAITS_SS_)
#define _CORBA_IDLTYPE__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::IDLType>
    : public
        Object_SArg_Traits_T<
            CORBA::IDLType_ptr,
            CORBA::IDLType_var,
            CORBA::IDLType_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:731

#if !defined (_CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__SARG_TRAITS_SS_)
#define _CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::InterfaceDef::FullInterfaceDescription>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InterfaceDef::FullInterfaceDescription,
            CORBA::InterfaceDef::FullInterfaceDescription_var,
            CORBA::InterfaceDef::FullInterfaceDescription_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_INTERFACEDEFSEQ__SARG_TRAITS_SS_)
#define _CORBA_INTERFACEDEFSEQ__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::InterfaceDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InterfaceDefSeq,
            CORBA::InterfaceDefSeq_var,
            CORBA::InterfaceDefSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_STRUCTMEMBERSEQ__SARG_TRAITS_SS_)
#define _CORBA_STRUCTMEMBERSEQ__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::StructMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::StructMemberSeq,
            CORBA::StructMemberSeq_var,
            CORBA::StructMemberSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_EXCDESCRIPTIONSEQ__SARG_TRAITS_SS_)
#define _CORBA_EXCDESCRIPTIONSEQ__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::ExcDescriptionSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExcDescriptionSeq,
            CORBA::ExcDescriptionSeq_var,
            CORBA::ExcDescriptionSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_UNIONMEMBERSEQ__SARG_TRAITS_SS_)
#define _CORBA_UNIONMEMBERSEQ__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::UnionMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::UnionMemberSeq,
            CORBA::UnionMemberSeq_var,
            CORBA::UnionMemberSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_ENUMMEMBERSEQ__SARG_TRAITS_SS_)
#define _CORBA_ENUMMEMBERSEQ__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::EnumMemberSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::EnumMemberSeq,
            CORBA::EnumMemberSeq_var,
            CORBA::EnumMemberSeq_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_PRIMITIVEDEF__SARG_TRAITS_SS_)
#define _CORBA_PRIMITIVEDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::PrimitiveDef>
    : public
        Object_SArg_Traits_T<
            CORBA::PrimitiveDef_ptr,
            CORBA::PrimitiveDef_var,
            CORBA::PrimitiveDef_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_STRINGDEF__SARG_TRAITS_SS_)
#define _CORBA_STRINGDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::StringDef>
    : public
        Object_SArg_Traits_T<
            CORBA::StringDef_ptr,
            CORBA::StringDef_var,
            CORBA::StringDef_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCEDEF__SARG_TRAITS_SS_)
#define _CORBA_SEQUENCEDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::SequenceDef>
    : public
        Object_SArg_Traits_T<
            CORBA::SequenceDef_ptr,
            CORBA::SequenceDef_var,
            CORBA::SequenceDef_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_ARRAYDEF__SARG_TRAITS_SS_)
#define _CORBA_ARRAYDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::ArrayDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ArrayDef_ptr,
            CORBA::ArrayDef_var,
            CORBA::ArrayDef_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_WSTRINGDEF__SARG_TRAITS_SS_)
#define _CORBA_WSTRINGDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::WstringDef>
    : public
        Object_SArg_Traits_T<
            CORBA::WstringDef_ptr,
            CORBA::WstringDef_var,
            CORBA::WstringDef_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_FIXEDDEF__SARG_TRAITS_SS_)
#define _CORBA_FIXEDDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::FixedDef>
    : public
        Object_SArg_Traits_T<
            CORBA::FixedDef_ptr,
            CORBA::FixedDef_var,
            CORBA::FixedDef_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:690

#if !defined (_CORBA_PRIMITIVEKIND__SARG_TRAITS_SS_)
#define _CORBA_PRIMITIVEKIND__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::PrimitiveKind>
    : public
        Basic_SArg_Traits_T<
            CORBA::PrimitiveKind
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_SS_)
#define _CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::ExceptionDefSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExceptionDefSeq,
            CORBA::ExceptionDefSeq_var,
            CORBA::ExceptionDefSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:690

#if !defined (_CORBA_ATTRIBUTEMODE__SARG_TRAITS_SS_)
#define _CORBA_ATTRIBUTEMODE__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::AttributeMode>
    : public
        Basic_SArg_Traits_T<
            CORBA::AttributeMode
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_ATTRIBUTEDEF__SARG_TRAITS_SS_)
#define _CORBA_ATTRIBUTEDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::AttributeDef>
    : public
        Object_SArg_Traits_T<
            CORBA::AttributeDef_ptr,
            CORBA::AttributeDef_var,
            CORBA::AttributeDef_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:731

#if !defined (_CORBA_EXTATTRIBUTEDESCRIPTION__SARG_TRAITS_SS_)
#define _CORBA_EXTATTRIBUTEDESCRIPTION__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::ExtAttributeDescription>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ExtAttributeDescription,
            CORBA::ExtAttributeDescription_var,
            CORBA::ExtAttributeDescription_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_EXTATTRIBUTEDEF__SARG_TRAITS_SS_)
#define _CORBA_EXTATTRIBUTEDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::ExtAttributeDef>
    : public
        Object_SArg_Traits_T<
            CORBA::ExtAttributeDef_ptr,
            CORBA::ExtAttributeDef_var,
            CORBA::ExtAttributeDef_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:690

#if !defined (_CORBA_OPERATIONMODE__SARG_TRAITS_SS_)
#define _CORBA_OPERATIONMODE__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::OperationMode>
    : public
        Basic_SArg_Traits_T<
            CORBA::OperationMode
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_SS_)
#define _CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::ParDescriptionSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ParDescriptionSeq,
            CORBA::ParDescriptionSeq_var,
            CORBA::ParDescriptionSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_CONTEXTIDSEQ__SARG_TRAITS_SS_)
#define _CORBA_CONTEXTIDSEQ__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::ContextIdSeq>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::ContextIdSeq,
            CORBA::ContextIdSeq_var,
            CORBA::ContextIdSeq_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_OPERATIONDEF__SARG_TRAITS_SS_)
#define _CORBA_OPERATIONDEF__SARG_TRAITS_SS_
  
  template<>
  class  SArg_Traits<CORBA::OperationDef>
    : public
        Object_SArg_Traits_T<
            CORBA::OperationDef_ptr,
            CORBA::OperationDef_var,
            CORBA::OperationDef_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:731

#if !defined (_CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__SARG_TRAITS_SS_)
#define _CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__SARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export SArg_Traits<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>
    : public
        Var_Size_SArg_Traits_T<
            CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription,
            CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_var,
            CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_out
          >
  {
  };

#endif /* end #if !defined */
}


// TAO_IDL - Generated from
// be\be_visitor_arg_traits.cpp:69

// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:690

#if !defined (_CORBA_DEFINITIONKIND__ARG_TRAITS_SS_)
#define _CORBA_DEFINITIONKIND__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::DefinitionKind>
    : public
        Basic_Arg_Traits_T<
            CORBA::DefinitionKind
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_CONTAINED__ARG_TRAITS_SS_)
#define _CORBA_CONTAINED__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::Contained>
    : public
        Object_Arg_Traits_T<
            CORBA::Contained_ptr,
            CORBA::Contained_var,
            CORBA::Contained_out,
            TAO::Objref_Traits<CORBA::Contained>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_REPOSITORY__ARG_TRAITS_SS_)
#define _CORBA_REPOSITORY__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::Repository>
    : public
        Object_Arg_Traits_T<
            CORBA::Repository_ptr,
            CORBA::Repository_var,
            CORBA::Repository_out,
            TAO::Objref_Traits<CORBA::Repository>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_CONTAINER__ARG_TRAITS_SS_)
#define _CORBA_CONTAINER__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::Container>
    : public
        Object_Arg_Traits_T<
            CORBA::Container_ptr,
            CORBA::Container_var,
            CORBA::Container_out,
            TAO::Objref_Traits<CORBA::Container>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_IDLTYPE__ARG_TRAITS_SS_)
#define _CORBA_IDLTYPE__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::IDLType>
    : public
        Object_Arg_Traits_T<
            CORBA::IDLType_ptr,
            CORBA::IDLType_var,
            CORBA::IDLType_out,
            TAO::Objref_Traits<CORBA::IDLType>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:731

#if !defined (_CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__ARG_TRAITS_SS_)
#define _CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::InterfaceDef::FullInterfaceDescription>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InterfaceDef::FullInterfaceDescription,
            CORBA::InterfaceDef::FullInterfaceDescription_var,
            CORBA::InterfaceDef::FullInterfaceDescription_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_INTERFACEDEFSEQ__ARG_TRAITS_SS_)
#define _CORBA_INTERFACEDEFSEQ__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::InterfaceDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InterfaceDefSeq,
            CORBA::InterfaceDefSeq_var,
            CORBA::InterfaceDefSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_STRUCTMEMBERSEQ__ARG_TRAITS_SS_)
#define _CORBA_STRUCTMEMBERSEQ__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::StructMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::StructMemberSeq,
            CORBA::StructMemberSeq_var,
            CORBA::StructMemberSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_EXCDESCRIPTIONSEQ__ARG_TRAITS_SS_)
#define _CORBA_EXCDESCRIPTIONSEQ__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::ExcDescriptionSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExcDescriptionSeq,
            CORBA::ExcDescriptionSeq_var,
            CORBA::ExcDescriptionSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_UNIONMEMBERSEQ__ARG_TRAITS_SS_)
#define _CORBA_UNIONMEMBERSEQ__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::UnionMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::UnionMemberSeq,
            CORBA::UnionMemberSeq_var,
            CORBA::UnionMemberSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_ENUMMEMBERSEQ__ARG_TRAITS_SS_)
#define _CORBA_ENUMMEMBERSEQ__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::EnumMemberSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::EnumMemberSeq,
            CORBA::EnumMemberSeq_var,
            CORBA::EnumMemberSeq_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_PRIMITIVEDEF__ARG_TRAITS_SS_)
#define _CORBA_PRIMITIVEDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::PrimitiveDef>
    : public
        Object_Arg_Traits_T<
            CORBA::PrimitiveDef_ptr,
            CORBA::PrimitiveDef_var,
            CORBA::PrimitiveDef_out,
            TAO::Objref_Traits<CORBA::PrimitiveDef>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_STRINGDEF__ARG_TRAITS_SS_)
#define _CORBA_STRINGDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::StringDef>
    : public
        Object_Arg_Traits_T<
            CORBA::StringDef_ptr,
            CORBA::StringDef_var,
            CORBA::StringDef_out,
            TAO::Objref_Traits<CORBA::StringDef>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCEDEF__ARG_TRAITS_SS_)
#define _CORBA_SEQUENCEDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::SequenceDef>
    : public
        Object_Arg_Traits_T<
            CORBA::SequenceDef_ptr,
            CORBA::SequenceDef_var,
            CORBA::SequenceDef_out,
            TAO::Objref_Traits<CORBA::SequenceDef>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_ARRAYDEF__ARG_TRAITS_SS_)
#define _CORBA_ARRAYDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::ArrayDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ArrayDef_ptr,
            CORBA::ArrayDef_var,
            CORBA::ArrayDef_out,
            TAO::Objref_Traits<CORBA::ArrayDef>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_WSTRINGDEF__ARG_TRAITS_SS_)
#define _CORBA_WSTRINGDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::WstringDef>
    : public
        Object_Arg_Traits_T<
            CORBA::WstringDef_ptr,
            CORBA::WstringDef_var,
            CORBA::WstringDef_out,
            TAO::Objref_Traits<CORBA::WstringDef>
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_FIXEDDEF__ARG_TRAITS_SS_)
#define _CORBA_FIXEDDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::FixedDef>
    : public
        Object_Arg_Traits_T<
            CORBA::FixedDef_ptr,
            CORBA::FixedDef_var,
            CORBA::FixedDef_out,
            TAO::Objref_Traits<CORBA::FixedDef>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:690

#if !defined (_CORBA_PRIMITIVEKIND__ARG_TRAITS_SS_)
#define _CORBA_PRIMITIVEKIND__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::PrimitiveKind>
    : public
        Basic_Arg_Traits_T<
            CORBA::PrimitiveKind
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_EXCEPTIONDEFSEQ__ARG_TRAITS_SS_)
#define _CORBA_EXCEPTIONDEFSEQ__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::ExceptionDefSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExceptionDefSeq,
            CORBA::ExceptionDefSeq_var,
            CORBA::ExceptionDefSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:690

#if !defined (_CORBA_ATTRIBUTEMODE__ARG_TRAITS_SS_)
#define _CORBA_ATTRIBUTEMODE__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::AttributeMode>
    : public
        Basic_Arg_Traits_T<
            CORBA::AttributeMode
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_ATTRIBUTEDEF__ARG_TRAITS_SS_)
#define _CORBA_ATTRIBUTEDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::AttributeDef>
    : public
        Object_Arg_Traits_T<
            CORBA::AttributeDef_ptr,
            CORBA::AttributeDef_var,
            CORBA::AttributeDef_out,
            TAO::Objref_Traits<CORBA::AttributeDef>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:731

#if !defined (_CORBA_EXTATTRIBUTEDESCRIPTION__ARG_TRAITS_SS_)
#define _CORBA_EXTATTRIBUTEDESCRIPTION__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::ExtAttributeDescription>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ExtAttributeDescription,
            CORBA::ExtAttributeDescription_var,
            CORBA::ExtAttributeDescription_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_EXTATTRIBUTEDEF__ARG_TRAITS_SS_)
#define _CORBA_EXTATTRIBUTEDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::ExtAttributeDef>
    : public
        Object_Arg_Traits_T<
            CORBA::ExtAttributeDef_ptr,
            CORBA::ExtAttributeDef_var,
            CORBA::ExtAttributeDef_out,
            TAO::Objref_Traits<CORBA::ExtAttributeDef>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:690

#if !defined (_CORBA_OPERATIONMODE__ARG_TRAITS_SS_)
#define _CORBA_OPERATIONMODE__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::OperationMode>
    : public
        Basic_Arg_Traits_T<
            CORBA::OperationMode
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_PARDESCRIPTIONSEQ__ARG_TRAITS_SS_)
#define _CORBA_PARDESCRIPTIONSEQ__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::ParDescriptionSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ParDescriptionSeq,
            CORBA::ParDescriptionSeq_var,
            CORBA::ParDescriptionSeq_out
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:480

#if !defined (_CORBA_CONTEXTIDSEQ__ARG_TRAITS_SS_)
#define _CORBA_CONTEXTIDSEQ__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::ContextIdSeq>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::ContextIdSeq,
            CORBA::ContextIdSeq_var,
            CORBA::ContextIdSeq_out
          >
  {
  };

#endif /* end #if !defined */

#if !defined (_CORBA_OPERATIONDEF__ARG_TRAITS_SS_)
#define _CORBA_OPERATIONDEF__ARG_TRAITS_SS_
  
  template<>
  class  Arg_Traits<CORBA::OperationDef>
    : public
        Object_Arg_Traits_T<
            CORBA::OperationDef_ptr,
            CORBA::OperationDef_var,
            CORBA::OperationDef_out,
            TAO::Objref_Traits<CORBA::OperationDef>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be\be_visitor_arg_traits.cpp:731

#if !defined (_CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__ARG_TRAITS_SS_)
#define _CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__ARG_TRAITS_SS_
  
  template<>
  class TAO_IFR_Client_Export Arg_Traits<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>
    : public
        Var_Size_Arg_Traits_T<
            CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription,
            CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_var,
            CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_out
          >
  {
  };

#endif /* end #if !defined */
}


// Stub/skeleton argument selection function templates.
// TAO_IDL - Generated from be\be_visitor_root/root.cpp:111

namespace
{
  template<typename T>
  typename TAO::SArg_Traits<T>::ret_arg_type
  get_ret_arg (TAO_Operation_Details const * details,
               TAO::Argument * const * skel_args)
  {
    return
      details
      ? static_cast<typename TAO::Arg_Traits<T>::ret_val *> (
          details->args ()[0])->arg ()
      : static_cast<typename TAO::SArg_Traits<T>::ret_val *> (
          skel_args[0])->arg ();
  }
  
  template<typename T>
  typename TAO::SArg_Traits<T>::in_arg_type
  get_in_arg (TAO_Operation_Details const * details,
              TAO::Argument * const * skel_args,
              size_t i)
  {
    return
      details
      ? static_cast<typename TAO::Arg_Traits<T>::in_arg_val *> (
          details->args ()[i])->arg ()
      : static_cast<typename TAO::SArg_Traits<T>::in_arg_val *> (
          skel_args[i])->arg ();
  }
  
  template<typename T>
  typename TAO::SArg_Traits<T>::inout_arg_type
  get_inout_arg (TAO_Operation_Details const * details,
                 TAO::Argument * const * skel_args,
                 size_t i)
  {
    return
      details
      ? static_cast<typename TAO::Arg_Traits<T>::inout_arg_val *> (
          details->args ()[i])->arg ()
      : static_cast<typename TAO::SArg_Traits<T>::inout_arg_val *> (
          skel_args[i])->arg ();
  }
  
  template<typename T>
  typename TAO::SArg_Traits<T>::out_arg_type
  get_out_arg (TAO_Operation_Details const * details,
               TAO::Argument * const * skel_args,
               size_t i)
  {
    return
      details
      ? static_cast<typename TAO::Arg_Traits<T>::out_arg_val *> (
          details->args ()[i])->arg ()
      : static_cast<typename TAO::SArg_Traits<T>::out_arg_val *> (
          skel_args[i])->arg ();
  }
}


// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_Repository_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 30,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 10,
     52,  0,  4, 10, 52,  5, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52,  8, 30, 15,
     52,  0, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 30,  0, 52, 52, 52, 20,  0, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 30, 52, 10, 52,  0,
      4, 10, 52,  5, 52, 52, 52, 52,  8, 30,
     15, 52,  0, 52, 52, 30,  0, 52, 52, 52,
     20,  0, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 32,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 25,
      MIN_HASH_VALUE = 11,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 41,
      DUPLICATES = 3,
      WORDLIST_SIZE = 43
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"",0,0},{"",0,0},
      {"destroy", &POA_CORBA::Repository::destroy_skel, 0},
      {"create_array", &POA_CORBA::Repository::create_array_skel, 0},
      {"create_struct", &POA_CORBA::Repository::create_struct_skel, 0},
      {"lookup", &POA_CORBA::Repository::lookup_skel, 0},
      {"create_constant", &POA_CORBA::Repository::create_constant_skel, 0},
      {"create_fixed", &POA_CORBA::Repository::create_fixed_skel, 0},
      {"create_string", &POA_CORBA::Repository::create_string_skel, 0},
      {"create_wstring", &POA_CORBA::Repository::create_wstring_skel, 0},
      {"lookup_id", &POA_CORBA::Repository::lookup_id_skel, 0},
      {"create_value", &POA_CORBA::Repository::create_value_skel, 0},
      {"create_module", &POA_CORBA::Repository::create_module_skel, 0},
      {"create_native", &POA_CORBA::Repository::create_native_skel, 0},
      {"create_sequence", &POA_CORBA::Repository::create_sequence_skel, 0},
      {"create_interface", &POA_CORBA::Repository::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::Repository::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::Repository::create_union_skel, 0},
      {"get_primitive", &POA_CORBA::Repository::get_primitive_skel, 0},
      {"lookup_name", &POA_CORBA::Repository::lookup_name_skel, 0},
      {"create_exception", &POA_CORBA::Repository::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::Repository::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::Repository::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::Repository::create_value_box_skel, 0},
      {"get_canonical_typecode", &POA_CORBA::Repository::get_canonical_typecode_skel, 0},
      {"contents", &POA_CORBA::Repository::contents_skel, 0},
      {"_component", &POA_CORBA::Repository::_component_skel, 0},
      {"create_enum", &POA_CORBA::Repository::create_enum_skel, 0},
      {"create_alias", &POA_CORBA::Repository::create_alias_skel, 0},
      {"_non_existent", &POA_CORBA::Repository::_non_existent_skel, 0},
      {"_is_a", &POA_CORBA::Repository::_is_a_skel, 0},
      {"_get_def_kind", &POA_CORBA::Repository::_get_def_kind_skel, 0},
      {"_interface", &POA_CORBA::Repository::_interface_skel, 0},
      {"describe_contents", &POA_CORBA::Repository::describe_contents_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,  -1,  -1, -21,  -2, -24,  -2,  11,  12,  13, 
       14,  15,  16,  -1,  17,  18,  -1,  19,  20, -67,  -1,  23, -68,  26, 
       27,  28,  -1,  29,  30,  -1,  -1,  31,  32,  33,  34,  -1,  35,  36, 
       37,  38,  -1,  39,  -1,  40,  -1,  -1,  41,  42, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_Repository_Perfect_Hash_OpTable tao_CORBA_Repository_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_Repository_Strategized_Proxy_Broker *
POA_CORBA::_TAO_Repository_Strategized_Proxy_Broker::the_TAO_Repository_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_Repository_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_Repository_Strategized_Proxy_Broker::_TAO_Repository_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_Repository_Strategized_Proxy_Broker::~_TAO_Repository_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_Repository_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_Repository_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_Repository_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_Repository_Strategized_Proxy_Broker::the_TAO_Repository_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_Repository_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_Repository_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_Repository_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_Repository_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_Repository_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_Repository_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::Repository::Repository (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_Repository_optable;
}

POA_CORBA::Repository::Repository (const Repository& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs)
{
}

POA_CORBA::Repository::~Repository (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::Repository::lookup_id_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::Contained>::ret_arg_type retval =
        get_ret_arg< CORBA::Contained> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_type arg_1 =
        get_in_arg< CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_->lookup_id (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::Contained>::ret_val retval;
  TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_val _tao_search_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_search_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::Repository::get_canonical_typecode_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::TypeCode>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_->get_canonical_typecode (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::TypeCode>::in_arg_val _tao_tc;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_tc
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::Repository::get_primitive_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::PrimitiveDef>::ret_arg_type retval =
        get_ret_arg< CORBA::PrimitiveDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::PrimitiveKind>::in_arg_type arg_1 =
        get_in_arg< CORBA::PrimitiveKind> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_->get_primitive (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::PrimitiveDef>::ret_val retval;
  TAO::SArg_Traits< CORBA::PrimitiveKind>::in_arg_val _tao_kind;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_kind
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::Repository::create_string_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::StringDef>::ret_arg_type retval =
        get_ret_arg< CORBA::StringDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_->create_string (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::StringDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::Repository::create_wstring_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::WstringDef>::ret_arg_type retval =
        get_ret_arg< CORBA::WstringDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_->create_wstring (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::WstringDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::Repository::create_sequence_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::SequenceDef>::ret_arg_type retval =
        get_ret_arg< CORBA::SequenceDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_2 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          2);
        
      
      retval =
        this->servant_->create_sequence (
          arg_1
          , arg_2
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::SequenceDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_element_type;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound,
      &_tao_element_type
    };
  
  static size_t const nargs = 3;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::Repository::create_array_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ArrayDef>::ret_arg_type retval =
        get_ret_arg< CORBA::ArrayDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_2 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          2);
        
      
      retval =
        this->servant_->create_array (
          arg_1
          , arg_2
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::ArrayDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_length;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_element_type;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_length,
      &_tao_element_type
    };
  
  static size_t const nargs = 3;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::Repository::create_fixed_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::FixedDef>::ret_arg_type retval =
        get_ret_arg< CORBA::FixedDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::UShort>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::UShort> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< ::CORBA::Short>::in_arg_type arg_2 =
        get_in_arg< ::CORBA::Short> (
          this->operation_details_,
          this->args_,
          2);
        
      
      retval =
        this->servant_->create_fixed (
          arg_1
          , arg_2
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::FixedDef>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::UShort>::in_arg_val _tao_digits;
  TAO::SArg_Traits< ::CORBA::Short>::in_arg_val _tao_scale;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_digits,
      &_tao_scale
    };
  
  static size_t const nargs = 3;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::Repository::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::Repository::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::Repository::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::Repository::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::Repository * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::Repository * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::Repository * const impl =
    static_cast<
      POA_CORBA::Repository *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::Repository::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Repository:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::Repository::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::Repository *
POA_CORBA::Repository::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::Repository STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_Repository_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_ModuleDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 20,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 10,
     64,  0, 20,  0, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 20,  0,  5,
     64, 10, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 15, 30, 64, 64, 64, 10,  5, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64,
#else
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
     64, 64, 64, 64, 64, 20, 64, 10, 64,  0,
     20,  0, 64, 64, 64, 64, 64, 64, 20,  0,
      5, 64, 10, 64, 64, 15, 30, 64, 64, 64,
     10,  5, 64, 64, 64, 64, 64, 64,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 35,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 63,
      HASH_VALUE_RANGE = 60,
      DUPLICATES = 6,
      WORDLIST_SIZE = 39
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ModuleDef::move_skel, 0},
      {"create_enum", &POA_CORBA::ModuleDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ModuleDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ModuleDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ModuleDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ModuleDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::ModuleDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ModuleDef::create_union_skel, 0},
      {"create_exception", &POA_CORBA::ModuleDef::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::ModuleDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ModuleDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ModuleDef::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::ModuleDef::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::ModuleDef::create_alias_skel, 0},
      {"describe", &POA_CORBA::ModuleDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ModuleDef::_get_name_skel, 0},
      {"_set_name", &POA_CORBA::ModuleDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ModuleDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ModuleDef::lookup_name_skel, 0},
      {"destroy", &POA_CORBA::ModuleDef::destroy_skel, 0},
      {"_is_a", &POA_CORBA::ModuleDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ModuleDef::lookup_skel, 0},
      {"_get_version", &POA_CORBA::ModuleDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ModuleDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ModuleDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ModuleDef::_get_defined_in_skel, 0},
      {"create_struct", &POA_CORBA::ModuleDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ModuleDef::create_constant_skel, 0},
      {"_get_id", &POA_CORBA::ModuleDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ModuleDef::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ModuleDef::_get_containing_repository_skel, 0},
      {"describe_contents", &POA_CORBA::ModuleDef::describe_contents_skel, 0},
      {"_get_def_kind", &POA_CORBA::ModuleDef::_get_def_kind_skel, 0},
      {"_component", &POA_CORBA::ModuleDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ModuleDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -1,  -1,  -7,  -2,   5,   6, -67, 
       -9,  -2, -65,  11,  -1, -19,  -2,  12,  13,  14,  -1,  15,  16,  17, 
       18, -73,  21,  22,  23, -26,  -2,  24,  25, -67,  28,  -1,  29, -32, 
       -2,  30,  -1,  31,  -1, -69,  -1,  -1,  -1,  34,  35,  36,  -1,  -1, 
       -1,  -1,  -1,  -1,  37,  -1,  -1,  38, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ModuleDef_Perfect_Hash_OpTable tao_CORBA_ModuleDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_ModuleDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_ModuleDef_Strategized_Proxy_Broker::the_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ModuleDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ModuleDef_Strategized_Proxy_Broker::_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_ModuleDef_Strategized_Proxy_Broker::~_TAO_ModuleDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_ModuleDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_ModuleDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_ModuleDef_Strategized_Proxy_Broker::the_TAO_ModuleDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_ModuleDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_ModuleDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ModuleDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_ModuleDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ModuleDef::ModuleDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ModuleDef_optable;
}

POA_CORBA::ModuleDef::ModuleDef (const ModuleDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs)
{
}

POA_CORBA::ModuleDef::~ModuleDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::ModuleDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ModuleDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ModuleDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ModuleDef * const impl =
    static_cast<
      POA_CORBA::ModuleDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::ModuleDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ModuleDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ModuleDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ModuleDef * const impl =
    static_cast<
      POA_CORBA::ModuleDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::ModuleDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::ModuleDef * const impl =
    static_cast<
      POA_CORBA::ModuleDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::ModuleDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ModuleDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ModuleDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ModuleDef * const impl =
    static_cast<
      POA_CORBA::ModuleDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::ModuleDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ModuleDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::ModuleDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::ModuleDef *
POA_CORBA::ModuleDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::ModuleDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ModuleDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_ConstantDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ConstantDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 22,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8,
      WORDLIST_SIZE = 26
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ConstantDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ConstantDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::ConstantDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ConstantDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ConstantDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::ConstantDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ConstantDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ConstantDef::_set_name_skel, 0},
      {"_get_value", &POA_CORBA::ConstantDef::_get_value_skel, 0},
      {"_interface", &POA_CORBA::ConstantDef::_interface_skel, 0},
      {"_set_value", &POA_CORBA::ConstantDef::_set_value_skel, 0},
      {"_get_version", &POA_CORBA::ConstantDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ConstantDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::ConstantDef::_get_def_kind_skel, 0},
      {"_get_defined_in", &POA_CORBA::ConstantDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::ConstantDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ConstantDef::_get_absolute_name_skel, 0},
      {"_get_type_def", &POA_CORBA::ConstantDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::ConstantDef::_set_type_def_skel, 0},
      {"_component", &POA_CORBA::ConstantDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ConstantDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ConstantDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -12,  -3, -15,  -2,   4,   5,  -1,  55,   8,  46, -46,  -1, -46,  17, 
       -1,  18,  -1,  19,  20,  -9,  -3, -21,  -2, -38,  -1,  23,  -6,  -2, 
       24,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  25, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ConstantDef_Perfect_Hash_OpTable tao_CORBA_ConstantDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_ConstantDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_ConstantDef_Strategized_Proxy_Broker::the_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ConstantDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ConstantDef_Strategized_Proxy_Broker::_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_ConstantDef_Strategized_Proxy_Broker::~_TAO_ConstantDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_ConstantDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_ConstantDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_ConstantDef_Strategized_Proxy_Broker::the_TAO_ConstantDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_ConstantDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_ConstantDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ConstantDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_ConstantDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ConstantDef::ConstantDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ConstantDef_optable;
}

POA_CORBA::ConstantDef::ConstantDef (const ConstantDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs)
{
}

POA_CORBA::ConstantDef::~ConstantDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ConstantDef::_get_type_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->type (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ConstantDef::_get_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::ret_arg_type retval =
        get_ret_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->type_def (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::IDLType>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ConstantDef::_set_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_1 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->type_def (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_type_def;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_type_def
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ConstantDef::_get_value_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Any>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->value (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Any>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ConstantDef::_set_value_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Any>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::Any> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->value (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Any>::in_arg_val _tao_value;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_value
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::ConstantDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::ConstantDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::ConstantDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::ConstantDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ConstantDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ConstantDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ConstantDef * const impl =
    static_cast<
      POA_CORBA::ConstantDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::ConstantDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::ConstantDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::ConstantDef *
POA_CORBA::ConstantDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::ConstantDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ConstantDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_StructDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_StructDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StructDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 25,  8,  0, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61,  0, 15,  5,
     61,  0, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 20, 20, 61, 61, 61, 15, 10, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61,
#else
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0, 61, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_StructDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 38,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 8,
      WORDLIST_SIZE = 43
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::StructDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::StructDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::StructDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::StructDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::StructDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::StructDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::StructDef::lookup_name_skel, 0},
      {"_get_id", &POA_CORBA::StructDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::StructDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::StructDef::describe_skel, 0},
      {"_get_version", &POA_CORBA::StructDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::StructDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::StructDef::_get_absolute_name_skel, 0},
      {"move", &POA_CORBA::StructDef::move_skel, 0},
      {"_get_defined_in", &POA_CORBA::StructDef::_get_defined_in_skel, 0},
      {"_get_def_kind", &POA_CORBA::StructDef::_get_def_kind_skel, 0},
      {"destroy", &POA_CORBA::StructDef::destroy_skel, 0},
      {"_component", &POA_CORBA::StructDef::_component_skel, 0},
      {"_get_members", &POA_CORBA::StructDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::StructDef::_set_members_skel, 0},
      {"_non_existent", &POA_CORBA::StructDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::StructDef::_get_containing_repository_skel, 0},
      {"create_value", &POA_CORBA::StructDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::StructDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::StructDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::StructDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::StructDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::StructDef::create_union_skel, 0},
      {"describe_contents", &POA_CORBA::StructDef::describe_contents_skel, 0},
      {"create_exception", &POA_CORBA::StructDef::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::StructDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::StructDef::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::StructDef::create_enum_skel, 0},
      {"contents", &POA_CORBA::StructDef::contents_skel, 0},
      {"create_value_box", &POA_CORBA::StructDef::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::StructDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::StructDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::StructDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -7,  -3,   5,   6, -12,  -2, -66,  10,  11,  -1, -15, 
       -2, -68,  14, -64,  17,  18,  19,  20,  -1,  -1,  -1,  21,  -1,  -1, 
      -23,  -2,  22,  -1, -64,  25, -28,  -2,  26,  27, -64, -30,  -2, -62, 
       32,  -1,  -1,  33,  34,  35,  -1,  -1,  36,  37,  -1,  38,  -1,  -1, 
       39,  40,  41,  -1,  42, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_StructDef_Perfect_Hash_OpTable tao_CORBA_StructDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_StructDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_StructDef_Strategized_Proxy_Broker::the_TAO_StructDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_StructDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_StructDef_Strategized_Proxy_Broker::_TAO_StructDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_StructDef_Strategized_Proxy_Broker::~_TAO_StructDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_StructDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_StructDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_StructDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_StructDef_Strategized_Proxy_Broker::the_TAO_StructDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_StructDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_StructDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_StructDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_StructDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_StructDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_StructDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::StructDef::StructDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_StructDef_optable;
}

POA_CORBA::StructDef::StructDef (const StructDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs)
{
}

POA_CORBA::StructDef::~StructDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::StructDef::_get_members_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::StructMemberSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->members (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::StructMemberSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::StructDef * const impl =
    static_cast<
      POA_CORBA::StructDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::StructDef::_set_members_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::StructMemberSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->members (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::StructMemberSeq>::in_arg_val _tao_members;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::StructDef * const impl =
    static_cast<
      POA_CORBA::StructDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::StructDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::StructDef * const impl =
    static_cast<
      POA_CORBA::StructDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::StructDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::StructDef * const impl =
    static_cast<
      POA_CORBA::StructDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::StructDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::StructDef * const impl =
    static_cast<
      POA_CORBA::StructDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::StructDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StructDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::StructDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::StructDef * const impl =
    static_cast<
      POA_CORBA::StructDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::StructDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/StructDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::StructDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::StructDef *
POA_CORBA::StructDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::StructDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_StructDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_UnionDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_UnionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93,  0,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93,  0,
     93, 25, 55,  0,  0, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93,  0,  0,  5,
     93,  0, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 20, 20, 93, 93, 93, 10,  5, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93,
#else
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
     93, 93, 93, 93, 93,  0, 93,  0, 93, 25,
     55,  0,  0, 93, 93, 93, 93, 93,  0,  0,
      5, 93,  0, 93, 93, 20, 20, 93, 93, 93,
     10,  5, 93, 93, 93, 93, 93, 93,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 41,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 92,
      HASH_VALUE_RANGE = 89,
      DUPLICATES = 9,
      WORDLIST_SIZE = 45
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::UnionDef::move_skel, 0},
      {"_is_a", &POA_CORBA::UnionDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::UnionDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::UnionDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::UnionDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::UnionDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::UnionDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::UnionDef::lookup_name_skel, 0},
      {"_get_version", &POA_CORBA::UnionDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::UnionDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::UnionDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::UnionDef::_get_defined_in_skel, 0},
      {"_get_discriminator_type", &POA_CORBA::UnionDef::_get_discriminator_type_skel, 0},
      {"_get_discriminator_type_def", &POA_CORBA::UnionDef::_get_discriminator_type_def_skel, 0},
      {"_set_discriminator_type_def", &POA_CORBA::UnionDef::_set_discriminator_type_def_skel, 0},
      {"_component", &POA_CORBA::UnionDef::_component_skel, 0},
      {"_get_containing_repository", &POA_CORBA::UnionDef::_get_containing_repository_skel, 0},
      {"_get_members", &POA_CORBA::UnionDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::UnionDef::_set_members_skel, 0},
      {"_non_existent", &POA_CORBA::UnionDef::_non_existent_skel, 0},
      {"create_enum", &POA_CORBA::UnionDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::UnionDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::UnionDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::UnionDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::UnionDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::UnionDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::UnionDef::create_union_skel, 0},
      {"create_exception", &POA_CORBA::UnionDef::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::UnionDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::UnionDef::create_abstract_interface_skel, 0},
      {"create_value_box", &POA_CORBA::UnionDef::create_value_box_skel, 0},
      {"contents", &POA_CORBA::UnionDef::contents_skel, 0},
      {"create_alias", &POA_CORBA::UnionDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::UnionDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::UnionDef::create_constant_skel, 0},
      {"_get_id", &POA_CORBA::UnionDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::UnionDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::UnionDef::describe_skel, 0},
      {"destroy", &POA_CORBA::UnionDef::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::UnionDef::_get_def_kind_skel, 0},
      {"describe_contents", &POA_CORBA::UnionDef::describe_contents_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -94,  10,  11,  -1,  -1, 
       -1, -12,  -2, -94,  14,  -1,  15,  -1,  -1,  16,  -1, -17,  -2, -94, 
      -21,  -2,  19,  20, -96,  23, -26,  -2,  24,  25, -96, -28,  -2, -94, 
       30,  -1,  -1,  -1,  31,  32,  -1,  -1,  33,  34,  -1,  35,  -1, -39, 
       -2,  36,  37,  -1,  38,  -1, -99,  41,  -1,  -1,  -1,  42,  43,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  44, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_UnionDef_Perfect_Hash_OpTable tao_CORBA_UnionDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_UnionDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_UnionDef_Strategized_Proxy_Broker::the_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_UnionDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_UnionDef_Strategized_Proxy_Broker::_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_UnionDef_Strategized_Proxy_Broker::~_TAO_UnionDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_UnionDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_UnionDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_UnionDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_UnionDef_Strategized_Proxy_Broker::the_TAO_UnionDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_UnionDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_UnionDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_UnionDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_UnionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_UnionDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_UnionDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::UnionDef::UnionDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_UnionDef_optable;
}

POA_CORBA::UnionDef::UnionDef (const UnionDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs)
{
}

POA_CORBA::UnionDef::~UnionDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::UnionDef::_get_discriminator_type_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->discriminator_type (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::UnionDef::_get_discriminator_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::ret_arg_type retval =
        get_ret_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->discriminator_type_def (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::IDLType>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::UnionDef::_set_discriminator_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_1 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->discriminator_type_def (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_discriminator_type_def;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_discriminator_type_def
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::UnionDef::_get_members_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::UnionMemberSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::UnionMemberSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->members (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::UnionMemberSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::UnionDef::_set_members_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::UnionMemberSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::UnionMemberSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->members (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::UnionMemberSeq>::in_arg_val _tao_members;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::UnionDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::UnionDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::UnionDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::UnionDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::UnionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::UnionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::UnionDef * const impl =
    static_cast<
      POA_CORBA::UnionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::UnionDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/UnionDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::UnionDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::UnionDef *
POA_CORBA::UnionDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::UnionDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_UnionDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_EnumDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_EnumDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 10, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 10, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 24
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::EnumDef::move_skel, 0},
      {"_is_a", &POA_CORBA::EnumDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::EnumDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::EnumDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::EnumDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::EnumDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::EnumDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::EnumDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::EnumDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::EnumDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::EnumDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::EnumDef::_get_def_kind_skel, 0},
      {"_get_defined_in", &POA_CORBA::EnumDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::EnumDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::EnumDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::EnumDef::_component_skel, 0},
      {"_get_members", &POA_CORBA::EnumDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::EnumDef::_set_members_skel, 0},
      {"_non_existent", &POA_CORBA::EnumDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::EnumDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -13,  -2, -20,  -2,   4,   5,  -1,  55,   8,  51,  12,  -1, -48,  15, 
       -1,  16,  -1,  17,  18,  -1,  19,  -1, -56,  22,  -9,  -3,  -6,  -2, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_EnumDef_Perfect_Hash_OpTable tao_CORBA_EnumDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_EnumDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_EnumDef_Strategized_Proxy_Broker::the_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_EnumDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_EnumDef_Strategized_Proxy_Broker::_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_EnumDef_Strategized_Proxy_Broker::~_TAO_EnumDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_EnumDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_EnumDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_EnumDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_EnumDef_Strategized_Proxy_Broker::the_TAO_EnumDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_EnumDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_EnumDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_EnumDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_EnumDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_EnumDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_EnumDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::EnumDef::EnumDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_EnumDef_optable;
}

POA_CORBA::EnumDef::EnumDef (const EnumDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, TypedefDef) (rhs)
{
}

POA_CORBA::EnumDef::~EnumDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::EnumDef::_get_members_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::EnumMemberSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::EnumMemberSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->members (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::EnumMemberSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::EnumDef * const impl =
    static_cast<
      POA_CORBA::EnumDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::EnumDef::_set_members_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::EnumMemberSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::EnumMemberSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->members (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::EnumMemberSeq>::in_arg_val _tao_members;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::EnumDef * const impl =
    static_cast<
      POA_CORBA::EnumDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::EnumDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::EnumDef * const impl =
    static_cast<
      POA_CORBA::EnumDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::EnumDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::EnumDef * const impl =
    static_cast<
      POA_CORBA::EnumDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::EnumDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::EnumDef * const impl =
    static_cast<
      POA_CORBA::EnumDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::EnumDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::EnumDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::EnumDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::EnumDef * const impl =
    static_cast<
      POA_CORBA::EnumDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::EnumDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/EnumDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::EnumDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::EnumDef *
POA_CORBA::EnumDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::EnumDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_EnumDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_AliasDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AliasDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6,
      WORDLIST_SIZE = 24
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::AliasDef::move_skel, 0},
      {"_is_a", &POA_CORBA::AliasDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::AliasDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::AliasDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::AliasDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::AliasDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::AliasDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::AliasDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::AliasDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::AliasDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::AliasDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::AliasDef::_get_def_kind_skel, 0},
      {"_get_defined_in", &POA_CORBA::AliasDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::AliasDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::AliasDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::AliasDef::_component_skel, 0},
      {"_get_original_type_def", &POA_CORBA::AliasDef::_get_original_type_def_skel, 0},
      {"_set_original_type_def", &POA_CORBA::AliasDef::_set_original_type_def_skel, 0},
      {"_non_existent", &POA_CORBA::AliasDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::AliasDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
      -13,  -2, -20,  -2,   4,   5,  -1,  55,   8,  51,  12,  -1, -48,  15, 
       -1,  16,  -1,  17,  18,  -1,  19,  -1, -56,  22,  -9,  -3,  -6,  -2, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AliasDef_Perfect_Hash_OpTable tao_CORBA_AliasDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_AliasDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_AliasDef_Strategized_Proxy_Broker::the_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_AliasDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_AliasDef_Strategized_Proxy_Broker::_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_AliasDef_Strategized_Proxy_Broker::~_TAO_AliasDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_AliasDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_AliasDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_AliasDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_AliasDef_Strategized_Proxy_Broker::the_TAO_AliasDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_AliasDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_AliasDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_AliasDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_AliasDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_AliasDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_AliasDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::AliasDef::AliasDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AliasDef_optable;
}

POA_CORBA::AliasDef::AliasDef (const AliasDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, TypedefDef) (rhs)
{
}

POA_CORBA::AliasDef::~AliasDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::AliasDef::_get_original_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::ret_arg_type retval =
        get_ret_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->original_type_def (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::IDLType>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AliasDef * const impl =
    static_cast<
      POA_CORBA::AliasDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::AliasDef::_set_original_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_1 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->original_type_def (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_original_type_def;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_original_type_def
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::AliasDef * const impl =
    static_cast<
      POA_CORBA::AliasDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::AliasDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::AliasDef * const impl =
    static_cast<
      POA_CORBA::AliasDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::AliasDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AliasDef * const impl =
    static_cast<
      POA_CORBA::AliasDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::AliasDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::AliasDef * const impl =
    static_cast<
      POA_CORBA::AliasDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::AliasDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AliasDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AliasDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AliasDef * const impl =
    static_cast<
      POA_CORBA::AliasDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::AliasDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AliasDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::AliasDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::AliasDef *
POA_CORBA::AliasDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::AliasDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_AliasDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_NativeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_NativeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_NativeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_NativeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5,
      WORDLIST_SIZE = 22
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::NativeDef::move_skel, 0},
      {"_is_a", &POA_CORBA::NativeDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::NativeDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::NativeDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::NativeDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::NativeDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::NativeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::NativeDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::NativeDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::NativeDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::NativeDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::NativeDef::_get_def_kind_skel, 0},
      {"_get_defined_in", &POA_CORBA::NativeDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::NativeDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::NativeDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::NativeDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::NativeDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::NativeDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
       -9,  -3, -13,  -2,   4,   5,  -1,  50,   8, -45,  12,  -1, -46,  15, 
       -1,  16,  -1,  17,  18,  -1,  19,  -6,  -2,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_NativeDef_Perfect_Hash_OpTable tao_CORBA_NativeDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_NativeDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_NativeDef_Strategized_Proxy_Broker::the_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_NativeDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_NativeDef_Strategized_Proxy_Broker::_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_NativeDef_Strategized_Proxy_Broker::~_TAO_NativeDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_NativeDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_NativeDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_NativeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_NativeDef_Strategized_Proxy_Broker::the_TAO_NativeDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_NativeDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_NativeDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_NativeDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_NativeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_NativeDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_NativeDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::NativeDef::NativeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_NativeDef_optable;
}

POA_CORBA::NativeDef::NativeDef (const NativeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, TypedefDef) (rhs)
{
}

POA_CORBA::NativeDef::~NativeDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::NativeDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::NativeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::NativeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::NativeDef * const impl =
    static_cast<
      POA_CORBA::NativeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::NativeDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::NativeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::NativeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::NativeDef * const impl =
    static_cast<
      POA_CORBA::NativeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::NativeDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::NativeDef * const impl =
    static_cast<
      POA_CORBA::NativeDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::NativeDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::NativeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::NativeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::NativeDef * const impl =
    static_cast<
      POA_CORBA::NativeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::NativeDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/NativeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/NativeDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::NativeDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::NativeDef *
POA_CORBA::NativeDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::NativeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_NativeDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  2, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  2, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 8,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0,
      WORDLIST_SIZE = 13
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::PrimitiveDef::_is_a_skel, 0},
      {"",0,0},
      {"destroy", &POA_CORBA::PrimitiveDef::destroy_skel, 0},
      {"",0,0},
      {"_get_kind", &POA_CORBA::PrimitiveDef::_get_kind_skel, 0},
      {"",0,0},
      {"_get_type", &POA_CORBA::PrimitiveDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::PrimitiveDef::_interface_skel, 0},
      {"_get_def_kind", &POA_CORBA::PrimitiveDef::_get_def_kind_skel, 0},
      {"",0,0},
      {"_component", &POA_CORBA::PrimitiveDef::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBA::PrimitiveDef::_non_existent_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable tao_CORBA_PrimitiveDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_PrimitiveDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_PrimitiveDef_Strategized_Proxy_Broker::the_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_PrimitiveDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_PrimitiveDef_Strategized_Proxy_Broker::_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_PrimitiveDef_Strategized_Proxy_Broker::~_TAO_PrimitiveDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_PrimitiveDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_PrimitiveDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_PrimitiveDef_Strategized_Proxy_Broker::the_TAO_PrimitiveDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_PrimitiveDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::PrimitiveDef::PrimitiveDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_PrimitiveDef_optable;
}

POA_CORBA::PrimitiveDef::PrimitiveDef (const PrimitiveDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs)
{
}

POA_CORBA::PrimitiveDef::~PrimitiveDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::PrimitiveDef::_get_kind_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::PrimitiveKind>::ret_arg_type retval =
        get_ret_arg< CORBA::PrimitiveKind> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->kind (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::PrimitiveKind>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::PrimitiveDef * const impl =
    static_cast<
      POA_CORBA::PrimitiveDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::PrimitiveDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::PrimitiveDef * const impl =
    static_cast<
      POA_CORBA::PrimitiveDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::PrimitiveDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::PrimitiveDef * const impl =
    static_cast<
      POA_CORBA::PrimitiveDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::PrimitiveDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::PrimitiveDef * const impl =
    static_cast<
      POA_CORBA::PrimitiveDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::PrimitiveDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::PrimitiveDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::PrimitiveDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::PrimitiveDef * const impl =
    static_cast<
      POA_CORBA::PrimitiveDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::PrimitiveDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/PrimitiveDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::PrimitiveDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::PrimitiveDef *
POA_CORBA::PrimitiveDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::PrimitiveDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_StringDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_StringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  2, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  2, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_StringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2,
      WORDLIST_SIZE = 14
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::StringDef::_is_a_skel, 0},
      {"destroy", &POA_CORBA::StringDef::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::StringDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::StringDef::_set_bound_skel, 0},
      {"_get_type", &POA_CORBA::StringDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::StringDef::_interface_skel, 0},
      {"_get_def_kind", &POA_CORBA::StringDef::_get_def_kind_skel, 0},
      {"_component", &POA_CORBA::StringDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::StringDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -20,   9,  10,  11, 
       -1,  12,  -1,  -1,  13, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_StringDef_Perfect_Hash_OpTable tao_CORBA_StringDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_StringDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_StringDef_Strategized_Proxy_Broker::the_TAO_StringDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_StringDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_StringDef_Strategized_Proxy_Broker::_TAO_StringDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_StringDef_Strategized_Proxy_Broker::~_TAO_StringDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_StringDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_StringDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_StringDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_StringDef_Strategized_Proxy_Broker::the_TAO_StringDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_StringDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_StringDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_StringDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_StringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_StringDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_StringDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::StringDef::StringDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_StringDef_optable;
}

POA_CORBA::StringDef::StringDef (const StringDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs)
{
}

POA_CORBA::StringDef::~StringDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::StringDef::_get_bound_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->bound (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::StringDef * const impl =
    static_cast<
      POA_CORBA::StringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::StringDef::_set_bound_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->bound (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::StringDef * const impl =
    static_cast<
      POA_CORBA::StringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::StringDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::StringDef * const impl =
    static_cast<
      POA_CORBA::StringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::StringDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::StringDef * const impl =
    static_cast<
      POA_CORBA::StringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::StringDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::StringDef * const impl =
    static_cast<
      POA_CORBA::StringDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::StringDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::StringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::StringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::StringDef * const impl =
    static_cast<
      POA_CORBA::StringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::StringDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/StringDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::StringDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::StringDef *
POA_CORBA::StringDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::StringDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_StringDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_WstringDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_WstringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  2, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  2, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2,
      WORDLIST_SIZE = 14
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::WstringDef::_is_a_skel, 0},
      {"destroy", &POA_CORBA::WstringDef::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::WstringDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::WstringDef::_set_bound_skel, 0},
      {"_get_type", &POA_CORBA::WstringDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::WstringDef::_interface_skel, 0},
      {"_get_def_kind", &POA_CORBA::WstringDef::_get_def_kind_skel, 0},
      {"_component", &POA_CORBA::WstringDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::WstringDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -20,   9,  10,  11, 
       -1,  12,  -1,  -1,  13, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_WstringDef_Perfect_Hash_OpTable tao_CORBA_WstringDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_WstringDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_WstringDef_Strategized_Proxy_Broker::the_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_WstringDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_WstringDef_Strategized_Proxy_Broker::_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_WstringDef_Strategized_Proxy_Broker::~_TAO_WstringDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_WstringDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_WstringDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_WstringDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_WstringDef_Strategized_Proxy_Broker::the_TAO_WstringDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_WstringDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_WstringDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_WstringDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_WstringDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_WstringDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_WstringDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::WstringDef::WstringDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_WstringDef_optable;
}

POA_CORBA::WstringDef::WstringDef (const WstringDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs)
{
}

POA_CORBA::WstringDef::~WstringDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::WstringDef::_get_bound_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->bound (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::WstringDef * const impl =
    static_cast<
      POA_CORBA::WstringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::WstringDef::_set_bound_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->bound (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::WstringDef * const impl =
    static_cast<
      POA_CORBA::WstringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::WstringDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::WstringDef * const impl =
    static_cast<
      POA_CORBA::WstringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::WstringDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::WstringDef * const impl =
    static_cast<
      POA_CORBA::WstringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::WstringDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::WstringDef * const impl =
    static_cast<
      POA_CORBA::WstringDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::WstringDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::WstringDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::WstringDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::WstringDef * const impl =
    static_cast<
      POA_CORBA::WstringDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::WstringDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/WstringDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::WstringDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::WstringDef *
POA_CORBA::WstringDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::WstringDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_WstringDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_SequenceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_SequenceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24,  0,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24,  0,
     24, 24,  0,  5,  0, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 10, 24, 24, 24, 24,  0, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24,
#else
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24,  0, 24,  0, 24, 24,
      0,  5,  0, 24, 24, 24, 24, 24, 24, 24,
     24, 24, 24, 24, 24, 24, 10, 24, 24, 24,
     24,  0, 24, 24, 24, 24, 24, 24,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 12,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 23,
      HASH_VALUE_RANGE = 19,
      DUPLICATES = 3,
      WORDLIST_SIZE = 17
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::SequenceDef::_is_a_skel, 0},
      {"destroy", &POA_CORBA::SequenceDef::destroy_skel, 0},
      {"_get_bound", &POA_CORBA::SequenceDef::_get_bound_skel, 0},
      {"_set_bound", &POA_CORBA::SequenceDef::_set_bound_skel, 0},
      {"_get_def_kind", &POA_CORBA::SequenceDef::_get_def_kind_skel, 0},
      {"_get_type", &POA_CORBA::SequenceDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::SequenceDef::_interface_skel, 0},
      {"_component", &POA_CORBA::SequenceDef::_component_skel, 0},
      {"_get_element_type_def", &POA_CORBA::SequenceDef::_get_element_type_def_skel, 0},
      {"_set_element_type_def", &POA_CORBA::SequenceDef::_set_element_type_def_skel, 0},
      {"_get_element_type", &POA_CORBA::SequenceDef::_get_element_type_skel, 0},
      {"_non_existent", &POA_CORBA::SequenceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -7,  -2, -25,  -1,  -1,   9, 
       10,  11,  -1,  -1, -13,  -2,  12, -26,  15,  16, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_SequenceDef_Perfect_Hash_OpTable tao_CORBA_SequenceDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_SequenceDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_SequenceDef_Strategized_Proxy_Broker::the_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_SequenceDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_SequenceDef_Strategized_Proxy_Broker::_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_SequenceDef_Strategized_Proxy_Broker::~_TAO_SequenceDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_SequenceDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_SequenceDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_SequenceDef_Strategized_Proxy_Broker::the_TAO_SequenceDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_SequenceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_SequenceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_SequenceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_SequenceDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::SequenceDef::SequenceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_SequenceDef_optable;
}

POA_CORBA::SequenceDef::SequenceDef (const SequenceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs)
{
}

POA_CORBA::SequenceDef::~SequenceDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::SequenceDef::_get_bound_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->bound (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::SequenceDef::_set_bound_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->bound (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_bound;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_bound
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::SequenceDef::_get_element_type_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->element_type (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::SequenceDef::_get_element_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::ret_arg_type retval =
        get_ret_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->element_type_def (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::IDLType>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::SequenceDef::_set_element_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_1 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->element_type_def (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_element_type_def;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_element_type_def
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::SequenceDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::SequenceDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::SequenceDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::SequenceDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::SequenceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::SequenceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::SequenceDef * const impl =
    static_cast<
      POA_CORBA::SequenceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::SequenceDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::SequenceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::SequenceDef *
POA_CORBA::SequenceDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::SequenceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_SequenceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_ArrayDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ArrayDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 12,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3,
      WORDLIST_SIZE = 17
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::ArrayDef::_is_a_skel, 0},
      {"destroy", &POA_CORBA::ArrayDef::destroy_skel, 0},
      {"_get_type", &POA_CORBA::ArrayDef::_get_type_skel, 0},
      {"_interface", &POA_CORBA::ArrayDef::_interface_skel, 0},
      {"_get_length", &POA_CORBA::ArrayDef::_get_length_skel, 0},
      {"_set_length", &POA_CORBA::ArrayDef::_set_length_skel, 0},
      {"_get_def_kind", &POA_CORBA::ArrayDef::_get_def_kind_skel, 0},
      {"_component", &POA_CORBA::ArrayDef::_component_skel, 0},
      {"_get_element_type", &POA_CORBA::ArrayDef::_get_element_type_skel, 0},
      {"_non_existent", &POA_CORBA::ArrayDef::_non_existent_skel, 0},
      {"_get_element_type_def", &POA_CORBA::ArrayDef::_get_element_type_def_skel, 0},
      {"_set_element_type_def", &POA_CORBA::ArrayDef::_set_element_type_def_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -9,  -2,   5,  -1,   6,  -1,   7,   8, -29,  -1,  11, 
       -1,  12,  -1,  13,  14, -15,  -2, -23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ArrayDef_Perfect_Hash_OpTable tao_CORBA_ArrayDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_ArrayDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_ArrayDef_Strategized_Proxy_Broker::the_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ArrayDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ArrayDef_Strategized_Proxy_Broker::_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_ArrayDef_Strategized_Proxy_Broker::~_TAO_ArrayDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_ArrayDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_ArrayDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_ArrayDef_Strategized_Proxy_Broker::the_TAO_ArrayDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_ArrayDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_ArrayDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ArrayDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_ArrayDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ArrayDef::ArrayDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ArrayDef_optable;
}

POA_CORBA::ArrayDef::ArrayDef (const ArrayDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs)
{
}

POA_CORBA::ArrayDef::~ArrayDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ArrayDef::_get_length_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::ret_arg_type retval =
        get_ret_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->length (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::ULong>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ArrayDef::_set_length_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::ULong>::in_arg_type arg_1 =
        get_in_arg< ::CORBA::ULong> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->length (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::ULong>::in_arg_val _tao_length;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_length
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ArrayDef::_get_element_type_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->element_type (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ArrayDef::_get_element_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::ret_arg_type retval =
        get_ret_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->element_type_def (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::IDLType>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ArrayDef::_set_element_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_1 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->element_type_def (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_element_type_def;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_element_type_def
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::ArrayDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::ArrayDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::ArrayDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::ArrayDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ArrayDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ArrayDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ArrayDef * const impl =
    static_cast<
      POA_CORBA::ArrayDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::ArrayDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::ArrayDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::ArrayDef *
POA_CORBA::ArrayDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::ArrayDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ArrayDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 25,  8,  0, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61,  0, 15,  5,
     61,  0, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 20, 20, 61, 61, 61, 15, 10, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61,
#else
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 25,
      8,  0, 61, 61, 61, 61, 61, 61,  0, 15,
      5, 61,  0, 61, 61, 20, 20, 61, 61, 61,
     15, 10, 61, 61, 61, 61, 61, 61,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 38,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 8,
      WORDLIST_SIZE = 43
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::ExceptionDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ExceptionDef::lookup_skel, 0},
      {"_get_name", &POA_CORBA::ExceptionDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExceptionDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExceptionDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExceptionDef::_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ExceptionDef::lookup_name_skel, 0},
      {"_get_id", &POA_CORBA::ExceptionDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExceptionDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ExceptionDef::describe_skel, 0},
      {"_get_version", &POA_CORBA::ExceptionDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExceptionDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExceptionDef::_get_absolute_name_skel, 0},
      {"move", &POA_CORBA::ExceptionDef::move_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExceptionDef::_get_defined_in_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExceptionDef::_get_def_kind_skel, 0},
      {"destroy", &POA_CORBA::ExceptionDef::destroy_skel, 0},
      {"_component", &POA_CORBA::ExceptionDef::_component_skel, 0},
      {"_get_members", &POA_CORBA::ExceptionDef::_get_members_skel, 0},
      {"_set_members", &POA_CORBA::ExceptionDef::_set_members_skel, 0},
      {"_non_existent", &POA_CORBA::ExceptionDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExceptionDef::_get_containing_repository_skel, 0},
      {"create_value", &POA_CORBA::ExceptionDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ExceptionDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ExceptionDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ExceptionDef::create_interface_skel, 0},
      {"create_ext_value", &POA_CORBA::ExceptionDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ExceptionDef::create_union_skel, 0},
      {"describe_contents", &POA_CORBA::ExceptionDef::describe_contents_skel, 0},
      {"create_exception", &POA_CORBA::ExceptionDef::create_exception_skel, 0},
      {"create_local_interface", &POA_CORBA::ExceptionDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ExceptionDef::create_abstract_interface_skel, 0},
      {"create_enum", &POA_CORBA::ExceptionDef::create_enum_skel, 0},
      {"contents", &POA_CORBA::ExceptionDef::contents_skel, 0},
      {"create_value_box", &POA_CORBA::ExceptionDef::create_value_box_skel, 0},
      {"create_alias", &POA_CORBA::ExceptionDef::create_alias_skel, 0},
      {"create_struct", &POA_CORBA::ExceptionDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ExceptionDef::create_constant_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -7,  -3,   5,   6, -12,  -2, -66,  10,  11,  -1, -15, 
       -2, -68,  14, -64,  17,  18,  19,  20,  -1,  -1,  -1,  21,  -1,  -1, 
      -23,  -2,  22,  -1, -64,  25, -28,  -2,  26,  27, -64, -30,  -2, -62, 
       32,  -1,  -1,  33,  34,  35,  -1,  -1,  36,  37,  -1,  38,  -1,  -1, 
       39,  40,  41,  -1,  42, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable tao_CORBA_ExceptionDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_ExceptionDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_ExceptionDef_Strategized_Proxy_Broker::the_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ExceptionDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ExceptionDef_Strategized_Proxy_Broker::_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_ExceptionDef_Strategized_Proxy_Broker::~_TAO_ExceptionDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_ExceptionDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_ExceptionDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_ExceptionDef_Strategized_Proxy_Broker::the_TAO_ExceptionDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_ExceptionDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExceptionDef::ExceptionDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExceptionDef_optable;
}

POA_CORBA::ExceptionDef::ExceptionDef (const ExceptionDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs)
{
}

POA_CORBA::ExceptionDef::~ExceptionDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ExceptionDef::_get_type_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->type (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExceptionDef * const impl =
    static_cast<
      POA_CORBA::ExceptionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ExceptionDef::_get_members_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::StructMemberSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->members (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::StructMemberSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExceptionDef * const impl =
    static_cast<
      POA_CORBA::ExceptionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ExceptionDef::_set_members_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::StructMemberSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::StructMemberSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->members (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::StructMemberSeq>::in_arg_val _tao_members;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_members
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ExceptionDef * const impl =
    static_cast<
      POA_CORBA::ExceptionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::ExceptionDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ExceptionDef * const impl =
    static_cast<
      POA_CORBA::ExceptionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::ExceptionDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExceptionDef * const impl =
    static_cast<
      POA_CORBA::ExceptionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::ExceptionDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::ExceptionDef * const impl =
    static_cast<
      POA_CORBA::ExceptionDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::ExceptionDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExceptionDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExceptionDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExceptionDef * const impl =
    static_cast<
      POA_CORBA::ExceptionDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::ExceptionDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::ExceptionDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::ExceptionDef *
POA_CORBA::ExceptionDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::ExceptionDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_AttributeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 15, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 15, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 22,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8,
      WORDLIST_SIZE = 26
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::AttributeDef::move_skel, 0},
      {"_is_a", &POA_CORBA::AttributeDef::_is_a_skel, 0},
      {"_get_id", &POA_CORBA::AttributeDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::AttributeDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::AttributeDef::describe_skel, 0},
      {"_get_name", &POA_CORBA::AttributeDef::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::AttributeDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::AttributeDef::_get_mode_skel, 0},
      {"_get_type", &POA_CORBA::AttributeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::AttributeDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::AttributeDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::AttributeDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::AttributeDef::_set_version_skel, 0},
      {"_get_def_kind", &POA_CORBA::AttributeDef::_get_def_kind_skel, 0},
      {"_get_defined_in", &POA_CORBA::AttributeDef::_get_defined_in_skel, 0},
      {"destroy", &POA_CORBA::AttributeDef::destroy_skel, 0},
      {"_get_absolute_name", &POA_CORBA::AttributeDef::_get_absolute_name_skel, 0},
      {"_component", &POA_CORBA::AttributeDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::AttributeDef::_non_existent_skel, 0},
      {"_get_type_def", &POA_CORBA::AttributeDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::AttributeDef::_set_type_def_skel, 0},
      {"_get_containing_repository", &POA_CORBA::AttributeDef::_get_containing_repository_skel, 0},
    };

  static const signed char lookup[] =
    {
       -9,  -5, -15,  -2,   4,   5,  -1,  50,   8, -45,  14,  -1, -46,  17, 
       -1,  18,  -1,  19,  20,  -1,  21,  -6,  -2,  22,  -1,  -1, -23,  -2, 
      -38,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  25, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AttributeDef_Perfect_Hash_OpTable tao_CORBA_AttributeDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_AttributeDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_AttributeDef_Strategized_Proxy_Broker::the_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_AttributeDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_AttributeDef_Strategized_Proxy_Broker::_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_AttributeDef_Strategized_Proxy_Broker::~_TAO_AttributeDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_AttributeDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_AttributeDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_AttributeDef_Strategized_Proxy_Broker::the_TAO_AttributeDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_AttributeDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_AttributeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_AttributeDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_AttributeDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::AttributeDef::AttributeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AttributeDef_optable;
}

POA_CORBA::AttributeDef::AttributeDef (const AttributeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs)
{
}

POA_CORBA::AttributeDef::~AttributeDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::AttributeDef::_get_type_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->type (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::AttributeDef::_get_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::ret_arg_type retval =
        get_ret_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->type_def (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::IDLType>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::AttributeDef::_set_type_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_1 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->type_def (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_type_def;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_type_def
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::AttributeDef::_get_mode_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::AttributeMode>::ret_arg_type retval =
        get_ret_arg< CORBA::AttributeMode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->mode (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::AttributeMode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::AttributeDef::_set_mode_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::AttributeMode>::in_arg_type arg_1 =
        get_in_arg< CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->mode (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::AttributeMode>::in_arg_val _tao_mode;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_mode
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::AttributeDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::AttributeDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::AttributeDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::AttributeDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AttributeDef * const impl =
    static_cast<
      POA_CORBA::AttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::AttributeDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::AttributeDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::AttributeDef *
POA_CORBA::AttributeDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::AttributeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_AttributeDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39,  0,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39,  0,
     39, 39, 15,  0,  0, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39,  0,  0,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39,  0, 25, 39, 39, 39, 39,  5, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39,
#else
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39,  0, 39,  0, 39, 39,
     15,  0,  0, 39, 39, 39, 39, 39, 39,  0,
      0, 39, 39, 39, 39,  0, 25, 39, 39, 39,
     39,  5, 39, 39, 39, 39, 39, 39,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 27,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 38,
      HASH_VALUE_RANGE = 35,
      DUPLICATES = 11,
      WORDLIST_SIZE = 31
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ExtAttributeDef::move_skel, 0},
      {"_is_a", &POA_CORBA::ExtAttributeDef::_is_a_skel, 0},
      {"_get_name", &POA_CORBA::ExtAttributeDef::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::ExtAttributeDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::ExtAttributeDef::_get_mode_skel, 0},
      {"_get_type", &POA_CORBA::ExtAttributeDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExtAttributeDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExtAttributeDef::_interface_skel, 0},
      {"_get_version", &POA_CORBA::ExtAttributeDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExtAttributeDef::_set_version_skel, 0},
      {"_get_type_def", &POA_CORBA::ExtAttributeDef::_get_type_def_skel, 0},
      {"_set_type_def", &POA_CORBA::ExtAttributeDef::_set_type_def_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExtAttributeDef::_get_defined_in_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExtAttributeDef::_get_absolute_name_skel, 0},
      {"_get_get_exceptions", &POA_CORBA::ExtAttributeDef::_get_get_exceptions_skel, 0},
      {"_set_set_exceptions", &POA_CORBA::ExtAttributeDef::_set_set_exceptions_skel, 0},
      {"_get_set_exceptions", &POA_CORBA::ExtAttributeDef::_get_set_exceptions_skel, 0},
      {"_set_get_exceptions", &POA_CORBA::ExtAttributeDef::_set_get_exceptions_skel, 0},
      {"_get_id", &POA_CORBA::ExtAttributeDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExtAttributeDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::ExtAttributeDef::describe_skel, 0},
      {"destroy", &POA_CORBA::ExtAttributeDef::destroy_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExtAttributeDef::_get_def_kind_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExtAttributeDef::_get_containing_repository_skel, 0},
      {"describe_attribute", &POA_CORBA::ExtAttributeDef::describe_attribute_skel, 0},
      {"_component", &POA_CORBA::ExtAttributeDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ExtAttributeDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -6,  -5, -12,  -2,   4,   5,  -1, -14,  -2, -47,  11,  -1, -48, -44, 
       -1,  16, -18,  -4,  17, -41, -22,  -2, -40,  24,  -1,  -1,  -1,  25, 
       26,  -1,  -1,  27,  -1,  28,  -1,  29,  -1,  -1,  30, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtAttributeDef_Perfect_Hash_OpTable tao_CORBA_ExtAttributeDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_ExtAttributeDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_ExtAttributeDef_Strategized_Proxy_Broker::the_TAO_ExtAttributeDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ExtAttributeDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ExtAttributeDef_Strategized_Proxy_Broker::_TAO_ExtAttributeDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_ExtAttributeDef_Strategized_Proxy_Broker::~_TAO_ExtAttributeDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_ExtAttributeDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_ExtAttributeDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_ExtAttributeDef_Strategized_Proxy_Broker::the_TAO_ExtAttributeDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_ExtAttributeDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExtAttributeDef::ExtAttributeDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtAttributeDef_optable;
}

POA_CORBA::ExtAttributeDef::ExtAttributeDef (const ExtAttributeDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, AttributeDef) (rhs)
{
}

POA_CORBA::ExtAttributeDef::~ExtAttributeDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ExtAttributeDef::_get_get_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ExcDescriptionSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->get_exceptions (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::ExcDescriptionSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ExtAttributeDef::_set_get_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ExcDescriptionSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->get_exceptions (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::ExcDescriptionSeq>::in_arg_val _tao_get_exceptions;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_get_exceptions
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ExtAttributeDef::_get_set_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ExcDescriptionSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->set_exceptions (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::ExcDescriptionSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ExtAttributeDef::_set_set_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ExcDescriptionSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::ExcDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->set_exceptions (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::ExcDescriptionSeq>::in_arg_val _tao_set_exceptions;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_set_exceptions
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::ExtAttributeDef::describe_attribute_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ExtAttributeDescription>::ret_arg_type retval =
        get_ret_arg< CORBA::ExtAttributeDescription> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->describe_attribute (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::ExtAttributeDescription>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::ExtAttributeDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::ExtAttributeDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::ExtAttributeDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::ExtAttributeDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAttributeDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAttributeDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtAttributeDef * const impl =
    static_cast<
      POA_CORBA::ExtAttributeDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::ExtAttributeDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtAttributeDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtAttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtAttributeDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::ExtAttributeDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::ExtAttributeDef *
POA_CORBA::ExtAttributeDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::ExtAttributeDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExtAttributeDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_OperationDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_OperationDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 28,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10,
      WORDLIST_SIZE = 32
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::OperationDef::move_skel, 0},
      {"_is_a", &POA_CORBA::OperationDef::_is_a_skel, 0},
      {"_get_name", &POA_CORBA::OperationDef::_get_name_skel, 0},
      {"_set_mode", &POA_CORBA::OperationDef::_set_mode_skel, 0},
      {"_get_mode", &POA_CORBA::OperationDef::_get_mode_skel, 0},
      {"_set_name", &POA_CORBA::OperationDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::OperationDef::_interface_skel, 0},
      {"_get_params", &POA_CORBA::OperationDef::_get_params_skel, 0},
      {"_set_params", &POA_CORBA::OperationDef::_set_params_skel, 0},
      {"_get_contexts", &POA_CORBA::OperationDef::_get_contexts_skel, 0},
      {"_set_contexts", &POA_CORBA::OperationDef::_set_contexts_skel, 0},
      {"_get_exceptions", &POA_CORBA::OperationDef::_get_exceptions_skel, 0},
      {"_set_exceptions", &POA_CORBA::OperationDef::_set_exceptions_skel, 0},
      {"_get_version", &POA_CORBA::OperationDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::OperationDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::OperationDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::OperationDef::_get_defined_in_skel, 0},
      {"_get_id", &POA_CORBA::OperationDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::OperationDef::_set_id_skel, 0},
      {"describe", &POA_CORBA::OperationDef::describe_skel, 0},
      {"_get_result_def", &POA_CORBA::OperationDef::_get_result_def_skel, 0},
      {"_set_result_def", &POA_CORBA::OperationDef::_set_result_def_skel, 0},
      {"_get_def_kind", &POA_CORBA::OperationDef::_get_def_kind_skel, 0},
      {"_component", &POA_CORBA::OperationDef::_component_skel, 0},
      {"_get_result", &POA_CORBA::OperationDef::_get_result_skel, 0},
      {"destroy", &POA_CORBA::OperationDef::destroy_skel, 0},
      {"_non_existent", &POA_CORBA::OperationDef::_non_existent_skel, 0},
      {"_get_containing_repository", &POA_CORBA::OperationDef::_get_containing_repository_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const struct TAO_operation_db_entry   *resword; 

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  10:
                  resword = &wordlist[10]; break;
                case  11:
                  resword = &wordlist[11];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[12];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[13];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[14];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[15];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[16];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[17];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[18];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[19]; break;
                case  20:
                  resword = &wordlist[20]; break;
                case  22:
                  resword = &wordlist[21];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[22];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[23]; break;
                case  25:
                  resword = &wordlist[24];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  resword = &wordlist[25];
                  if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[26]; break;
                case  30:
                  resword = &wordlist[27]; break;
                case  31:
                  resword = &wordlist[28]; break;
                case  32:
                  resword = &wordlist[29]; break;
                case  33:
                  resword = &wordlist[30]; break;
                case  36:
                  resword = &wordlist[31]; break;
                default: return 0;
                }
              if (*str == *resword->opname && !strncmp (str + 1, resword->opname + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}

static TAO_CORBA_OperationDef_Perfect_Hash_OpTable tao_CORBA_OperationDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_OperationDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_OperationDef_Strategized_Proxy_Broker::the_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_OperationDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_OperationDef_Strategized_Proxy_Broker::_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_OperationDef_Strategized_Proxy_Broker::~_TAO_OperationDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_OperationDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_OperationDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_OperationDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_OperationDef_Strategized_Proxy_Broker::the_TAO_OperationDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_OperationDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_OperationDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_OperationDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_OperationDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_OperationDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_OperationDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::OperationDef::OperationDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_OperationDef_optable;
}

POA_CORBA::OperationDef::OperationDef (const OperationDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs)
{
}

POA_CORBA::OperationDef::~OperationDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_get_result_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::TypeCode>::ret_arg_type retval =
        get_ret_arg< ::CORBA::TypeCode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->result (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::TypeCode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_get_result_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::ret_arg_type retval =
        get_ret_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->result_def (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::IDLType>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_set_result_def_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_1 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->result_def (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_result_def;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_result_def
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_get_params_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ParDescriptionSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->params (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::ParDescriptionSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_set_params_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ParDescriptionSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->params (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::ParDescriptionSeq>::in_arg_val _tao_params;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_params
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_get_mode_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::OperationMode>::ret_arg_type retval =
        get_ret_arg< CORBA::OperationMode> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->mode (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::OperationMode>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_set_mode_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::OperationMode>::in_arg_type arg_1 =
        get_in_arg< CORBA::OperationMode> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->mode (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::OperationMode>::in_arg_val _tao_mode;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_mode
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_get_contexts_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ContextIdSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->contexts (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::ContextIdSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_set_contexts_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ContextIdSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->contexts (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::ContextIdSeq>::in_arg_val _tao_contexts;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_contexts
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_get_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ExceptionDefSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->exceptions (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::ExceptionDefSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::OperationDef::_set_exceptions_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ExceptionDefSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->exceptions (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::ExceptionDefSeq>::in_arg_val _tao_exceptions;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_exceptions
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::OperationDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::OperationDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::OperationDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::OperationDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::OperationDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::OperationDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::OperationDef * const impl =
    static_cast<
      POA_CORBA::OperationDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::OperationDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/OperationDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::OperationDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::OperationDef *
POA_CORBA::OperationDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::OperationDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_OperationDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 25,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79,  0,
     79,  0, 20,  0, 79, 79, 79,  5, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 15,  0,  5,
     79, 15, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 25, 40, 79, 79, 79, 15,  0, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79,
#else
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 25, 79,  0, 79,  0,
     20,  0, 79, 79, 79,  5, 79, 79, 15,  0,
      5, 79, 15, 79, 79, 25, 40, 79, 79, 79,
     15,  0, 79, 79, 79, 79, 79, 79,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 42,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 78,
      HASH_VALUE_RANGE = 75,
      DUPLICATES = 10,
      WORDLIST_SIZE = 46
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::InterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::InterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::InterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::InterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::InterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::InterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::InterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::InterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::InterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::InterfaceDef::create_union_skel, 0},
      {"create_exception", &POA_CORBA::InterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::InterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::InterfaceDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::InterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::InterfaceDef::lookup_name_skel, 0},
      {"destroy", &POA_CORBA::InterfaceDef::destroy_skel, 0},
      {"describe", &POA_CORBA::InterfaceDef::describe_skel, 0},
      {"_is_a", &POA_CORBA::InterfaceDef::_is_a_skel, 0},
      {"create_value_box", &POA_CORBA::InterfaceDef::create_value_box_skel, 0},
      {"contents", &POA_CORBA::InterfaceDef::contents_skel, 0},
      {"_get_name", &POA_CORBA::InterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::InterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::InterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::InterfaceDef::_interface_skel, 0},
      {"lookup", &POA_CORBA::InterfaceDef::lookup_skel, 0},
      {"create_alias", &POA_CORBA::InterfaceDef::create_alias_skel, 0},
      {"describe_interface", &POA_CORBA::InterfaceDef::describe_interface_skel, 0},
      {"_get_version", &POA_CORBA::InterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::InterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::InterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::InterfaceDef::_get_defined_in_skel, 0},
      {"_get_containing_repository", &POA_CORBA::InterfaceDef::_get_containing_repository_skel, 0},
      {"_get_id", &POA_CORBA::InterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::InterfaceDef::_set_id_skel, 0},
      {"create_struct", &POA_CORBA::InterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::InterfaceDef::create_constant_skel, 0},
      {"_get_def_kind", &POA_CORBA::InterfaceDef::_get_def_kind_skel, 0},
      {"describe_contents", &POA_CORBA::InterfaceDef::describe_contents_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::InterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::InterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::InterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::InterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -84, 
      -10,  -3, -80,  13,  -1, -14,  -2, -80,  16, -24,  -3,  17,  18,  19, 
       20,  -1,  21,  22,  -1,  23, -89,  27,  28,  29,  30,  -1, -31,  -2, 
      -80,  33,  -1,  34,  -1,  -1,  -1, -36,  -2,  35, -81,  38,  -1,  39, 
       -1,  -1,  40,  -1,  -1,  -1,  41,  -1,  -1,  -1,  -1,  -1, -42,  -2, 
      -80,  -1,  -1,  -1,  -1,  44,  -1,  -1,  45, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable tao_CORBA_InterfaceDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_InterfaceDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_InterfaceDef_Strategized_Proxy_Broker::the_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_InterfaceDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_InterfaceDef_Strategized_Proxy_Broker::_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_InterfaceDef_Strategized_Proxy_Broker::~_TAO_InterfaceDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_InterfaceDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_InterfaceDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_InterfaceDef_Strategized_Proxy_Broker::the_TAO_InterfaceDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_InterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::InterfaceDef::InterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_InterfaceDef_optable;
}

POA_CORBA::InterfaceDef::InterfaceDef (const InterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs)
{
}

POA_CORBA::InterfaceDef::~InterfaceDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::InterfaceDef::_get_base_interfaces_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::InterfaceDefSeq>::ret_arg_type retval =
        get_ret_arg< CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->base_interfaces (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::InterfaceDefSeq>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::InterfaceDef::_set_base_interfaces_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::InterfaceDefSeq>::in_arg_type arg_1 =
        get_in_arg< CORBA::InterfaceDefSeq> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->base_interfaces (
        arg_1
        ACE_ENV_ARG_PARAMETER);
      
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< CORBA::InterfaceDefSeq>::in_arg_val _tao_base_interfaces;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_base_interfaces
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::InterfaceDef::is_a_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_type arg_1 =
        get_in_arg< CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_->is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_val _tao_interface_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_interface_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::InterfaceDef::describe_interface_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::InterfaceDef::FullInterfaceDescription>::ret_arg_type retval =
        get_ret_arg< CORBA::InterfaceDef::FullInterfaceDescription> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->describe_interface (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::InterfaceDef::FullInterfaceDescription>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::InterfaceDef::create_attribute_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::AttributeDef>::ret_arg_type retval =
        get_ret_arg< CORBA::AttributeDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_type arg_1 =
        get_in_arg< CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< CORBA::Identifier>::in_arg_type arg_2 =
        get_in_arg< CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< CORBA::VersionSpec>::in_arg_type arg_3 =
        get_in_arg< CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_4 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< CORBA::AttributeMode>::in_arg_type arg_5 =
        get_in_arg< CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          5);
        
      
      retval =
        this->servant_->create_attribute (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::AttributeDef>::ret_val retval;
  TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_type;
  TAO::SArg_Traits< CORBA::AttributeMode>::in_arg_val _tao_mode;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_type,
      &_tao_mode
    };
  
  static size_t const nargs = 6;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::InterfaceDef::create_operation_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::OperationDef>::ret_arg_type retval =
        get_ret_arg< CORBA::OperationDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_type arg_1 =
        get_in_arg< CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< CORBA::Identifier>::in_arg_type arg_2 =
        get_in_arg< CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< CORBA::VersionSpec>::in_arg_type arg_3 =
        get_in_arg< CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_4 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< CORBA::OperationMode>::in_arg_type arg_5 =
        get_in_arg< CORBA::OperationMode> (
          this->operation_details_,
          this->args_,
          5);
        
      TAO::SArg_Traits< CORBA::ParDescriptionSeq>::in_arg_type arg_6 =
        get_in_arg< CORBA::ParDescriptionSeq> (
          this->operation_details_,
          this->args_,
          6);
        
      TAO::SArg_Traits< CORBA::ExceptionDefSeq>::in_arg_type arg_7 =
        get_in_arg< CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          7);
        
      TAO::SArg_Traits< CORBA::ContextIdSeq>::in_arg_type arg_8 =
        get_in_arg< CORBA::ContextIdSeq> (
          this->operation_details_,
          this->args_,
          8);
        
      
      retval =
        this->servant_->create_operation (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6
          , arg_7
          , arg_8
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::OperationDef>::ret_val retval;
  TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_result;
  TAO::SArg_Traits< CORBA::OperationMode>::in_arg_val _tao_mode;
  TAO::SArg_Traits< CORBA::ParDescriptionSeq>::in_arg_val _tao_params;
  TAO::SArg_Traits< CORBA::ExceptionDefSeq>::in_arg_val _tao_exceptions;
  TAO::SArg_Traits< CORBA::ContextIdSeq>::in_arg_val _tao_contexts;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_result,
      &_tao_mode,
      &_tao_params,
      &_tao_exceptions,
      &_tao_contexts
    };
  
  static size_t const nargs = 9;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::InterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::InterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::InterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::InterfaceDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::InterfaceDef * const impl =
    static_cast<
      POA_CORBA::InterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::InterfaceDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::InterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::InterfaceDef *
POA_CORBA::InterfaceDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::InterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23,  0,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23,  0,
     23,  0,  0,  0, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23,  5, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,
#else
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23,  0, 23,  0, 23,  0,
      0,  0, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,  5, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 22,
      HASH_VALUE_RANGE = 18,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_CORBA::InterfaceAttrExtension::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_interface", &POA_CORBA::InterfaceAttrExtension::_interface_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_CORBA::InterfaceAttrExtension::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_CORBA::InterfaceAttrExtension::_non_existent_skel, 0},
      {"",0,0},
      {"create_ext_attribute", &POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel, 0},
      {"",0,0},
      {"describe_ext_interface", &POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_CORBA_InterfaceAttrExtension_Perfect_Hash_OpTable tao_CORBA_InterfaceAttrExtension_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker *
POA_CORBA::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker::the_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker::~_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker::the_TAO_InterfaceAttrExtension_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::InterfaceAttrExtension::InterfaceAttrExtension (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_InterfaceAttrExtension_optable;
}

POA_CORBA::InterfaceAttrExtension::InterfaceAttrExtension (const InterfaceAttrExtension& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_CORBA::InterfaceAttrExtension::~InterfaceAttrExtension (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::InterfaceAttrExtension::describe_ext_interface_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::ret_arg_type retval =
        get_ret_arg< CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_->describe_ext_interface (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<
      POA_CORBA::InterfaceAttrExtension *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_operation/operation_ss.cpp:165

void POA_CORBA::InterfaceAttrExtension::create_ext_attribute_skel (
    TAO_ServerRequest & server_request,
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< CORBA::ExtAttributeDef>::ret_arg_type retval =
        get_ret_arg< CORBA::ExtAttributeDef> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_type arg_1 =
        get_in_arg< CORBA::RepositoryId> (
          this->operation_details_,
          this->args_,
          1);
        
      TAO::SArg_Traits< CORBA::Identifier>::in_arg_type arg_2 =
        get_in_arg< CORBA::Identifier> (
          this->operation_details_,
          this->args_,
          2);
        
      TAO::SArg_Traits< CORBA::VersionSpec>::in_arg_type arg_3 =
        get_in_arg< CORBA::VersionSpec> (
          this->operation_details_,
          this->args_,
          3);
        
      TAO::SArg_Traits< CORBA::IDLType>::in_arg_type arg_4 =
        get_in_arg< CORBA::IDLType> (
          this->operation_details_,
          this->args_,
          4);
        
      TAO::SArg_Traits< CORBA::AttributeMode>::in_arg_type arg_5 =
        get_in_arg< CORBA::AttributeMode> (
          this->operation_details_,
          this->args_,
          5);
        
      TAO::SArg_Traits< CORBA::ExceptionDefSeq>::in_arg_type arg_6 =
        get_in_arg< CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          6);
        
      TAO::SArg_Traits< CORBA::ExceptionDefSeq>::in_arg_type arg_7 =
        get_in_arg< CORBA::ExceptionDefSeq> (
          this->operation_details_,
          this->args_,
          7);
        
      
      retval =
        this->servant_->create_ext_attribute (
          arg_1
          , arg_2
          , arg_3
          , arg_4
          , arg_5
          , arg_6
          , arg_7
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< CORBA::ExtAttributeDef>::ret_val retval;
  TAO::SArg_Traits< CORBA::RepositoryId>::in_arg_val _tao_id;
  TAO::SArg_Traits< CORBA::Identifier>::in_arg_val _tao_name;
  TAO::SArg_Traits< CORBA::VersionSpec>::in_arg_val _tao_version;
  TAO::SArg_Traits< CORBA::IDLType>::in_arg_val _tao_type;
  TAO::SArg_Traits< CORBA::AttributeMode>::in_arg_val _tao_mode;
  TAO::SArg_Traits< CORBA::ExceptionDefSeq>::in_arg_val _tao_get_exceptions;
  TAO::SArg_Traits< CORBA::ExceptionDefSeq>::in_arg_val _tao_set_exceptions;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_id,
      &_tao_name,
      &_tao_version,
      &_tao_type,
      &_tao_mode,
      &_tao_get_exceptions,
      &_tao_set_exceptions
    };
  
  static size_t const nargs = 8;
  
  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<
      POA_CORBA::InterfaceAttrExtension *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::InterfaceAttrExtension::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<
      POA_CORBA::InterfaceAttrExtension *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::InterfaceAttrExtension::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<
      POA_CORBA::InterfaceAttrExtension *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::InterfaceAttrExtension::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<
      POA_CORBA::InterfaceAttrExtension *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::InterfaceAttrExtension::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::InterfaceAttrExtension * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::InterfaceAttrExtension * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::InterfaceAttrExtension * const impl =
    static_cast<
      POA_CORBA::InterfaceAttrExtension *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::InterfaceAttrExtension::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::InterfaceAttrExtension::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::InterfaceAttrExtension::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::InterfaceAttrExtension *
POA_CORBA::InterfaceAttrExtension::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::InterfaceAttrExtension STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_InterfaceAttrExtension_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 30,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74,  0,
     74,  0, 20,  0, 74, 74, 74,  5, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 15,  0,  5,
     74, 15, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 15, 30, 74, 74, 74, 15,  5, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74,
#else
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 44,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 48
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ExtInterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::ExtInterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::ExtInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ExtInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ExtInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ExtInterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ExtInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ExtInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ExtInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ExtInterfaceDef::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ExtInterfaceDef::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::ExtInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ExtInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::ExtInterfaceDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ExtInterfaceDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ExtInterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ExtInterfaceDef::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::ExtInterfaceDef::create_alias_skel, 0},
      {"describe", &POA_CORBA::ExtInterfaceDef::describe_skel, 0},
      {"create_value_box", &POA_CORBA::ExtInterfaceDef::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::ExtInterfaceDef::destroy_skel, 0},
      {"_is_a", &POA_CORBA::ExtInterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ExtInterfaceDef::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::ExtInterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::ExtInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExtInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExtInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExtInterfaceDef::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::ExtInterfaceDef::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::ExtInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ExtInterfaceDef::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::ExtInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExtInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExtInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExtInterfaceDef::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::ExtInterfaceDef::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::ExtInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExtInterfaceDef::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExtInterfaceDef::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExtInterfaceDef::_get_def_kind_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::ExtInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::ExtInterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::ExtInterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ExtInterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79, 
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21, 
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1, 
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40, 
       -2, -75,  -1, -44,  -2,  42,  -1,  43,  -1, -79,  -1,  -1,  -1,  -1, 
       46,  -1,  -1,  47, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtInterfaceDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker::the_TAO_ExtInterfaceDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker::~_TAO_ExtInterfaceDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_ExtInterfaceDef_Strategized_Proxy_Broker::the_TAO_ExtInterfaceDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExtInterfaceDef::ExtInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtInterfaceDef_optable;
}

POA_CORBA::ExtInterfaceDef::ExtInterfaceDef (const ExtInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, InterfaceAttrExtension) (rhs)
{
}

POA_CORBA::ExtInterfaceDef::~ExtInterfaceDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::ExtInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::ExtInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::ExtInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtInterfaceDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::ExtInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::ExtInterfaceDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::ExtInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::ExtInterfaceDef *
POA_CORBA::ExtInterfaceDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::ExtInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExtInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 25,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79,  0,
     79,  0, 20,  0, 79, 79, 79,  5, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 15,  0,  5,
     79, 15, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 25, 40, 79, 79, 79, 15,  0, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79,
#else
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 25, 79,  0, 79,  0,
     20,  0, 79, 79, 79,  5, 79, 79, 15,  0,
      5, 79, 15, 79, 79, 25, 40, 79, 79, 79,
     15,  0, 79, 79, 79, 79, 79, 79,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 42,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 78,
      HASH_VALUE_RANGE = 75,
      DUPLICATES = 10,
      WORDLIST_SIZE = 46
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::AbstractInterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::AbstractInterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::AbstractInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::AbstractInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::AbstractInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::AbstractInterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::AbstractInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::AbstractInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::AbstractInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::AbstractInterfaceDef::create_union_skel, 0},
      {"create_exception", &POA_CORBA::AbstractInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::AbstractInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::AbstractInterfaceDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::AbstractInterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::AbstractInterfaceDef::lookup_name_skel, 0},
      {"destroy", &POA_CORBA::AbstractInterfaceDef::destroy_skel, 0},
      {"describe", &POA_CORBA::AbstractInterfaceDef::describe_skel, 0},
      {"_is_a", &POA_CORBA::AbstractInterfaceDef::_is_a_skel, 0},
      {"create_value_box", &POA_CORBA::AbstractInterfaceDef::create_value_box_skel, 0},
      {"contents", &POA_CORBA::AbstractInterfaceDef::contents_skel, 0},
      {"_get_name", &POA_CORBA::AbstractInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::AbstractInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::AbstractInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::AbstractInterfaceDef::_interface_skel, 0},
      {"lookup", &POA_CORBA::AbstractInterfaceDef::lookup_skel, 0},
      {"create_alias", &POA_CORBA::AbstractInterfaceDef::create_alias_skel, 0},
      {"describe_interface", &POA_CORBA::AbstractInterfaceDef::describe_interface_skel, 0},
      {"_get_version", &POA_CORBA::AbstractInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::AbstractInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::AbstractInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::AbstractInterfaceDef::_get_defined_in_skel, 0},
      {"_get_containing_repository", &POA_CORBA::AbstractInterfaceDef::_get_containing_repository_skel, 0},
      {"_get_id", &POA_CORBA::AbstractInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::AbstractInterfaceDef::_set_id_skel, 0},
      {"create_struct", &POA_CORBA::AbstractInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::AbstractInterfaceDef::create_constant_skel, 0},
      {"_get_def_kind", &POA_CORBA::AbstractInterfaceDef::_get_def_kind_skel, 0},
      {"describe_contents", &POA_CORBA::AbstractInterfaceDef::describe_contents_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::AbstractInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::AbstractInterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::AbstractInterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::AbstractInterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -84, 
      -10,  -3, -80,  13,  -1, -14,  -2, -80,  16, -24,  -3,  17,  18,  19, 
       20,  -1,  21,  22,  -1,  23, -89,  27,  28,  29,  30,  -1, -31,  -2, 
      -80,  33,  -1,  34,  -1,  -1,  -1, -36,  -2,  35, -81,  38,  -1,  39, 
       -1,  -1,  40,  -1,  -1,  -1,  41,  -1,  -1,  -1,  -1,  -1, -42,  -2, 
      -80,  -1,  -1,  -1,  -1,  44,  -1,  -1,  45, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_AbstractInterfaceDef_Perfect_Hash_OpTable tao_CORBA_AbstractInterfaceDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker::the_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker::~_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker::the_TAO_AbstractInterfaceDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::AbstractInterfaceDef::AbstractInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_AbstractInterfaceDef_optable;
}

POA_CORBA::AbstractInterfaceDef::AbstractInterfaceDef (const AbstractInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, InterfaceDef) (rhs)
{
}

POA_CORBA::AbstractInterfaceDef::~AbstractInterfaceDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::AbstractInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<
      POA_CORBA::AbstractInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::AbstractInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<
      POA_CORBA::AbstractInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::AbstractInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<
      POA_CORBA::AbstractInterfaceDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::AbstractInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::AbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::AbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::AbstractInterfaceDef * const impl =
    static_cast<
      POA_CORBA::AbstractInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::AbstractInterfaceDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::AbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::AbstractInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::AbstractInterfaceDef *
POA_CORBA::AbstractInterfaceDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::AbstractInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_AbstractInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 30,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74,  0,
     74,  0, 20,  0, 74, 74, 74,  5, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 15,  0,  5,
     74, 15, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 15, 30, 74, 74, 74, 15,  5, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74,
#else
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 44,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 48
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ExtAbstractInterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::ExtAbstractInterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::ExtAbstractInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ExtAbstractInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ExtAbstractInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ExtAbstractInterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ExtAbstractInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ExtAbstractInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ExtAbstractInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ExtAbstractInterfaceDef::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ExtAbstractInterfaceDef::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::ExtAbstractInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ExtAbstractInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::ExtAbstractInterfaceDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ExtAbstractInterfaceDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ExtAbstractInterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ExtAbstractInterfaceDef::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::ExtAbstractInterfaceDef::create_alias_skel, 0},
      {"describe", &POA_CORBA::ExtAbstractInterfaceDef::describe_skel, 0},
      {"create_value_box", &POA_CORBA::ExtAbstractInterfaceDef::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::ExtAbstractInterfaceDef::destroy_skel, 0},
      {"_is_a", &POA_CORBA::ExtAbstractInterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ExtAbstractInterfaceDef::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::ExtAbstractInterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::ExtAbstractInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExtAbstractInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExtAbstractInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExtAbstractInterfaceDef::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::ExtAbstractInterfaceDef::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::ExtAbstractInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ExtAbstractInterfaceDef::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::ExtAbstractInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExtAbstractInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExtAbstractInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExtAbstractInterfaceDef::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::ExtAbstractInterfaceDef::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::ExtAbstractInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExtAbstractInterfaceDef::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExtAbstractInterfaceDef::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExtAbstractInterfaceDef::_get_def_kind_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::ExtAbstractInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::ExtAbstractInterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::ExtAbstractInterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ExtAbstractInterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79, 
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21, 
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1, 
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40, 
       -2, -75,  -1, -44,  -2,  42,  -1,  43,  -1, -79,  -1,  -1,  -1,  -1, 
       46,  -1,  -1,  47, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtAbstractInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtAbstractInterfaceDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker::the_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker::~_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker::the_TAO_ExtAbstractInterfaceDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExtAbstractInterfaceDef::ExtAbstractInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtAbstractInterfaceDef_optable;
}

POA_CORBA::ExtAbstractInterfaceDef::ExtAbstractInterfaceDef (const ExtAbstractInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, AbstractInterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, InterfaceAttrExtension) (rhs)
{
}

POA_CORBA::ExtAbstractInterfaceDef::~ExtAbstractInterfaceDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::ExtAbstractInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtAbstractInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::ExtAbstractInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtAbstractInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::ExtAbstractInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtAbstractInterfaceDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::ExtAbstractInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtAbstractInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtAbstractInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtAbstractInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtAbstractInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::ExtAbstractInterfaceDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/AbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtAbstractInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtAbstractInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::ExtAbstractInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::ExtAbstractInterfaceDef *
POA_CORBA::ExtAbstractInterfaceDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::ExtAbstractInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExtAbstractInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 25,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79,  0,
     79,  0, 20,  0, 79, 79, 79,  5, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 15,  0,  5,
     79, 15, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 25, 40, 79, 79, 79, 15,  0, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79,
#else
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 79, 79, 79, 79, 79,
     79, 79, 79, 79, 79, 25, 79,  0, 79,  0,
     20,  0, 79, 79, 79,  5, 79, 79, 15,  0,
      5, 79, 15, 79, 79, 25, 40, 79, 79, 79,
     15,  0, 79, 79, 79, 79, 79, 79,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 42,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 78,
      HASH_VALUE_RANGE = 75,
      DUPLICATES = 10,
      WORDLIST_SIZE = 46
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::LocalInterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::LocalInterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::LocalInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::LocalInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::LocalInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::LocalInterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::LocalInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::LocalInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::LocalInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::LocalInterfaceDef::create_union_skel, 0},
      {"create_exception", &POA_CORBA::LocalInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::LocalInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::LocalInterfaceDef::create_local_interface_skel, 0},
      {"create_abstract_interface", &POA_CORBA::LocalInterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::LocalInterfaceDef::lookup_name_skel, 0},
      {"destroy", &POA_CORBA::LocalInterfaceDef::destroy_skel, 0},
      {"describe", &POA_CORBA::LocalInterfaceDef::describe_skel, 0},
      {"_is_a", &POA_CORBA::LocalInterfaceDef::_is_a_skel, 0},
      {"create_value_box", &POA_CORBA::LocalInterfaceDef::create_value_box_skel, 0},
      {"contents", &POA_CORBA::LocalInterfaceDef::contents_skel, 0},
      {"_get_name", &POA_CORBA::LocalInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::LocalInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::LocalInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::LocalInterfaceDef::_interface_skel, 0},
      {"lookup", &POA_CORBA::LocalInterfaceDef::lookup_skel, 0},
      {"create_alias", &POA_CORBA::LocalInterfaceDef::create_alias_skel, 0},
      {"describe_interface", &POA_CORBA::LocalInterfaceDef::describe_interface_skel, 0},
      {"_get_version", &POA_CORBA::LocalInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::LocalInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::LocalInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::LocalInterfaceDef::_get_defined_in_skel, 0},
      {"_get_containing_repository", &POA_CORBA::LocalInterfaceDef::_get_containing_repository_skel, 0},
      {"_get_id", &POA_CORBA::LocalInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::LocalInterfaceDef::_set_id_skel, 0},
      {"create_struct", &POA_CORBA::LocalInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::LocalInterfaceDef::create_constant_skel, 0},
      {"_get_def_kind", &POA_CORBA::LocalInterfaceDef::_get_def_kind_skel, 0},
      {"describe_contents", &POA_CORBA::LocalInterfaceDef::describe_contents_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::LocalInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::LocalInterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::LocalInterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::LocalInterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -84, 
      -10,  -3, -80,  13,  -1, -14,  -2, -80,  16, -24,  -3,  17,  18,  19, 
       20,  -1,  21,  22,  -1,  23, -89,  27,  28,  29,  30,  -1, -31,  -2, 
      -80,  33,  -1,  34,  -1,  -1,  -1, -36,  -2,  35, -81,  38,  -1,  39, 
       -1,  -1,  40,  -1,  -1,  -1,  41,  -1,  -1,  -1,  -1,  -1, -42,  -2, 
      -80,  -1,  -1,  -1,  -1,  44,  -1,  -1,  45, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_LocalInterfaceDef_Perfect_Hash_OpTable tao_CORBA_LocalInterfaceDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker::the_TAO_LocalInterfaceDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker::~_TAO_LocalInterfaceDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_LocalInterfaceDef_Strategized_Proxy_Broker::the_TAO_LocalInterfaceDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::LocalInterfaceDef::LocalInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_LocalInterfaceDef_optable;
}

POA_CORBA::LocalInterfaceDef::LocalInterfaceDef (const LocalInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, InterfaceDef) (rhs)
{
}

POA_CORBA::LocalInterfaceDef::~LocalInterfaceDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::LocalInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::LocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::LocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<
      POA_CORBA::LocalInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::LocalInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::LocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::LocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<
      POA_CORBA::LocalInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::LocalInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<
      POA_CORBA::LocalInterfaceDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::LocalInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::LocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::LocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::LocalInterfaceDef * const impl =
    static_cast<
      POA_CORBA::LocalInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::LocalInterfaceDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::LocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/LocalInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::LocalInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::LocalInterfaceDef *
POA_CORBA::LocalInterfaceDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::LocalInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_LocalInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_interface.cpp:1535

class TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: c:\ace\POAmerge\ace_wrappers\bin\gperf.exe -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 30,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74,  0,
     74,  0, 20,  0, 74, 74, 74,  5, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 15,  0,  5,
     74, 15, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 15, 30, 74, 74, 74, 15,  5, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74,
#else
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
     74, 74, 74, 74, 74, 30, 74,  0, 74,  0,
     20,  0, 74, 74, 74,  5, 74, 74, 15,  0,
      5, 74, 15, 74, 74, 15, 30, 74, 74, 74,
     15,  5, 74, 74, 74, 74, 74, 74,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const struct TAO_operation_db_entry *
TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 44,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 73,
      HASH_VALUE_RANGE = 70,
      DUPLICATES = 10,
      WORDLIST_SIZE = 48
    };

  static const struct TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"move", &POA_CORBA::ExtLocalInterfaceDef::move_skel, 0},
      {"is_a", &POA_CORBA::ExtLocalInterfaceDef::is_a_skel, 0},
      {"create_enum", &POA_CORBA::ExtLocalInterfaceDef::create_enum_skel, 0},
      {"create_value", &POA_CORBA::ExtLocalInterfaceDef::create_value_skel, 0},
      {"create_module", &POA_CORBA::ExtLocalInterfaceDef::create_module_skel, 0},
      {"create_native", &POA_CORBA::ExtLocalInterfaceDef::create_native_skel, 0},
      {"create_interface", &POA_CORBA::ExtLocalInterfaceDef::create_interface_skel, 0},
      {"create_attribute", &POA_CORBA::ExtLocalInterfaceDef::create_attribute_skel, 0},
      {"create_ext_value", &POA_CORBA::ExtLocalInterfaceDef::create_ext_value_skel, 0},
      {"create_union", &POA_CORBA::ExtLocalInterfaceDef::create_union_skel, 0},
      {"create_ext_attribute", &POA_CORBA::ExtLocalInterfaceDef::create_ext_attribute_skel, 0},
      {"create_exception", &POA_CORBA::ExtLocalInterfaceDef::create_exception_skel, 0},
      {"create_operation", &POA_CORBA::ExtLocalInterfaceDef::create_operation_skel, 0},
      {"create_local_interface", &POA_CORBA::ExtLocalInterfaceDef::create_local_interface_skel, 0},
      {"contents", &POA_CORBA::ExtLocalInterfaceDef::contents_skel, 0},
      {"create_abstract_interface", &POA_CORBA::ExtLocalInterfaceDef::create_abstract_interface_skel, 0},
      {"lookup_name", &POA_CORBA::ExtLocalInterfaceDef::lookup_name_skel, 0},
      {"create_alias", &POA_CORBA::ExtLocalInterfaceDef::create_alias_skel, 0},
      {"describe", &POA_CORBA::ExtLocalInterfaceDef::describe_skel, 0},
      {"create_value_box", &POA_CORBA::ExtLocalInterfaceDef::create_value_box_skel, 0},
      {"destroy", &POA_CORBA::ExtLocalInterfaceDef::destroy_skel, 0},
      {"_is_a", &POA_CORBA::ExtLocalInterfaceDef::_is_a_skel, 0},
      {"lookup", &POA_CORBA::ExtLocalInterfaceDef::lookup_skel, 0},
      {"describe_interface", &POA_CORBA::ExtLocalInterfaceDef::describe_interface_skel, 0},
      {"_get_name", &POA_CORBA::ExtLocalInterfaceDef::_get_name_skel, 0},
      {"_get_type", &POA_CORBA::ExtLocalInterfaceDef::_get_type_skel, 0},
      {"_set_name", &POA_CORBA::ExtLocalInterfaceDef::_set_name_skel, 0},
      {"_interface", &POA_CORBA::ExtLocalInterfaceDef::_interface_skel, 0},
      {"describe_ext_interface", &POA_CORBA::ExtLocalInterfaceDef::describe_ext_interface_skel, 0},
      {"create_struct", &POA_CORBA::ExtLocalInterfaceDef::create_struct_skel, 0},
      {"create_constant", &POA_CORBA::ExtLocalInterfaceDef::create_constant_skel, 0},
      {"_get_version", &POA_CORBA::ExtLocalInterfaceDef::_get_version_skel, 0},
      {"_set_version", &POA_CORBA::ExtLocalInterfaceDef::_set_version_skel, 0},
      {"_get_absolute_name", &POA_CORBA::ExtLocalInterfaceDef::_get_absolute_name_skel, 0},
      {"_get_defined_in", &POA_CORBA::ExtLocalInterfaceDef::_get_defined_in_skel, 0},
      {"describe_contents", &POA_CORBA::ExtLocalInterfaceDef::describe_contents_skel, 0},
      {"_get_id", &POA_CORBA::ExtLocalInterfaceDef::_get_id_skel, 0},
      {"_set_id", &POA_CORBA::ExtLocalInterfaceDef::_set_id_skel, 0},
      {"_get_containing_repository", &POA_CORBA::ExtLocalInterfaceDef::_get_containing_repository_skel, 0},
      {"_get_def_kind", &POA_CORBA::ExtLocalInterfaceDef::_get_def_kind_skel, 0},
      {"_get_base_interfaces", &POA_CORBA::ExtLocalInterfaceDef::_get_base_interfaces_skel, 0},
      {"_set_base_interfaces", &POA_CORBA::ExtLocalInterfaceDef::_set_base_interfaces_skel, 0},
      {"_component", &POA_CORBA::ExtLocalInterfaceDef::_component_skel, 0},
      {"_non_existent", &POA_CORBA::ExtLocalInterfaceDef::_non_existent_skel, 0},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,  -1,  -1,  -8,  -2,   5,  -1,   6,   7, -79, 
      -10,  -3, -75,  13, -15,  -2,  14, -76,  17,  18,  -1,  19,  20,  21, 
       22, -28,  -3,  23,  24, -35,  -2,  25,  26,  -1,  27, -83,  31,  -1, 
       32,  33,  -1,  34,  -1, -87,  37,  -1,  38,  -1,  39,  -1,  -1, -40, 
       -2, -75,  -1, -44,  -2,  42,  -1,  43,  -1, -79,  -1,  -1,  -1,  -1, 
       46,  -1,  -1,  47, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < WORDLIST_SIZE)
            {
              const char *s = wordlist[slot].opname;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const struct TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const struct TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname && !strncmp (str + 1, ptr->opname + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}

static TAO_CORBA_ExtLocalInterfaceDef_Perfect_Hash_OpTable tao_CORBA_ExtLocalInterfaceDef_optable;
///////////////////////////////////////////////////////////////////////
//            Strategized Proxy Broker Implementation
//

// TAO_IDL - Generated from
// be\be_visitor_interface/strategized_proxy_broker_ss.cpp:40

// Factory function Implementation.
POA_CORBA::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker *
POA_CORBA::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker::the_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker (void)
{
  static POA_CORBA::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker
  strategized_proxy_broker;
  
  return &strategized_proxy_broker;
}

POA_CORBA::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker (void)
{
}

POA_CORBA::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker::~_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker (void)
{
}

TAO::Collocation_Strategy
POA_CORBA::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker::get_strategy (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  TAO::Collocation_Strategy strategy =
    TAO_ORB_Core::collocation_strategy (obj ACE_ENV_ARG_PARAMETER);
  ACE_CHECK_RETURN (TAO::TAO_CS_REMOTE_STRATEGY);
  
  return strategy;
}

void
POA_CORBA::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker::dispatch (
    CORBA::Object_ptr obj,
    CORBA::Object_out forward_obj,
    TAO::Argument ** args,
    int num_args,
    const char * op,
    size_t op_len,
    TAO::Collocation_Strategy strategy
    ACE_ENV_ARG_DECL
  )
  ACE_THROW_SPEC ((CORBA::Exception))
{
  TAO_Abstract_ServantBase * const servant = obj->_servant ();
  
  TAO_Collocated_Skeleton collocated_skel;
  int const status = servant->_find (op,
                                     collocated_skel,
                                     strategy,
                                     op_len);
  
  if (status == -1)
    {
      ACE_THROW (CORBA::BAD_OPERATION (CORBA::OMGVMCID | 2, CORBA::COMPLETED_NO));
    }
  
  ACE_TRY
    {
      collocated_skel (servant,
                       args,
                       num_args
                       ACE_ENV_ARG_PARAMETER);
      ACE_TRY_CHECK;
    }
#if (TAO_HAS_MINIMUM_CORBA == 0)
  ACE_CATCH (PortableServer::ForwardRequest, forward_request)
    {
      forward_obj =
        CORBA::Object::_duplicate (forward_request.forward_reference.in ());
      return;
    }
#else
  ACE_CATCHANY
    {
      ACE_UNUSED_ARG (forward_obj);
      ACE_RE_THROW;
    }
#endif /* TAO_HAS_MINIMUM_CORBA */
  ACE_ENDTRY;
  ACE_CHECK;
}

//
//        End Strategized Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:832

TAO::Collocation_Proxy_Broker *
CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function (CORBA::Object_ptr)
{
  return
    ::POA_CORBA::_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker::the_TAO_ExtLocalInterfaceDef_Strategized_Proxy_Broker ();
}

int
CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_Initializer (size_t)
{
  CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function_pointer = 
    CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<
          size_t> (
          CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_Initializer
        )
    );



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:103

POA_CORBA::ExtLocalInterfaceDef::ExtLocalInterfaceDef (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_CORBA_ExtLocalInterfaceDef_optable;
}

POA_CORBA::ExtLocalInterfaceDef::ExtLocalInterfaceDef (const ExtLocalInterfaceDef& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IRObject) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, InterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, LocalInterfaceDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA, InterfaceAttrExtension) (rhs)
{
}

POA_CORBA::ExtLocalInterfaceDef::~ExtLocalInterfaceDef (void)
{
}

// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:169

void POA_CORBA::ExtLocalInterfaceDef::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtLocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< CORBA::Char *>::in_arg_type arg_1 =
        get_in_arg< CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      
      retval =
        this->servant_-> _is_a (
          arg_1
          ACE_ENV_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtLocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtLocalInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

void POA_CORBA::ExtLocalInterfaceDef::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtLocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _non_existent (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtLocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtLocalInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}



// TAO_IDL - Generated from 
// be\be_visitor_interface/interface_ss.cpp:385



void POA_CORBA::ExtLocalInterfaceDef::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      ACE_THROW (CORBA::INTF_REPOS (CORBA::OMGVMCID | 1,
                                    CORBA::COMPLETED_NO));
    }
  
  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtLocalInterfaceDef *> (servant);
  CORBA::InterfaceDef_ptr _tao_retval = 
    impl->_get_interface (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK;
  
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (
        _tao_out,
        _tao_retval
      );
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == 0)
    {
      ACE_THROW (CORBA::MARSHAL ());
    }
}

void POA_CORBA::ExtLocalInterfaceDef::_component_skel (
    TAO_ServerRequest & server_request, 
    void * servant_upcall,
    void * servant
    ACE_ENV_ARG_DECL
  )
{
  
  
  // TAO_IDL - Generated from
  // be\be_visitor_operation/upcall_command_ss.cpp:74
  
  class Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    
    inline Upcall_Command (
      POA_CORBA::ExtLocalInterfaceDef * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
      , operation_details_ (operation_details)
      , args_ (args)
    {
    }
    
    virtual void execute (ACE_ENV_SINGLE_ARG_DECL)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      
      retval =
        this->servant_-> _get_component (
          ACE_ENV_SINGLE_ARG_PARAMETER);
        
    }
  
  private:
    
    POA_CORBA::ExtLocalInterfaceDef * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
  
  
#if TAO_HAS_INTERCEPTORS == 1
  static CORBA::TypeCode_ptr const * const exceptions = 0;
  static size_t const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_CORBA::ExtLocalInterfaceDef * const impl =
    static_cast<
      POA_CORBA::ExtLocalInterfaceDef *> (servant);
  
  Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
  
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
  
                         ACE_ENV_ARG_PARAMETER);
  ACE_CHECK;
  
}

CORBA::Boolean POA_CORBA::ExtLocalInterfaceDef::_is_a (
    const char* value
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IRObject:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Container:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Contained:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/IDLType:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/InterfaceAttrExtension:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_CORBA::ExtLocalInterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExtLocalInterfaceDef:1.0";
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:780

void POA_CORBA::ExtLocalInterfaceDef::_dispatch (
    TAO_ServerRequest & req,
    void * servant_upcall
    ACE_ENV_ARG_DECL
  )
{
  this->synchronous_upcall_dispatch (req,
                                     servant_upcall,
                                     this
                                     ACE_ENV_ARG_PARAMETER);
}

// TAO_IDL - Generated from
// be\be_visitor_interface/interface_ss.cpp:731

CORBA::ExtLocalInterfaceDef *
POA_CORBA::ExtLocalInterfaceDef::_this (ACE_ENV_SINGLE_ARG_DECL)
{
  TAO_Stub *stub = this->_create_stub (ACE_ENV_SINGLE_ARG_PARAMETER);
  ACE_CHECK_RETURN (0);
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  CORBA::Object_ptr tmp = CORBA::Object::_nil ();
  
  CORBA::Boolean _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::CORBA::ExtLocalInterfaceDef STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        CORBA__TAO_ExtLocalInterfaceDef_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be\be_visitor_root/root.cpp:1674

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

#if !defined (_CORBA_DEFINITIONKIND__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_DEFINITIONKIND__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::DefinitionKind>;

  template class TAO::Basic_SArg_Traits_T<CORBA::DefinitionKind>;

#endif /* end #if !defined */

#if !defined (_CORBA_CONTAINED__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_CONTAINED__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::Contained>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::Contained_ptr,
        CORBA::Contained_var,
        CORBA::Contained_out,
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_REPOSITORY__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_REPOSITORY__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::Repository>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::Repository_ptr,
        CORBA::Repository_var,
        CORBA::Repository_out,
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::Contained_ptr,
        CORBA::Contained_var
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::PrimitiveDef_ptr,
        CORBA::PrimitiveDef_var
      >;

  template class
    TAO::In_Basic_SArgument_T<
        CORBA::PrimitiveKind
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::StringDef_ptr,
        CORBA::StringDef_var
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::WstringDef_ptr,
        CORBA::WstringDef_var
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::SequenceDef_ptr,
        CORBA::SequenceDef_var
      >;

  template class
    TAO::In_Object_SArgument_T<
        CORBA::IDLType_ptr
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::ArrayDef_ptr,
        CORBA::ArrayDef_var
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::FixedDef_ptr,
        CORBA::FixedDef_var
      >;

#if !defined (_CORBA_CONTAINER__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_CONTAINER__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::Container>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::Container_ptr,
        CORBA::Container_var,
        CORBA::Container_out,
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::IDLType_ptr,
        CORBA::IDLType_var
      >;

#if !defined (_CORBA_IDLTYPE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_IDLTYPE__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::IDLType>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::IDLType_ptr,
        CORBA::IDLType_var,
        CORBA::IDLType_out,
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::StructMemberSeq,
        CORBA::StructMemberSeq_var
      >;

  template class
    TAO::In_Var_Size_SArgument_T<
        CORBA::StructMemberSeq
      >;

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::UnionMemberSeq,
        CORBA::UnionMemberSeq_var
      >;

  template class
    TAO::In_Var_Size_SArgument_T<
        CORBA::UnionMemberSeq
      >;

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::EnumMemberSeq,
        CORBA::EnumMemberSeq_var
      >;

  template class
    TAO::In_Var_Size_SArgument_T<
        CORBA::EnumMemberSeq
      >;

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::InterfaceDefSeq,
        CORBA::InterfaceDefSeq_var
      >;

  template class
    TAO::In_Var_Size_SArgument_T<
        CORBA::InterfaceDefSeq
      >;

#if !defined (_CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::InterfaceDef::FullInterfaceDescription>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::InterfaceDef::FullInterfaceDescription,
        CORBA::InterfaceDef::FullInterfaceDescription_var,
        CORBA::InterfaceDef::FullInterfaceDescription_out
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::InterfaceDef::FullInterfaceDescription,
        CORBA::InterfaceDef::FullInterfaceDescription_var
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::AttributeDef_ptr,
        CORBA::AttributeDef_var
      >;

  template class
    TAO::In_Basic_SArgument_T<
        CORBA::AttributeMode
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::OperationDef_ptr,
        CORBA::OperationDef_var
      >;

  template class
    TAO::In_Basic_SArgument_T<
        CORBA::OperationMode
      >;

  template class
    TAO::In_Var_Size_SArgument_T<
        CORBA::ParDescriptionSeq
      >;

  template class
    TAO::In_Var_Size_SArgument_T<
        CORBA::ExceptionDefSeq
      >;

  template class
    TAO::In_Var_Size_SArgument_T<
        CORBA::ContextIdSeq
      >;

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::InterfaceDefSeq>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::InterfaceDefSeq,
        CORBA::InterfaceDefSeq_var,
        CORBA::InterfaceDefSeq_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::StructMemberSeq>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::StructMemberSeq,
        CORBA::StructMemberSeq_var,
        CORBA::StructMemberSeq_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::ExcDescriptionSeq>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::ExcDescriptionSeq,
        CORBA::ExcDescriptionSeq_var,
        CORBA::ExcDescriptionSeq_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::UnionMemberSeq>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::UnionMemberSeq,
        CORBA::UnionMemberSeq_var,
        CORBA::UnionMemberSeq_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::EnumMemberSeq>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::EnumMemberSeq,
        CORBA::EnumMemberSeq_var,
        CORBA::EnumMemberSeq_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_PRIMITIVEDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_PRIMITIVEDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::PrimitiveDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::PrimitiveDef_ptr,
        CORBA::PrimitiveDef_var,
        CORBA::PrimitiveDef_out,
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Basic_SArgument_T<
        CORBA::PrimitiveKind
      >;

#if !defined (_CORBA_STRINGDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_STRINGDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::StringDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::StringDef_ptr,
        CORBA::StringDef_var,
        CORBA::StringDef_out,
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCEDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCEDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::SequenceDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::SequenceDef_ptr,
        CORBA::SequenceDef_var,
        CORBA::SequenceDef_out,
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_ARRAYDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_ARRAYDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::ArrayDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::ArrayDef_ptr,
        CORBA::ArrayDef_var,
        CORBA::ArrayDef_out,
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_WSTRINGDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_WSTRINGDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::WstringDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::WstringDef_ptr,
        CORBA::WstringDef_var,
        CORBA::WstringDef_out,
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_FIXEDDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_FIXEDDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::FixedDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::FixedDef_ptr,
        CORBA::FixedDef_var,
        CORBA::FixedDef_out,
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_PRIMITIVEKIND__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_PRIMITIVEKIND__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::PrimitiveKind>;

  template class TAO::Basic_SArg_Traits_T<CORBA::PrimitiveKind>;

#endif /* end #if !defined */

#if !defined (_CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::ExceptionDefSeq>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::ExceptionDefSeq,
        CORBA::ExceptionDefSeq_var,
        CORBA::ExceptionDefSeq_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_ATTRIBUTEMODE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_ATTRIBUTEMODE__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::AttributeMode>;

  template class TAO::Basic_SArg_Traits_T<CORBA::AttributeMode>;

#endif /* end #if !defined */

#if !defined (_CORBA_ATTRIBUTEDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_ATTRIBUTEDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::AttributeDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::AttributeDef_ptr,
        CORBA::AttributeDef_var,
        CORBA::AttributeDef_out,
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Basic_SArgument_T<
        CORBA::AttributeMode
      >;

#if !defined (_CORBA_EXTATTRIBUTEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_EXTATTRIBUTEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::ExtAttributeDescription>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::ExtAttributeDescription,
        CORBA::ExtAttributeDescription_var,
        CORBA::ExtAttributeDescription_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_EXTATTRIBUTEDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_EXTATTRIBUTEDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::ExtAttributeDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::ExtAttributeDef_ptr,
        CORBA::ExtAttributeDef_var,
        CORBA::ExtAttributeDef_out,
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::ExcDescriptionSeq,
        CORBA::ExcDescriptionSeq_var
      >;

  template class
    TAO::In_Var_Size_SArgument_T<
        CORBA::ExcDescriptionSeq
      >;

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::ExtAttributeDescription,
        CORBA::ExtAttributeDescription_var
      >;

#if !defined (_CORBA_OPERATIONMODE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_OPERATIONMODE__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::OperationMode>;

  template class TAO::Basic_SArg_Traits_T<CORBA::OperationMode>;

#endif /* end #if !defined */

#if !defined (_CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::ParDescriptionSeq>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::ParDescriptionSeq,
        CORBA::ParDescriptionSeq_var,
        CORBA::ParDescriptionSeq_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_CONTEXTIDSEQ__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_CONTEXTIDSEQ__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::ContextIdSeq>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::ContextIdSeq,
        CORBA::ContextIdSeq_var,
        CORBA::ContextIdSeq_out
      >;

#endif /* end #if !defined */

#if !defined (_CORBA_OPERATIONDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_OPERATIONDEF__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::OperationDef>;

  template class
    TAO::Object_SArg_Traits_T<
        CORBA::OperationDef_ptr,
        CORBA::OperationDef_var,
        CORBA::OperationDef_out,
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::ParDescriptionSeq,
        CORBA::ParDescriptionSeq_var
      >;

  template class
    TAO::Ret_Basic_SArgument_T<
        CORBA::OperationMode
      >;

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::ContextIdSeq,
        CORBA::ContextIdSeq_var
      >;

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::ExceptionDefSeq,
        CORBA::ExceptionDefSeq_var
      >;

#if !defined (_CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_

  template class TAO::SArg_Traits<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>;

  template class
    TAO::Var_Size_SArg_Traits_T<
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription,
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_var,
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_out
      >;

#endif /* end #if !defined */

  template class
    TAO::Ret_Var_Size_SArgument_T<
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription,
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_var
      >;

  template class
    TAO::Ret_Object_SArgument_T<
        CORBA::ExtAttributeDef_ptr,
        CORBA::ExtAttributeDef_var
      >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

#if !defined (_CORBA_DEFINITIONKIND__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_DEFINITIONKIND__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::DefinitionKind>

# pragma instantiate TAO::Basic_SArg_Traits_T<CORBA::DefinitionKind>

#endif /* end #if !defined */

#if !defined (_CORBA_CONTAINED__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_CONTAINED__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::Contained>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::Contained_ptr, \
        CORBA::Contained_var, \
        CORBA::Contained_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_REPOSITORY__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_REPOSITORY__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::Repository>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::Repository_ptr, \
        CORBA::Repository_var, \
        CORBA::Repository_out, \
      >

#endif /* end #if !defined */

# pragma instantiate \
    TAO::In_Basic_SArgument_T< \
        CORBA::PrimitiveKind \
      >

# pragma instantiate \
    TAO::In_Object_SArgument_T< \
        CORBA::IDLType_ptr \
      >

#if !defined (_CORBA_CONTAINER__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_CONTAINER__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::Container>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::Container_ptr, \
        CORBA::Container_var, \
        CORBA::Container_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_IDLTYPE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_IDLTYPE__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::IDLType>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::IDLType_ptr, \
        CORBA::IDLType_var, \
        CORBA::IDLType_out, \
      >

#endif /* end #if !defined */

# pragma instantiate \
    TAO::In_Var_Size_SArgument_T< \
        CORBA::StructMemberSeq \
      >

# pragma instantiate \
    TAO::In_Var_Size_SArgument_T< \
        CORBA::UnionMemberSeq \
      >

# pragma instantiate \
    TAO::In_Var_Size_SArgument_T< \
        CORBA::EnumMemberSeq \
      >

# pragma instantiate \
    TAO::In_Var_Size_SArgument_T< \
        CORBA::InterfaceDefSeq \
      >

#if !defined (_CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_INTERFACEDEF_FULLINTERFACEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::InterfaceDef::FullInterfaceDescription>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::InterfaceDef::FullInterfaceDescription, \
        CORBA::InterfaceDef::FullInterfaceDescription_var, \
        CORBA::InterfaceDef::FullInterfaceDescription_out \
      >

#endif /* end #if !defined */

# pragma instantiate \
    TAO::In_Basic_SArgument_T< \
        CORBA::AttributeMode \
      >

# pragma instantiate \
    TAO::In_Basic_SArgument_T< \
        CORBA::OperationMode \
      >

# pragma instantiate \
    TAO::In_Var_Size_SArgument_T< \
        CORBA::ParDescriptionSeq \
      >

# pragma instantiate \
    TAO::In_Var_Size_SArgument_T< \
        CORBA::ExceptionDefSeq \
      >

# pragma instantiate \
    TAO::In_Var_Size_SArgument_T< \
        CORBA::ContextIdSeq \
      >

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::InterfaceDefSeq>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::InterfaceDefSeq, \
        CORBA::InterfaceDefSeq_var, \
        CORBA::InterfaceDefSeq_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::StructMemberSeq>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::StructMemberSeq, \
        CORBA::StructMemberSeq_var, \
        CORBA::StructMemberSeq_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::ExcDescriptionSeq>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::ExcDescriptionSeq, \
        CORBA::ExcDescriptionSeq_var, \
        CORBA::ExcDescriptionSeq_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::UnionMemberSeq>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::UnionMemberSeq, \
        CORBA::UnionMemberSeq_var, \
        CORBA::UnionMemberSeq_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCE__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::EnumMemberSeq>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::EnumMemberSeq, \
        CORBA::EnumMemberSeq_var, \
        CORBA::EnumMemberSeq_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_PRIMITIVEDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_PRIMITIVEDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::PrimitiveDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::PrimitiveDef_ptr, \
        CORBA::PrimitiveDef_var, \
        CORBA::PrimitiveDef_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_STRINGDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_STRINGDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::StringDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::StringDef_ptr, \
        CORBA::StringDef_var, \
        CORBA::StringDef_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_SEQUENCEDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_SEQUENCEDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::SequenceDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::SequenceDef_ptr, \
        CORBA::SequenceDef_var, \
        CORBA::SequenceDef_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_ARRAYDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_ARRAYDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::ArrayDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::ArrayDef_ptr, \
        CORBA::ArrayDef_var, \
        CORBA::ArrayDef_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_WSTRINGDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_WSTRINGDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::WstringDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::WstringDef_ptr, \
        CORBA::WstringDef_var, \
        CORBA::WstringDef_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_FIXEDDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_FIXEDDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::FixedDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::FixedDef_ptr, \
        CORBA::FixedDef_var, \
        CORBA::FixedDef_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_PRIMITIVEKIND__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_PRIMITIVEKIND__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::PrimitiveKind>

# pragma instantiate TAO::Basic_SArg_Traits_T<CORBA::PrimitiveKind>

#endif /* end #if !defined */

#if !defined (_CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_EXCEPTIONDEFSEQ__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::ExceptionDefSeq>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::ExceptionDefSeq, \
        CORBA::ExceptionDefSeq_var, \
        CORBA::ExceptionDefSeq_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_ATTRIBUTEMODE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_ATTRIBUTEMODE__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::AttributeMode>

# pragma instantiate TAO::Basic_SArg_Traits_T<CORBA::AttributeMode>

#endif /* end #if !defined */

#if !defined (_CORBA_ATTRIBUTEDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_ATTRIBUTEDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::AttributeDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::AttributeDef_ptr, \
        CORBA::AttributeDef_var, \
        CORBA::AttributeDef_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_EXTATTRIBUTEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_EXTATTRIBUTEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::ExtAttributeDescription>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::ExtAttributeDescription, \
        CORBA::ExtAttributeDescription_var, \
        CORBA::ExtAttributeDescription_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_EXTATTRIBUTEDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_EXTATTRIBUTEDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::ExtAttributeDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::ExtAttributeDef_ptr, \
        CORBA::ExtAttributeDef_var, \
        CORBA::ExtAttributeDef_out, \
      >

#endif /* end #if !defined */

# pragma instantiate \
    TAO::In_Var_Size_SArgument_T< \
        CORBA::ExcDescriptionSeq \
      >

#if !defined (_CORBA_OPERATIONMODE__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_OPERATIONMODE__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::OperationMode>

# pragma instantiate TAO::Basic_SArg_Traits_T<CORBA::OperationMode>

#endif /* end #if !defined */

#if !defined (_CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_PARDESCRIPTIONSEQ__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::ParDescriptionSeq>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::ParDescriptionSeq, \
        CORBA::ParDescriptionSeq_var, \
        CORBA::ParDescriptionSeq_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_CONTEXTIDSEQ__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_CONTEXTIDSEQ__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::ContextIdSeq>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::ContextIdSeq, \
        CORBA::ContextIdSeq_var, \
        CORBA::ContextIdSeq_out \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_OPERATIONDEF__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_OPERATIONDEF__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::OperationDef>

# pragma instantiate \
    TAO::Object_SArg_Traits_T< \
        CORBA::OperationDef_ptr, \
        CORBA::OperationDef_var, \
        CORBA::OperationDef_out, \
      >

#endif /* end #if !defined */

#if !defined (_CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_)
#define _CORBA_INTERFACEATTREXTENSION_EXTFULLINTERFACEDESCRIPTION__SARG_TRAITS_TMPLINST_SS_

# pragma instantiate TAO::SArg_Traits<CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription>

# pragma instantiate \
    TAO::Var_Size_SArg_Traits_T< \
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription, \
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_var, \
        CORBA::InterfaceAttrExtension::ExtFullInterfaceDescription_out \
      >

#endif /* end #if !defined */

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */ 

#endif /* ifndef */

