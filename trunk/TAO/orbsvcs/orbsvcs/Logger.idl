// $Id$

interface Logger
{
  // = TITLE
  //   Used to log messages to a logging server.
  //
  // = DESCRIPTION
  //   @@ This interface is very simple-minded and can certainly be
  //   improved, e.g., by passing over more interesting logging
  //   records similar to what we do in <ACE_Log_Msg>.
  
  enum Log_Priority
  {
    
    LM_SHUTDOWN,
    // Shutdown the logger

    LM_TRACE,    
    // Messages indicating function-calling sequence

    LM_DEBUG,    
    // Messages that contain information normally of use only when
    // debugging a program

    LM_INFO,	    
    // Informational messages

    LM_NOTICE,   
    // Conditions that are not error conditions, but that may require
    // special handling

    LM_WARNING,  
    // Warning messages

    LM_STARTUP,  
    // Initialize the logger

    LM_ERROR,    
    // Error messages

    LM_CRITICAL,
    // Critical conditions, such as hard device errors

    LM_ALERT,
    // A condition that should be corrected immediately, such as a
    // corrupted system database

    LM_EMERGENCY,
    // A panic condition.  This is normally broadcast to all users

    LM_MAX
    // In ACE_Log_Priority, LM_MAX is aliased to LM_EMERGENCY rather than
    // being a distinct tag, but that is invalid IDL syntax. Make sure to
    // adjust for this
  };
  
  struct Log_Record
  {
    Log_Priority   type;      // Type of logging message
    long           time;      // Timestamp of the sender
    long           app_id;    // Process id of the sender
    long           host_addr; // IP address of the sender
    // @@ Matt, let's make this the same size as the max ACE_Log_Record string. 
    string         msg_data;  // The logging message
  };

  oneway void log(in Logger::Log_Record log_rec);
  // Transmit a Log_Record to the logging server

  //  attribute char verbose;
};

interface Logger_Factory
{
  // = TITLE
  //   Create a <Logger> of type <name>.
  
  Logger make_logger (in string name);
};

    
    
