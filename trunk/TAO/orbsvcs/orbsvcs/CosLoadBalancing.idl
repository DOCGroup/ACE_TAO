// -*- IDL -*-

//=============================================================================
/**
 *  @file    CosLoadBalancing.idl
 *
 *  $Id$
 *
 *  @author Object Management Group
 */
//=============================================================================


#ifndef COSLOADBALANCING_IDL
#define COSLOADBALANCING_IDL

//#include "tao/PortableInterceptor.pidl"
#include "PortableGroup.idl"
#include "orb.idl"

#pragma prefix "omg.org"

/**
 * @class CosLoadBalancing
 *
 * @brief This module defines the interfaces and data types used in
 * TAO's Load Balancing service.
 * @par
 * TAO's Load Balancer manages distribution of requests to replicas of
 * a given Object in an effort to ensure that the  applications/hosts
 * pointed to by the Object reference are as equally loaded as
 * possible, i.e. load balanced.
 * @par
 * The definition of 'load' is application specific, for example, some
 * applications may choose to load balance access to multiple
 * dedicated lines, or separate network interfaces, as well as more
 * traditional load balancing metrics, such as CPU or power load.
 */
module CosLoadBalancing
{
  typedef PortableGroup::Location Location;
  typedef PortableGroup::Properties Properties;

  /// Types used for obtaining and/or reporting loads
  typedef unsigned long LoadId;
  struct Load {
    LoadId id;
    float value;
  };
  typedef sequence<Load> LoadList;

//   typedef unsigned short MonitoringStyle;
//   const MonitoringStyle PULL = 0;
//   const MonitoringStyle PUSH = 1;
//   //  const MonitoringStyle NOT_MONITORED = 2;

//   typedef unsigned short MonitoringGranularity;
//   const MonitoringGranularity MEMB = 0;
//   const MonitoringGranularity LOC = 1;
//   const MonitoringGranularity LOC_AND_TYPE = 2;

//   typedef unsigned short ClientBinding;
//   const ClientBinding PER_SESSION = 0;
//   const ClientBinding PER_REQUEST = 1;
//   const ClientBinding ON_DEMAND = 2;

//   typedef unsigned short BalancingPolicy;
//   const BalancingPolicy NON_ADAPTIVE = 0;
//   const BalancingPolicy ADAPTIVE = 1;

  exception MonitorAlreadyPresent {};
  exception LocationNotFound {};

  exception StrategyNotAdaptive {};

  interface LoadManager;

  interface Strategy
  {
    readonly attribute string name;

    Properties get_properties ();

    // Report loads at given location to the Strategy.
    void push_loads (in PortableGroup::Location the_location,
                     in LoadList loads)
      raises (LocationNotFound,
              StrategyNotAdaptive);

    // Return the next member from the given object group which will
    // requests will be forward to.
    Object next_member (in PortableGroup::ObjectGroup object_group,
                        in LoadManager load_manager)
      raises (PortableGroup::ObjectGroupNotFound,
              PortableGroup::MemberNotFound);

    // Ask the Strategy to analyze loads, and enable or disable alerts
    // at object group members residing at appropriate locations.
    oneway void analyze_loads (in LoadManager load_manager);

    // The given loads at the given location should no longer be
    // considered when performing load analysis.
    void location_removed (in PortableGroup::Location the_location)
      raises (LocationNotFound);
  };

  struct StrategyInfo
  {
    
    Properties props;
  };

  interface LoadAlert
  {
    // Forward requests back to the load manager via the object group
    // reference.
    void alert (in Object object_group);

    // Stop forwarding requests, and begin accepting them again.
    void disable_alert ();
  };

  // Interface that all load monitors must implement.
  interface LoadMonitor
  {
    // Retrieve the location at which the LoadMonitor resides.
    readonly attribute Location the_location;

    // Retrieve the current load at the location LoadMonitor resides.
    readonly attribute LoadList loads;
  };

  // Specification of LoadManager Interface
  interface LoadManager
    : PortableGroup::PropertyManager,
      PortableGroup::ObjectGroupManager,
      PortableGroup::GenericFactory
  {
//     void register_load_notifier (in LoadNotifier load_notifier);

//     LoadNotifier get_load_notifier ()
//       raises (PortableGroup::InterfaceNotFound);

    // For the PUSH load monitoring style.
    void push_loads (in PortableGroup::Location the_location,
                     in LoadList loads)
      raises (StrategyNotAdaptive);

    // The following load monitor methods are only used for the PULL
    // load monitoring style.
    void register_load_monitor (in LoadMonitor load_monitor,
                                in PortableGroup::Location the_location)
      raises (MonitorAlreadyPresent);

    LoadMonitor get_load_monitor (in PortableGroup::Location the_location)
      raises (LocationNotFound);

    void remove_load_monitor (in PortableGroup::Location the_location)
      raises (LocationNotFound);

    void register_alerter (in PortableGroup::ObjectGroup object_group,
                           in PortableGroup::Location the_location,
                           in Object alert)
      raises (LocationNotFound);
  };

//   /// It's not clear this interface is needed for the Load Balancer.
//   interface LoadNotifier
//   {
//   };
};

#pragma prefix ""

#endif /* COSLOADBALANCING_IDL */
