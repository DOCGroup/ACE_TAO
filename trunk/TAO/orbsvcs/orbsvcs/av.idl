// $Id$

// IDL for Control and Management of Audio/Video Streams
// Revised Submission

#include "PropertyService.idl"

module AVStreams{

  struct QoS{
    string QoSType;
    PropertyService::Properties QoSParams;
  };

  typedef sequence<QoS> streamQoS;

  typedef sequence<string> flowSpec;

  typedef sequence<string> protocolSpec;

  typedef sequence<octet> key;

  // protocol names registered by OMG.
  // e.g., TCP, UDP, AAL5, IPX, RTP

  // This structure is defined for SFP1.0
  // Subsequent versions of the protocol may
  // specify new structures
  struct SFPStatus{
    boolean isFormatted;
    boolean isSpecialFormat;
    boolean seqNums;
    boolean timestamps;
    boolean sourceIndicators;
  };

  enum flowState {stopped, started, dead};

  enum dirType {dir_in, dir_out};

  struct flowStatus{
    string flowName;
    dirType directionality;
    flowState status;
    SFPStatus theFormat;
    QoS theQoS;
  };

  typedef PropertyService::Property streamEvent;

  exception notSupported {};
  exception PropertyException {};
  // An flow protocol related error
  exception FPError { string flow_name; };

  exception streamOpFailed{
    string reason;};
  exception streamOpDenied{
    string reason;};
  exception noSuchFlow{};
  exception QoSRequestFailed{
    string reason;};

  interface Basic_StreamCtrl : PropertyService::PropertySet {

    // Empty flowSpec => apply operation to all flows
    void stop(in flowSpec the_spec) raises (noSuchFlow);
    void start(in flowSpec the_spec) raises (noSuchFlow);
    void destroy(in flowSpec the_spec) raises (noSuchFlow);

    boolean modify_QoS(inout streamQoS new_qos,
                       in flowSpec the_spec)
      raises (noSuchFlow, QoSRequestFailed);

    // Called by StreamEndPoint when something goes wrong
    // with a flow
    oneway void push_event(
                           in streamEvent the_event);

    void set_FPStatus(in flowSpec the_spec,
                      in string fp_name,		// Only SFP1.0 currently 
                      // specified
                      in any fp_settings)		// Currently SFP accepts 
      // SFPStatus structure
      raises (noSuchFlow, FPError);

    Object get_flow_connection(in string flow_name) 
      raises (noSuchFlow, notSupported);

    void set_flow_connection(in string flow_name,
                             in Object flow_connection)
      raises (noSuchFlow, notSupported);
  };

  interface Negotiator{
    boolean negotiate(in Negotiator remote_negotiator,
                      in streamQoS qos_spec);
  };

  interface VDev;
  interface MMDevice;
  interface StreamEndPoint;
  interface StreamEndPoint_A;
  interface StreamEndPoint_B;

  interface StreamCtrl : Basic_StreamCtrl {

    boolean bind_devs(in MMDevice a_party, in MMDevice b_party,
                      inout streamQoS the_qos,
                      in flowSpec the_flows)
      raises (streamOpFailed, noSuchFlow, QoSRequestFailed);

    boolean bind(in StreamEndPoint_A a_party,
                 in StreamEndPoint_B b_party,
                 inout streamQoS the_qos,
                 in flowSpec the_flows)
      raises (streamOpFailed, noSuchFlow, QoSRequestFailed);

    void unbind_party(in StreamEndPoint the_ep,
                      in flowSpec the_spec)
      raises (streamOpFailed, noSuchFlow);

    void unbind()
      raises (streamOpFailed);
  };

  interface MCastConfigIf : PropertyService::PropertySet{

    boolean set_peer(
                     in Object peer,
                     inout streamQoS the_qos,
                     in flowSpec the_spec)
      raises (QoSRequestFailed, streamOpFailed);

    void configure(in PropertyService::Property a_configuration);

    void set_initial_configuration(
                                   in PropertyService::Properties initial);

    // Uses <format_name> standardised by OMG and IETF
    void set_format(in string flowName, in string format_name)
      raises (notSupported);

    // Note, some of these device params are standardised by OMG
    void set_dev_params(in string flowName,
                        in PropertyService::Properties new_params)
      raises(PropertyService::PropertyException,
             streamOpFailed);

  };

  interface StreamEndPoint : PropertyService::PropertySet{

    void stop(in flowSpec the_spec) raises (noSuchFlow);
    void start(in flowSpec the_spec) raises (noSuchFlow);
    void destroy(in flowSpec the_spec) raises (noSuchFlow);

    boolean connect(in StreamEndPoint responder,
                    inout streamQoS qos_spec,
                    in flowSpec the_spec)
      raises (noSuchFlow, QoSRequestFailed, streamOpFailed);

    boolean request_connection(
                               in StreamEndPoint initiator,
                               in boolean is_mcast,
                               inout streamQoS qos,
                               inout flowSpec the_spec)
      raises (streamOpDenied, noSuchFlow,
              QoSRequestFailed, FPError);

    boolean modify_QoS(inout streamQoS new_qos,
                       in flowSpec the_flows)
      raises (noSuchFlow, QoSRequestFailed);

    boolean set_protocol_restriction(in protocolSpec the_pspec);

    void disconnect(in flowSpec the_spec)
      raises (noSuchFlow, streamOpFailed);

    void set_FPStatus(in flowSpec the_spec,
                      in string fp_name,
                      in any fp_settings)
      raises (noSuchFlow, FPError);

    Object get_fep(in string flow_name)
      raises (notSupported, noSuchFlow);

    string add_fep(in Object the_fep)
      // Can fail for reasons {duplicateFepName, duplicateRef}
      raises (notSupported, streamOpFailed);

    void remove_fep(in string fep_name)
      raises (notSupported, streamOpFailed);

    void set_negotiator(in Negotiator new_negotiator);
    void set_key(in string flow_name, in key the_key);
    void set_source_id(in long source_id);
  };

  interface StreamEndPoint_A : StreamEndPoint{

    boolean multiconnect(inout streamQoS the_qos,
                         inout flowSpec the_spec)
      raises (noSuchFlow, QoSRequestFailed, streamOpFailed);

    boolean connect_leaf(in StreamEndPoint_B the_ep,
                         inout streamQoS the_qos,
                         in flowSpec the_flows)
      raises (streamOpFailed, noSuchFlow,
              QoSRequestFailed, notSupported);

    void disconnect_leaf(in StreamEndPoint_B the_ep,
                         in flowSpec theSpec)
      raises(streamOpFailed, noSuchFlow);
  };

  interface StreamEndPoint_B : StreamEndPoint {

    boolean multiconnect(inout streamQoS the_qos,
                         inout flowSpec the_spec)
      raises (streamOpFailed, noSuchFlow,
              QoSRequestFailed, FPError);
  };

  interface VDev : PropertyService::PropertySet{

    boolean set_peer(
                     in StreamCtrl the_ctrl,
                     in VDev the_peer_dev,
                     inout streamQoS the_qos,
                     in flowSpec the_spec)
      raises (noSuchFlow, QoSRequestFailed, streamOpFailed);

    boolean set_Mcast_peer(in StreamCtrl the_ctrl,
                           in MCastConfigIf a_mcastconfigif,
                           inout streamQoS the_qos,
                           in flowSpec the_spec)
      raises (noSuchFlow, QoSRequestFailed, streamOpFailed);

    void configure(in PropertyService::Property the_config_mesg)
      raises(PropertyException, streamOpFailed);

    // Uses <formatName> standardised by OMG and IETF
    void set_format(in string flowName, in string format_name)
      raises (notSupported);

    // Note, some of these device params are standardised by OMG
    void set_dev_params(in string flowName,
                        in PropertyService::Properties new_params)
      raises(PropertyException, streamOpFailed);

    boolean modify_QoS(inout streamQoS the_qos,
                       in flowSpec the_spec)
      raises (noSuchFlow, QoSRequestFailed);

  };

  interface MMDevice : PropertyService::PropertySet {
    StreamEndPoint_A create_A(
                              in StreamCtrl the_requester,
                              out VDev the_vdev,
                              inout streamQoS the_qos,
                              out boolean met_qos,
                              inout string named_vdev,
                              in flowSpec the_spec)
      raises(streamOpFailed, streamOpDenied, notSupported,
             QoSRequestFailed, noSuchFlow);

    StreamEndPoint_B create_B(
                              in StreamCtrl the_requester,
                              out VDev the_vdev,
                              inout streamQoS the_qos,
                              out boolean met_qos,
                              inout string named_vdev,
                              in flowSpec the_spec)
      raises(streamOpFailed, streamOpDenied, notSupported,
             QoSRequestFailed, noSuchFlow);

    StreamCtrl bind(in MMDevice peer_device,
                    inout streamQoS the_qos,
                    out boolean is_met,
                    in flowSpec the_spec)
      raises (streamOpFailed, noSuchFlow, QoSRequestFailed);

    StreamCtrl bind_mcast(in MMDevice first_peer,
                          inout streamQoS the_qos,
                          out boolean is_met,
                          in flowSpec the_spec)
      raises (streamOpFailed, noSuchFlow, QoSRequestFailed);

    void destroy(in StreamEndPoint the_ep, in string vdev_name)
      // ie VDev not found
      raises (notSupported);

    string add_fdev(in Object the_fdev)
      raises(notSupported, streamOpFailed);

    Object get_fdev(in string flow_name)
      raises(notSupported, noSuchFlow);

    void remove_fdev(in string flow_name)
      raises (notSupported, noSuchFlow);

  };

};

// Additional IDL for full profile
#include "AVStreams.idl"

module AVStreams_Full{

  exception protocolNotSupported{};
  exception formatNotSupported{};
  exception formatMismatch{};
  exception FEPMismatch{};
  exception alreadyConnected{};
  exception invalidSettings{string settings;};
  exception notConnected{};
  exception deviceQosMismatch{};
  exception failedToConnect{string reason;};
  exception failedToListen{string reason;};


  interface FlowProducer;
  interface FlowConsumer;
  interface FlowEndPoint;
  interface FDev;

  interface FlowConnection : PropertyService::PropertySet{
    void stop();
    void start();
    void destroy();

    boolean modify_QoS(
		
                       inout AVStreams::QoS new_qos)
      raises (AVStreams::QoSRequestFailed);

    boolean use_flow_protocol(
                              in string fp_name,
                              in any fp_settings)
      raises (AVStreams::FPError, AVStreams::notSupported);

    oneway void push_event(in AVStreams::streamEvent the_event);

    boolean connect_devs(in FDev a_party, in FDev b_party,
                         inout AVStreams::QoS the_qos)
      raises (AVStreams::streamOpFailed, 
              AVStreams::streamOpDenied, 
              AVStreams::QoSRequestFailed);

    boolean connect(
                    in FlowProducer flow_producer,
                    in FlowConsumer flow_consumer,
                    inout AVStreams::QoS the_qos)
      raises (formatMismatch, FEPMismatch, alreadyConnected);

    boolean disconnect();

    // The notSupported exception is raised where
    // flow cannot have multiple producers
    boolean add_producer(in FlowProducer flow_producer,
                         inout AVStreams::QoS the_qos)
      raises (alreadyConnected, AVStreams::notSupported);

    boolean add_consumer(in FlowConsumer flow_consumer,
                         inout AVStreams::QoS the_qos)
      raises (alreadyConnected);

    boolean drop(in FlowEndPoint target)
      raises (notConnected);
  };

  interface FlowEndPoint : PropertyService::PropertySet
    {
      boolean lock();
      void unlock();

      void stop();
      void start();
      void destroy();

      // Default is a nil object reference
      attribute AVStreams::StreamEndPoint related_sep;
      attribute FlowConnection related_flow_connection;

      FlowEndPoint get_connected_fep()
        raises (notConnected,
                AVStreams::notSupported);

      // syntax of fp_name is <flowProtocol>
      boolean use_flow_protocol(in string fp_name,
                                in any fp_settings)
        raises (AVStreams::FPError, AVStreams::notSupported);

      // set_format() initializes 'format' 
      // as current media format e.g. MPEG.
      void set_format(in string format)
        raises (AVStreams::notSupported);

      void set_dev_params(
                          in PropertyService::Properties new_settings)
        raises (PropertyService::PropertyException, 
                AVStreams::streamOpFailed);

      void set_protocol_restriction(in AVStreams::protocolSpec 
                                    the_spec)
        raises (AVStreams::notSupported);

      boolean is_fep_compatible(in FlowEndPoint fep) 
        raises (formatMismatch, deviceQosMismatch);

      boolean set_peer(
                       in FlowConnection the_fc,
		
                       in FlowEndPoint the_peer_fep,
                       inout AVStreams::QoS the_qos)
        raises (AVStreams::QoSRequestFailed,
                AVStreams::streamOpFailed);

      boolean set_Mcast_peer(
                             in FlowConnection the_fc,
                             in AVStreams::MCastConfigIf a_mcastconfigif,
                             inout AVStreams::QoS the_qos)
        raises (AVStreams::QoSRequestFailed);

    };

  interface FlowProducer : FlowEndPoint
    {
      boolean connect_to_peer(inout AVStreams::QoS the_qos,
                              in string address,

                              in string use_flow_protocol) // syntax <flowProtocol>
        raises(failedToConnect,
               AVStreams::FPError, AVStreams::QoSRequestFailed);

      string connect_mcast(inout AVStreams::QoS the_qos,
                           out boolean is_met,
                           in string address,
                           in string use_flow_protocol)
        raises (failedToConnect,
                AVStreams::notSupported,
                AVStreams::FPError,
                AVStreams::QoSRequestFailed);

      string get_rev_channel(in string pcol_name);

      void set_key(in AVStreams::key the_key);
      void set_source_id(in long source_id);
    };

  interface FlowConsumer : FlowEndPoint
    {


      // Needs to know its peer to choose its protocol correctly
      // Also to ask for a reverse channel for credit-based flow
      // control, if one is required
      string go_to_listen(
                          inout AVStreams::QoS the_qos,
                          in boolean is_mcast,
                          in FlowProducer peer,
                          inout string flowProtocol)// syntax <flowProtocol>
        raises(failedToListen, AVStreams::FPError, 
               AVStreams::QoSRequestFailed);
    };

  interface FDev : PropertyService::PropertySet {
    FlowProducer create_producer(
                                 in FlowConnection the_requester,
                                 inout AVStreams::QoS the_qos,
                                 out boolean met_qos,
                                 inout string named_fdev)
      raises(AVStreams::streamOpFailed,
             AVStreams::streamOpDenied,
             AVStreams::notSupported,
             AVStreams::QoSRequestFailed);

    FlowConsumer create_consumer(
                                 in FlowConnection the_requester,
                                 inout AVStreams::QoS the_qos,
                                 out boolean met_qos,
                                 inout string named_fdev)
      raises(AVStreams::streamOpFailed,
             AVStreams::streamOpDenied,
             AVStreams::notSupported,
             AVStreams::QoSRequestFailed);

    FlowConnection bind(in FDev peer_device,
                        inout AVStreams::QoS the_qos,
                        out boolean is_met)
      raises (AVStreams::streamOpFailed,
              AVStreams::QoSRequestFailed);

    FlowConnection bind_mcast(in FDev first_peer,
                              inout AVStreams::QoS the_qos,
                              out boolean is_met)
      raises (AVStreams::streamOpFailed,
              AVStreams::QoSRequestFailed);

    void destroy(in FlowEndPoint the_ep, in string fdev_name)
      // ie FDev not found
      raises (AVStreams::notSupported);
  };

  enum PositionOrigin {
    AbsolutePosition, RelativePosition, ModuloPosition
  };

  enum PositionKey {
    ByteCount, SampleCount, MediaTime
  };

  struct Position {
    PositionOrigin origin;
    PositionKey key;
    long value;
  };

  exception PostionKeyNotSupported { PositionKey key;};
  exception InvalidPosition { PositionKey key;};

  // MediaControl interface is similar to
  // ControlledStream interface in MSS.
  // It can be inherited by flow endpoints or
  // FlowConnection interfaces.
  interface MediaControl{

    exception PostionKeyNotSupported { PositionKey key;};

    Position get_media_position(
                                in PositionOrigin an_origin,
                                in PositionKey a_key)
      raises (PostionKeyNotSupported);

    void set_media_position(in Position a_position)
      raises (PostionKeyNotSupported, InvalidPosition);

    void start(in Position a_position)
      raises(InvalidPosition);
    void pause(in Position a_position)
      raises(InvalidPosition);
    void resume(in Position a_position)
      raises(InvalidPosition);
    void stop(in Position a_position)
      raises(InvalidPosition);
  };
};

