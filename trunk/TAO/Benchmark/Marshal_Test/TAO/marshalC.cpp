/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "marshalC.h"

#if !defined (__ACE_INLINE__)
#include "marshalC.i"
#endif /* !defined INLINE */

void Marshal::_tao_any_destructor (void *x)
{
  Marshal *tmp = ACE_static_cast (Marshal*,x);
  CORBA::release (tmp);
}

Marshal_ptr Marshal::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Marshal::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:Marshal:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (Marshal::_nil ());
      if (is_a == 0)
        return Marshal::_nil ();
    }
  return Marshal::_unchecked_narrow (obj, ACE_TRY_ENV);
}

Marshal_ptr Marshal::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Marshal::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Marshal_ptr default_proxy = Marshal::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_Marshal_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_Marshal_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, Marshal (stub), Marshal::_nil ());
      #if (TAO_HAS_SMART_PROXIES == 1)
        return TAO_Marshal_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
      #else 
        return default_proxy;
      #endif /*TAO_HAS_SMART_PROXIES == 1*/
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Marshal_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Marshal::_narrow
                  )
              )
        );
}

Marshal_ptr 
Marshal::_duplicate (Marshal_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

static const CORBA::Long _oc_Marshal_Marshal_Struct[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c2f), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c5f), ACE_NTOHL (0x53747275), ACE_NTOHL (0x63743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Marshal/Marshal_Struct:1.0
  15, ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c5f), ACE_NTOHL (0x53747275), ACE_NTOHL (0x63740000),  // name = Marshal_Struct
  5, // member count
  2, ACE_NTOHL (0x73000000),  // name = s
  CORBA::tk_short,

  2, ACE_NTOHL (0x6c000000),  // name = l
  CORBA::tk_long,

  2, ACE_NTOHL (0x63000000),  // name = c
  CORBA::tk_char,

  2, ACE_NTOHL (0x6f000000),  // name = o
  CORBA::tk_octet,

  2, ACE_NTOHL (0x64000000),  // name = d
  CORBA::tk_double,

};
static CORBA::TypeCode _tc_TAO_tc_Marshal_Marshal_Struct (CORBA::tk_struct, sizeof (_oc_Marshal_Marshal_Struct), (char *) &_oc_Marshal_Marshal_Struct, 0, sizeof (Marshal::Marshal_Struct));
CORBA::TypeCode_ptr Marshal::_tc_Marshal_Struct = &_tc_TAO_tc_Marshal_Marshal_Struct;

void Marshal::Marshal_Struct::_tao_any_destructor (void *x)
{
  Marshal_Struct *tmp = ACE_static_cast (Marshal_Struct*,x);
  delete tmp;
}

static const CORBA::Long _oc_Marshal_discrim[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  24, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c2f), ACE_NTOHL (0x64697363), ACE_NTOHL (0x72696d3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Marshal/discrim:1.0
  8, ACE_NTOHL (0x64697363), ACE_NTOHL (0x72696d00),  // name = discrim
  7, // member count
  6, ACE_NTOHL (0x655f3074), ACE_NTOHL (0x68000000),  // name = e_0th
  6, ACE_NTOHL (0x655f3173), ACE_NTOHL (0x74000000),  // name = e_1st
  6, ACE_NTOHL (0x655f326e), ACE_NTOHL (0x64000000),  // name = e_2nd
  6, ACE_NTOHL (0x655f3372), ACE_NTOHL (0x64000000),  // name = e_3rd
  6, ACE_NTOHL (0x655f3474), ACE_NTOHL (0x68000000),  // name = e_4th
  6, ACE_NTOHL (0x655f3574), ACE_NTOHL (0x68000000),  // name = e_5th
  6, ACE_NTOHL (0x655f3674), ACE_NTOHL (0x68000000),  // name = e_6th
};
static CORBA::TypeCode _tc_TAO_tc_Marshal_discrim (CORBA::tk_enum, sizeof (_oc_Marshal_discrim), (char *) &_oc_Marshal_discrim, 0, sizeof (Marshal::discrim));
CORBA::TypeCode_ptr Marshal::_tc_discrim = &_tc_TAO_tc_Marshal_discrim;

// *************************************************************
// Operations for union Marshal::Marshal_Union
// *************************************************************

// default constructor
Marshal::Marshal_Union::Marshal_Union (void)
{
  ACE_OS::memset (&this->disc_, 0, sizeof (this->disc_));
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = Marshal::e_0th;
}

// copy constructor
Marshal::Marshal_Union::Marshal_Union (const ::Marshal::Marshal_Union &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Marshal::e_0th:
    {
      // set the value
      this->u_.s_ = u.u_.s_;
    }
    break;
    case Marshal::e_1st:
    {
      // set the value
      this->u_.l_ = u.u_.l_;
    }
    break;
    case Marshal::e_2nd:
    {
      // set the value
      this->u_.c_ = u.u_.c_;
    }
    break;
    case Marshal::e_3rd:
    {
      // set the value
      this->u_.o_ = u.u_.o_;
    }
    break;
    case Marshal::e_4th:
    {
      // set the value
      this->u_.d_ = u.u_.d_;
    }
    break;
    case Marshal::e_5th:
    default:
    {
      this->u_.ms_ = u.u_.ms_;
    }
    break;
  }
}

// destructor
Marshal::Marshal_Union::~Marshal_Union (void)
{
  // finalize
  this->_reset (this->disc_, 1);
}

void Marshal::Marshal_Union::_tao_any_destructor (void *x)
{
  Marshal_Union *tmp = ACE_static_cast (Marshal_Union*,x);
  delete tmp;
}

// assignment operator
Marshal::Marshal_Union &
Marshal::Marshal_Union::operator= (const ::Marshal::Marshal_Union &u)
{
  this->_reset (u.disc_, 0);
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case Marshal::e_0th:
    {
      // set the value
      this->u_.s_ = u.u_.s_;
    }
    break;
    case Marshal::e_1st:
    {
      // set the value
      this->u_.l_ = u.u_.l_;
    }
    break;
    case Marshal::e_2nd:
    {
      // set the value
      this->u_.c_ = u.u_.c_;
    }
    break;
    case Marshal::e_3rd:
    {
      // set the value
      this->u_.o_ = u.u_.o_;
    }
    break;
    case Marshal::e_4th:
    {
      // set the value
      this->u_.d_ = u.u_.d_;
    }
    break;
    case Marshal::e_5th:
    default:
    {
      this->u_.ms_ = u.u_.ms_;
    }
    break;
  }
  return *this;
}

// reset method to reset old values of a union
void Marshal::Marshal_Union::_reset (Marshal::discrim, CORBA::Boolean /*finalize*/)
{
  switch (this->disc_)
  {
    case Marshal::e_0th:
      break;
    case Marshal::e_1st:
      break;
    case Marshal::e_2nd:
      break;
    case Marshal::e_3rd:
      break;
    case Marshal::e_4th:
      break;
    case Marshal::e_5th:
    default:
      break;
    
  }
}

static const CORBA::Long _oc_Marshal_Marshal_Union[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c2f), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c5f), ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e3a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Marshal/Marshal_Union:1.0
  14, ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c5f), ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e000000),  // name = Marshal_Union
  CORBA::tk_enum, // typecode kind
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    24, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c2f), ACE_NTOHL (0x64697363), ACE_NTOHL (0x72696d3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Marshal/discrim:1.0
    8, ACE_NTOHL (0x64697363), ACE_NTOHL (0x72696d00),  // name = discrim
    7, // member count
    6, ACE_NTOHL (0x655f3074), ACE_NTOHL (0x68000000),  // name = e_0th
    6, ACE_NTOHL (0x655f3173), ACE_NTOHL (0x74000000),  // name = e_1st
    6, ACE_NTOHL (0x655f326e), ACE_NTOHL (0x64000000),  // name = e_2nd
    6, ACE_NTOHL (0x655f3372), ACE_NTOHL (0x64000000),  // name = e_3rd
    6, ACE_NTOHL (0x655f3474), ACE_NTOHL (0x68000000),  // name = e_4th
    6, ACE_NTOHL (0x655f3574), ACE_NTOHL (0x68000000),  // name = e_5th
    6, ACE_NTOHL (0x655f3674), ACE_NTOHL (0x68000000),  // name = e_6th

  6, // default used index
  6, // member count
  0x00000000, // union case label (evaluated value)
  2, ACE_NTOHL (0x73000000),  // name = s
  CORBA::tk_short,

  0x00000001, // union case label (evaluated value)
  2, ACE_NTOHL (0x6c000000),  // name = l
  CORBA::tk_long,

  0x00000002, // union case label (evaluated value)
  2, ACE_NTOHL (0x63000000),  // name = c
  CORBA::tk_char,

  0x00000003, // union case label (evaluated value)
  2, ACE_NTOHL (0x6f000000),  // name = o
  CORBA::tk_octet,

  0x00000004, // union case label (evaluated value)
  2, ACE_NTOHL (0x64000000),  // name = d
  CORBA::tk_double,

  0x00000005, // union case label (evaluated value)
  3, ACE_NTOHL (0x6d730000),  // name = ms
  CORBA::tk_struct, // typecode kind
  124, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c2f), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c5f), ACE_NTOHL (0x53747275), ACE_NTOHL (0x63743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Marshal/Marshal_Struct:1.0
    15, ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c5f), ACE_NTOHL (0x53747275), ACE_NTOHL (0x63740000),  // name = Marshal_Struct
    5, // member count
    2, ACE_NTOHL (0x73000000),  // name = s
    CORBA::tk_short,

    2, ACE_NTOHL (0x6c000000),  // name = l
    CORBA::tk_long,

    2, ACE_NTOHL (0x63000000),  // name = c
    CORBA::tk_char,

    2, ACE_NTOHL (0x6f000000),  // name = o
    CORBA::tk_octet,

    2, ACE_NTOHL (0x64000000),  // name = d
    CORBA::tk_double,


};
static CORBA::TypeCode _tc_TAO_tc_Marshal_Marshal_Union (CORBA::tk_union, sizeof (_oc_Marshal_Marshal_Union), (char *) &_oc_Marshal_Marshal_Union, 0, sizeof (Marshal::Marshal_Union));
CORBA::TypeCode_ptr Marshal::_tc_Marshal_Union = &_tc_TAO_tc_Marshal_Marshal_Union;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_MARSHAL_ANYSEQ_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_MARSHAL_ANYSEQ_CS_

  void
  Marshal::_TAO_Unbounded_Sequence_Marshal_AnySeq::_allocate_buffer (CORBA::ULong length)
  {
    CORBA::Any* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_Marshal_AnySeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      CORBA::Any *old = ACE_reinterpret_cast (CORBA::Any *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_Marshal_AnySeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  Marshal::_TAO_Unbounded_Sequence_Marshal_AnySeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    CORBA::Any *tmp = ACE_reinterpret_cast (CORBA::Any *,this->buffer_);
    
    _TAO_Unbounded_Sequence_Marshal_AnySeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  Marshal::_TAO_Unbounded_Sequence_Marshal_AnySeq::~_TAO_Unbounded_Sequence_Marshal_AnySeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_MARSHAL_ANYSEQ_CS_)
#define _MARSHAL_ANYSEQ_CS_

// *************************************************************
// Marshal::AnySeq
// *************************************************************

Marshal::AnySeq::AnySeq (void)
{}
Marshal::AnySeq::AnySeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_Marshal_AnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Any>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Marshal::AnySeq::AnySeq (CORBA::ULong max, CORBA::ULong length, CORBA::Any *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_Marshal_AnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Any>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Marshal::AnySeq::AnySeq (const AnySeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_Marshal_AnySeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Any>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Marshal::AnySeq::~AnySeq (void) // dtor
{}
void Marshal::AnySeq::_tao_any_destructor (void *x)
{
  AnySeq *tmp = ACE_static_cast (AnySeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_Marshal_AnySeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  23, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c2f), ACE_NTOHL (0x416e7953), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Marshal/AnySeq:1.0
  7, ACE_NTOHL (0x416e7953), ACE_NTOHL (0x65710000),  // name = AnySeq
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_any,

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_Marshal_AnySeq (CORBA::tk_alias, sizeof (_oc_Marshal_AnySeq), (char *) &_oc_Marshal_AnySeq, 0, sizeof (Marshal::AnySeq));
CORBA::TypeCode_ptr Marshal::_tc_AnySeq = &_tc_TAO_tc_Marshal_AnySeq;

static const CORBA::Long _oc_Marshal_Marshal_Recursive[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c2f), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c5f), ACE_NTOHL (0x52656375), ACE_NTOHL (0x72736976), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Marshal/Marshal_Recursive:1.0
  18, ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c5f), ACE_NTOHL (0x52656375), ACE_NTOHL (0x72736976), ACE_NTOHL (0x65000000),  // name = Marshal_Recursive
  2, // member count
  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

  5, ACE_NTOHL (0x6e657874), ACE_NTOHL (0x0),  // name = next
  CORBA::tk_sequence, // typecode kind
  16, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    0xffffffff, // indirection
    0xffffff84, // negative offset (-124)
    0U,

};
static CORBA::TypeCode _tc_TAO_tc_Marshal_Marshal_Recursive (CORBA::tk_struct, sizeof (_oc_Marshal_Marshal_Recursive), (char *) &_oc_Marshal_Marshal_Recursive, 0, sizeof (Marshal::Marshal_Recursive));
CORBA::TypeCode_ptr Marshal::_tc_Marshal_Recursive = &_tc_TAO_tc_Marshal_Marshal_Recursive;

void Marshal::Marshal_Recursive::_tao_any_destructor (void *x)
{
  Marshal_Recursive *tmp = ACE_static_cast (Marshal_Recursive*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
#if !defined (__TAO_UNBOUNDED_SEQUENCE_MARSHAL_MARSHAL_RECURSIVE__TAO_SEQ_MARSHAL_RECURSIVE_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_MARSHAL_MARSHAL_RECURSIVE__TAO_SEQ_MARSHAL_RECURSIVE_CS_

  void
  Marshal::Marshal_Recursive::_TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive::_allocate_buffer (CORBA::ULong length)
  {
    Marshal::Marshal_Recursive* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      Marshal::Marshal_Recursive *old = ACE_reinterpret_cast (Marshal::Marshal_Recursive *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  Marshal::Marshal_Recursive::_TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    Marshal::Marshal_Recursive *tmp = ACE_reinterpret_cast (Marshal::Marshal_Recursive *,this->buffer_);
    
    _TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  Marshal::Marshal_Recursive::_TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive::~_TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_MARSHAL_MARSHAL_RECURSIVE__TAO_SEQ_MARSHAL_RECURSIVE_CS_)
#define _MARSHAL_MARSHAL_RECURSIVE__TAO_SEQ_MARSHAL_RECURSIVE_CS_

// *************************************************************
// Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive
// *************************************************************

Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive::_tao_seq_Marshal_Recursive (void)
{}
Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive::_tao_seq_Marshal_Recursive (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<Marshal::Marshal_Recursive>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive::_tao_seq_Marshal_Recursive (CORBA::ULong max, CORBA::ULong length, Marshal::Marshal_Recursive *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<Marshal::Marshal_Recursive>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive::_tao_seq_Marshal_Recursive (const _tao_seq_Marshal_Recursive &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<Marshal::Marshal_Recursive>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive::~_tao_seq_Marshal_Recursive (void) // dtor
{}
void Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive::_tao_any_destructor (void *x)
{
  _tao_seq_Marshal_Recursive *tmp = ACE_static_cast (_tao_seq_Marshal_Recursive*,x);
  delete tmp;
}


#endif /* end #if !defined */

void Marshal::test_short (
    CORBA::Short s1,
    CORBA::Short_out s2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_short",
      10,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_short",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << s1)              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> s2)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_short",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_short",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_long (
    CORBA::Long l1,
    CORBA::Long_out l2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_long",
      9,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_long",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << l1)              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> l2)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_long",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_long",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_octet (
    CORBA::Octet o1,
    CORBA::Octet_out o2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_octet",
      10,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_octet",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << CORBA::Any::from_octet (o1))              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> CORBA::Any::to_octet (o2))
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_octet",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_octet",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_char (
    CORBA::Char c1,
    CORBA::Char_out c2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_char",
      9,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_char",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << CORBA::Any::from_char (c1))              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> CORBA::Any::to_char (c2))
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_char",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_char",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_double (
    CORBA::Double d1,
    CORBA::Double_out d2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_double",
      11,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_double",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << d1)              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> d2)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_double",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_double",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_struct (
    const Marshal::Marshal_Struct & ms1,
    Marshal::Marshal_Struct_out ms2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_struct",
      11,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_struct",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << ms1)              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> ms2)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_struct",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_struct",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_union (
    const Marshal::Marshal_Union & u1,
    Marshal::Marshal_Union_out u2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_union",
      10,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_union",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << u1)              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> u2)
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_union",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_union",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_any (
    const CORBA::Any & a1,
    CORBA::Any_out a2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  ACE_NEW (a2.ptr (), CORBA::Any);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_any",
      8,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_any",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << a1)              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> *a2.ptr ())
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_any",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_any",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_sequence (
    const Marshal::AnySeq & as1,
    Marshal::AnySeq_out as2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  ACE_NEW (as2.ptr (), Marshal::AnySeq);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_sequence",
      13,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_sequence",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << as1)              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> *as2.ptr ())
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_sequence",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_sequence",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

void Marshal::test_recursive (
    const Marshal::Marshal_Recursive & mr1,
    Marshal::Marshal_Recursive_out mr2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  ACE_DECLARE_NEW_CORBA_ENV;

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  ACE_NEW (mr2.ptr (), Marshal::Marshal_Recursive);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "test_recursive",
      14,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
    TAO_ClientRequestInterceptor_Adapter
      _tao_vfr (istub->orb_core ()->orb ()->_get_client_interceptor (ACE_TRY_ENV));
    ACE_CHECK;
    PortableInterceptor::Cookies _tao_cookies;
    CORBA::NVList_var _tao_interceptor_args;
    if (_tao_vfr.valid ())
      {
        istub->orb_core ()->orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
        ACE_CHECK;
      }

    ACE_TRY
      {
#endif /* TAO_HAS_INTERCEPTORS */

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_INTERCEPTOR (
            _tao_vfr.preinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_recursive",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        CORBA::Short flag = 131;
        // Tremporary hack until GIOP 1.2 is implemented.
        
        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        TAO_INTERCEPTOR_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << mr1)              
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                TAO_INTERCEPTOR_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          TAO_INTERCEPTOR_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> *mr2.ptr ())
          ))
          TAO_INTERCEPTOR_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        TAO_INTERCEPTOR (
            _tao_vfr.postinvoke (
                _tao_call.request_id (),
                1,
                this,
                "test_recursive",
                _tao_call.service_info (),
                _tao_interceptor_args.inout (),
                _tao_cookies,
                ACE_TRY_ENV
              )
          );
        TAO_INTERCEPTOR_CHECK;
        break;
        
      }
#if (TAO_HAS_INTERCEPTORS == 1)
      
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_call.request_id (),
          1,
          this,
          "test_recursive",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

}

CORBA::Boolean Marshal::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Marshal:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *Marshal::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &Marshal::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* Marshal::_interface_repository_id (void) const
{
  return "IDL:Marshal:1.0";
}

TAO_Marshal_Default_Proxy_Factory::TAO_Marshal_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_Marshal_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

TAO_Marshal_Default_Proxy_Factory::~TAO_Marshal_Default_Proxy_Factory (void)
{
}

Marshal_ptr
TAO_Marshal_Default_Proxy_Factory::create_proxy (
    ::Marshal_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

TAO_Marshal_Proxy_Factory_Adapter::TAO_Marshal_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

TAO_Marshal_Proxy_Factory_Adapter::~TAO_Marshal_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
TAO_Marshal_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_Marshal_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
TAO_Marshal_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is 
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

Marshal_ptr
TAO_Marshal_Proxy_Factory_Adapter::create_proxy (
    ::Marshal_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_Marshal_Default_Proxy_Factory (1), 
         0);
      
    
  return this->proxy_factory_->create_proxy (proxy);
}

TAO_Marshal_Smart_Proxy_Base::TAO_Marshal_Smart_Proxy_Base (void)
{
}

TAO_Marshal_Smart_Proxy_Base::~TAO_Marshal_Smart_Proxy_Base (void)
{
}

TAO_Stub *
TAO_Marshal_Smart_Proxy_Base::_stubobj (void) const
{
  return this->base_proxy_->_stubobj ();
}

void TAO_Marshal_Smart_Proxy_Base::test_short  (
    CORBA::Short s1,
    CORBA::Short_out s2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_short (
      s1,
      s2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_long  (
    CORBA::Long l1,
    CORBA::Long_out l2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_long (
      l1,
      l2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_octet  (
    CORBA::Octet o1,
    CORBA::Octet_out o2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_octet (
      o1,
      o2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_char  (
    CORBA::Char c1,
    CORBA::Char_out c2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_char (
      c1,
      c2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_double  (
    CORBA::Double d1,
    CORBA::Double_out d2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_double (
      d1,
      d2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_struct  (
    const Marshal::Marshal_Struct & ms1,
    Marshal::Marshal_Struct_out ms2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_struct (
      ms1,
      ms2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_union  (
    const Marshal::Marshal_Union & u1,
    Marshal::Marshal_Union_out u2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_union (
      u1,
      u2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_any  (
    const CORBA::Any & a1,
    CORBA::Any_out a2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_any (
      a1,
      a2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_sequence  (
    const Marshal::AnySeq & as1,
    Marshal::AnySeq_out as2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_sequence (
      as1,
      as2
    );

}

void TAO_Marshal_Smart_Proxy_Base::test_recursive  (
    const Marshal::Marshal_Recursive & mr1,
    Marshal::Marshal_Recursive_out mr2
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->get_proxy ()->test_recursive (
      mr1,
      mr2
    );

}

Marshal_ptr
TAO_Marshal_Smart_Proxy_Base::get_proxy (void)
  
{
  // Obtain the real proxy stored in <base_proxy_>
  if (CORBA::is_nil (this->proxy_.in ()))
    {
      // Necessary to do this else you are stuck in an infinte loop
      // creating smart proxies!
      TAO_Marshal_PROXY_FACTORY_ADAPTER::instance ()->unregister_proxy_factory ();
      this->proxy_ = ::Marshal::_unchecked_narrow (this->base_proxy_.in ());
    }
    
    return this->proxy_.in ();
  }
  
    #if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
    defined (ACE_HAS_GNU_REPO)
  template class ACE_Singleton<TAO_Marshal_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX >;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #pragma instantiate ACE_Singleton<TAO_Marshal_Proxy_Factory_Adapter, ACE_SYNCH_RECURSIVE_MUTEX>
  #endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
  
    static const CORBA::Long _oc_Marshal[] =
  {
    TAO_ENCAP_BYTE_ORDER, // byte order
    16, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Marshal:1.0
    8, ACE_NTOHL (0x4d617273), ACE_NTOHL (0x68616c00),  // name = Marshal
};
  static CORBA::TypeCode _tc_TAO_tc_Marshal (CORBA::tk_objref, sizeof (_oc_Marshal), (char *) &_oc_Marshal, 0, sizeof (Marshal));
  CORBA::TypeCode_ptr _tc_Marshal = &_tc_TAO_tc_Marshal;

  Marshal_ptr (*_TAO_collocation_Marshal_Stub_Factory_function_pointer) (
      CORBA::Object_ptr obj
    ) = 0;
    void operator<<= (CORBA::Any &_tao_any, Marshal_ptr _tao_elem)
  {
    TAO_OutputCDR stream;
    if (stream << _tao_elem)
    {
      _tao_any._tao_replace (
          _tc_Marshal, 
          TAO_ENCAP_BYTE_ORDER,
          stream.begin (),
          1,
          Marshal::_duplicate (_tao_elem),
          Marshal::_tao_any_destructor
        );
    }
  }

  CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Marshal_ptr &_tao_elem)
  {
    ACE_TRY_NEW_ENV
    {
      _tao_elem = Marshal::_nil ();
      CORBA::TypeCode_var type = _tao_any.type ();
      if (!type->equivalent (_tc_Marshal, ACE_TRY_ENV)) // not equal
        {
          return 0;
        }
      ACE_TRY_CHECK;
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::Object_var _tao_obj_var;
      if (stream >> _tao_obj_var.out ())
      {
        _tao_elem = Marshal::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
        ACE_TRY_CHECK;
        
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            _tc_Marshal,
            1,
            _tao_elem,
            Marshal::_tao_any_destructor
          );
        return 1;
      }
    }
    ACE_CATCHANY
    {
      _tao_elem = Marshal::_nil ();
      return 0;
    }
    ACE_ENDTRY;
    _tao_elem = Marshal::_nil ();
    return 0;
  }

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
      defined (ACE_HAS_GNU_REPO)
      template class TAO_Object_Field_T<Marshal,Marshal_var>;
    template class TAO_Object_Manager<Marshal,Marshal_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Field_T<Marshal,Marshal_var>
#  pragma instantiate TAO_Object_Manager<Marshal,Marshal_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const Marshal::Marshal_Struct &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      Marshal::_tc_Marshal_Struct,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, Marshal::Marshal_Struct *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      Marshal::_tc_Marshal_Struct,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      Marshal::Marshal_Struct::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Marshal::Marshal_Struct *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const Marshal::Marshal_Struct*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const Marshal::Marshal_Struct *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Marshal::_tc_Marshal_Struct, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const Marshal::Marshal_Struct*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      Marshal::Marshal_Struct *tmp;
      ACE_NEW_RETURN (tmp, Marshal::Marshal_Struct, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Marshal::_tc_Marshal_Struct,
            1,
            ACE_static_cast (void *, tmp),
            Marshal::Marshal_Struct::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, Marshal::discrim _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      Marshal::_tc_discrim,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Marshal::discrim &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Marshal::_tc_discrim, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const Marshal::Marshal_Union &_tao_elem
  )
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        Marshal::_tc_Marshal_Union,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (
    CORBA::Any &_tao_any,
    Marshal::Marshal_Union *_tao_elem
  )
{
  TAO_OutputCDR stream;
  if (stream << *_tao_elem)
  {
    _tao_any._tao_replace (
        Marshal::_tc_Marshal_Union,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        _tao_elem,
        Marshal::Marshal_Union::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    Marshal::Marshal_Union *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast(
      const Marshal::Marshal_Union*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const Marshal::Marshal_Union *&_tao_elem
  )
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Marshal::_tc_Marshal_Union, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const Marshal::Marshal_Union*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      Marshal::Marshal_Union *tmp;
      ACE_NEW_RETURN (tmp, Marshal::Marshal_Union, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Marshal::_tc_Marshal_Union,
            1,
            ACE_static_cast (void *, tmp),
            Marshal::Marshal_Union::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete  tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const Marshal::AnySeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        Marshal::_tc_AnySeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, Marshal::AnySeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      Marshal::_tc_AnySeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      Marshal::AnySeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Marshal::AnySeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const Marshal::AnySeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const Marshal::AnySeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Marshal::_tc_AnySeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const Marshal::AnySeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      Marshal::AnySeq *tmp;
      ACE_NEW_RETURN (tmp, Marshal::AnySeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Marshal::_tc_AnySeq,
            1,
            ACE_static_cast (void *, tmp),
            Marshal::AnySeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const Marshal::Marshal_Recursive &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      Marshal::_tc_Marshal_Recursive,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, Marshal::Marshal_Recursive *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      Marshal::_tc_Marshal_Recursive,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      Marshal::Marshal_Recursive::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Marshal::Marshal_Recursive *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const Marshal::Marshal_Recursive*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const Marshal::Marshal_Recursive *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (Marshal::_tc_Marshal_Recursive, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const Marshal::Marshal_Recursive*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      Marshal::Marshal_Recursive *tmp;
      ACE_NEW_RETURN (tmp, Marshal::Marshal_Recursive, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            Marshal::_tc_Marshal_Recursive,
            1,
            ACE_static_cast (void *, tmp),
            Marshal::Marshal_Recursive::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Marshal::AnySeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Marshal::AnySeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}


#if !defined _TAO_CDR_OP_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive_CPP_
#define _TAO_CDR_OP_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive_CPP_

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Marshal::Marshal_Recursive::_tao_seq_Marshal_Recursive &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

#endif /* _TAO_CDR_OP_Marshal_Marshal_Recursive__tao_seq_Marshal_Recursive_CPP_ */

