// ============================================================================
//
// = LIBRARY
//    TAO IDL
// 
// = FILENAME
//    be_helper.cpp
//
// = DESCRIPTION
//   Provides helper classes to print generated code to the output
//
// = AUTHOR
//    Copyright 1994-1995 by Sun Microsystems, Inc.
//    and 
//    Aniruddha Gokhale
// 
// ============================================================================

#include	"idl.h"
#include	"idl_extern.h"
#include	"be.h"

static const char copyright [] =
"// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******\n\
// TAO ORB and the TAO IDL Compiler have been developed by Washington \n\
// University Computer Science's Distributed Object Computing Group.\n\
//\n\
// Information on TAO is available at\n\
//                 http://www.cs.wustl.edu/~schmidt/TAO.html\n"; 

TAO_NL::TAO_NL (void)
{
}

// methods of the TAO_OutStream class

TAO_OutStream::TAO_OutStream (void)
  : fp_ (NULL),
    indent_level_ (0)
{
}

TAO_OutStream::~TAO_OutStream (void)
{
  // close the underlying I/O handle only if it exists
  if (fp_)
    {
      ACE_OS::fclose (fp_);
      fp_ = NULL;
    }
  indent_level_ = 0;
}

int
TAO_OutStream::open (const char *fname, TAO_OutStream::STREAM_TYPE st)
{
  if (fname)
    {
      // file name exists, open an I/O file handle
      fp_ = ACE_OS::fopen (fname, "w");
      if (fp_)
        {
          this->st_ = st;
          // put the copyright notice
          ACE_OS::fprintf (fp_, "%s\n", copyright);
          return 0;
        }
      else
        return -1;
    }
  else
    {
      return -1;
    }
}

// set and get the stream type
void
TAO_OutStream::stream_type (TAO_OutStream::STREAM_TYPE st)
{
  this->st_ = st;
}

TAO_OutStream::STREAM_TYPE
TAO_OutStream::stream_type (void)
{
  return this->st_;
}

// indentation
int
TAO_OutStream::incr_indent (unsigned short flag)
{
  indent_level_++;
  if (flag)
    return this->indent ();
  else
    return 0; // do not indent output
}

// indentation
int
TAO_OutStream::decr_indent (unsigned short flag)
{
  indent_level_--;
  if (flag)
    return this->indent ();
  else
    return 0; // do not indent output
}

int
TAO_OutStream::reset (void)
{
  indent_level_ = 0;
  return 0;
}

// indented print
int
TAO_OutStream::indent (void)
{
  int i;
  // based on the current indentation level, leave appropriate number of blank
  // spaces in the output
  if (this->indent_level_ > 0)
    {
      for (i=0; i < this->indent_level_; i++)
        {
          ACE_OS::fprintf (this->fp_, "  ");
        }
    }
  return 0;
}

// printf style variable argument print
int 
TAO_OutStream::print (const char *format, ...)
{
  int result = 0;
  va_list ap;
  va_start (ap, format);
  ACE_OSCALL (::vfprintf (this->fp_, format, ap), int, -1, result);
  va_end (ap);
  return result;
}

TAO_OutStream &
TAO_OutStream::operator<< (const char *str)
{
  ACE_OS::fprintf (this->fp_, "%s", str);
  return *this;
}

TAO_OutStream &
TAO_OutStream::operator<< (const long num)
{
  ACE_OS::fprintf (this->fp_, "%ld", num);
  return *this;
}

TAO_OutStream &
TAO_OutStream::operator<< (const TAO_NL nl)
{
  // Macro to avoid "warning: unused parameter" type warning.
  ACE_UNUSED_ARG (nl);

  ACE_OS::fprintf (this->fp_ , "\n");
  this->indent ();
  return *this;
}

TAO_OutStream &
TAO_OutStream::operator<< (Identifier *id)
{
  return this->print (id);
}

TAO_OutStream &
TAO_OutStream::operator<< (UTL_IdList *id)
{
  return this->print (id);
}

TAO_OutStream &
TAO_OutStream::operator<< (AST_Expression *expr)
{
  return this->print (expr);
}

