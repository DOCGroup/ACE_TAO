--- lex.yy.cpp.new	2004-08-27 21:34:13.000000000 -0500
+++ lex.yy.cpp	2004-08-27 21:53:40.000000000 -0500
@@ -1,369 +1,290 @@
-lex -L -t fe/idl.ll
-
-#line 3 "<stdout>"
-
-#define  YY_INT_ALIGNED short int
-
 /* A lexical scanner generated by flex */
 
+/* Scanner skeleton version:
+ * $Id$
+ */
+
 #define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 31
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
+#define TAO_YY_FLEX_MAJOR_VERSION 2
+#define TAO_YY_FLEX_MINOR_VERSION 5
 
-/* First, we deal with  platform-specific or compiler-specific issues. */
 
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
 
-/* end standard C headers. */
+/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
+#ifdef c_plusplus
+#ifndef __cplusplus
+#define __cplusplus
+#endif
+#endif
 
-/* flex integer type definitions */
 
-#ifndef FLEXINT_H
-#define FLEXINT_H
+#ifdef __cplusplus
 
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+#include "ace/os_include/os_stdio.h"
+#include "ace/os_include/os_ctype.h"
 
-#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
+/* Use prototypes in function declarations. */
+#define TAO_YY_USE_PROTOS
 
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
+/* The "const" storage-class-modifier is valid. */
+#define TAO_YY_USE_CONST
 
-#endif /* ! FLEXINT_H */
+#else   /* ! __cplusplus */
 
-#ifdef __cplusplus
+#ifdef __STDC__
 
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
+#define TAO_YY_USE_PROTOS
+#define TAO_YY_USE_CONST
 
-#else	/* ! __cplusplus */
+#endif  /* __STDC__ */
+#endif  /* ! __cplusplus */
 
-#if __STDC__
+#ifdef __TURBOC__
+ #pragma warn -rch
+ #pragma warn -use
+#define TAO_YY_USE_CONST
+#define TAO_YY_USE_PROTOS
+#endif
 
-#define YY_USE_CONST
+#ifdef TAO_YY_USE_CONST
+#define tao_yyconst const
+#else
+#define tao_yyconst
+#endif
 
-#endif	/* __STDC__ */
-#endif	/* ! __cplusplus */
 
-#ifdef YY_USE_CONST
-#define yyconst const
+#ifdef TAO_YY_USE_PROTOS
+#define TAO_YY_PROTO(proto) proto
 #else
-#define yyconst
+#define TAO_YY_PROTO(proto) ()
 #endif
 
 /* Returned upon end-of-file. */
-#define YY_NULL 0
+#define TAO_YY_NULL 0
 
 /* Promotes a possibly negative, possibly signed char to an unsigned
  * integer for use as an array index.  If the signed char is negative,
  * we want to instead treat it as an 8-bit unsigned char, hence the
  * double cast.
  */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+#define TAO_YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
 
 /* Enter a start condition.  This macro really ought to take a parameter,
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN (yy_start) = 1 + 2 *
+#define BEGIN tao_yy_start = 1 + 2 *
 
 /* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * to BEGIN to return to the state.  The TAO_YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
+#define TAO_YY_START ((tao_yy_start - 1) / 2)
+#define TAO_YYSTATE TAO_YY_START
 
 /* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+#define TAO_YY_STATE_EOF(state) (TAO_YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
+#define TAO_YY_NEW_FILE tao_yyrestart( tao_yyin )
 
-#define YY_END_OF_BUFFER_CHAR 0
+#define TAO_YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#define YY_BUF_SIZE 16384
-#endif
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
+#define TAO_YY_BUF_SIZE 16384
 
-extern int yyleng;
+typedef struct tao_yy_buffer_state *TAO_YY_BUFFER_STATE;
 
-extern FILE *yyin, *yyout;
+extern int tao_yyleng;
+extern FILE *tao_yyin, *tao_yyout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-    #define YY_LESS_LINENO(n)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
+/* The funky do-while in the following #define is used to turn the definition
+ * int a single C statement (which needs a semi-colon terminator).  This
+ * avoids problems with code like:
+ *
+ *      if ( condition_holds )
+ *              tao_yyless( 5 );
+ *      else
+ *              do_something_else();
+ *
+ * Prior to using the do-while the compiler would get upset at the
+ * "else" because it interpreted the "if" statement as being all
+ * done when it reached the ';' after the tao_yyless() call.
+ */
+
+/* Return all but the first 'n' matched characters back to the input stream. */
+
+#define tao_yyless(n) \
+        do \
+                { \
+                /* Undo effects of setting up tao_yytext. */ \
+                *tao_yy_cp = tao_yy_hold_char; \
+                TAO_YY_RESTORE_TAO_YY_MORE_OFFSET \
+                tao_yy_c_buf_p = tao_yy_cp = tao_yy_bp + n - TAO_YY_MORE_ADJ; \
+                TAO_YY_DO_BEFORE_ACTION; /* set up tao_yytext again */ \
+                } \
+        while ( 0 )
 
-#define unput(c) yyunput( c, (yytext_ptr)  )
+#define unput(c) tao_yyunput( c, tao_yytext_ptr )
 
 /* The following is because we cannot portably get our hands on size_t
  * (without autoconf's help, which isn't available because we want
  * flex-generated scanners to compile on their own).
  */
+typedef unsigned int tao_yy_size_t;
 
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef unsigned int yy_size_t;
-#endif
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-    
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
+struct tao_yy_buffer_state
+        {
+        FILE *tao_yy_input_file;
 
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+        char *tao_yy_ch_buf;            /* input buffer */
+        char *tao_yy_buf_pos;           /* current position in input buffer */
 
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
+        /* Size of input buffer in bytes, not including room for EOB
+         * characters.
+         */
+        tao_yy_size_t tao_yy_buf_size;
 
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
+        /* Number of characters read into tao_yy_ch_buf, not including EOB
+         * characters.
+         */
+        int tao_yy_n_chars;
+
+        /* Whether we "own" the buffer - i.e., we know we created it,
+         * and can realloc() it to grow it, and should free() it to
+         * delete it.
+         */
+        int tao_yy_is_our_buffer;
+
+        /* Whether this is an "interactive" input source; if so, and
+         * if we're using stdio for input, then we want to use getc()
+         * instead of fread(), to make sure we stop fetching input after
+         * each newline.
+         */
+        int tao_yy_is_interactive;
+
+        /* Whether we're considered to be at the beginning of a line.
+         * If so, '^' rules will be active on the next match, otherwise
+         * not.
+         */
+        int tao_yy_at_bol;
+
+        /* Whether to try to fill the input buffer when we reach the
+         * end of it.
+         */
+        int tao_yy_fill_buffer;
+
+        int tao_yy_buffer_status;
+#define TAO_YY_BUFFER_NEW 0
+#define TAO_YY_BUFFER_NORMAL 1
+        /* When an EOF's been seen but there's still some text to process
+         * then we mark the buffer as TAO_YY_EOF_PENDING, to indicate that we
+         * shouldn't try reading from the input source any more.  We might
+         * still have a bunch of tokens to match, though, because of
+         * possible backing-up.
+         *
+         * When we actually see the EOF, we change the status to "new"
+         * (via tao_yyrestart()), so that the user can continue scanning by
+         * just pointing tao_yyin at a new input file.
+         */
+#define TAO_YY_BUFFER_EOF_PENDING 2
+        };
 
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
+static TAO_YY_BUFFER_STATE tao_yy_current_buffer = 0;
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
  */
-static int yy_did_buffer_switch_on_eof;
+#define TAO_YY_CURRENT_BUFFER tao_yy_current_buffer
 
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
 
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+/* tao_yy_hold_char holds the character lost when tao_yytext is formed. */
+static char tao_yy_hold_char;
 
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+static int tao_yy_n_chars;              /* number of characters read into tao_yy_ch_buf */
 
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
 
-void *yyalloc (yy_size_t  );
-void *yyrealloc (void *,yy_size_t  );
-void yyfree (void *  );
+int tao_yyleng;
 
-#define yy_new_buffer yy_create_buffer
+/* Points to current character in buffer. */
+static char *tao_yy_c_buf_p = (char *) 0;
+static int tao_yy_init = 1;             /* whether we need to initialize */
+static int tao_yy_start = 0;    /* start state number */
 
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
+/* Flag which is used to allow tao_yywrap()'s to do buffer switches
+ * instead of setting up a fresh tao_yyin.  A bit of a hack ...
+ */
+static int tao_yy_did_buffer_switch_on_eof;
 
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
+void tao_yyrestart TAO_YY_PROTO(( FILE *input_file ));
 
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+void tao_yy_switch_to_buffer TAO_YY_PROTO(( TAO_YY_BUFFER_STATE new_buffer ));
+void tao_yy_load_buffer_state TAO_YY_PROTO(( void ));
+TAO_YY_BUFFER_STATE tao_yy_create_buffer TAO_YY_PROTO(( FILE *file, int size ));
+void tao_yy_delete_buffer TAO_YY_PROTO(( TAO_YY_BUFFER_STATE b ));
+void tao_yy_init_buffer TAO_YY_PROTO(( TAO_YY_BUFFER_STATE b, FILE *file ));
+void tao_yy_flush_buffer TAO_YY_PROTO(( TAO_YY_BUFFER_STATE b ));
+#define TAO_YY_FLUSH_BUFFER tao_yy_flush_buffer( tao_yy_current_buffer )
 
-/* Begin user sect3 */
+TAO_YY_BUFFER_STATE tao_yy_scan_buffer TAO_YY_PROTO(( char *base, tao_yy_size_t size ));
+TAO_YY_BUFFER_STATE tao_yy_scan_string TAO_YY_PROTO(( tao_yyconst char *tao_yy_str ));
+TAO_YY_BUFFER_STATE tao_yy_scan_bytes TAO_YY_PROTO(( tao_yyconst char *bytes, int len ));
 
-typedef unsigned char YY_CHAR;
+static void *tao_yy_flex_alloc TAO_YY_PROTO(( tao_yy_size_t ));
+static void *tao_yy_flex_realloc TAO_YY_PROTO(( void *, tao_yy_size_t ));
+static void tao_yy_flex_free TAO_YY_PROTO(( void * ));
 
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+#define tao_yy_new_buffer tao_yy_create_buffer
 
-typedef int yy_state_type;
+#define tao_yy_set_interactive(is_interactive) \
+        { \
+        if ( ! tao_yy_current_buffer ) \
+                tao_yy_current_buffer = tao_yy_create_buffer( tao_yyin, TAO_YY_BUF_SIZE ); \
+        tao_yy_current_buffer->tao_yy_is_interactive = is_interactive; \
+        }
 
-extern int yylineno;
+#define tao_yy_set_bol(at_bol) \
+        { \
+        if ( ! tao_yy_current_buffer ) \
+                tao_yy_current_buffer = tao_yy_create_buffer( tao_yyin, TAO_YY_BUF_SIZE ); \
+        tao_yy_current_buffer->tao_yy_at_bol = at_bol; \
+        }
+
+#define TAO_YY_AT_BOL() (tao_yy_current_buffer->tao_yy_at_bol)
 
-int yylineno = 1;
+typedef unsigned char TAO_YY_CHAR;
+FILE *tao_yyin = (FILE *) 0, *tao_yyout = (FILE *) 0;
+typedef int tao_yy_state_type;
+extern char tao_yytext[];
 
-extern char yytext[];
 
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yy_fatal_error (yyconst char msg[]  );
+static tao_yy_state_type tao_yy_get_previous_state TAO_YY_PROTO(( void ));
+static tao_yy_state_type tao_yy_try_NUL_trans TAO_YY_PROTO(( tao_yy_state_type current_state ));
+static int tao_yy_get_next_buffer TAO_YY_PROTO(( void ));
+static void tao_yy_fatal_error TAO_YY_PROTO(( tao_yyconst char msg[] ));
 
 /* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
+ * corresponding action - sets up tao_yytext.
  */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (size_t) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	if ( yyleng >= YYLMAX ) \
-		YY_FATAL_ERROR( "token too large, exceeds YYLMAX" ); \
-	yy_flex_strncpy( yytext, (yytext_ptr), yyleng + 1 ); \
-	(yy_c_buf_p) = yy_cp;
-
-#define YY_NUM_RULES 104
-#define YY_END_OF_BUFFER 105
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static yyconst flex_int16_t yy_accept[551] =
+#define TAO_YY_DO_BEFORE_ACTION \
+        tao_yytext_ptr = tao_yy_bp; \
+        tao_yyleng = (int) (tao_yy_cp - tao_yy_bp); \
+        tao_yy_hold_char = *tao_yy_cp; \
+        *tao_yy_cp = '\0'; \
+        if ( tao_yyleng >= TAO_YYLMAX ) \
+                TAO_YY_FATAL_ERROR( "token too large, exceeds TAO_YYLMAX" ); \
+        tao_yy_flex_strncpy( tao_yytext, tao_yytext_ptr, tao_yyleng + 1 ); \
+        tao_yy_c_buf_p = tao_yy_cp;
+
+#define TAO_YY_NUM_RULES 104
+#define TAO_YY_END_OF_BUFFER 105
+static tao_yyconst short int tao_yy_accept[551] =
     {   0,
       101,  101,  105,  103,  101,  102,  102,  103,  103,  103,
       103,  103,   76,   72,  103,  103,  103,   68,   68,   68,
@@ -427,7 +348,7 @@
        98,    0,    0,    0,   40,   94,    0,   86,   86,    0
     } ;
 
-static yyconst flex_int32_t yy_ec[256] =
+static tao_yyconst int tao_yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
@@ -459,7 +380,7 @@
         1,    1,    1,    1,    1
     } ;
 
-static yyconst flex_int32_t yy_meta[60] =
+static tao_yyconst int tao_yy_meta[60] =
     {   0,
         1,    1,    2,    1,    1,    3,    1,    4,    1,    1,
         1,    1,    1,    5,    5,    5,    1,    1,    1,    1,
@@ -469,7 +390,7 @@
         6,    8,    6,    8,    6,    8,    6,    8,    6
     } ;
 
-static yyconst flex_int16_t yy_base[578] =
+static tao_yyconst short int tao_yy_base[578] =
     {   0,
         0,   58, 1044, 1045,   59, 1045, 1045,   56, 1009,   54,
        57,   65,   68,   73, 1025, 1023, 1020,    0, 1017,   69,
@@ -536,7 +457,7 @@
       739,  747,  755,  763,  771,  779,  787
     } ;
 
-static yyconst flex_int16_t yy_def[578] =
+static tao_yyconst short int tao_yy_def[578] =
     {   0,
       550,    1,  550,  550,  550,  550,  550,  551,  552,  550,
       550,  550,  550,  550,  550,  550,  550,  553,  553,  553,
@@ -603,7 +524,7 @@
       550,  550,  550,  550,  550,  550,  550
     } ;
 
-static yyconst flex_int16_t yy_nxt[1105] =
+static tao_yyconst short int tao_yy_nxt[1105] =
     {   0,
         4,    5,    6,    7,    5,    8,    4,    9,    4,    4,
        10,   11,   12,   13,   14,   14,   15,   16,    4,   17,
@@ -727,9 +648,10 @@
       550,  550,  550,  550,  550,  550,  550,  550,  550,  550,
 
       550,  550,  550,  550
+
     } ;
 
-static yyconst flex_int16_t yy_chk[1105] =
+static tao_yyconst short int tao_yy_chk[1105] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -853,28 +775,27 @@
       550,  550,  550,  550,  550,  550,  550,  550,  550,  550,
 
       550,  550,  550,  550
-    } ;
 
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
+    } ;
 
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
+static tao_yy_state_type tao_yy_last_accepting_state;
+static char *tao_yy_last_accepting_cpos;
 
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
 #define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-#ifndef YYLMAX
-#define YYLMAX 8192
+#define tao_yymore() tao_yymore_used_but_not_detected
+#define TAO_YY_MORE_ADJ 0
+#define TAO_YY_RESTORE_TAO_YY_MORE_OFFSET
+#ifndef TAO_YYLMAX
+#define TAO_YYLMAX 8192
 #endif
 
-char yytext[YYLMAX];
-char *yytext_ptr;
-/*  $Id$
+char tao_yytext[TAO_YYLMAX];
+char *tao_yytext_ptr;
+#define INITIAL 0
+/*  $Id$
 
 COPYRIGHT
 
@@ -953,6 +874,7 @@
 #include "ast_expression.h"
 #include "ast_argument.h"
 #include "ast_operation.h"
+#include "ast_root.h"
 #include "fe_interface_header.h"
 #include "global_extern.h"
 #include "fe_private.h"
@@ -964,533 +886,541 @@
 static char             idl_escape_reader (char *);
 static double           idl_atof (char *);
 static long             idl_atoi (char *, long);
-static ACE_UINT64	idl_atoui (char *, long);
-static void		idl_parse_line_and_file (char *);
-static void		idl_store_pragma (char *);
+static ACE_UINT64       idl_atoui (char *, long);
+static void             idl_parse_line_and_file (char *);
+static void             idl_store_pragma (char *);
 static char *           idl_get_pragma_string (char *);
 static idl_bool         idl_valid_version (char *);
 static AST_Decl *       idl_find_node (char *);
 
 #if 0 /* defined (HPUX) */
-// HPUX has yytext typed to unsigned char *. We make sure here that
-// we'll always use char * static char* __yytext = (char*) yytext;
-// NOTE: This will not work under flex(1) were yytext is not a fixed
+// HPUX has tao_yytext typed to unsigned char *. We make sure here that
+// we'll always use char * static char* __tao_yytext = (char*) tao_yytext;
+// NOTE: This will not work under flex(1) were tao_yytext is not a fixed
 // buffer, but a dynamically allocated one. This function should do
 // the trick for us.
-inline char *__yytext()
+inline char *__tao_yytext()
 {
-  return (char *) yytext;
+  return (char *) tao_yytext;
 }
-#define ace_yytext __yytext()
+#define ace_tao_yytext __tao_yytext()
 #else
-#define ace_yytext yytext
+#define ace_tao_yytext tao_yytext
 #endif /* 0 */
 
 /* SO we don't choke on files that use \r\n */
-
-#define INITIAL 0
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
+#define TAO_YY_NEVER_INTERACTIVE 1
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
  */
 
-#ifndef YY_SKIP_YYWRAP
+#ifndef TAO_YY_SKIP_TAO_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap (void );
+extern "C" int tao_yywrap TAO_YY_PROTO(( void ));
 #else
-extern int yywrap (void );
+extern int tao_yywrap TAO_YY_PROTO(( void ));
 #endif
 #endif
 
-    static void yyunput (int c,char *buf_ptr  );
-    
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int );
+#ifndef TAO_YY_NO_UNPUT
+static void tao_yyunput TAO_YY_PROTO(( int c, char *buf_ptr ));
 #endif
 
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * );
+#ifndef tao_yytext_ptr
+static void tao_yy_flex_strncpy TAO_YY_PROTO(( char *, tao_yyconst char *, int ));
 #endif
 
-#ifndef YY_NO_INPUT
+#ifdef TAO_YY_NEED_STRLEN
+static int tao_yy_flex_strlen TAO_YY_PROTO(( tao_yyconst char * ));
+#endif
 
+#ifndef TAO_YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput (void );
+static int tao_yyinput TAO_YY_PROTO(( void ));
 #else
-static int input (void );
+static int input TAO_YY_PROTO(( void ));
+#endif
 #endif
 
+#ifdef TAO_YY_STACK_USED
+static int tao_yy_start_stack_ptr = 0;
+static int tao_yy_start_stack_depth = 0;
+static int *tao_yy_start_stack = 0;
+#ifndef TAO_YY_NO_PUSH_STATE
+static void tao_yy_push_state TAO_YY_PROTO(( int new_state ));
+#endif
+#ifndef TAO_YY_NO_POP_STATE
+static void tao_yy_pop_state TAO_YY_PROTO(( void ));
+#endif
+#ifndef TAO_YY_NO_TOP_STATE
+static int tao_yy_top_state TAO_YY_PROTO(( void ));
+#endif
+
+#else
+#define TAO_YY_NO_PUSH_STATE 1
+#define TAO_YY_NO_POP_STATE 1
+#define TAO_YY_NO_TOP_STATE 1
+#endif
+
+#ifdef TAO_YY_MALLOC_DECL
+TAO_YY_MALLOC_DECL
+#else
+#ifdef __STDC__
+#ifndef __cplusplus
+#endif
+#else
+/* Just try to get by without declaring the routines.  This will fail
+ * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
+ * or sizeof(void*) != sizeof(int).
+ */
+#endif
 #endif
 
 /* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
+#ifndef TAO_YY_READ_BUF_SIZE
+#define TAO_YY_READ_BUF_SIZE 8192
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
+
+#ifndef TAO_YY_ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define TAO_YY_ECHO (void) fwrite( tao_yytext, tao_yyleng, 1, tao_yyout )
 #endif
 
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+/* Gets input and stuffs it into "buf".  number of characters read, or TAO_YY_NULL,
  * is returned in "result".
  */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		size_t n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
+#ifndef TAO_YY_INPUT
+#define TAO_YY_INPUT(buf,result,max_size) \
+        if ( tao_yy_current_buffer->tao_yy_is_interactive ) \
+                { \
+                int c = '*', n; \
+                for ( n = 0; n < max_size && \
+                             (c = getc( tao_yyin )) != EOF && c != '\n'; ++n ) \
+                        buf[n] = (char) c; \
+                if ( c == '\n' ) \
+                        buf[n++] = (char) c; \
+                if ( c == EOF && ferror( tao_yyin ) ) \
+                        TAO_YY_FATAL_ERROR( "input in flex scanner failed" ); \
+                result = n; \
+                } \
+        else if ( ((result = static_cast<int> ( \
+                                  fread( buf, 1, max_size, tao_yyin ))) == 0) \
+                  && ferror( tao_yyin ) ) \
+                TAO_YY_FATAL_ERROR( "input in flex scanner failed" );
 #endif
 
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
+/* No semi-colon after return; correct usage is to write "tao_yyterminate();" -
  * we don't want an extra ';' after the "return" because that will cause
  * some compilers to complain about unreachable statements.
  */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
+#ifndef tao_yyterminate
+#define tao_yyterminate() return TAO_YY_NULL
 #endif
 
 /* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
+#ifndef TAO_YY_START_STACK_INCR
+#define TAO_YY_START_STACK_INCR 25
 #endif
 
 /* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#ifndef TAO_YY_FATAL_ERROR
+#define TAO_YY_FATAL_ERROR(msg) tao_yy_fatal_error( msg )
 #endif
 
-/* end tables serialization structures and prototypes */
-
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
+#ifndef TAO_YY_DECL
+#define TAO_YY_DECL int tao_yylex TAO_YY_PROTO(( void ))
+#endif
 
-/* Code executed at the beginning of each rule, after yytext and yyleng
+/* Code executed at the beginning of each rule, after tao_yytext and tao_yyleng
  * have been set up.
  */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
+#ifndef TAO_YY_USER_ACTION
+#define TAO_YY_USER_ACTION
 #endif
 
 /* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
+#ifndef TAO_YY_BREAK
+#define TAO_YY_BREAK ACE_NOTREACHED (break;)
+#endif
+
+#define TAO_YY_RULE_SETUP \
+        if ( tao_yyleng > 0 ) \
+                tao_yy_current_buffer->tao_yy_at_bol = \
+                                (tao_yytext[tao_yyleng - 1] == '\n'); \
+        TAO_YY_USER_ACTION
+
+TAO_YY_DECL
+        {
+        register tao_yy_state_type tao_yy_current_state;
+        register char *tao_yy_cp = 0, *tao_yy_bp = 0;
+        register int tao_yy_act;
+
+
+
+
+        if ( tao_yy_init )
+                {
+                tao_yy_init = 0;
+
+#ifdef TAO_YY_USER_INIT
+                TAO_YY_USER_INIT;
 #endif
 
-#define YY_RULE_SETUP \
-	if ( yyleng > 0 ) \
-		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
-				(yytext[yyleng - 1] == '\n'); \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-    
-	if ( (yy_init) )
-		{
-		(yy_init) = 0;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state( );
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-		yy_current_state += YY_AT_BOL();
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 551 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_current_state != 550 );
-		yy_cp = (yy_last_accepting_cpos);
-		yy_current_state = (yy_last_accepting_state);
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
+                if ( ! tao_yy_start )
+                        tao_yy_start = 1;       /* first start state */
+
+                if ( ! tao_yyin )
+                        tao_yyin = stdin;
+
+                if ( ! tao_yyout )
+                        tao_yyout = stdout;
+
+                if ( ! tao_yy_current_buffer )
+                        tao_yy_current_buffer =
+                                tao_yy_create_buffer( tao_yyin, TAO_YY_BUF_SIZE );
+
+                tao_yy_load_buffer_state();
+                }
+
+        while ( 1 )             /* loops until end-of-file is reached */
+                {
+                tao_yy_cp = tao_yy_c_buf_p;
+
+                /* Support of tao_yytext. */
+                *tao_yy_cp = tao_yy_hold_char;
+
+                /* tao_yy_bp points to the position in tao_yy_ch_buf of the start of
+                 * the current run.
+                 */
+                tao_yy_bp = tao_yy_cp;
+
+                tao_yy_current_state = tao_yy_start;
+                tao_yy_current_state += TAO_YY_AT_BOL();
+tao_yy_match:
+                do
+                        {
+                        register TAO_YY_CHAR tao_yy_c = tao_yy_ec[TAO_YY_SC_TO_UI(*tao_yy_cp)];
+                        if ( tao_yy_accept[tao_yy_current_state] )
+                                {
+                                tao_yy_last_accepting_state = tao_yy_current_state;
+                                tao_yy_last_accepting_cpos = tao_yy_cp;
+                                }
+                        while ( tao_yy_chk[tao_yy_base[tao_yy_current_state] + tao_yy_c] != tao_yy_current_state )
+                                {
+                                tao_yy_current_state = (int) tao_yy_def[tao_yy_current_state];
+                                if ( tao_yy_current_state >= 551 )
+                                        tao_yy_c = tao_yy_meta[(unsigned int) tao_yy_c];
+                                }
+                        tao_yy_current_state = tao_yy_nxt[tao_yy_base[tao_yy_current_state] + (unsigned int) tao_yy_c];
+                        ++tao_yy_cp;
+                        }
+                while ( tao_yy_current_state != 550 );
+
+tao_yy_find_action:
+                tao_yy_act = tao_yy_accept[tao_yy_current_state];
+                if ( tao_yy_act == 0 )
+                        { /* have to back up */
+                        tao_yy_cp = tao_yy_last_accepting_cpos;
+                        tao_yy_current_state = tao_yy_last_accepting_state;
+                        tao_yy_act = tao_yy_accept[tao_yy_current_state];
+                        }
+
+                TAO_YY_DO_BEFORE_ACTION;
+
+
+do_action:      /* This label is used only to access EOF actions. */
+
+
+                switch ( tao_yy_act )
+        { /* beginning of action switch */
+                        case 0: /* must back up */
+                        /* undo the effects of TAO_YY_DO_BEFORE_ACTION */
+                        *tao_yy_cp = tao_yy_hold_char;
+                        tao_yy_cp = tao_yy_last_accepting_cpos;
+                        tao_yy_current_state = tao_yy_last_accepting_state;
+                        goto tao_yy_find_action;
 
 case 1:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_ANY;
-	YY_BREAK
+        TAO_YY_BREAK
 case 2:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_OBJECT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 3:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_MODULE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 4:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_RAISES;
-	YY_BREAK
+        TAO_YY_BREAK
 case 5:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_READONLY;
-	YY_BREAK
+        TAO_YY_BREAK
 case 6:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_ATTRIBUTE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 7:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_EXCEPTION;
-	YY_BREAK
+        TAO_YY_BREAK
 case 8:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_CONTEXT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 9:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_INTERFACE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 10:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_CONST;
-	YY_BREAK
+        TAO_YY_BREAK
 case 11:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_TYPEDEF;
-	YY_BREAK
+        TAO_YY_BREAK
 case 12:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_STRUCT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 13:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_ENUM;
-	YY_BREAK
+        TAO_YY_BREAK
 case 14:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_STRING;
-	YY_BREAK
+        TAO_YY_BREAK
 case 15:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_WSTRING;
-	YY_BREAK
+        TAO_YY_BREAK
 case 16:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_SEQUENCE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 17:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_UNION;
-	YY_BREAK
+        TAO_YY_BREAK
 case 18:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_FIXED;
-	YY_BREAK
+        TAO_YY_BREAK
 case 19:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_SWITCH;
-	YY_BREAK
+        TAO_YY_BREAK
 case 20:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_CASE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 21:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_DEFAULT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 22:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_FLOAT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 23:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_DOUBLE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 24:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_LONG;
-	YY_BREAK
+        TAO_YY_BREAK
 case 25:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_SHORT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 26:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_UNSIGNED;
-	YY_BREAK
+        TAO_YY_BREAK
 case 27:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_CHAR;
-	YY_BREAK
+        TAO_YY_BREAK
 case 28:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_WCHAR;
-	YY_BREAK
+        TAO_YY_BREAK
 case 29:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_BOOLEAN;
-	YY_BREAK
+        TAO_YY_BREAK
 case 30:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_OCTET;
-	YY_BREAK
+        TAO_YY_BREAK
 case 31:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_VOID;
-	YY_BREAK
+        TAO_YY_BREAK
 case 32:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_NATIVE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 33:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_LOCAL;
-	YY_BREAK
+        TAO_YY_BREAK
 case 34:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_ABSTRACT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 35:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_CUSTOM;
-	YY_BREAK
+        TAO_YY_BREAK
 case 36:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_FACTORY;
-	YY_BREAK
+        TAO_YY_BREAK
 case 37:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_PRIVATE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 38:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_PUBLIC;
-	YY_BREAK
+        TAO_YY_BREAK
 case 39:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_SUPPORTS;
-	YY_BREAK
+        TAO_YY_BREAK
 case 40:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_TRUNCATABLE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 41:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_VALUETYPE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 42:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_COMPONENT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 43:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_CONSUMES;
-	YY_BREAK
+        TAO_YY_BREAK
 case 44:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_EMITS;
-	YY_BREAK
+        TAO_YY_BREAK
 case 45:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_EVENTTYPE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 46:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_FINDER;
-	YY_BREAK
+        TAO_YY_BREAK
 case 47:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_GETRAISES;
-	YY_BREAK
+        TAO_YY_BREAK
 case 48:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_HOME;
-	YY_BREAK
+        TAO_YY_BREAK
 case 49:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_IMPORT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 50:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_MULTIPLE;
-	YY_BREAK
+        TAO_YY_BREAK
 case 51:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_PRIMARYKEY;
-	YY_BREAK
+        TAO_YY_BREAK
 case 52:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_PROVIDES;
-	YY_BREAK
+        TAO_YY_BREAK
 case 53:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_PUBLISHES;
-	YY_BREAK
+        TAO_YY_BREAK
 case 54:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_SETRAISES;
-	YY_BREAK
+        TAO_YY_BREAK
 case 55:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_TYPEID;
-	YY_BREAK
+        TAO_YY_BREAK
 case 56:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_TYPEPREFIX;
-	YY_BREAK
+        TAO_YY_BREAK
 case 57:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_USES;
-	YY_BREAK
+        TAO_YY_BREAK
 case 58:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_MANAGES;
-	YY_BREAK
+        TAO_YY_BREAK
 case 59:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_TRUETOK;
-	YY_BREAK
+        TAO_YY_BREAK
 case 60:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_FALSETOK;
-	YY_BREAK
+        TAO_YY_BREAK
 case 61:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_INOUT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 62:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_IN;
-	YY_BREAK
+        TAO_YY_BREAK
 case 63:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_OUT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 64:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_ONEWAY;
-	YY_BREAK
+        TAO_YY_BREAK
 case 65:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_LEFT_SHIFT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 66:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 return IDL_RIGHT_SHIFT;
-	YY_BREAK
+        TAO_YY_BREAK
 case 67:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  yylval.strval = (char *) "::";
-		  return IDL_SCOPE_DELIMITOR;
-		}
-	YY_BREAK
+                  tao_yylval.strval = (char *) "::";
+                  return IDL_SCOPE_DELIMITOR;
+                }
+        TAO_YY_BREAK
 case 68:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
   // Make sure that this identifier is not a C++ keyword. If it is,
   // prepend it with a _cxx_. Lookup in the perfect hash table for C++
@@ -1499,15 +1429,16 @@
 
   TAO_IDL_CPP_Keyword_Table cpp_key_tbl;
   const TAO_IDL_CPP_Keyword_Entry *entry = 0;
+
   if (!idl_global->preserve_cpp_keywords())
     {
       // This check will ensure that escaped C++ keywords will be
       // caught and prepended with '_cxx' as non-escaped keywords
       // are now prepended with '_cxx_'.
-      const char *tmp = 
+      const char *tmp =
         ace_tao_yytext[0] == '_' ? ace_tao_yytext + 1 : ace_tao_yytext;
 
-      entry = 
+      entry =
         cpp_key_tbl.lookup (tmp,
                             static_cast<unsigned int> (ACE_OS::strlen (tmp)));
     }
@@ -1523,69 +1454,68 @@
 
   return IDENTIFIER;
 }
-	YY_BREAK
+        TAO_YY_BREAK
 case 69:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-                  yylval.dval = idl_atof(ace_yytext);
+                  tao_yylval.dval = idl_atof(ace_tao_yytext);
                   return IDL_FLOATING_PT_LITERAL;
                 }
-	YY_BREAK
+        TAO_YY_BREAK
 case 70:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-                  yylval.dval = idl_atof(ace_yytext);
+                  tao_yylval.dval = idl_atof(ace_tao_yytext);
                   return IDL_FLOATING_PT_LITERAL;
                 }
-	YY_BREAK
+        TAO_YY_BREAK
 case 71:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  yylval.ival = idl_atoi(ace_yytext, 10);
-		  return IDL_INTEGER_LITERAL;
-	        }
-	YY_BREAK
+                  tao_yylval.ival = idl_atoi(ace_tao_yytext, 10);
+                  return IDL_INTEGER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 72:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  yylval.uival = idl_atoui(ace_yytext, 10);
-		  return IDL_UINTEGER_LITERAL;
-		}
-	YY_BREAK
+                  tao_yylval.uival = idl_atoui(ace_tao_yytext, 10);
+                  return IDL_UINTEGER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 73:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  yylval.ival = idl_atoi(ace_yytext, 16);
-		  return IDL_INTEGER_LITERAL;
-	        }
-	YY_BREAK
+                  tao_yylval.ival = idl_atoi(ace_tao_yytext, 16);
+                  return IDL_INTEGER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 74:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-                  yylval.uival = idl_atoui(ace_yytext, 16);
-		  return IDL_UINTEGER_LITERAL;
-		}
-	YY_BREAK
+                  tao_yylval.uival = idl_atoui(ace_tao_yytext, 16);
+                  return IDL_UINTEGER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 75:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  yylval.ival = idl_atoi(ace_yytext, 8);
-		  return IDL_INTEGER_LITERAL;
-	      	}
-	YY_BREAK
+                  tao_yylval.ival = idl_atoi(ace_tao_yytext, 8);
+                  return IDL_INTEGER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 76:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  yylval.uival = idl_atoui(ace_yytext, 8);
-		  return IDL_UINTEGER_LITERAL;
-	      	}
-	YY_BREAK
+                  tao_yylval.uival = idl_atoui(ace_tao_yytext, 8);
+                  return IDL_UINTEGER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 77:
-/* rule 77 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  /* Skip the quotes */
-		  char *tmp = ace_yytext;
+                  /* Skip the quotes */
+                  char *tmp = ace_tao_yytext;
                   for(int i = strlen(tmp) - 1; i >= 0; --i) {
                     if (isspace(tmp[i])) {
                       tmp[i] = '\0';
@@ -1594,1146 +1524,1051 @@
                       break;
                     }
                   }
-		  tmp[strlen (tmp) - 1] = '\0';
-		  ACE_NEW_RETURN (yylval.sval,
+                  tmp[strlen (tmp) - 1] = '\0';
+                  ACE_NEW_RETURN (tao_yylval.sval,
                                   UTL_String (tmp + 1),
                                   IDL_STRING_LITERAL);
-		  return IDL_STRING_LITERAL;
-	      	}
-	YY_BREAK
+                  return IDL_STRING_LITERAL;
+                }
+        TAO_YY_BREAK
 case 78:
-/* rule 78 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  /* Skip the bookends */
-		  char *tmp = ACE_OS::strdup (ace_yytext);
-		  tmp[strlen (tmp) - 1] = '\0';
-		  yylval.wsval = idl_wstring_escape_reader(tmp + 2);
-		  return IDL_WSTRING_LITERAL;
-		}
-	YY_BREAK
+                  /* Skip the bookends */
+                  char *tmp = ACE_OS::strdup (ace_tao_yytext);
+                  tmp[strlen (tmp) - 1] = '\0';
+                  tao_yylval.wsval = idl_wstring_escape_reader(tmp + 2);
+                  return IDL_WSTRING_LITERAL;
+                }
+        TAO_YY_BREAK
 case 79:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  yylval.cval = ace_yytext [1];
-		  return IDL_CHARACTER_LITERAL;
-	      	}
-	YY_BREAK
+                  tao_yylval.cval = ace_tao_yytext [1];
+                  return IDL_CHARACTER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 80:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  // octal character constant
-		  yylval.cval = idl_escape_reader(ace_yytext + 1);
-		  return IDL_CHARACTER_LITERAL;
-		}
-	YY_BREAK
+                  // octal character constant
+                  tao_yylval.cval = idl_escape_reader(ace_tao_yytext + 1);
+                  return IDL_CHARACTER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 81:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  // hexadecimal character constant
-		  yylval.cval = idl_escape_reader(ace_yytext + 1);
-		  return IDL_CHARACTER_LITERAL;
-		}
-	YY_BREAK
+                  // hexadecimal character constant
+                  tao_yylval.cval = idl_escape_reader(ace_tao_yytext + 1);
+                  return IDL_CHARACTER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 82:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  yylval.cval = idl_escape_reader(ace_yytext + 1);
-		  return IDL_CHARACTER_LITERAL;
-		}
-	YY_BREAK
+                  tao_yylval.cval = idl_escape_reader(ace_tao_yytext + 1);
+                  return IDL_CHARACTER_LITERAL;
+                }
+        TAO_YY_BREAK
 case 83:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  // wide character constant
-		  yylval.wcval = ace_yytext [2];
-		  return IDL_WCHAR_LITERAL;
-		}
-	YY_BREAK
+                  // wide character constant
+                  tao_yylval.wcval = ace_tao_yytext [2];
+                  return IDL_WCHAR_LITERAL;
+                }
+        TAO_YY_BREAK
 case 84:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  // hexadecimal wide character constant
-		  yylval.wcval = idl_wchar_escape_reader(ace_yytext + 2);
-		  return IDL_WCHAR_LITERAL;
-		}
-	YY_BREAK
+                  // hexadecimal wide character constant
+                  tao_yylval.wcval = idl_wchar_escape_reader(ace_tao_yytext + 2);
+                  return IDL_WCHAR_LITERAL;
+                }
+        TAO_YY_BREAK
 case 85:
-/* rule 85 can match eol */
 case 86:
-/* rule 86 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {/* remember pragma */
-  		  idl_global->set_lineno(idl_global->lineno() + 1);
-		  idl_store_pragma(ace_yytext);
-		}
-	YY_BREAK
+                  idl_global->set_lineno(idl_global->lineno() + 1);
+                  idl_store_pragma(ace_tao_yytext);
+                }
+        break;
 case 87:
-/* rule 87 can match eol */
 case 88:
-/* rule 88 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {/* ignore file */
-  		  idl_global->set_lineno(idl_global->lineno() + 1);
-		}
-	YY_BREAK
+                  idl_global->set_lineno(idl_global->lineno() + 1);
+                }
+        break;
 case 89:
-/* rule 89 can match eol */
 case 90:
-/* rule 90 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  idl_parse_line_and_file(ace_yytext);
-		}
-	YY_BREAK
+                  idl_parse_line_and_file(ace_tao_yytext);
+                }
+        break;
 case 91:
-/* rule 91 can match eol */
 case 92:
-/* rule 92 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  idl_parse_line_and_file(ace_yytext);
-		}
-	YY_BREAK
+                  idl_parse_line_and_file(ace_tao_yytext);
+                }
+        break;
 case 93:
-/* rule 93 can match eol */
 case 94:
-/* rule 94 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  idl_parse_line_and_file(ace_yytext);
-		}
-	YY_BREAK
+                  idl_parse_line_and_file(ace_tao_yytext);
+                }
+        break;
 case 95:
-/* rule 95 can match eol */
 case 96:
-/* rule 96 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  idl_parse_line_and_file(ace_yytext);
-	        }
-	YY_BREAK
+                  idl_parse_line_and_file(ace_tao_yytext);
+                }
+        break;
 case 97:
-/* rule 97 can match eol */
 case 98:
-/* rule 98 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  /* ignore cpp ident */
-  		  idl_global->set_lineno(idl_global->lineno() + 1);
-		}
-	YY_BREAK
+                  /* ignore cpp ident */
+                  idl_global->set_lineno(idl_global->lineno() + 1);
+                }
+        break;
 case 99:
-/* rule 99 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  /* ignore comments */
-  		  idl_global->set_lineno(idl_global->lineno() + 1);
-		}
-	YY_BREAK
+                  /* ignore comments */
+                  idl_global->set_lineno(idl_global->lineno() + 1);
+                }
+        break;
 case 100:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-		  for(;;) {
-		    char c = yyinput();
-		    if (c == '*') {
-		      char next = yyinput();
-		      if (next == '/')
-			break;
-		      else
-			yyunput(c, NULL);
-	              if (c == '\n')
-		        idl_global->set_lineno(idl_global->lineno() + 1);
-		    }
-	          }
-	        }
-	YY_BREAK
+                  for(;;) {
+                    char c = tao_yyinput();
+                    if (c == '*') {
+                      char next = tao_yyinput();
+                      if (next == '/')
+                        break;
+                      else
+                        tao_yyunput(c, NULL);
+                      if (c == '\n')
+                        idl_global->set_lineno(idl_global->lineno() + 1);
+                    }
+                  }
+                }
+        break;
 case 101:
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 ;
-	YY_BREAK
+        break;
 case 102:
-/* rule 102 can match eol */
-YY_RULE_SETUP
+TAO_YY_RULE_SETUP
 {
-  		  idl_global->set_lineno(idl_global->lineno() + 1);
-		}
-	YY_BREAK
+                  idl_global->set_lineno(idl_global->lineno() + 1);
+                }
+        break;
 case 103:
-YY_RULE_SETUP
-return ace_yytext [0];
-	YY_BREAK
+TAO_YY_RULE_SETUP
+return ace_tao_yytext [0];
+        break;
 case 104:
-YY_RULE_SETUP
-ECHO;
-	YY_BREAK
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_last_accepting_cpos);
-				yy_current_state = (yy_last_accepting_state);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap( ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-} /* end of yylex */
+TAO_YY_RULE_SETUP
+TAO_YY_ECHO;
+        break;
+case TAO_YY_STATE_EOF(INITIAL):
+        tao_yyterminate();
+
+        case TAO_YY_END_OF_BUFFER:
+                {
+                /* Amount of text matched not including the EOB char. */
+                int tao_yy_amount_of_matched_text = (int) (tao_yy_cp - tao_yytext_ptr) - 1;
+
+                /* Undo the effects of TAO_YY_DO_BEFORE_ACTION. */
+                *tao_yy_cp = tao_yy_hold_char;
+                TAO_YY_RESTORE_TAO_YY_MORE_OFFSET
+
+                if ( tao_yy_current_buffer->tao_yy_buffer_status == TAO_YY_BUFFER_NEW )
+                        {
+                        /* We're scanning a new file or input source.  It's
+                         * possible that this happened because the user
+                         * just pointed tao_yyin at a new source and called
+                         * tao_yylex().  If so, then we have to assure
+                         * consistency between tao_yy_current_buffer and our
+                         * globals.  Here is the right place to do so, because
+                         * this is the first action (other than possibly a
+                         * back-up) that will match for the new input source.
+                         */
+                        tao_yy_n_chars = tao_yy_current_buffer->tao_yy_n_chars;
+                        tao_yy_current_buffer->tao_yy_input_file = tao_yyin;
+                        tao_yy_current_buffer->tao_yy_buffer_status = TAO_YY_BUFFER_NORMAL;
+                        }
+
+                /* Note that here we test for tao_yy_c_buf_p "<=" to the position
+                 * of the first EOB in the buffer, since tao_yy_c_buf_p will
+                 * already have been incremented past the NUL character
+                 * (since all states make transitions on EOB to the
+                 * end-of-buffer state).  Contrast this with the test
+                 * in input().
+                 */
+                if ( tao_yy_c_buf_p <= &tao_yy_current_buffer->tao_yy_ch_buf[tao_yy_n_chars] )
+                        { /* This was really a NUL. */
+                        tao_yy_state_type tao_yy_next_state;
+
+                        tao_yy_c_buf_p = tao_yytext_ptr + tao_yy_amount_of_matched_text;
+
+                        tao_yy_current_state = tao_yy_get_previous_state();
+
+                        /* Okay, we're now positioned to make the NUL
+                         * transition.  We couldn't have
+                         * tao_yy_get_previous_state() go ahead and do it
+                         * for us because it doesn't know how to deal
+                         * with the possibility of jamming (and we don't
+                         * want to build jamming into it because then it
+                         * will run more slowly).
+                         */
+
+                        tao_yy_next_state = tao_yy_try_NUL_trans( tao_yy_current_state );
+
+                        tao_yy_bp = tao_yytext_ptr + TAO_YY_MORE_ADJ;
+
+                        if ( tao_yy_next_state )
+                                {
+                                /* Consume the NUL. */
+                                tao_yy_cp = ++tao_yy_c_buf_p;
+                                tao_yy_current_state = tao_yy_next_state;
+                                goto tao_yy_match;
+                                }
+
+                        else
+                                {
+                                tao_yy_cp = tao_yy_c_buf_p;
+                                goto tao_yy_find_action;
+                                }
+                        }
+
+                else switch ( tao_yy_get_next_buffer() )
+                        {
+                        case EOB_ACT_END_OF_FILE:
+                                {
+                                tao_yy_did_buffer_switch_on_eof = 0;
+
+                                if ( tao_yywrap() )
+                                        {
+                                        /* Note: because we've taken care in
+                                         * tao_yy_get_next_buffer() to have set up
+                                         * tao_yytext, we can now set up
+                                         * tao_yy_c_buf_p so that if some total
+                                         * hoser (like flex itself) wants to
+                                         * call the scanner after we return the
+                                         * TAO_YY_NULL, it'll still work - another
+                                         * TAO_YY_NULL will get returned.
+                                         */
+                                        tao_yy_c_buf_p = tao_yytext_ptr + TAO_YY_MORE_ADJ;
+
+                                        tao_yy_act = TAO_YY_STATE_EOF(TAO_YY_START);
+                                        goto do_action;
+                                        }
+
+                                else
+                                        {
+                                        if ( ! tao_yy_did_buffer_switch_on_eof )
+                                                TAO_YY_NEW_FILE;
+                                        }
+                                break;
+                                }
+
+                        case EOB_ACT_CONTINUE_SCAN:
+                                tao_yy_c_buf_p =
+                                        tao_yytext_ptr + tao_yy_amount_of_matched_text;
+
+                                tao_yy_current_state = tao_yy_get_previous_state();
+
+                                tao_yy_cp = tao_yy_c_buf_p;
+                                tao_yy_bp = tao_yytext_ptr + TAO_YY_MORE_ADJ;
+                                goto tao_yy_match;
+
+                        case EOB_ACT_LAST_MATCH:
+                                tao_yy_c_buf_p =
+                                &tao_yy_current_buffer->tao_yy_ch_buf[tao_yy_n_chars];
+
+                                tao_yy_current_state = tao_yy_get_previous_state();
+
+                                tao_yy_cp = tao_yy_c_buf_p;
+                                tao_yy_bp = tao_yytext_ptr + TAO_YY_MORE_ADJ;
+                                goto tao_yy_find_action;
+                        }
+                break;
+                }
+
+        default:
+                TAO_YY_FATAL_ERROR(
+                        "fatal flex scanner internal error--no action found" );
+        } /* end of action switch */
+                } /* end of scanning one token */
+        } /* end of tao_yylex */
+
 
-/* yy_get_next_buffer - try to read in a new buffer
+/* tao_yy_get_next_buffer - try to read in a new buffer
  *
  * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	register char *source = (yytext_ptr);
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			size_t num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+ *      EOB_ACT_LAST_MATCH -
+ *      EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *      EOB_ACT_END_OF_FILE - end of file
+ */
+
+static int tao_yy_get_next_buffer()
+        {
+        register char *dest = tao_yy_current_buffer->tao_yy_ch_buf;
+        register char *source = tao_yytext_ptr;
+        register int number_to_move, i;
+        int ret_val;
+
+        if ( tao_yy_c_buf_p > &tao_yy_current_buffer->tao_yy_ch_buf[tao_yy_n_chars + 1] )
+                TAO_YY_FATAL_ERROR(
+                "fatal flex scanner internal error--end of buffer missed" );
+
+        if ( tao_yy_current_buffer->tao_yy_fill_buffer == 0 )
+                { /* Don't try to fill the buffer, so this is an EOF. */
+                if ( tao_yy_c_buf_p - tao_yytext_ptr - TAO_YY_MORE_ADJ == 1 )
+                        {
+                        /* We matched a single character, the EOB, so
+                         * treat this as a final EOF.
+                         */
+                        return EOB_ACT_END_OF_FILE;
+                        }
+
+                else
+                        {
+                        /* We matched some text prior to the EOB, first
+                         * process it.
+                         */
+                        return EOB_ACT_LAST_MATCH;
+                        }
+                }
 
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+        /* Try to read more data. */
 
-	return ret_val;
-}
+        /* First move last chars to start of buffer. */
+        number_to_move = (int) (tao_yy_c_buf_p - tao_yytext_ptr) - 1;
 
-/* yy_get_previous_state - get the state just before the EOB char was reached */
+        for ( i = 0; i < number_to_move; ++i )
+                *(dest++) = *(source++);
 
-    static yy_state_type yy_get_previous_state (void)
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-    
-	yy_current_state = (yy_start);
-	yy_current_state += YY_AT_BOL();
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 551 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
+        if ( tao_yy_current_buffer->tao_yy_buffer_status == TAO_YY_BUFFER_EOF_PENDING )
+                /* don't do the read, it's not guaranteed to return an EOF,
+                 * just force an EOF
+                 */
+                tao_yy_current_buffer->tao_yy_n_chars = tao_yy_n_chars = 0;
+
+        else
+                {
+                int num_to_read =
+                        tao_yy_current_buffer->tao_yy_buf_size - number_to_move - 1;
+
+                while ( num_to_read <= 0 )
+                        { /* Not enough room in the buffer - grow it. */
+#ifdef TAO_YY_USES_REJECT
+                        TAO_YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+#else
+
+                        /* just a shorter name for the current buffer */
+                        TAO_YY_BUFFER_STATE b = tao_yy_current_buffer;
+
+                        int tao_yy_c_buf_p_offset =
+                                (int) (tao_yy_c_buf_p - b->tao_yy_ch_buf);
+
+                        if ( b->tao_yy_is_our_buffer )
+                                {
+                                int new_size = b->tao_yy_buf_size * 2;
+
+                                if ( new_size <= 0 )
+                                        b->tao_yy_buf_size += b->tao_yy_buf_size / 8;
+                                else
+                                        b->tao_yy_buf_size *= 2;
+
+                                b->tao_yy_ch_buf = (char *)
+                                        /* Include room in for 2 EOB chars. */
+                                        tao_yy_flex_realloc( (void *) b->tao_yy_ch_buf,
+                                                         b->tao_yy_buf_size + 2 );
+                                }
+                        else
+                                /* Can't grow it, we don't own it. */
+                                b->tao_yy_ch_buf = 0;
+
+                        if ( ! b->tao_yy_ch_buf )
+                                TAO_YY_FATAL_ERROR(
+                                "fatal error - scanner input buffer overflow" );
+
+                        tao_yy_c_buf_p = &b->tao_yy_ch_buf[tao_yy_c_buf_p_offset];
+
+                        num_to_read = tao_yy_current_buffer->tao_yy_buf_size -
+                                                number_to_move - 1;
+#endif
+                        }
+
+                if ( num_to_read > TAO_YY_READ_BUF_SIZE )
+                        num_to_read = TAO_YY_READ_BUF_SIZE;
+
+                /* Read in more data. */
+                TAO_YY_INPUT( (&tao_yy_current_buffer->tao_yy_ch_buf[number_to_move]),
+                        tao_yy_n_chars, num_to_read );
+
+                tao_yy_current_buffer->tao_yy_n_chars = tao_yy_n_chars;
+                }
+
+        if ( tao_yy_n_chars == 0 )
+                {
+                if ( number_to_move == TAO_YY_MORE_ADJ )
+                        {
+                        ret_val = EOB_ACT_END_OF_FILE;
+                        tao_yyrestart( tao_yyin );
+                        }
+
+                else
+                        {
+                        ret_val = EOB_ACT_LAST_MATCH;
+                        tao_yy_current_buffer->tao_yy_buffer_status =
+                                TAO_YY_BUFFER_EOF_PENDING;
+                        }
+                }
+
+        else
+                ret_val = EOB_ACT_CONTINUE_SCAN;
+
+        tao_yy_n_chars += number_to_move;
+        tao_yy_current_buffer->tao_yy_ch_buf[tao_yy_n_chars] = TAO_YY_END_OF_BUFFER_CHAR;
+        tao_yy_current_buffer->tao_yy_ch_buf[tao_yy_n_chars + 1] = TAO_YY_END_OF_BUFFER_CHAR;
+
+        tao_yytext_ptr = &tao_yy_current_buffer->tao_yy_ch_buf[0];
+
+        return ret_val;
+        }
 
-	return yy_current_state;
-}
 
-/* yy_try_NUL_trans - try to make a transition on the NUL character
+/* tao_yy_get_previous_state - get the state just before the EOB char was reached */
+
+static tao_yy_state_type tao_yy_get_previous_state()
+        {
+        register tao_yy_state_type tao_yy_current_state;
+        register char *tao_yy_cp;
+
+        tao_yy_current_state = tao_yy_start;
+        tao_yy_current_state += TAO_YY_AT_BOL();
+
+        for ( tao_yy_cp = tao_yytext_ptr + TAO_YY_MORE_ADJ; tao_yy_cp < tao_yy_c_buf_p; ++tao_yy_cp )
+                {
+                register TAO_YY_CHAR tao_yy_c = (*tao_yy_cp ? tao_yy_ec[TAO_YY_SC_TO_UI(*tao_yy_cp)] : 1);
+                if ( tao_yy_accept[tao_yy_current_state] )
+                        {
+                        tao_yy_last_accepting_state = tao_yy_current_state;
+                        tao_yy_last_accepting_cpos = tao_yy_cp;
+                        }
+                while ( tao_yy_chk[tao_yy_base[tao_yy_current_state] + tao_yy_c] != tao_yy_current_state )
+                        {
+                        tao_yy_current_state = (int) tao_yy_def[tao_yy_current_state];
+                        if ( tao_yy_current_state >= 551 )
+                                tao_yy_c = tao_yy_meta[(unsigned int) tao_yy_c];
+                        }
+                tao_yy_current_state = tao_yy_nxt[tao_yy_base[tao_yy_current_state] + (unsigned int) tao_yy_c];
+                }
+
+        return tao_yy_current_state;
+        }
+
+
+/* tao_yy_try_NUL_trans - try to make a transition on the NUL character
  *
  * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
+ *      next_state = tao_yy_try_NUL_trans( current_state );
  */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	register int yy_is_jam;
-    	register char *yy_cp = (yy_c_buf_p);
 
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 551 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 550);
+#ifdef TAO_YY_USE_PROTOS
+static tao_yy_state_type tao_yy_try_NUL_trans( tao_yy_state_type tao_yy_current_state )
+#else
+static tao_yy_state_type tao_yy_try_NUL_trans( tao_yy_current_state )
+tao_yy_state_type tao_yy_current_state;
+#endif
+        {
+        register int tao_yy_is_jam;
+        register char *tao_yy_cp = tao_yy_c_buf_p;
 
-	return yy_is_jam ? 0 : yy_current_state;
-}
+        register TAO_YY_CHAR tao_yy_c = 1;
+        if ( tao_yy_accept[tao_yy_current_state] )
+                {
+                tao_yy_last_accepting_state = tao_yy_current_state;
+                tao_yy_last_accepting_cpos = tao_yy_cp;
+                }
+        while ( tao_yy_chk[tao_yy_base[tao_yy_current_state] + tao_yy_c] != tao_yy_current_state )
+                {
+                tao_yy_current_state = (int) tao_yy_def[tao_yy_current_state];
+                if ( tao_yy_current_state >= 551 )
+                        tao_yy_c = tao_yy_meta[(unsigned int) tao_yy_c];
+                }
+        tao_yy_current_state = tao_yy_nxt[tao_yy_base[tao_yy_current_state] + (unsigned int) tao_yy_c];
+        tao_yy_is_jam = (tao_yy_current_state == 550);
+
+        return tao_yy_is_jam ? 0 : tao_yy_current_state;
+        }
+
+
+#ifndef TAO_YY_NO_UNPUT
+#ifdef TAO_YY_USE_PROTOS
+static void tao_yyunput( int c, register char *tao_yy_bp )
+#else
+static void tao_yyunput( c, tao_yy_bp )
+int c;
+register char *tao_yy_bp;
+#endif
+        {
+        register char *tao_yy_cp = tao_yy_c_buf_p;
+
+        /* undo effects of setting up tao_yytext */
+        *tao_yy_cp = tao_yy_hold_char;
+
+        if ( tao_yy_cp < tao_yy_current_buffer->tao_yy_ch_buf + 2 )
+                { /* need to shift things up to make room */
+                /* +2 for EOB chars. */
+                register int number_to_move = tao_yy_n_chars + 2;
+                register char *dest = &tao_yy_current_buffer->tao_yy_ch_buf[
+                                        tao_yy_current_buffer->tao_yy_buf_size + 2];
+                register char *source =
+                                &tao_yy_current_buffer->tao_yy_ch_buf[number_to_move];
+
+                while ( source > tao_yy_current_buffer->tao_yy_ch_buf )
+                        *--dest = *--source;
+
+                tao_yy_cp += (int) (dest - source);
+                tao_yy_bp += (int) (dest - source);
+                tao_yy_current_buffer->tao_yy_n_chars =
+                        tao_yy_n_chars = tao_yy_current_buffer->tao_yy_buf_size;
+
+                if ( tao_yy_cp < tao_yy_current_buffer->tao_yy_ch_buf + 2 )
+                        TAO_YY_FATAL_ERROR( "flex scanner push-back overflow" );
+                }
+
+        *--tao_yy_cp = (char) c;
+
+
+        tao_yytext_ptr = tao_yy_bp;
+        tao_yy_hold_char = *tao_yy_cp;
+        tao_yy_c_buf_p = tao_yy_cp;
+        }
+#endif  /* ifndef TAO_YY_NO_UNPUT */
 
-    static void yyunput (int c, register char * yy_bp )
-{
-	register char *yy_cp;
-    
-    yy_cp = (yy_c_buf_p);
-
-	/* undo effects of setting up yytext */
-	*yy_cp = (yy_hold_char);
-
-	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		register int number_to_move = (yy_n_chars) + 2;
-		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
-					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		register char *source =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
-
-		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
-
-		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-	(yytext_ptr) = yy_bp;
-	(yy_hold_char) = *yy_cp;
-	(yy_c_buf_p) = yy_cp;
-}
 
-#ifndef YY_NO_INPUT
 #ifdef __cplusplus
-    static int yyinput (void)
+static int tao_yyinput()
 #else
-    static int input  (void)
+static int input()
 #endif
+        {
+        int c;
 
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			int offset = (yy_c_buf_p) - (yytext_ptr);
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart(yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( ) )
-						return EOF;
+        *tao_yy_c_buf_p = tao_yy_hold_char;
+
+        if ( *tao_yy_c_buf_p == TAO_YY_END_OF_BUFFER_CHAR )
+                {
+                /* tao_yy_c_buf_p now points to the character we want to return.
+                 * If this occurs *before* the EOB characters, then it's a
+                 * valid NUL; if not, then we've hit the end of the buffer.
+                 */
+                if ( tao_yy_c_buf_p < &tao_yy_current_buffer->tao_yy_ch_buf[tao_yy_n_chars] )
+                        /* This was really a NUL. */
+                        *tao_yy_c_buf_p = '\0';
+
+                else
+                        { /* need more input */
+                        int offset = tao_yy_c_buf_p - tao_yytext_ptr;
+                        ++tao_yy_c_buf_p;
+
+                        switch ( tao_yy_get_next_buffer() )
+                                {
+                                case EOB_ACT_LAST_MATCH:
+                                        /* This happens because tao_yy_g_n_b()
+                                         * sees that we've accumulated a
+                                         * token and flags that we need to
+                                         * try matching the token before
+                                         * proceeding.  But for input(),
+                                         * there's no matching to consider.
+                                         * So convert the EOB_ACT_LAST_MATCH
+                                         * to EOB_ACT_END_OF_FILE.
+                                         */
+
+                                        /* Reset buffer status. */
+                                        tao_yyrestart( tao_yyin );
+
+                                        /* fall through */
+
+                                case EOB_ACT_END_OF_FILE:
+                                        {
+                                        if ( tao_yywrap() )
+                                                return EOF;
 
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
+                                        if ( ! tao_yy_did_buffer_switch_on_eof )
+                                                TAO_YY_NEW_FILE;
 #ifdef __cplusplus
-					return yyinput();
+                                        return tao_yyinput();
 #else
-					return input();
+                                        return input();
 #endif
-					}
+                                        }
 
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
+                                case EOB_ACT_CONTINUE_SCAN:
+                                        tao_yy_c_buf_p = tao_yytext_ptr + offset;
+                                        break;
+                                }
+                        }
+                }
 
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
+        c = *(unsigned char *) tao_yy_c_buf_p;  /* cast for 8-bit char's */
+        *tao_yy_c_buf_p = '\0'; /* preserve tao_yytext */
+        tao_yy_hold_char = *++tao_yy_c_buf_p;
 
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');
+        tao_yy_current_buffer->tao_yy_at_bol = (c == '\n');
 
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
+        return c;
+        }
 
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
-	}
 
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
-}
+#ifdef TAO_YY_USE_PROTOS
+void tao_yyrestart( FILE *input_file )
+#else
+void tao_yyrestart( input_file )
+FILE *input_file;
+#endif
+        {
+        if ( ! tao_yy_current_buffer )
+                tao_yy_current_buffer = tao_yy_create_buffer( tao_yyin, TAO_YY_BUF_SIZE );
 
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
+        tao_yy_init_buffer( tao_yy_current_buffer, input_file );
+        tao_yy_load_buffer_state();
+        }
 
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
 
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+#ifdef TAO_YY_USE_PROTOS
+void tao_yy_switch_to_buffer( TAO_YY_BUFFER_STATE new_buffer )
+#else
+void tao_yy_switch_to_buffer( new_buffer )
+TAO_YY_BUFFER_STATE new_buffer;
+#endif
+        {
+        if ( tao_yy_current_buffer == new_buffer )
+                return;
 
-	b->yy_is_our_buffer = 1;
+        if ( tao_yy_current_buffer )
+                {
+                /* Flush out information for old buffer. */
+                *tao_yy_c_buf_p = tao_yy_hold_char;
+                tao_yy_current_buffer->tao_yy_buf_pos = tao_yy_c_buf_p;
+                tao_yy_current_buffer->tao_yy_n_chars = tao_yy_n_chars;
+                }
 
-	yy_init_buffer(b,file );
+        tao_yy_current_buffer = new_buffer;
+        tao_yy_load_buffer_state();
 
-	return b;
-}
+        /* We don't actually know whether we did this switch during
+         * EOF (tao_yywrap()) processing, but the only time this flag
+         * is looked at is after tao_yywrap() is called, so it's safe
+         * to go ahead and always set it.
+         */
+        tao_yy_did_buffer_switch_on_eof = 1;
+        }
 
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
 
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+#ifdef TAO_YY_USE_PROTOS
+void tao_yy_load_buffer_state( void )
+#else
+void tao_yy_load_buffer_state()
+#endif
+        {
+        tao_yy_n_chars = tao_yy_current_buffer->tao_yy_n_chars;
+        tao_yytext_ptr = tao_yy_c_buf_p = tao_yy_current_buffer->tao_yy_buf_pos;
+        tao_yyin = tao_yy_current_buffer->tao_yy_input_file;
+        tao_yy_hold_char = *tao_yy_c_buf_p;
+        }
 
-	if ( b->yy_is_our_buffer )
-		yyfree((void *) b->yy_ch_buf  );
 
-	yyfree((void *) b  );
-}
+#ifdef TAO_YY_USE_PROTOS
+TAO_YY_BUFFER_STATE tao_yy_create_buffer( FILE *file, int size )
+#else
+TAO_YY_BUFFER_STATE tao_yy_create_buffer( file, size )
+FILE *file;
+int size;
+#endif
+        {
+        TAO_YY_BUFFER_STATE b;
 
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+        b = (TAO_YY_BUFFER_STATE) tao_yy_flex_alloc( sizeof( struct tao_yy_buffer_state ) );
+        if ( ! b )
+                TAO_YY_FATAL_ERROR( "out of dynamic memory in tao_yy_create_buffer()" );
 
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer(b );
+        b->tao_yy_buf_size = size;
 
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
+        /* tao_yy_ch_buf has to be 2 characters longer than the size given because
+         * we need to put in 2 end-of-buffer characters.
+         */
+        b->tao_yy_ch_buf = (char *) tao_yy_flex_alloc( b->tao_yy_buf_size + 2 );
+        if ( ! b->tao_yy_ch_buf )
+                TAO_YY_FATAL_ERROR( "out of dynamic memory in tao_yy_create_buffer()" );
 
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
+        b->tao_yy_is_our_buffer = 1;
 
-        b->yy_is_interactive = 0;
-    
-	errno = oerrno;
-}
+        tao_yy_init_buffer( b, file );
 
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
+        return b;
+        }
 
-	b->yy_n_chars = 0;
 
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+#ifdef TAO_YY_USE_PROTOS
+void tao_yy_delete_buffer( TAO_YY_BUFFER_STATE b )
+#else
+void tao_yy_delete_buffer( b )
+TAO_YY_BUFFER_STATE b;
+#endif
+        {
+        if ( ! b )
+                return;
 
-	b->yy_buf_pos = &b->yy_ch_buf[0];
+        if ( b == tao_yy_current_buffer )
+                tao_yy_current_buffer = (TAO_YY_BUFFER_STATE) 0;
 
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
+        if ( b->tao_yy_is_our_buffer )
+                tao_yy_flex_free( (void *) b->tao_yy_ch_buf );
 
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
-}
+        tao_yy_flex_free( (void *) b );
+        }
 
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
 
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
+#ifndef TAO_YY_ALWAYS_INTERACTIVE
+#ifndef TAO_YY_NEVER_INTERACTIVE
+extern int isatty TAO_YY_PROTO(( int ));
+#endif
+#endif
 
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	int num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
+#ifdef TAO_YY_USE_PROTOS
+void tao_yy_init_buffer( TAO_YY_BUFFER_STATE b, FILE *file )
+#else
+void tao_yy_init_buffer( b, file )
+TAO_YY_BUFFER_STATE b;
+FILE *file;
+#endif
+
+
+        {
+        tao_yy_flush_buffer( b );
+
+        b->tao_yy_input_file = file;
+        b->tao_yy_fill_buffer = 1;
+
+#ifdef TAO_YY_ALWAYS_INTERACTIVE
+        b->tao_yy_is_interactive = 1;
+#else
+#ifdef TAO_YY_NEVER_INTERACTIVE
+        b->tao_yy_is_interactive = 0;
+#else
+        b->tao_yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+#endif
+#endif
+        }
+
+
+#ifdef TAO_YY_USE_PROTOS
+void tao_yy_flush_buffer( TAO_YY_BUFFER_STATE b )
+#else
+void tao_yy_flush_buffer( b )
+TAO_YY_BUFFER_STATE b;
+#endif
+
+        {
+        if ( ! b )
+                return;
+
+        b->tao_yy_n_chars = 0;
+
+        /* We always need two end-of-buffer characters.  The first causes
+         * a transition to the end-of-buffer state.  The second causes
+         * a jam in that state.
          */
-		num_to_alloc = 1;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		int grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
+        b->tao_yy_ch_buf[0] = TAO_YY_END_OF_BUFFER_CHAR;
+        b->tao_yy_ch_buf[1] = TAO_YY_END_OF_BUFFER_CHAR;
 
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
+        b->tao_yy_buf_pos = &b->tao_yy_ch_buf[0];
 
-	yy_switch_to_buffer(b  );
+        b->tao_yy_at_bol = 1;
+        b->tao_yy_buffer_status = TAO_YY_BUFFER_NEW;
 
-	return b;
-}
+        if ( b == tao_yy_current_buffer )
+                tao_yy_load_buffer_state();
+        }
 
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param str a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yy_str )
-{
-    
-	return yy_scan_bytes(yy_str,strlen(yy_str) );
-}
 
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * bytes, int  len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yyalloc(n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
-
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer(buf,n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
+#ifndef TAO_YY_NO_SCAN_BUFFER
+#ifdef TAO_YY_USE_PROTOS
+TAO_YY_BUFFER_STATE tao_yy_scan_buffer( char *base, tao_yy_size_t size )
+#else
+TAO_YY_BUFFER_STATE tao_yy_scan_buffer( base, size )
+char *base;
+tao_yy_size_t size;
+#endif
+        {
+        TAO_YY_BUFFER_STATE b;
+
+        if ( size < 2 ||
+             base[size-2] != TAO_YY_END_OF_BUFFER_CHAR ||
+             base[size-1] != TAO_YY_END_OF_BUFFER_CHAR )
+                /* They forgot to leave room for the EOB's. */
+                return 0;
 
-	return b;
-}
+        b = (TAO_YY_BUFFER_STATE) tao_yy_flex_alloc( sizeof( struct tao_yy_buffer_state ) );
+        if ( ! b )
+                TAO_YY_FATAL_ERROR( "out of dynamic memory in tao_yy_scan_buffer()" );
 
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
+        b->tao_yy_buf_size = size - 2;  /* "- 2" to take care of EOB's */
+        b->tao_yy_buf_pos = b->tao_yy_ch_buf = base;
+        b->tao_yy_is_our_buffer = 0;
+        b->tao_yy_input_file = 0;
+        b->tao_yy_n_chars = b->tao_yy_buf_size;
+        b->tao_yy_is_interactive = 0;
+        b->tao_yy_at_bol = 1;
+        b->tao_yy_fill_buffer = 0;
+        b->tao_yy_buffer_status = TAO_YY_BUFFER_NEW;
+
+        tao_yy_switch_to_buffer( b );
+
+        return b;
+        }
 #endif
 
-static void yy_fatal_error (yyconst char* msg )
-{
-    	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
 
-/* Redefine yyless() so it works in section 3 code. */
+#ifndef TAO_YY_NO_SCAN_STRING
+#ifdef TAO_YY_USE_PROTOS
+TAO_YY_BUFFER_STATE tao_yy_scan_string( tao_yyconst char *tao_yy_str )
+#else
+TAO_YY_BUFFER_STATE tao_yy_scan_string( tao_yy_str )
+tao_yyconst char *tao_yy_str;
+#endif
+        {
+        int len;
+        for ( len = 0; tao_yy_str[len]; ++len )
+                ;
 
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
+        return tao_yy_scan_bytes( tao_yy_str, len );
+        }
+#endif
 
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-        
-    return yylineno;
-}
 
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
+#ifndef TAO_YY_NO_SCAN_BYTES
+#ifdef TAO_YY_USE_PROTOS
+TAO_YY_BUFFER_STATE tao_yy_scan_bytes( tao_yyconst char *bytes, int len )
+#else
+TAO_YY_BUFFER_STATE tao_yy_scan_bytes( bytes, len )
+tao_yyconst char *bytes;
+int len;
+#endif
+        {
+        TAO_YY_BUFFER_STATE b;
+        char *buf;
+        tao_yy_size_t n;
+        int i;
 
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
+        /* Get memory for full buffer, including space for trailing EOB's. */
+        n = len + 2;
+        buf = (char *) tao_yy_flex_alloc( n );
+        if ( ! buf )
+                TAO_YY_FATAL_ERROR( "out of dynamic memory in tao_yy_scan_bytes()" );
+
+        for ( i = 0; i < len; ++i )
+                buf[i] = bytes[i];
+
+        buf[len] = buf[len+1] = TAO_YY_END_OF_BUFFER_CHAR;
+
+        b = tao_yy_scan_buffer( buf, n );
+        if ( ! b )
+                TAO_YY_FATAL_ERROR( "bad buffer in tao_yy_scan_bytes()" );
 
-/** Get the length of the current token.
- * 
- */
-int yyget_leng  (void)
-{
-        return yyleng;
-}
+        /* It's okay to grow etc. this buffer, and we should throw it
+         * away when we're done.
+         */
+        b->tao_yy_is_our_buffer = 1;
 
-/** Get the current token.
- * 
- */
+        return b;
+        }
+#endif
 
-char *yyget_text  (void)
-{
-        return yytext;
-}
 
-/** Set the current line number.
- * @param line_number
- * 
- */
-void yyset_lineno (int  line_number )
-{
-    
-    yylineno = line_number;
-}
+#ifndef TAO_YY_NO_PUSH_STATE
+#ifdef TAO_YY_USE_PROTOS
+static void tao_yy_push_state( int new_state )
+#else
+static void tao_yy_push_state( new_state )
+int new_state;
+#endif
+        {
+        if ( tao_yy_start_stack_ptr >= tao_yy_start_stack_depth )
+                {
+                tao_yy_size_t new_size;
 
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  in_str )
-{
-        yyin = in_str ;
-}
+                tao_yy_start_stack_depth += TAO_YY_START_STACK_INCR;
+                new_size = tao_yy_start_stack_depth * sizeof( int );
 
-void yyset_out (FILE *  out_str )
-{
-        yyout = out_str ;
-}
+                if ( ! tao_yy_start_stack )
+                        tao_yy_start_stack = (int *) tao_yy_flex_alloc( new_size );
 
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
+                else
+                        tao_yy_start_stack = (int *) tao_yy_flex_realloc(
+                                        (void *) tao_yy_start_stack, new_size );
 
-void yyset_debug (int  bdebug )
-{
-        yy_flex_debug = bdebug ;
-}
+                if ( ! tao_yy_start_stack )
+                        TAO_YY_FATAL_ERROR(
+                        "out of memory expanding start-condition stack" );
+                }
 
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
+        tao_yy_start_stack[tao_yy_start_stack_ptr++] = TAO_YY_START;
 
-    return 0;
-}
+        BEGIN(new_state);
+        }
+#endif
 
-/*
- * Internal utility routines.
- */
 
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
-{
-	register int i;
-    	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
+#ifndef TAO_YY_NO_POP_STATE
+static void tao_yy_pop_state()
+        {
+        if ( --tao_yy_start_stack_ptr < 0 )
+                TAO_YY_FATAL_ERROR( "start-condition stack underflow" );
+
+        BEGIN(tao_yy_start_stack[tao_yy_start_stack_ptr]);
+        }
 #endif
 
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s )
-{
-	register int n;
-    	for ( n = 0; s[n]; ++n )
-		;
 
-	return n;
-}
+#ifndef TAO_YY_NO_TOP_STATE
+static int tao_yy_top_state()
+        {
+        return tao_yy_start_stack[tao_yy_start_stack_ptr - 1];
+        }
 #endif
 
-void *yyalloc (yy_size_t  size )
-{
-	return (void *) malloc( size );
-}
+#ifndef TAO_YY_EXIT_FAILURE
+#define TAO_YY_EXIT_FAILURE 2
+#endif
 
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-}
+#ifdef TAO_YY_USE_PROTOS
+static void tao_yy_fatal_error( tao_yyconst char msg[] )
+#else
+static void tao_yy_fatal_error( msg )
+char msg[];
+#endif
+        {
+        (void) fprintf( stderr, "%s\n", msg );
+        exit( TAO_YY_EXIT_FAILURE );
+        }
 
-void yyfree (void * ptr )
-{
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
 
-#define YYTABLES_NAME "yytables"
 
-#undef YY_NEW_FILE
-#undef YY_FLUSH_BUFFER
-#undef yy_set_bol
-#undef yy_new_buffer
-#undef yy_set_interactive
-#undef yytext_ptr
-#undef YY_DO_BEFORE_ACTION
-
-#ifdef YY_DECL_IS_OURS
-#undef YY_DECL_IS_OURS
-#undef YY_DECL
+/* Redefine tao_yyless() so it works in section 3 code. */
+
+#undef tao_yyless
+#define tao_yyless(n) \
+        do \
+                { \
+                /* Undo effects of setting up tao_yytext. */ \
+                tao_yytext[tao_yyleng] = tao_yy_hold_char; \
+                tao_yy_c_buf_p = tao_yytext + n; \
+                tao_yy_hold_char = *tao_yy_c_buf_p; \
+                *tao_yy_c_buf_p = '\0'; \
+                tao_yyleng = n; \
+                } \
+        while ( 0 )
+
+
+/* Internal utility routines. */
+
+#ifndef tao_yytext_ptr
+#ifdef TAO_YY_USE_PROTOS
+static void tao_yy_flex_strncpy( char *s1, tao_yyconst char *s2, int n )
+#else
+static void tao_yy_flex_strncpy( s1, s2, n )
+char *s1;
+tao_yyconst char *s2;
+int n;
+#endif
+        {
+        register int i;
+        for ( i = 0; i < n; ++i )
+                s1[i] = s2[i];
+        }
 #endif
 
-	/* subroutines */
+#ifdef TAO_YY_NEED_STRLEN
+#ifdef TAO_YY_USE_PROTOS
+static int tao_yy_flex_strlen( tao_yyconst char *s )
+#else
+static int tao_yy_flex_strlen( s )
+tao_yyconst char *s;
+#endif
+        {
+        register int n;
+        for ( n = 0; s[n]; ++n )
+                ;
+
+        return n;
+        }
+#endif
+
+
+#ifdef TAO_YY_USE_PROTOS
+static void *tao_yy_flex_alloc( tao_yy_size_t size )
+#else
+static void *tao_yy_flex_alloc( size )
+tao_yy_size_t size;
+#endif
+        {
+        return (void *) malloc( size );
+        }
+
+#ifdef TAO_YY_USE_PROTOS
+static void *tao_yy_flex_realloc( void *ptr, tao_yy_size_t size )
+#else
+static void *tao_yy_flex_realloc( ptr, size )
+void *ptr;
+tao_yy_size_t size;
+#endif
+        {
+        /* The cast to (char *) in the following accommodates both
+         * implementations that use char* generic pointers, and those
+         * that use void* generic pointers.  It works with the latter
+         * because both ANSI C and C++ allow castless assignment from
+         * any pointer type to void*, and deal with argument conversions
+         * as though doing an assignment.
+         */
+        return (void *) realloc( (char *) ptr, size );
+        }
+
+#ifdef TAO_YY_USE_PROTOS
+static void tao_yy_flex_free( void *ptr )
+#else
+static void tao_yy_flex_free( ptr )
+void *ptr;
+#endif
+        {
+        free( ptr );
+        }
+
+#ifdef TAO_YY_MAIN
+int main()
+        {
+        tao_yylex();
+        return 0;
+        }
+#endif
+
+        /* subroutines */
 
 // Parse a #line statement generated by the C preprocessor
 static void
@@ -2813,10 +2648,10 @@
         {
           if (h[j] == '\\' && h[j + 1] == '\\')
             {
-	            j++;
+                    j++;
             }
 
-	        h[i] = h[j];
+                h[i] = h[j];
         }
 
       h[i] = '\0';
@@ -2845,7 +2680,7 @@
 
   // Strip off any command line -I prefix that may have been added
   // by the preprocessor.
-  if (!(idl_global->in_main_file ()) && idl_global->import ()) 
+  if (!(idl_global->in_main_file ()) && idl_global->import ())
     {
       ACE_NEW (
           nm,
@@ -2957,7 +2792,7 @@
           ext_id.set (idl_global->filename ()->get_string (),
                       0);
           char *int_id = ACE::strnew (new_prefix);
-          (void) idl_global->file_prefixes ().rebind (ext_id, 
+          (void) idl_global->file_prefixes ().rebind (ext_id,
                                                       int_id);
         }
     }
@@ -2992,7 +2827,7 @@
           len = ACE_OS::strlen (number);
         }
 
-      // This call adds a proper null terminator to tmp, so no need to 
+      // This call adds a proper null terminator to tmp, so no need to
       // do it here.
       AST_Decl *d = idl_find_node (tmp);
 
@@ -3009,7 +2844,7 @@
 
       d->version (ACE::strnew (number));
     }
-  else if (ACE_OS::strncmp (buf + 8, "ident", 5) == 0) 
+  else if (ACE_OS::strncmp (buf + 8, "ident", 5) == 0)
     {
       idl_global->ident_string (buf + 8);
     }
@@ -3039,7 +2874,7 @@
                                                   new_id);
               return;
             }
-            
+
           d->repoID (new_id);
           d->typeid_set (I_TRUE);
         }
@@ -3137,24 +2972,24 @@
   double e, k;
   long neg = 0, negexp = 0;
 
-  if (*s == '-') 
+  if (*s == '-')
     {
       neg = 1;
       s++;
     }
 
-  while (*s >= '0' && *s <= '9') 
+  while (*s >= '0' && *s <= '9')
     {
       d = (d * 10) + *s - '0';
       s++;
     }
 
-  if (*s == '.') 
+  if (*s == '.')
     {
       s++;
       e = 10;
 
-      while (*s >= '0' && *s <= '9') 
+      while (*s >= '0' && *s <= '9')
         {
           d += (*s - '0') / (e * 1.0);
           e *= 10;
@@ -3162,15 +2997,15 @@
         }
     }
 
-  if (*s == 'e' || *s == 'E') 
+  if (*s == 'e' || *s == 'E')
     {
       s++;
 
-      if (*s == '-') 
+      if (*s == '-')
         {
             negexp = 1;
             s++;
-        } 
+        }
       else if (*s == '+')
         {
           s++;
@@ -3178,13 +3013,13 @@
 
       e = 0;
 
-      while (*s >= '0' && *s <= '9') 
+      while (*s >= '0' && *s <= '9')
         {
           e = (e * 10) + *s - '0';
           s++;
         }
 
-      if (e > 0) 
+      if (e > 0)
         {
           for (k = 1; e > 0; k *= 10, e--);
 
@@ -3199,7 +3034,7 @@
         }
     }
 
-  if (neg) 
+  if (neg)
     {
       d *= -1.0;
     }
@@ -3215,74 +3050,74 @@
     char *str
   )
 {
-  if (str[0] != '\\') 
+  if (str[0] != '\\')
     {
-	    return str[0];
+            return str[0];
     }
 
-  switch (str[1]) 
+  switch (str[1])
   {
     case 'n':
-      return '\n';
+            return '\n';
     case 't':
-      return '\t';
+            return '\t';
     case 'v':
-      return '\v';
+            return '\v';
     case 'b':
-      return '\b';
+            return '\b';
     case 'r':
-      return '\r';
+            return '\r';
     case 'f':
-      return '\f';
+            return '\f';
     case 'a':
-      return '\a';
+            return '\a';
     case '\\':
-      return '\\';
+            return '\\';
     case '\?':
-      return '?';
+            return '?';
     case '\'':
-      return '\'';
+            return '\'';
     case '"':
-      return '"';
+            return '"';
     case 'x':
-      {
-        int i;
+            {
+              int i;
 
-        // hex value
-        for (i = 2; str[i] != '\0' && isxdigit (str[i]); ++i) 
+              // hex value
+              for (i = 2; str[i] != '\0' && isxdigit(str[i]); ++i)
           {
-	     continue;
-	  }
+                        continue;
+                }
 
-        char save = str[i];
-        str[i] = '\0';
-        char out = (char)idl_atoui(&str[2], 16);
-        str[i] = save;
-        return out;
-      }
-      ACE_NOTREACHED (break;)
+              char save = str[i];
+              str[i] = '\0';
+              char out = (char)idl_atoui(&str[2], 16);
+              str[i] = save;
+              return out;
+            }
+            ACE_NOTREACHED (break;)
     default:
-      // check for octal value
-      if (str[1] >= '0' && str[1] <= '7') 
+            // check for octal value
+            if (str[1] >= '0' && str[1] <= '7')
         {
- 	  int i;
+                int i;
 
-	  for (i = 1; str[i] >= '0' && str[i] <= '7'; ++i) 
+                for (i = 1; str[i] >= '0' && str[i] <= '7'; ++i)
             {
-	      continue;
-	    }
+                          continue;
+                  }
 
-	  char save = str[i];
-	  str[i] = '\0';
-	  char out = (char)idl_atoui(&str[1], 8);
-	  str[i] = save;
-	  return out;
-	} 
-      else 
-        {
-	  return str[1] - 'a';
-	}
-      ACE_NOTREACHED  (break;)
+                char save = str[i];
+                str[i] = '\0';
+                char out = (char)idl_atoui(&str[1], 8);
+                str[i] = save;
+                return out;
+              }
+      else
+        {
+                return str[1] - 'a';
+              }
+            ACE_NOTREACHED  (break;)
   }
 }
 /*
@@ -3302,6 +3137,7 @@
     {
       continue;
     }
+
   char save = str[i];
   str[i] = '\0';
   ACE_CDR::WChar out = (ACE_CDR::WChar) idl_atoui (&str[2], 16);
@@ -3425,4 +3261,3 @@
 
   return d;
 }
-
