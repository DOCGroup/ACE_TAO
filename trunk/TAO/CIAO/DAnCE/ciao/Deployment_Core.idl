// $Id$

#if !defined (DEPLOYMENT_CORE_IDL)
#define DEPLOYMENT_CORE_IDL

#include "CCM_Component.idl"

// *************** Packaging and Deployment ***************
module Deployment
{
  // Typeprefix Components "omg.org";
  // OMG threw these things away, didn't it.

  exception UnknownImplId {};
  exception InvalidLocation {};
  exception InstallationFailure {/*Do we still need a reason? --Tao*/};
  exception ImplEntryPointNotFound {};

  //Below are from the OMG Deployment.idl

  exception StartError {
    string name;
    string reason;
  };

  exception InvalidConnection {
    string name;
    string reason;
  };
  //==============property==================
  struct Property {
    string name;
    any value;
  };
  typedef sequence < Property > Properties;

  //============connection==================

  typedef sequence < Object > Endpoints;
  //typedef Object Endpoint;

  enum CCMComponentPortKind {
    Facet,
    SimplexReceptacle,
    MultiplexReceptacle,
    EventEmitter,
    EventPublisher,
    EventConsumer
  };

  // To avoid the connection info in the plan being passed to the
  // local node and to make the implementation not very cumbersome
  // I changed the connection struct to include some extra informations.
  struct Connection {
    string instanceName;
    string portName;
    CCMComponentPortKind kind;

    // the endpoints member is change to endpoint.
    // Since we will not have more than 1 objref in there.
    Object endpoint;
  };
  typedef sequence < Connection > Connections;

  //=======================================
  struct ImplementationInfo
  {
    string component_instance_name;
    string executor_dll;
    string executor_entrypt;
    string servant_dll;
    string servant_entrypt;
    Properties component_config;
    //  Properties home_config;      //ignored for now.
    //  Properties container_config  //igore for now
  };

  typedef sequence < ImplementationInfo > ImplementationInfos;

  //==================================
  interface Application
  {
    void finishLaunch (in Connections providedReference, in boolean start)
      raises (StartError, InvalidConnection);
    void start ()
      raises (StartError);
  };

  struct Component_Info
  {
    string component_instance_name;
    Components::CCMObject component_ref;
  };

  typedef sequence < Component_Info > ComponentInfos;

  // @@ (OO) Tao, you're altering an OMG defined interface below.  In
  //         order to avoid confusion, it is probably better to create
  //         another NodeApplication interface in the CIAO namespace
  //         that inherits from Deployment::NodeApplication.  You'd
  //         then use the CIAO::NodeApplication in your
  //         implementation.
  //
  //         Alternatively, you should at least place a CIAO-specific
  //         typeprefix within your altered NodeApplication interface
  //         to prevent interoperability issues.

  // This NodeApplication contains the semantic from both Container and
  // the new DnC NodeApplication  --Tao
  
  // I separated the Container and NodeApplication interfaces for the
  // RT-CCM integration purpose.

  interface NodeApplication; // Forward decl.
  typedef sequence<NodeApplication> NodeApplications;

  interface Container
  {
    readonly attribute ::Deployment::Properties properties;

    NodeApplication get_node_application ();

    //@@ The properties will contain
    //1 component instance name as the key.
    //2 dll/so name of the exec
    //3 entry point of the exec
    //4 dll/so name of the svnt
    //5 entry point of the svnt
    //6 Poosible other configuration for container/home/component
    //Note:: We have to decide later how container/home/component could be configured.
    //       These properties could be passed in here or at higher level
    //       according to the plan(@ NodeApplicationManager/NodeApplication?)
    //
    ::Components::CCMHome install_home (in ImplementationInfo impl_info)
        raises (UnknownImplId,
                ImplEntryPointNotFound,
                InstallationFailure,
                ::Components::InvalidConfiguration);

    void remove_home (in string comp_ins_name)
      raises (::Components::RemoveFailure);

    ::Components::CCMHomes get_homes ();

    void remove ()
      raises (::Components::RemoveFailure);
  };
  typedef sequence<Container> Containers;


  interface NodeApplication : Application
  {
    readonly attribute ::Deployment::Properties properties;

    /*@@ This operation is added for the NodeApplicationManager to
     *   initialize the NodeApplication after creating it.  The
     *   properties are those for the Container and they will be
     *   implemented upon request from our users.   --Tao
     *
     *   Seems Kitty is opposing the idea of sending anys around. But
     *   what really stroke me down was that OMG is working out
     *   another property&configuration specification so all the
     *   properties we set/used might have to be thrown away in the
     *   future.....I am totally speachless and confused...and
     *   frustrated.
     *
     *   But any way seems I can forget about the configuration
     *   now. --Tao
     */

    // @@ Initialize the nodeapplication, so it will know what
    //    components it will create and home many of them are
    //    there. However the real create action will take place when
    //    start launch is called on NodeApplicationManager.
    long init ();

    // @@ This operation will be called by NodeApplicationManager
    //    client to really start to create homes and components.
    ComponentInfos install (in ImplementationInfos impl_infos)
      raises (UnknownImplId,
              ImplEntryPointNotFound,
              InstallationFailure,
              ::Components::InvalidConfiguration);


    //@@ We know that Dployment::NodeApplicationManager will be returned,
    //   however to avoid the size of the shared object of CIAO_Server.
    //   we return an Object.
    Object get_node_application_manager ();

    Container create_container (in ::Components::ConfigValues config)
      raises (::Components::CreateFailure,
              ::Components::InvalidConfiguration);

    void remove_container (in Container cref)
      raises (::Components::RemoveFailure);

    Containers get_containers ();
  };

};
#endif /* DEPLOYMENT_CORE_IDL */
