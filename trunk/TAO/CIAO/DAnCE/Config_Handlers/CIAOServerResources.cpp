/* $Id$
 * This code was generated by the XML Schema Compiler.
 *
 * Changes made to this code will most likely be overwritten
 * when the handlers are recompiled.
 * 
 * If you find errors or feel that there are bugfixes to be made,
 * please contact the current XSC maintainer:
 *             Will Otte <wotte@dre.vanderbilt.edu>
 */
 
#include "CIAOServerResources.hpp"

namespace CIAO
{
  namespace Config_Handlers
  {
    // ServerResourcesDef
    // 

    ServerResourcesDef::
    ServerResourcesDef (::CIAO::Config_Handlers::ORBConfigs const& orbConfigs__)
    : 
    ::XSCRT::Type (), 
    orbConfigs_ (new ::CIAO::Config_Handlers::ORBConfigs (orbConfigs__)),
    regulator__ ()
    {
      orbConfigs_->container (this);
    }

    ServerResourcesDef::
    ServerResourcesDef (::CIAO::Config_Handlers::ServerResourcesDef const& s)
    :
    ::XSCRT::Type (),
    cmdline_ (s.cmdline_.get () ? new ::CIAO::Config_Handlers::ServerCmdlineOptions (*s.cmdline_) : 0),
    svcconf_ (s.svcconf_.get () ? new ::CIAO::Config_Handlers::ACESvcConf (*s.svcconf_) : 0),
    orbConfigs_ (new ::CIAO::Config_Handlers::ORBConfigs (*s.orbConfigs_)),
    regulator__ ()
    {
      if (cmdline_.get ()) cmdline_->container (this);
      if (svcconf_.get ()) svcconf_->container (this);
      orbConfigs_->container (this);
    }

    ::CIAO::Config_Handlers::ServerResourcesDef& ServerResourcesDef::
    operator= (::CIAO::Config_Handlers::ServerResourcesDef const& s)
    {
      if (s.cmdline_.get ()) cmdline (*(s.cmdline_));
      else cmdline_ = ::std::auto_ptr< ::CIAO::Config_Handlers::ServerCmdlineOptions > (0);

      if (s.svcconf_.get ()) svcconf (*(s.svcconf_));
      else svcconf_ = ::std::auto_ptr< ::CIAO::Config_Handlers::ACESvcConf > (0);

      orbConfigs (s.orbConfigs ());

      return *this;
    }


    // ServerResourcesDef
    // 
    bool ServerResourcesDef::
    cmdline_p () const
    {
      return cmdline_.get () != 0;
    }

    ::CIAO::Config_Handlers::ServerCmdlineOptions const& ServerResourcesDef::
    cmdline () const
    {
      return *cmdline_;
    }

    ::CIAO::Config_Handlers::ServerCmdlineOptions& ServerResourcesDef::
    cmdline ()
    {
      return *cmdline_;
    }

    void ServerResourcesDef::
    cmdline (::CIAO::Config_Handlers::ServerCmdlineOptions const& e)
    {
      if (cmdline_.get ())
      {
        *cmdline_ = e;
      }

      else
      {
        cmdline_ = ::std::auto_ptr< ::CIAO::Config_Handlers::ServerCmdlineOptions > (new ::CIAO::Config_Handlers::ServerCmdlineOptions (e));
        cmdline_->container (this);
      }
    }

    // ServerResourcesDef
    // 
    bool ServerResourcesDef::
    svcconf_p () const
    {
      return svcconf_.get () != 0;
    }

    ::CIAO::Config_Handlers::ACESvcConf const& ServerResourcesDef::
    svcconf () const
    {
      return *svcconf_;
    }

    ::CIAO::Config_Handlers::ACESvcConf& ServerResourcesDef::
    svcconf ()
    {
      return *svcconf_;
    }

    void ServerResourcesDef::
    svcconf (::CIAO::Config_Handlers::ACESvcConf const& e)
    {
      if (svcconf_.get ())
      {
        *svcconf_ = e;
      }

      else
      {
        svcconf_ = ::std::auto_ptr< ::CIAO::Config_Handlers::ACESvcConf > (new ::CIAO::Config_Handlers::ACESvcConf (e));
        svcconf_->container (this);
      }
    }

    // ServerResourcesDef
    // 
    ::CIAO::Config_Handlers::ORBConfigs const& ServerResourcesDef::
    orbConfigs () const
    {
      return *orbConfigs_;
    }

    ::CIAO::Config_Handlers::ORBConfigs& ServerResourcesDef::
    orbConfigs ()
    {
      return *orbConfigs_;
    }

    void ServerResourcesDef::
    orbConfigs (::CIAO::Config_Handlers::ORBConfigs const& e)
    {
      *orbConfigs_ = e;
    }


    // ServerCmdlineOptions
    // 

    ServerCmdlineOptions::
    ServerCmdlineOptions ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    ServerCmdlineOptions::
    ServerCmdlineOptions (::CIAO::Config_Handlers::ServerCmdlineOptions const& s)
    :
    ::XSCRT::Type (),
    regulator__ ()
    {
      arg_.reserve (s.arg_.size ());
      {
        for (arg_const_iterator i (s.arg_.begin ());
        i != s.arg_.end ();
        ++i) add_arg (*i);
      }
    }

    ::CIAO::Config_Handlers::ServerCmdlineOptions& ServerCmdlineOptions::
    operator= (::CIAO::Config_Handlers::ServerCmdlineOptions const& s)
    {
      arg_.clear ();
      arg_.reserve (s.arg_.size ());
      {
        for (arg_const_iterator i (s.arg_.begin ());
        i != s.arg_.end ();
        ++i) add_arg (*i);
      }

      return *this;
    }


    // ServerCmdlineOptions
    // 
    ServerCmdlineOptions::arg_iterator ServerCmdlineOptions::
    begin_arg ()
    {
      return arg_.begin ();
    }

    ServerCmdlineOptions::arg_iterator ServerCmdlineOptions::
    end_arg ()
    {
      return arg_.end ();
    }

    ServerCmdlineOptions::arg_const_iterator ServerCmdlineOptions::
    begin_arg () const
    {
      return arg_.begin ();
    }

    ServerCmdlineOptions::arg_const_iterator ServerCmdlineOptions::
    end_arg () const
    {
      return arg_.end ();
    }

    void ServerCmdlineOptions::
    add_arg (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (arg_.capacity () < arg_.size () + 1)
      {
        ::std::vector< ::XMLSchema::string< ACE_TCHAR > > v;
        v.reserve (arg_.size () + 1);

        while (arg_.size ())
        {
          //@@ VC6
          ::XMLSchema::string< ACE_TCHAR >& t = arg_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          arg_.pop_back ();
        }

        arg_.swap (v);
      }

      arg_.push_back (e);
      arg_.back ().container (this);
    }

    size_t ServerCmdlineOptions::
    count_arg(void)
    {
      return arg_.size ();
    }


    // ACESvcConf
    // 

    ACESvcConf::
    ACESvcConf ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    ACESvcConf::
    ACESvcConf (::CIAO::Config_Handlers::ACESvcConf const& s)
    :
    ::XSCRT::Type (),
    uri_ (s.uri_.get () ? new ::XMLSchema::string< ACE_TCHAR > (*s.uri_) : 0),
    regulator__ ()
    {
      if (uri_.get ()) uri_->container (this);
    }

    ::CIAO::Config_Handlers::ACESvcConf& ACESvcConf::
    operator= (::CIAO::Config_Handlers::ACESvcConf const& s)
    {
      if (s.uri_.get ()) uri (*(s.uri_));
      else uri_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (0);

      return *this;
    }


    // ACESvcConf
    // 
    bool ACESvcConf::
    uri_p () const
    {
      return uri_.get () != 0;
    }

    ::XMLSchema::string< ACE_TCHAR > const& ACESvcConf::
    uri () const
    {
      return *uri_;
    }

    ::XMLSchema::string< ACE_TCHAR >& ACESvcConf::
    uri ()
    {
      return *uri_;
    }

    void ACESvcConf::
    uri (::XMLSchema::string< ACE_TCHAR > const& e)
    {
      if (uri_.get ())
      {
        *uri_ = e;
      }

      else
      {
        uri_ = ::std::auto_ptr< ::XMLSchema::string< ACE_TCHAR > > (new ::XMLSchema::string< ACE_TCHAR > (e));
        uri_->container (this);
      }
    }


    // ORBConfigs
    // 

    ORBConfigs::
    ORBConfigs ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    ORBConfigs::
    ORBConfigs (::CIAO::Config_Handlers::ORBConfigs const& s)
    :
    ::XSCRT::Type (),
    resources_ (s.resources_.get () ? new ::CIAO::Config_Handlers::ORBResources (*s.resources_) : 0),
    regulator__ ()
    {
      if (resources_.get ()) resources_->container (this);
      policySet_.reserve (s.policySet_.size ());
      {
        for (policySet_const_iterator i (s.policySet_.begin ());
        i != s.policySet_.end ();
        ++i) add_policySet (*i);
      }
    }

    ::CIAO::Config_Handlers::ORBConfigs& ORBConfigs::
    operator= (::CIAO::Config_Handlers::ORBConfigs const& s)
    {
      if (s.resources_.get ()) resources (*(s.resources_));
      else resources_ = ::std::auto_ptr< ::CIAO::Config_Handlers::ORBResources > (0);

      policySet_.clear ();
      policySet_.reserve (s.policySet_.size ());
      {
        for (policySet_const_iterator i (s.policySet_.begin ());
        i != s.policySet_.end ();
        ++i) add_policySet (*i);
      }

      return *this;
    }


    // ORBConfigs
    // 
    bool ORBConfigs::
    resources_p () const
    {
      return resources_.get () != 0;
    }

    ::CIAO::Config_Handlers::ORBResources const& ORBConfigs::
    resources () const
    {
      return *resources_;
    }

    ::CIAO::Config_Handlers::ORBResources& ORBConfigs::
    resources ()
    {
      return *resources_;
    }

    void ORBConfigs::
    resources (::CIAO::Config_Handlers::ORBResources const& e)
    {
      if (resources_.get ())
      {
        *resources_ = e;
      }

      else
      {
        resources_ = ::std::auto_ptr< ::CIAO::Config_Handlers::ORBResources > (new ::CIAO::Config_Handlers::ORBResources (e));
        resources_->container (this);
      }
    }

    // ORBConfigs
    // 
    ORBConfigs::policySet_iterator ORBConfigs::
    begin_policySet ()
    {
      return policySet_.begin ();
    }

    ORBConfigs::policySet_iterator ORBConfigs::
    end_policySet ()
    {
      return policySet_.end ();
    }

    ORBConfigs::policySet_const_iterator ORBConfigs::
    begin_policySet () const
    {
      return policySet_.begin ();
    }

    ORBConfigs::policySet_const_iterator ORBConfigs::
    end_policySet () const
    {
      return policySet_.end ();
    }

    void ORBConfigs::
    add_policySet (::CIAO::Config_Handlers::PolicySet const& e)
    {
      if (policySet_.capacity () < policySet_.size () + 1)
      {
        ::std::vector< ::CIAO::Config_Handlers::PolicySet > v;
        v.reserve (policySet_.size () + 1);

        while (policySet_.size ())
        {
          //@@ VC6
          ::CIAO::Config_Handlers::PolicySet& t = policySet_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          policySet_.pop_back ();
        }

        policySet_.swap (v);
      }

      policySet_.push_back (e);
      policySet_.back ().container (this);
    }

    size_t ORBConfigs::
    count_policySet(void)
    {
      return policySet_.size ();
    }


    // ORBResources
    // 

    ORBResources::
    ORBResources ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    ORBResources::
    ORBResources (::CIAO::Config_Handlers::ORBResources const& s)
    :
    ::XSCRT::Type (),
    regulator__ ()
    {
      threadpool_.reserve (s.threadpool_.size ());
      {
        for (threadpool_const_iterator i (s.threadpool_.begin ());
        i != s.threadpool_.end ();
        ++i) add_threadpool (*i);
      }

      threadpoolWithLanes_.reserve (s.threadpoolWithLanes_.size ());
      {
        for (threadpoolWithLanes_const_iterator i (s.threadpoolWithLanes_.begin ());
        i != s.threadpoolWithLanes_.end ();
        ++i) add_threadpoolWithLanes (*i);
      }

      connectionBands_.reserve (s.connectionBands_.size ());
      {
        for (connectionBands_const_iterator i (s.connectionBands_.begin ());
        i != s.connectionBands_.end ();
        ++i) add_connectionBands (*i);
      }
    }

    ::CIAO::Config_Handlers::ORBResources& ORBResources::
    operator= (::CIAO::Config_Handlers::ORBResources const& s)
    {
      threadpool_.clear ();
      threadpool_.reserve (s.threadpool_.size ());
      {
        for (threadpool_const_iterator i (s.threadpool_.begin ());
        i != s.threadpool_.end ();
        ++i) add_threadpool (*i);
      }

      threadpoolWithLanes_.clear ();
      threadpoolWithLanes_.reserve (s.threadpoolWithLanes_.size ());
      {
        for (threadpoolWithLanes_const_iterator i (s.threadpoolWithLanes_.begin ());
        i != s.threadpoolWithLanes_.end ();
        ++i) add_threadpoolWithLanes (*i);
      }

      connectionBands_.clear ();
      connectionBands_.reserve (s.connectionBands_.size ());
      {
        for (connectionBands_const_iterator i (s.connectionBands_.begin ());
        i != s.connectionBands_.end ();
        ++i) add_connectionBands (*i);
      }

      return *this;
    }


    // ORBResources
    // 
    ORBResources::threadpool_iterator ORBResources::
    begin_threadpool ()
    {
      return threadpool_.begin ();
    }

    ORBResources::threadpool_iterator ORBResources::
    end_threadpool ()
    {
      return threadpool_.end ();
    }

    ORBResources::threadpool_const_iterator ORBResources::
    begin_threadpool () const
    {
      return threadpool_.begin ();
    }

    ORBResources::threadpool_const_iterator ORBResources::
    end_threadpool () const
    {
      return threadpool_.end ();
    }

    void ORBResources::
    add_threadpool (::CIAO::Config_Handlers::ThreadpoolDef const& e)
    {
      if (threadpool_.capacity () < threadpool_.size () + 1)
      {
        ::std::vector< ::CIAO::Config_Handlers::ThreadpoolDef > v;
        v.reserve (threadpool_.size () + 1);

        while (threadpool_.size ())
        {
          //@@ VC6
          ::CIAO::Config_Handlers::ThreadpoolDef& t = threadpool_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          threadpool_.pop_back ();
        }

        threadpool_.swap (v);
      }

      threadpool_.push_back (e);
      threadpool_.back ().container (this);
    }

    size_t ORBResources::
    count_threadpool(void)
    {
      return threadpool_.size ();
    }

    // ORBResources
    // 
    ORBResources::threadpoolWithLanes_iterator ORBResources::
    begin_threadpoolWithLanes ()
    {
      return threadpoolWithLanes_.begin ();
    }

    ORBResources::threadpoolWithLanes_iterator ORBResources::
    end_threadpoolWithLanes ()
    {
      return threadpoolWithLanes_.end ();
    }

    ORBResources::threadpoolWithLanes_const_iterator ORBResources::
    begin_threadpoolWithLanes () const
    {
      return threadpoolWithLanes_.begin ();
    }

    ORBResources::threadpoolWithLanes_const_iterator ORBResources::
    end_threadpoolWithLanes () const
    {
      return threadpoolWithLanes_.end ();
    }

    void ORBResources::
    add_threadpoolWithLanes (::CIAO::Config_Handlers::ThreadpoolWithLanesDef const& e)
    {
      if (threadpoolWithLanes_.capacity () < threadpoolWithLanes_.size () + 1)
      {
        ::std::vector< ::CIAO::Config_Handlers::ThreadpoolWithLanesDef > v;
        v.reserve (threadpoolWithLanes_.size () + 1);

        while (threadpoolWithLanes_.size ())
        {
          //@@ VC6
          ::CIAO::Config_Handlers::ThreadpoolWithLanesDef& t = threadpoolWithLanes_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          threadpoolWithLanes_.pop_back ();
        }

        threadpoolWithLanes_.swap (v);
      }

      threadpoolWithLanes_.push_back (e);
      threadpoolWithLanes_.back ().container (this);
    }

    size_t ORBResources::
    count_threadpoolWithLanes(void)
    {
      return threadpoolWithLanes_.size ();
    }

    // ORBResources
    // 
    ORBResources::connectionBands_iterator ORBResources::
    begin_connectionBands ()
    {
      return connectionBands_.begin ();
    }

    ORBResources::connectionBands_iterator ORBResources::
    end_connectionBands ()
    {
      return connectionBands_.end ();
    }

    ORBResources::connectionBands_const_iterator ORBResources::
    begin_connectionBands () const
    {
      return connectionBands_.begin ();
    }

    ORBResources::connectionBands_const_iterator ORBResources::
    end_connectionBands () const
    {
      return connectionBands_.end ();
    }

    void ORBResources::
    add_connectionBands (::CIAO::Config_Handlers::ConnectionBandsDef const& e)
    {
      if (connectionBands_.capacity () < connectionBands_.size () + 1)
      {
        ::std::vector< ::CIAO::Config_Handlers::ConnectionBandsDef > v;
        v.reserve (connectionBands_.size () + 1);

        while (connectionBands_.size ())
        {
          //@@ VC6
          ::CIAO::Config_Handlers::ConnectionBandsDef& t = connectionBands_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          connectionBands_.pop_back ();
        }

        connectionBands_.swap (v);
      }

      connectionBands_.push_back (e);
      connectionBands_.back ().container (this);
    }

    size_t ORBResources::
    count_connectionBands(void)
    {
      return connectionBands_.size ();
    }


    // Priority
    // 

    Priority::
    Priority (::XMLSchema::int_ const& b__)
    : 
    Base__ (b__),
    regulator__ ()
    {
    }

    Priority::
    Priority (::CIAO::Config_Handlers::Priority const& s)
    :
    Base__ (s),
    regulator__ ()
    {
    }

    ::CIAO::Config_Handlers::Priority& Priority::
    operator= (::CIAO::Config_Handlers::Priority const& s)
    {
      static_cast< Base__& > (*this) = static_cast< Base__ const& > (s);

      return *this;
    }



    // ThreadpoolDef
    // 

    ThreadpoolDef::
    ThreadpoolDef ()
    : 
    regulator__ ()
    {
    }

    ThreadpoolDef::
    ThreadpoolDef (::CIAO::Config_Handlers::ThreadpoolDef const& s)
    :
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    stacksize_ (s.stacksize_.get () ? new ::XMLSchema::unsignedLong (*s.stacksize_) : 0),
    static_threads_ (s.static_threads_.get () ? new ::XMLSchema::unsignedLong (*s.static_threads_) : 0),
    dynamic_threads_ (s.dynamic_threads_.get () ? new ::XMLSchema::unsignedLong (*s.dynamic_threads_) : 0),
    default_priority_ (s.default_priority_.get () ? new ::CIAO::Config_Handlers::Priority (*s.default_priority_) : 0),
    allow_request_buffering_ (s.allow_request_buffering_.get () ? new ::XMLSchema::boolean (*s.allow_request_buffering_) : 0),
    max_buffered_requests_ (s.max_buffered_requests_.get () ? new ::XMLSchema::unsignedLong (*s.max_buffered_requests_) : 0),
    max_request_buffered_size_ (s.max_request_buffered_size_.get () ? new ::XMLSchema::unsignedLong (*s.max_request_buffered_size_) : 0),
    regulator__ ()
    {
      if (id_.get ()) id_->container (this);
      if (stacksize_.get ()) stacksize_->container (this);
      if (static_threads_.get ()) static_threads_->container (this);
      if (dynamic_threads_.get ()) dynamic_threads_->container (this);
      if (default_priority_.get ()) default_priority_->container (this);
      if (allow_request_buffering_.get ()) allow_request_buffering_->container (this);
      if (max_buffered_requests_.get ()) max_buffered_requests_->container (this);
      if (max_request_buffered_size_.get ()) max_request_buffered_size_->container (this);
    }

    ::CIAO::Config_Handlers::ThreadpoolDef& ThreadpoolDef::
    operator= (::CIAO::Config_Handlers::ThreadpoolDef const& s)
    {
      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      if (s.stacksize_.get ()) stacksize (*(s.stacksize_));
      else stacksize_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      if (s.static_threads_.get ()) static_threads (*(s.static_threads_));
      else static_threads_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      if (s.dynamic_threads_.get ()) dynamic_threads (*(s.dynamic_threads_));
      else dynamic_threads_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      if (s.default_priority_.get ()) default_priority (*(s.default_priority_));
      else default_priority_ = ::std::auto_ptr< ::CIAO::Config_Handlers::Priority > (0);

      if (s.allow_request_buffering_.get ()) allow_request_buffering (*(s.allow_request_buffering_));
      else allow_request_buffering_ = ::std::auto_ptr< ::XMLSchema::boolean > (0);

      if (s.max_buffered_requests_.get ()) max_buffered_requests (*(s.max_buffered_requests_));
      else max_buffered_requests_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      if (s.max_request_buffered_size_.get ()) max_request_buffered_size (*(s.max_request_buffered_size_));
      else max_request_buffered_size_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      return *this;
    }


    // ThreadpoolDef
    // 
    bool ThreadpoolDef::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& ThreadpoolDef::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& ThreadpoolDef::
    id ()
    {
      return *id_;
    }

    void ThreadpoolDef::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }

    // ThreadpoolDef
    // 
    bool ThreadpoolDef::
    stacksize_p () const
    {
      return stacksize_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolDef::
    stacksize () const
    {
      return *stacksize_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolDef::
    stacksize ()
    {
      return *stacksize_;
    }

    void ThreadpoolDef::
    stacksize (::XMLSchema::unsignedLong const& e)
    {
      if (stacksize_.get ())
      {
        *stacksize_ = e;
      }

      else
      {
        stacksize_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        stacksize_->container (this);
      }
    }

    // ThreadpoolDef
    // 
    bool ThreadpoolDef::
    static_threads_p () const
    {
      return static_threads_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolDef::
    static_threads () const
    {
      return *static_threads_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolDef::
    static_threads ()
    {
      return *static_threads_;
    }

    void ThreadpoolDef::
    static_threads (::XMLSchema::unsignedLong const& e)
    {
      if (static_threads_.get ())
      {
        *static_threads_ = e;
      }

      else
      {
        static_threads_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        static_threads_->container (this);
      }
    }

    // ThreadpoolDef
    // 
    bool ThreadpoolDef::
    dynamic_threads_p () const
    {
      return dynamic_threads_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolDef::
    dynamic_threads () const
    {
      return *dynamic_threads_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolDef::
    dynamic_threads ()
    {
      return *dynamic_threads_;
    }

    void ThreadpoolDef::
    dynamic_threads (::XMLSchema::unsignedLong const& e)
    {
      if (dynamic_threads_.get ())
      {
        *dynamic_threads_ = e;
      }

      else
      {
        dynamic_threads_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        dynamic_threads_->container (this);
      }
    }

    // ThreadpoolDef
    // 
    bool ThreadpoolDef::
    default_priority_p () const
    {
      return default_priority_.get () != 0;
    }

    ::CIAO::Config_Handlers::Priority const& ThreadpoolDef::
    default_priority () const
    {
      return *default_priority_;
    }

    ::CIAO::Config_Handlers::Priority& ThreadpoolDef::
    default_priority ()
    {
      return *default_priority_;
    }

    void ThreadpoolDef::
    default_priority (::CIAO::Config_Handlers::Priority const& e)
    {
      if (default_priority_.get ())
      {
        *default_priority_ = e;
      }

      else
      {
        default_priority_ = ::std::auto_ptr< ::CIAO::Config_Handlers::Priority > (new ::CIAO::Config_Handlers::Priority (e));
        default_priority_->container (this);
      }
    }

    // ThreadpoolDef
    // 
    bool ThreadpoolDef::
    allow_request_buffering_p () const
    {
      return allow_request_buffering_.get () != 0;
    }

    ::XMLSchema::boolean const& ThreadpoolDef::
    allow_request_buffering () const
    {
      return *allow_request_buffering_;
    }

    ::XMLSchema::boolean& ThreadpoolDef::
    allow_request_buffering ()
    {
      return *allow_request_buffering_;
    }

    void ThreadpoolDef::
    allow_request_buffering (::XMLSchema::boolean const& e)
    {
      if (allow_request_buffering_.get ())
      {
        *allow_request_buffering_ = e;
      }

      else
      {
        allow_request_buffering_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
        allow_request_buffering_->container (this);
      }
    }

    // ThreadpoolDef
    // 
    bool ThreadpoolDef::
    max_buffered_requests_p () const
    {
      return max_buffered_requests_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolDef::
    max_buffered_requests () const
    {
      return *max_buffered_requests_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolDef::
    max_buffered_requests ()
    {
      return *max_buffered_requests_;
    }

    void ThreadpoolDef::
    max_buffered_requests (::XMLSchema::unsignedLong const& e)
    {
      if (max_buffered_requests_.get ())
      {
        *max_buffered_requests_ = e;
      }

      else
      {
        max_buffered_requests_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        max_buffered_requests_->container (this);
      }
    }

    // ThreadpoolDef
    // 
    bool ThreadpoolDef::
    max_request_buffered_size_p () const
    {
      return max_request_buffered_size_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolDef::
    max_request_buffered_size () const
    {
      return *max_request_buffered_size_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolDef::
    max_request_buffered_size ()
    {
      return *max_request_buffered_size_;
    }

    void ThreadpoolDef::
    max_request_buffered_size (::XMLSchema::unsignedLong const& e)
    {
      if (max_request_buffered_size_.get ())
      {
        *max_request_buffered_size_ = e;
      }

      else
      {
        max_request_buffered_size_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        max_request_buffered_size_->container (this);
      }
    }


    // ThreadpoolWithLanesDef
    // 

    ThreadpoolWithLanesDef::
    ThreadpoolWithLanesDef ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    ThreadpoolWithLanesDef::
    ThreadpoolWithLanesDef (::CIAO::Config_Handlers::ThreadpoolWithLanesDef const& s)
    :
    ::XSCRT::Type (),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    stacksize_ (s.stacksize_.get () ? new ::XMLSchema::unsignedLong (*s.stacksize_) : 0),
    allow_borrowing_ (s.allow_borrowing_.get () ? new ::XMLSchema::boolean (*s.allow_borrowing_) : 0),
    allow_request_buffering_ (s.allow_request_buffering_.get () ? new ::XMLSchema::boolean (*s.allow_request_buffering_) : 0),
    max_buffered_requests_ (s.max_buffered_requests_.get () ? new ::XMLSchema::unsignedLong (*s.max_buffered_requests_) : 0),
    max_request_buffered_size_ (s.max_request_buffered_size_.get () ? new ::XMLSchema::unsignedLong (*s.max_request_buffered_size_) : 0),
    regulator__ ()
    {
      threadpoolLane_.reserve (s.threadpoolLane_.size ());
      {
        for (threadpoolLane_const_iterator i (s.threadpoolLane_.begin ());
        i != s.threadpoolLane_.end ();
        ++i) add_threadpoolLane (*i);
      }

      if (id_.get ()) id_->container (this);
      if (stacksize_.get ()) stacksize_->container (this);
      if (allow_borrowing_.get ()) allow_borrowing_->container (this);
      if (allow_request_buffering_.get ()) allow_request_buffering_->container (this);
      if (max_buffered_requests_.get ()) max_buffered_requests_->container (this);
      if (max_request_buffered_size_.get ()) max_request_buffered_size_->container (this);
    }

    ::CIAO::Config_Handlers::ThreadpoolWithLanesDef& ThreadpoolWithLanesDef::
    operator= (::CIAO::Config_Handlers::ThreadpoolWithLanesDef const& s)
    {
      threadpoolLane_.clear ();
      threadpoolLane_.reserve (s.threadpoolLane_.size ());
      {
        for (threadpoolLane_const_iterator i (s.threadpoolLane_.begin ());
        i != s.threadpoolLane_.end ();
        ++i) add_threadpoolLane (*i);
      }

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      if (s.stacksize_.get ()) stacksize (*(s.stacksize_));
      else stacksize_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      if (s.allow_borrowing_.get ()) allow_borrowing (*(s.allow_borrowing_));
      else allow_borrowing_ = ::std::auto_ptr< ::XMLSchema::boolean > (0);

      if (s.allow_request_buffering_.get ()) allow_request_buffering (*(s.allow_request_buffering_));
      else allow_request_buffering_ = ::std::auto_ptr< ::XMLSchema::boolean > (0);

      if (s.max_buffered_requests_.get ()) max_buffered_requests (*(s.max_buffered_requests_));
      else max_buffered_requests_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      if (s.max_request_buffered_size_.get ()) max_request_buffered_size (*(s.max_request_buffered_size_));
      else max_request_buffered_size_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      return *this;
    }


    // ThreadpoolWithLanesDef
    // 
    ThreadpoolWithLanesDef::threadpoolLane_iterator ThreadpoolWithLanesDef::
    begin_threadpoolLane ()
    {
      return threadpoolLane_.begin ();
    }

    ThreadpoolWithLanesDef::threadpoolLane_iterator ThreadpoolWithLanesDef::
    end_threadpoolLane ()
    {
      return threadpoolLane_.end ();
    }

    ThreadpoolWithLanesDef::threadpoolLane_const_iterator ThreadpoolWithLanesDef::
    begin_threadpoolLane () const
    {
      return threadpoolLane_.begin ();
    }

    ThreadpoolWithLanesDef::threadpoolLane_const_iterator ThreadpoolWithLanesDef::
    end_threadpoolLane () const
    {
      return threadpoolLane_.end ();
    }

    void ThreadpoolWithLanesDef::
    add_threadpoolLane (::CIAO::Config_Handlers::ThreadpoolLaneDef const& e)
    {
      if (threadpoolLane_.capacity () < threadpoolLane_.size () + 1)
      {
        ::std::vector< ::CIAO::Config_Handlers::ThreadpoolLaneDef > v;
        v.reserve (threadpoolLane_.size () + 1);

        while (threadpoolLane_.size ())
        {
          //@@ VC6
          ::CIAO::Config_Handlers::ThreadpoolLaneDef& t = threadpoolLane_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          threadpoolLane_.pop_back ();
        }

        threadpoolLane_.swap (v);
      }

      threadpoolLane_.push_back (e);
      threadpoolLane_.back ().container (this);
    }

    size_t ThreadpoolWithLanesDef::
    count_threadpoolLane(void)
    {
      return threadpoolLane_.size ();
    }

    // ThreadpoolWithLanesDef
    // 
    bool ThreadpoolWithLanesDef::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& ThreadpoolWithLanesDef::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& ThreadpoolWithLanesDef::
    id ()
    {
      return *id_;
    }

    void ThreadpoolWithLanesDef::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }

    // ThreadpoolWithLanesDef
    // 
    bool ThreadpoolWithLanesDef::
    stacksize_p () const
    {
      return stacksize_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolWithLanesDef::
    stacksize () const
    {
      return *stacksize_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolWithLanesDef::
    stacksize ()
    {
      return *stacksize_;
    }

    void ThreadpoolWithLanesDef::
    stacksize (::XMLSchema::unsignedLong const& e)
    {
      if (stacksize_.get ())
      {
        *stacksize_ = e;
      }

      else
      {
        stacksize_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        stacksize_->container (this);
      }
    }

    // ThreadpoolWithLanesDef
    // 
    bool ThreadpoolWithLanesDef::
    allow_borrowing_p () const
    {
      return allow_borrowing_.get () != 0;
    }

    ::XMLSchema::boolean const& ThreadpoolWithLanesDef::
    allow_borrowing () const
    {
      return *allow_borrowing_;
    }

    ::XMLSchema::boolean& ThreadpoolWithLanesDef::
    allow_borrowing ()
    {
      return *allow_borrowing_;
    }

    void ThreadpoolWithLanesDef::
    allow_borrowing (::XMLSchema::boolean const& e)
    {
      if (allow_borrowing_.get ())
      {
        *allow_borrowing_ = e;
      }

      else
      {
        allow_borrowing_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
        allow_borrowing_->container (this);
      }
    }

    // ThreadpoolWithLanesDef
    // 
    bool ThreadpoolWithLanesDef::
    allow_request_buffering_p () const
    {
      return allow_request_buffering_.get () != 0;
    }

    ::XMLSchema::boolean const& ThreadpoolWithLanesDef::
    allow_request_buffering () const
    {
      return *allow_request_buffering_;
    }

    ::XMLSchema::boolean& ThreadpoolWithLanesDef::
    allow_request_buffering ()
    {
      return *allow_request_buffering_;
    }

    void ThreadpoolWithLanesDef::
    allow_request_buffering (::XMLSchema::boolean const& e)
    {
      if (allow_request_buffering_.get ())
      {
        *allow_request_buffering_ = e;
      }

      else
      {
        allow_request_buffering_ = ::std::auto_ptr< ::XMLSchema::boolean > (new ::XMLSchema::boolean (e));
        allow_request_buffering_->container (this);
      }
    }

    // ThreadpoolWithLanesDef
    // 
    bool ThreadpoolWithLanesDef::
    max_buffered_requests_p () const
    {
      return max_buffered_requests_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolWithLanesDef::
    max_buffered_requests () const
    {
      return *max_buffered_requests_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolWithLanesDef::
    max_buffered_requests ()
    {
      return *max_buffered_requests_;
    }

    void ThreadpoolWithLanesDef::
    max_buffered_requests (::XMLSchema::unsignedLong const& e)
    {
      if (max_buffered_requests_.get ())
      {
        *max_buffered_requests_ = e;
      }

      else
      {
        max_buffered_requests_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        max_buffered_requests_->container (this);
      }
    }

    // ThreadpoolWithLanesDef
    // 
    bool ThreadpoolWithLanesDef::
    max_request_buffered_size_p () const
    {
      return max_request_buffered_size_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolWithLanesDef::
    max_request_buffered_size () const
    {
      return *max_request_buffered_size_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolWithLanesDef::
    max_request_buffered_size ()
    {
      return *max_request_buffered_size_;
    }

    void ThreadpoolWithLanesDef::
    max_request_buffered_size (::XMLSchema::unsignedLong const& e)
    {
      if (max_request_buffered_size_.get ())
      {
        *max_request_buffered_size_ = e;
      }

      else
      {
        max_request_buffered_size_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        max_request_buffered_size_->container (this);
      }
    }


    // ThreadpoolLaneDef
    // 

    ThreadpoolLaneDef::
    ThreadpoolLaneDef ()
    : 
    regulator__ ()
    {
    }

    ThreadpoolLaneDef::
    ThreadpoolLaneDef (::CIAO::Config_Handlers::ThreadpoolLaneDef const& s)
    :
    static_threads_ (s.static_threads_.get () ? new ::XMLSchema::unsignedLong (*s.static_threads_) : 0),
    dynamic_threads_ (s.dynamic_threads_.get () ? new ::XMLSchema::unsignedLong (*s.dynamic_threads_) : 0),
    priority_ (s.priority_.get () ? new ::CIAO::Config_Handlers::Priority (*s.priority_) : 0),
    regulator__ ()
    {
      if (static_threads_.get ()) static_threads_->container (this);
      if (dynamic_threads_.get ()) dynamic_threads_->container (this);
      if (priority_.get ()) priority_->container (this);
    }

    ::CIAO::Config_Handlers::ThreadpoolLaneDef& ThreadpoolLaneDef::
    operator= (::CIAO::Config_Handlers::ThreadpoolLaneDef const& s)
    {
      if (s.static_threads_.get ()) static_threads (*(s.static_threads_));
      else static_threads_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      if (s.dynamic_threads_.get ()) dynamic_threads (*(s.dynamic_threads_));
      else dynamic_threads_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (0);

      if (s.priority_.get ()) priority (*(s.priority_));
      else priority_ = ::std::auto_ptr< ::CIAO::Config_Handlers::Priority > (0);

      return *this;
    }


    // ThreadpoolLaneDef
    // 
    bool ThreadpoolLaneDef::
    static_threads_p () const
    {
      return static_threads_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolLaneDef::
    static_threads () const
    {
      return *static_threads_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolLaneDef::
    static_threads ()
    {
      return *static_threads_;
    }

    void ThreadpoolLaneDef::
    static_threads (::XMLSchema::unsignedLong const& e)
    {
      if (static_threads_.get ())
      {
        *static_threads_ = e;
      }

      else
      {
        static_threads_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        static_threads_->container (this);
      }
    }

    // ThreadpoolLaneDef
    // 
    bool ThreadpoolLaneDef::
    dynamic_threads_p () const
    {
      return dynamic_threads_.get () != 0;
    }

    ::XMLSchema::unsignedLong const& ThreadpoolLaneDef::
    dynamic_threads () const
    {
      return *dynamic_threads_;
    }

    ::XMLSchema::unsignedLong& ThreadpoolLaneDef::
    dynamic_threads ()
    {
      return *dynamic_threads_;
    }

    void ThreadpoolLaneDef::
    dynamic_threads (::XMLSchema::unsignedLong const& e)
    {
      if (dynamic_threads_.get ())
      {
        *dynamic_threads_ = e;
      }

      else
      {
        dynamic_threads_ = ::std::auto_ptr< ::XMLSchema::unsignedLong > (new ::XMLSchema::unsignedLong (e));
        dynamic_threads_->container (this);
      }
    }

    // ThreadpoolLaneDef
    // 
    bool ThreadpoolLaneDef::
    priority_p () const
    {
      return priority_.get () != 0;
    }

    ::CIAO::Config_Handlers::Priority const& ThreadpoolLaneDef::
    priority () const
    {
      return *priority_;
    }

    ::CIAO::Config_Handlers::Priority& ThreadpoolLaneDef::
    priority ()
    {
      return *priority_;
    }

    void ThreadpoolLaneDef::
    priority (::CIAO::Config_Handlers::Priority const& e)
    {
      if (priority_.get ())
      {
        *priority_ = e;
      }

      else
      {
        priority_ = ::std::auto_ptr< ::CIAO::Config_Handlers::Priority > (new ::CIAO::Config_Handlers::Priority (e));
        priority_->container (this);
      }
    }


    // ConnectionBandsDef
    // 

    ConnectionBandsDef::
    ConnectionBandsDef ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    ConnectionBandsDef::
    ConnectionBandsDef (::CIAO::Config_Handlers::ConnectionBandsDef const& s)
    :
    ::XSCRT::Type (),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      band_.reserve (s.band_.size ());
      {
        for (band_const_iterator i (s.band_.begin ());
        i != s.band_.end ();
        ++i) add_band (*i);
      }

      if (id_.get ()) id_->container (this);
    }

    ::CIAO::Config_Handlers::ConnectionBandsDef& ConnectionBandsDef::
    operator= (::CIAO::Config_Handlers::ConnectionBandsDef const& s)
    {
      band_.clear ();
      band_.reserve (s.band_.size ());
      {
        for (band_const_iterator i (s.band_.begin ());
        i != s.band_.end ();
        ++i) add_band (*i);
      }

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // ConnectionBandsDef
    // 
    ConnectionBandsDef::band_iterator ConnectionBandsDef::
    begin_band ()
    {
      return band_.begin ();
    }

    ConnectionBandsDef::band_iterator ConnectionBandsDef::
    end_band ()
    {
      return band_.end ();
    }

    ConnectionBandsDef::band_const_iterator ConnectionBandsDef::
    begin_band () const
    {
      return band_.begin ();
    }

    ConnectionBandsDef::band_const_iterator ConnectionBandsDef::
    end_band () const
    {
      return band_.end ();
    }

    void ConnectionBandsDef::
    add_band (::CIAO::Config_Handlers::PriorityBandDef const& e)
    {
      if (band_.capacity () < band_.size () + 1)
      {
        ::std::vector< ::CIAO::Config_Handlers::PriorityBandDef > v;
        v.reserve (band_.size () + 1);

        while (band_.size ())
        {
          //@@ VC6
          ::CIAO::Config_Handlers::PriorityBandDef& t = band_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          band_.pop_back ();
        }

        band_.swap (v);
      }

      band_.push_back (e);
      band_.back ().container (this);
    }

    size_t ConnectionBandsDef::
    count_band(void)
    {
      return band_.size ();
    }

    // ConnectionBandsDef
    // 
    bool ConnectionBandsDef::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& ConnectionBandsDef::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& ConnectionBandsDef::
    id ()
    {
      return *id_;
    }

    void ConnectionBandsDef::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // PriorityBandDef
    // 

    PriorityBandDef::
    PriorityBandDef ()
    : 
    regulator__ ()
    {
    }

    PriorityBandDef::
    PriorityBandDef (::CIAO::Config_Handlers::PriorityBandDef const& s)
    :
    low_ (s.low_.get () ? new ::XMLSchema::int_ (*s.low_) : 0),
    high_ (s.high_.get () ? new ::XMLSchema::int_ (*s.high_) : 0),
    regulator__ ()
    {
      if (low_.get ()) low_->container (this);
      if (high_.get ()) high_->container (this);
    }

    ::CIAO::Config_Handlers::PriorityBandDef& PriorityBandDef::
    operator= (::CIAO::Config_Handlers::PriorityBandDef const& s)
    {
      if (s.low_.get ()) low (*(s.low_));
      else low_ = ::std::auto_ptr< ::XMLSchema::int_ > (0);

      if (s.high_.get ()) high (*(s.high_));
      else high_ = ::std::auto_ptr< ::XMLSchema::int_ > (0);

      return *this;
    }


    // PriorityBandDef
    // 
    bool PriorityBandDef::
    low_p () const
    {
      return low_.get () != 0;
    }

    ::XMLSchema::int_ const& PriorityBandDef::
    low () const
    {
      return *low_;
    }

    ::XMLSchema::int_& PriorityBandDef::
    low ()
    {
      return *low_;
    }

    void PriorityBandDef::
    low (::XMLSchema::int_ const& e)
    {
      if (low_.get ())
      {
        *low_ = e;
      }

      else
      {
        low_ = ::std::auto_ptr< ::XMLSchema::int_ > (new ::XMLSchema::int_ (e));
        low_->container (this);
      }
    }

    // PriorityBandDef
    // 
    bool PriorityBandDef::
    high_p () const
    {
      return high_.get () != 0;
    }

    ::XMLSchema::int_ const& PriorityBandDef::
    high () const
    {
      return *high_;
    }

    ::XMLSchema::int_& PriorityBandDef::
    high ()
    {
      return *high_;
    }

    void PriorityBandDef::
    high (::XMLSchema::int_ const& e)
    {
      if (high_.get ())
      {
        *high_ = e;
      }

      else
      {
        high_ = ::std::auto_ptr< ::XMLSchema::int_ > (new ::XMLSchema::int_ (e));
        high_->container (this);
      }
    }


    // PolicySet
    // 

    PolicySet::
    PolicySet ()
    : 
    ::XSCRT::Type (), 
    regulator__ ()
    {
    }

    PolicySet::
    PolicySet (::CIAO::Config_Handlers::PolicySet const& s)
    :
    ::XSCRT::Type (),
    id_ (s.id_.get () ? new ::XMLSchema::ID< ACE_TCHAR > (*s.id_) : 0),
    regulator__ ()
    {
      priorityModel_.reserve (s.priorityModel_.size ());
      {
        for (priorityModel_const_iterator i (s.priorityModel_.begin ());
        i != s.priorityModel_.end ();
        ++i) add_priorityModel (*i);
      }

      threadpool_.reserve (s.threadpool_.size ());
      {
        for (threadpool_const_iterator i (s.threadpool_.begin ());
        i != s.threadpool_.end ();
        ++i) add_threadpool (*i);
      }

      priorityBandedConnection_.reserve (s.priorityBandedConnection_.size ());
      {
        for (priorityBandedConnection_const_iterator i (s.priorityBandedConnection_.begin ());
        i != s.priorityBandedConnection_.end ();
        ++i) add_priorityBandedConnection (*i);
      }

      if (id_.get ()) id_->container (this);
    }

    ::CIAO::Config_Handlers::PolicySet& PolicySet::
    operator= (::CIAO::Config_Handlers::PolicySet const& s)
    {
      priorityModel_.clear ();
      priorityModel_.reserve (s.priorityModel_.size ());
      {
        for (priorityModel_const_iterator i (s.priorityModel_.begin ());
        i != s.priorityModel_.end ();
        ++i) add_priorityModel (*i);
      }

      threadpool_.clear ();
      threadpool_.reserve (s.threadpool_.size ());
      {
        for (threadpool_const_iterator i (s.threadpool_.begin ());
        i != s.threadpool_.end ();
        ++i) add_threadpool (*i);
      }

      priorityBandedConnection_.clear ();
      priorityBandedConnection_.reserve (s.priorityBandedConnection_.size ());
      {
        for (priorityBandedConnection_const_iterator i (s.priorityBandedConnection_.begin ());
        i != s.priorityBandedConnection_.end ();
        ++i) add_priorityBandedConnection (*i);
      }

      if (s.id_.get ()) id (*(s.id_));
      else id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (0);

      return *this;
    }


    // PolicySet
    // 
    PolicySet::priorityModel_iterator PolicySet::
    begin_priorityModel ()
    {
      return priorityModel_.begin ();
    }

    PolicySet::priorityModel_iterator PolicySet::
    end_priorityModel ()
    {
      return priorityModel_.end ();
    }

    PolicySet::priorityModel_const_iterator PolicySet::
    begin_priorityModel () const
    {
      return priorityModel_.begin ();
    }

    PolicySet::priorityModel_const_iterator PolicySet::
    end_priorityModel () const
    {
      return priorityModel_.end ();
    }

    void PolicySet::
    add_priorityModel (::CIAO::Config_Handlers::PriorityModelPolicyDef const& e)
    {
      if (priorityModel_.capacity () < priorityModel_.size () + 1)
      {
        ::std::vector< ::CIAO::Config_Handlers::PriorityModelPolicyDef > v;
        v.reserve (priorityModel_.size () + 1);

        while (priorityModel_.size ())
        {
          //@@ VC6
          ::CIAO::Config_Handlers::PriorityModelPolicyDef& t = priorityModel_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          priorityModel_.pop_back ();
        }

        priorityModel_.swap (v);
      }

      priorityModel_.push_back (e);
      priorityModel_.back ().container (this);
    }

    size_t PolicySet::
    count_priorityModel(void)
    {
      return priorityModel_.size ();
    }

    // PolicySet
    // 
    PolicySet::threadpool_iterator PolicySet::
    begin_threadpool ()
    {
      return threadpool_.begin ();
    }

    PolicySet::threadpool_iterator PolicySet::
    end_threadpool ()
    {
      return threadpool_.end ();
    }

    PolicySet::threadpool_const_iterator PolicySet::
    begin_threadpool () const
    {
      return threadpool_.begin ();
    }

    PolicySet::threadpool_const_iterator PolicySet::
    end_threadpool () const
    {
      return threadpool_.end ();
    }

    void PolicySet::
    add_threadpool (::XMLSchema::IDREF< ACE_TCHAR > const& e)
    {
      if (threadpool_.capacity () < threadpool_.size () + 1)
      {
        ::std::vector< ::XMLSchema::IDREF< ACE_TCHAR > > v;
        v.reserve (threadpool_.size () + 1);

        while (threadpool_.size ())
        {
          //@@ VC6
          ::XMLSchema::IDREF< ACE_TCHAR >& t = threadpool_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          threadpool_.pop_back ();
        }

        threadpool_.swap (v);
      }

      threadpool_.push_back (e);
      threadpool_.back ().container (this);
    }

    size_t PolicySet::
    count_threadpool(void)
    {
      return threadpool_.size ();
    }

    // PolicySet
    // 
    PolicySet::priorityBandedConnection_iterator PolicySet::
    begin_priorityBandedConnection ()
    {
      return priorityBandedConnection_.begin ();
    }

    PolicySet::priorityBandedConnection_iterator PolicySet::
    end_priorityBandedConnection ()
    {
      return priorityBandedConnection_.end ();
    }

    PolicySet::priorityBandedConnection_const_iterator PolicySet::
    begin_priorityBandedConnection () const
    {
      return priorityBandedConnection_.begin ();
    }

    PolicySet::priorityBandedConnection_const_iterator PolicySet::
    end_priorityBandedConnection () const
    {
      return priorityBandedConnection_.end ();
    }

    void PolicySet::
    add_priorityBandedConnection (::XMLSchema::IDREF< ACE_TCHAR > const& e)
    {
      if (priorityBandedConnection_.capacity () < priorityBandedConnection_.size () + 1)
      {
        ::std::vector< ::XMLSchema::IDREF< ACE_TCHAR > > v;
        v.reserve (priorityBandedConnection_.size () + 1);

        while (priorityBandedConnection_.size ())
        {
          //@@ VC6
          ::XMLSchema::IDREF< ACE_TCHAR >& t = priorityBandedConnection_.back ();
          t.container (0);
          v.push_back (t);
          v.back ().container (this);
          priorityBandedConnection_.pop_back ();
        }

        priorityBandedConnection_.swap (v);
      }

      priorityBandedConnection_.push_back (e);
      priorityBandedConnection_.back ().container (this);
    }

    size_t PolicySet::
    count_priorityBandedConnection(void)
    {
      return priorityBandedConnection_.size ();
    }

    // PolicySet
    // 
    bool PolicySet::
    id_p () const
    {
      return id_.get () != 0;
    }

    ::XMLSchema::ID< ACE_TCHAR > const& PolicySet::
    id () const
    {
      return *id_;
    }

    ::XMLSchema::ID< ACE_TCHAR >& PolicySet::
    id ()
    {
      return *id_;
    }

    void PolicySet::
    id (::XMLSchema::ID< ACE_TCHAR > const& e)
    {
      if (id_.get ())
      {
        *id_ = e;
      }

      else
      {
        id_ = ::std::auto_ptr< ::XMLSchema::ID< ACE_TCHAR > > (new ::XMLSchema::ID< ACE_TCHAR > (e));
        id_->container (this);
      }
    }


    // PriorityModel
    // 

    PriorityModel::Value PriorityModel::
    integral () const
    {
      return v_;
    }

    bool
    operator== (::CIAO::Config_Handlers::PriorityModel const& a, ::CIAO::Config_Handlers::PriorityModel const& b)
    {
      return a.v_ == b.v_;
    }

    bool
    operator!= (::CIAO::Config_Handlers::PriorityModel const& a, ::CIAO::Config_Handlers::PriorityModel const& b)
    {
      return a.v_ != b.v_;
    }

    PriorityModel::
    PriorityModel (PriorityModel::Value v)
    : v_ (v)
    {
    }

    // PriorityModelPolicyDef
    // 

    PriorityModelPolicyDef::
    PriorityModelPolicyDef (::CIAO::Config_Handlers::PriorityModel const& priority_model__)
    : 
    ::XSCRT::Type (), 
    priority_model_ (new ::CIAO::Config_Handlers::PriorityModel (priority_model__)),
    regulator__ ()
    {
      priority_model_->container (this);
    }

    PriorityModelPolicyDef::
    PriorityModelPolicyDef (::CIAO::Config_Handlers::PriorityModelPolicyDef const& s)
    :
    ::XSCRT::Type (),
    priority_model_ (new ::CIAO::Config_Handlers::PriorityModel (*s.priority_model_)),
    server_priority_ (s.server_priority_.get () ? new ::CIAO::Config_Handlers::Priority (*s.server_priority_) : 0),
    regulator__ ()
    {
      priority_model_->container (this);
      if (server_priority_.get ()) server_priority_->container (this);
    }

    ::CIAO::Config_Handlers::PriorityModelPolicyDef& PriorityModelPolicyDef::
    operator= (::CIAO::Config_Handlers::PriorityModelPolicyDef const& s)
    {
      priority_model (s.priority_model ());

      if (s.server_priority_.get ()) server_priority (*(s.server_priority_));
      else server_priority_ = ::std::auto_ptr< ::CIAO::Config_Handlers::Priority > (0);

      return *this;
    }


    // PriorityModelPolicyDef
    // 
    ::CIAO::Config_Handlers::PriorityModel const& PriorityModelPolicyDef::
    priority_model () const
    {
      return *priority_model_;
    }

    ::CIAO::Config_Handlers::PriorityModel& PriorityModelPolicyDef::
    priority_model ()
    {
      return *priority_model_;
    }

    void PriorityModelPolicyDef::
    priority_model (::CIAO::Config_Handlers::PriorityModel const& e)
    {
      *priority_model_ = e;
    }

    // PriorityModelPolicyDef
    // 
    bool PriorityModelPolicyDef::
    server_priority_p () const
    {
      return server_priority_.get () != 0;
    }

    ::CIAO::Config_Handlers::Priority const& PriorityModelPolicyDef::
    server_priority () const
    {
      return *server_priority_;
    }

    ::CIAO::Config_Handlers::Priority& PriorityModelPolicyDef::
    server_priority ()
    {
      return *server_priority_;
    }

    void PriorityModelPolicyDef::
    server_priority (::CIAO::Config_Handlers::Priority const& e)
    {
      if (server_priority_.get ())
      {
        *server_priority_ = e;
      }

      else
      {
        server_priority_ = ::std::auto_ptr< ::CIAO::Config_Handlers::Priority > (new ::CIAO::Config_Handlers::Priority (e));
        server_priority_->container (this);
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    // ServerResourcesDef
    //

    ServerResourcesDef::
    ServerResourcesDef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "cmdline")
        {
          ::CIAO::Config_Handlers::ServerCmdlineOptions t (e);
          cmdline (t);
        }

        else if (n == "svcconf")
        {
          ::CIAO::Config_Handlers::ACESvcConf t (e);
          svcconf (t);
        }

        else if (n == "orbConfigs")
        {
          orbConfigs_ = ::std::auto_ptr< ::CIAO::Config_Handlers::ORBConfigs > (new ::CIAO::Config_Handlers::ORBConfigs (e));
          orbConfigs_->container (this);
        }

        else 
        {
        }
      }
    }

    // ServerCmdlineOptions
    //

    ServerCmdlineOptions::
    ServerCmdlineOptions (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "arg")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          add_arg (t);
        }

        else 
        {
        }
      }
    }

    // ACESvcConf
    //

    ACESvcConf::
    ACESvcConf (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "uri")
        {
          ::XMLSchema::string< ACE_TCHAR > t (e);
          uri (t);
        }

        else 
        {
        }
      }
    }

    // ORBConfigs
    //

    ORBConfigs::
    ORBConfigs (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "resources")
        {
          ::CIAO::Config_Handlers::ORBResources t (e);
          resources (t);
        }

        else if (n == "policySet")
        {
          ::CIAO::Config_Handlers::PolicySet t (e);
          add_policySet (t);
        }

        else 
        {
        }
      }
    }

    // ORBResources
    //

    ORBResources::
    ORBResources (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "threadpool")
        {
          ::CIAO::Config_Handlers::ThreadpoolDef t (e);
          add_threadpool (t);
        }

        else if (n == "threadpoolWithLanes")
        {
          ::CIAO::Config_Handlers::ThreadpoolWithLanesDef t (e);
          add_threadpoolWithLanes (t);
        }

        else if (n == "connectionBands")
        {
          ::CIAO::Config_Handlers::ConnectionBandsDef t (e);
          add_connectionBands (t);
        }

        else 
        {
        }
      }
    }

    // Priority
    //

    Priority::
    Priority (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {
    }

    Priority::
    Priority (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    :
    Base__ (a),
    regulator__ ()
    {
    }

    // ThreadpoolDef
    //

    ThreadpoolDef::
    ThreadpoolDef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "id")
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
        }

        else if (n == "stacksize")
        {
          ::XMLSchema::unsignedLong t (a);
          stacksize (t);
        }

        else if (n == "static_threads")
        {
          ::XMLSchema::unsignedLong t (a);
          static_threads (t);
        }

        else if (n == "dynamic_threads")
        {
          ::XMLSchema::unsignedLong t (a);
          dynamic_threads (t);
        }

        else if (n == "default_priority")
        {
          ::CIAO::Config_Handlers::Priority t (a);
          default_priority (t);
        }

        else if (n == "allow_request_buffering")
        {
          ::XMLSchema::boolean t (a);
          allow_request_buffering (t);
        }

        else if (n == "max_buffered_requests")
        {
          ::XMLSchema::unsignedLong t (a);
          max_buffered_requests (t);
        }

        else if (n == "max_request_buffered_size")
        {
          ::XMLSchema::unsignedLong t (a);
          max_request_buffered_size (t);
        }

        else 
        {
        }
      }
    }

    // ThreadpoolWithLanesDef
    //

    ThreadpoolWithLanesDef::
    ThreadpoolWithLanesDef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "threadpoolLane")
        {
          ::CIAO::Config_Handlers::ThreadpoolLaneDef t (e);
          add_threadpoolLane (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "id")
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
        }

        else if (n == "stacksize")
        {
          ::XMLSchema::unsignedLong t (a);
          stacksize (t);
        }

        else if (n == "allow_borrowing")
        {
          ::XMLSchema::boolean t (a);
          allow_borrowing (t);
        }

        else if (n == "allow_request_buffering")
        {
          ::XMLSchema::boolean t (a);
          allow_request_buffering (t);
        }

        else if (n == "max_buffered_requests")
        {
          ::XMLSchema::unsignedLong t (a);
          max_buffered_requests (t);
        }

        else if (n == "max_request_buffered_size")
        {
          ::XMLSchema::unsignedLong t (a);
          max_request_buffered_size (t);
        }

        else 
        {
        }
      }
    }

    // ThreadpoolLaneDef
    //

    ThreadpoolLaneDef::
    ThreadpoolLaneDef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "static_threads")
        {
          ::XMLSchema::unsignedLong t (a);
          static_threads (t);
        }

        else if (n == "dynamic_threads")
        {
          ::XMLSchema::unsignedLong t (a);
          dynamic_threads (t);
        }

        else if (n == "priority")
        {
          ::CIAO::Config_Handlers::Priority t (a);
          priority (t);
        }

        else 
        {
        }
      }
    }

    // ConnectionBandsDef
    //

    ConnectionBandsDef::
    ConnectionBandsDef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "band")
        {
          ::CIAO::Config_Handlers::PriorityBandDef t (e);
          add_band (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "id")
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
        }

        else 
        {
        }
      }
    }

    // PriorityBandDef
    //

    PriorityBandDef::
    PriorityBandDef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "low")
        {
          ::XMLSchema::int_ t (a);
          low (t);
        }

        else if (n == "high")
        {
          ::XMLSchema::int_ t (a);
          high (t);
        }

        else 
        {
        }
      }
    }

    // PolicySet
    //

    PolicySet::
    PolicySet (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "priorityModel")
        {
          ::CIAO::Config_Handlers::PriorityModelPolicyDef t (e);
          add_priorityModel (t);
        }

        else if (n == "threadpool")
        {
          ::XMLSchema::IDREF< ACE_TCHAR > t (e);
          add_threadpool (t);
        }

        else if (n == "priorityBandedConnection")
        {
          ::XMLSchema::IDREF< ACE_TCHAR > t (e);
          add_priorityBandedConnection (t);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "id")
        {
          ::XMLSchema::ID< ACE_TCHAR > t (a);
          id (t);
        }

        else 
        {
        }
      }
    }

    // PriorityModel
    //

    PriorityModel::
    PriorityModel (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    : ::XSCRT::Type (e)
    {
      ::std::basic_string< ACE_TCHAR > v (e.value ());

      if (v == "SERVER_DECLARED") v_ = SERVER_DECLARED_l;
      else if (v == "CLIENT_PROPAGATED") v_ = CLIENT_PROPAGATED_l;
      else 
      {
      }
    }

    PriorityModel::
    PriorityModel (::XSCRT::XML::Attribute< ACE_TCHAR > const& a)
    : ::XSCRT::Type (a)
    {
      ::std::basic_string< ACE_TCHAR > v (a.value ());

      if (v == "SERVER_DECLARED") v_ = SERVER_DECLARED_l;
      else if (v == "CLIENT_PROPAGATED") v_ = CLIENT_PROPAGATED_l;
      else 
      {
      }
    }

    PriorityModel const PriorityModel::SERVER_DECLARED (PriorityModel::SERVER_DECLARED_l);
    PriorityModel const PriorityModel::CLIENT_PROPAGATED (PriorityModel::CLIENT_PROPAGATED_l);

    // PriorityModelPolicyDef
    //

    PriorityModelPolicyDef::
    PriorityModelPolicyDef (::XSCRT::XML::Element< ACE_TCHAR > const& e)
    :Base__ (e), regulator__ ()
    {

      ::XSCRT::Parser< ACE_TCHAR > p (e);

      while (p.more_elements ())
      {
        ::XSCRT::XML::Element< ACE_TCHAR > e (p.next_element ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (e.name ()));

        if (n == "priority_model")
        {
          priority_model_ = ::std::auto_ptr< ::CIAO::Config_Handlers::PriorityModel > (new ::CIAO::Config_Handlers::PriorityModel (e));
          priority_model_->container (this);
        }

        else 
        {
        }
      }

      while (p.more_attributes ())
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a (p.next_attribute ());
        ::std::basic_string< ACE_TCHAR > n (::XSCRT::XML::uq_name (a.name ()));
        if (n == "server_priority")
        {
          ::CIAO::Config_Handlers::Priority t (a);
          server_priority (t);
        }

        else 
        {
        }
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    ::CIAO::Config_Handlers::ServerResourcesDef
    ServerResources (xercesc::DOMDocument const* d)
    {
      ::XSCRT::XML::Element< ACE_TCHAR > e (d->getDocumentElement ());
      if (e.name () == "ServerResources")
      {
        ::CIAO::Config_Handlers::ServerResourcesDef r (e);
        return r;
      }

      else
      {
        throw 1;
      }
    }
  }
}

#include "XMLSchema/TypeInfo.hpp"

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace
    {
      ::XMLSchema::TypeInfoInitializer < ACE_TCHAR > XMLSchemaTypeInfoInitializer_ (::XSCRT::extended_type_info_map ());

      struct ServerResourcesDefTypeInfoInitializer
      {
        ServerResourcesDefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ServerResourcesDef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ServerResourcesDefTypeInfoInitializer ServerResourcesDefTypeInfoInitializer_;

      struct ServerCmdlineOptionsTypeInfoInitializer
      {
        ServerCmdlineOptionsTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ServerCmdlineOptions));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ServerCmdlineOptionsTypeInfoInitializer ServerCmdlineOptionsTypeInfoInitializer_;

      struct ACESvcConfTypeInfoInitializer
      {
        ACESvcConfTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ACESvcConf));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ACESvcConfTypeInfoInitializer ACESvcConfTypeInfoInitializer_;

      struct ORBConfigsTypeInfoInitializer
      {
        ORBConfigsTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ORBConfigs));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ORBConfigsTypeInfoInitializer ORBConfigsTypeInfoInitializer_;

      struct ORBResourcesTypeInfoInitializer
      {
        ORBResourcesTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ORBResources));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ORBResourcesTypeInfoInitializer ORBResourcesTypeInfoInitializer_;

      struct PriorityTypeInfoInitializer
      {
        PriorityTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (Priority));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XMLSchema::int_));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PriorityTypeInfoInitializer PriorityTypeInfoInitializer_;

      struct ThreadpoolDefTypeInfoInitializer
      {
        ThreadpoolDefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ThreadpoolDef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ThreadpoolDefTypeInfoInitializer ThreadpoolDefTypeInfoInitializer_;

      struct ThreadpoolWithLanesDefTypeInfoInitializer
      {
        ThreadpoolWithLanesDefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ThreadpoolWithLanesDef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ThreadpoolWithLanesDefTypeInfoInitializer ThreadpoolWithLanesDefTypeInfoInitializer_;

      struct ThreadpoolLaneDefTypeInfoInitializer
      {
        ThreadpoolLaneDefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ThreadpoolLaneDef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ThreadpoolLaneDefTypeInfoInitializer ThreadpoolLaneDefTypeInfoInitializer_;

      struct ConnectionBandsDefTypeInfoInitializer
      {
        ConnectionBandsDefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (ConnectionBandsDef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      ConnectionBandsDefTypeInfoInitializer ConnectionBandsDefTypeInfoInitializer_;

      struct PriorityBandDefTypeInfoInitializer
      {
        PriorityBandDefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (PriorityBandDef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PriorityBandDefTypeInfoInitializer PriorityBandDefTypeInfoInitializer_;

      struct PolicySetTypeInfoInitializer
      {
        PolicySetTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (PolicySet));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PolicySetTypeInfoInitializer PolicySetTypeInfoInitializer_;

      struct PriorityModelTypeInfoInitializer
      {
        PriorityModelTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (PriorityModel));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));

          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PriorityModelTypeInfoInitializer PriorityModelTypeInfoInitializer_;

      struct PriorityModelPolicyDefTypeInfoInitializer
      {
        PriorityModelPolicyDefTypeInfoInitializer ()
        {
          ::XSCRT::TypeId id (typeid (PriorityModelPolicyDef));
          ::XSCRT::ExtendedTypeInfo nf (id);

          nf.add_base (::XSCRT::ExtendedTypeInfo::Access::public_, false, typeid (::XSCRT::Type));
          ::XSCRT::extended_type_info_map ().insert (::std::make_pair (id, nf));
        }
      };

      PriorityModelPolicyDefTypeInfoInitializer PriorityModelPolicyDefTypeInfoInitializer_;
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace Traversal
    {
      // ServerResourcesDef
      //
      //

      void ServerResourcesDef::
      traverse (Type& o)
      {
        pre (o);
        if (o.cmdline_p ()) cmdline (o);
        else cmdline_none (o);
        if (o.svcconf_p ()) svcconf (o);
        else svcconf_none (o);
        orbConfigs (o);
        post (o);
      }

      void ServerResourcesDef::
      traverse (Type const& o)
      {
        pre (o);
        if (o.cmdline_p ()) cmdline (o);
        else cmdline_none (o);
        if (o.svcconf_p ()) svcconf (o);
        else svcconf_none (o);
        orbConfigs (o);
        post (o);
      }

      void ServerResourcesDef::
      pre (Type&)
      {
      }

      void ServerResourcesDef::
      pre (Type const&)
      {
      }

      void ServerResourcesDef::
      cmdline (Type& o)
      {
        dispatch (o.cmdline ());
      }

      void ServerResourcesDef::
      cmdline (Type const& o)
      {
        dispatch (o.cmdline ());
      }

      void ServerResourcesDef::
      cmdline_none (Type&)
      {
      }

      void ServerResourcesDef::
      cmdline_none (Type const&)
      {
      }

      void ServerResourcesDef::
      svcconf (Type& o)
      {
        dispatch (o.svcconf ());
      }

      void ServerResourcesDef::
      svcconf (Type const& o)
      {
        dispatch (o.svcconf ());
      }

      void ServerResourcesDef::
      svcconf_none (Type&)
      {
      }

      void ServerResourcesDef::
      svcconf_none (Type const&)
      {
      }

      void ServerResourcesDef::
      orbConfigs (Type& o)
      {
        dispatch (o.orbConfigs ());
      }

      void ServerResourcesDef::
      orbConfigs (Type const& o)
      {
        dispatch (o.orbConfigs ());
      }

      void ServerResourcesDef::
      post (Type&)
      {
      }

      void ServerResourcesDef::
      post (Type const&)
      {
      }

      // ServerCmdlineOptions
      //
      //

      void ServerCmdlineOptions::
      traverse (Type& o)
      {
        pre (o);
        arg (o);
        post (o);
      }

      void ServerCmdlineOptions::
      traverse (Type const& o)
      {
        pre (o);
        arg (o);
        post (o);
      }

      void ServerCmdlineOptions::
      pre (Type&)
      {
      }

      void ServerCmdlineOptions::
      pre (Type const&)
      {
      }

      void ServerCmdlineOptions::
      arg (Type& o)
      {
        // VC6 anathema strikes again
        //
        ServerCmdlineOptions::Type::arg_iterator b (o.begin_arg()), e (o.end_arg());

        if (b != e)
        {
          arg_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) arg_next (o);
          }

          arg_post (o);
        }
      }

      void ServerCmdlineOptions::
      arg (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ServerCmdlineOptions::Type::arg_const_iterator b (o.begin_arg()), e (o.end_arg());

        if (b != e)
        {
          arg_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) arg_next (o);
          }

          arg_post (o);
        }
      }

      void ServerCmdlineOptions::
      arg_pre (Type&)
      {
      }

      void ServerCmdlineOptions::
      arg_pre (Type const&)
      {
      }

      void ServerCmdlineOptions::
      arg_next (Type&)
      {
      }

      void ServerCmdlineOptions::
      arg_next (Type const&)
      {
      }

      void ServerCmdlineOptions::
      arg_post (Type&)
      {
      }

      void ServerCmdlineOptions::
      arg_post (Type const&)
      {
      }

      void ServerCmdlineOptions::
      post (Type&)
      {
      }

      void ServerCmdlineOptions::
      post (Type const&)
      {
      }

      // ACESvcConf
      //
      //

      void ACESvcConf::
      traverse (Type& o)
      {
        pre (o);
        if (o.uri_p ()) uri (o);
        else uri_none (o);
        post (o);
      }

      void ACESvcConf::
      traverse (Type const& o)
      {
        pre (o);
        if (o.uri_p ()) uri (o);
        else uri_none (o);
        post (o);
      }

      void ACESvcConf::
      pre (Type&)
      {
      }

      void ACESvcConf::
      pre (Type const&)
      {
      }

      void ACESvcConf::
      uri (Type& o)
      {
        dispatch (o.uri ());
      }

      void ACESvcConf::
      uri (Type const& o)
      {
        dispatch (o.uri ());
      }

      void ACESvcConf::
      uri_none (Type&)
      {
      }

      void ACESvcConf::
      uri_none (Type const&)
      {
      }

      void ACESvcConf::
      post (Type&)
      {
      }

      void ACESvcConf::
      post (Type const&)
      {
      }

      // ORBConfigs
      //
      //

      void ORBConfigs::
      traverse (Type& o)
      {
        pre (o);
        if (o.resources_p ()) resources (o);
        else resources_none (o);
        policySet (o);
        post (o);
      }

      void ORBConfigs::
      traverse (Type const& o)
      {
        pre (o);
        if (o.resources_p ()) resources (o);
        else resources_none (o);
        policySet (o);
        post (o);
      }

      void ORBConfigs::
      pre (Type&)
      {
      }

      void ORBConfigs::
      pre (Type const&)
      {
      }

      void ORBConfigs::
      resources (Type& o)
      {
        dispatch (o.resources ());
      }

      void ORBConfigs::
      resources (Type const& o)
      {
        dispatch (o.resources ());
      }

      void ORBConfigs::
      resources_none (Type&)
      {
      }

      void ORBConfigs::
      resources_none (Type const&)
      {
      }

      void ORBConfigs::
      policySet (Type& o)
      {
        // VC6 anathema strikes again
        //
        ORBConfigs::Type::policySet_iterator b (o.begin_policySet()), e (o.end_policySet());

        if (b != e)
        {
          policySet_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) policySet_next (o);
          }

          policySet_post (o);
        }
      }

      void ORBConfigs::
      policySet (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ORBConfigs::Type::policySet_const_iterator b (o.begin_policySet()), e (o.end_policySet());

        if (b != e)
        {
          policySet_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) policySet_next (o);
          }

          policySet_post (o);
        }
      }

      void ORBConfigs::
      policySet_pre (Type&)
      {
      }

      void ORBConfigs::
      policySet_pre (Type const&)
      {
      }

      void ORBConfigs::
      policySet_next (Type&)
      {
      }

      void ORBConfigs::
      policySet_next (Type const&)
      {
      }

      void ORBConfigs::
      policySet_post (Type&)
      {
      }

      void ORBConfigs::
      policySet_post (Type const&)
      {
      }

      void ORBConfigs::
      post (Type&)
      {
      }

      void ORBConfigs::
      post (Type const&)
      {
      }

      // ORBResources
      //
      //

      void ORBResources::
      traverse (Type& o)
      {
        pre (o);
        threadpool (o);
        threadpoolWithLanes (o);
        connectionBands (o);
        post (o);
      }

      void ORBResources::
      traverse (Type const& o)
      {
        pre (o);
        threadpool (o);
        threadpoolWithLanes (o);
        connectionBands (o);
        post (o);
      }

      void ORBResources::
      pre (Type&)
      {
      }

      void ORBResources::
      pre (Type const&)
      {
      }

      void ORBResources::
      threadpool (Type& o)
      {
        // VC6 anathema strikes again
        //
        ORBResources::Type::threadpool_iterator b (o.begin_threadpool()), e (o.end_threadpool());

        if (b != e)
        {
          threadpool_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) threadpool_next (o);
          }

          threadpool_post (o);
        }

        else threadpool_none (o);
      }

      void ORBResources::
      threadpool (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ORBResources::Type::threadpool_const_iterator b (o.begin_threadpool()), e (o.end_threadpool());

        if (b != e)
        {
          threadpool_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) threadpool_next (o);
          }

          threadpool_post (o);
        }

        else threadpool_none (o);
      }

      void ORBResources::
      threadpool_pre (Type&)
      {
      }

      void ORBResources::
      threadpool_pre (Type const&)
      {
      }

      void ORBResources::
      threadpool_next (Type&)
      {
      }

      void ORBResources::
      threadpool_next (Type const&)
      {
      }

      void ORBResources::
      threadpool_post (Type&)
      {
      }

      void ORBResources::
      threadpool_post (Type const&)
      {
      }

      void ORBResources::
      threadpool_none (Type&)
      {
      }

      void ORBResources::
      threadpool_none (Type const&)
      {
      }

      void ORBResources::
      threadpoolWithLanes (Type& o)
      {
        // VC6 anathema strikes again
        //
        ORBResources::Type::threadpoolWithLanes_iterator b (o.begin_threadpoolWithLanes()), e (o.end_threadpoolWithLanes());

        if (b != e)
        {
          threadpoolWithLanes_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) threadpoolWithLanes_next (o);
          }

          threadpoolWithLanes_post (o);
        }

        else threadpoolWithLanes_none (o);
      }

      void ORBResources::
      threadpoolWithLanes (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ORBResources::Type::threadpoolWithLanes_const_iterator b (o.begin_threadpoolWithLanes()), e (o.end_threadpoolWithLanes());

        if (b != e)
        {
          threadpoolWithLanes_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) threadpoolWithLanes_next (o);
          }

          threadpoolWithLanes_post (o);
        }

        else threadpoolWithLanes_none (o);
      }

      void ORBResources::
      threadpoolWithLanes_pre (Type&)
      {
      }

      void ORBResources::
      threadpoolWithLanes_pre (Type const&)
      {
      }

      void ORBResources::
      threadpoolWithLanes_next (Type&)
      {
      }

      void ORBResources::
      threadpoolWithLanes_next (Type const&)
      {
      }

      void ORBResources::
      threadpoolWithLanes_post (Type&)
      {
      }

      void ORBResources::
      threadpoolWithLanes_post (Type const&)
      {
      }

      void ORBResources::
      threadpoolWithLanes_none (Type&)
      {
      }

      void ORBResources::
      threadpoolWithLanes_none (Type const&)
      {
      }

      void ORBResources::
      connectionBands (Type& o)
      {
        // VC6 anathema strikes again
        //
        ORBResources::Type::connectionBands_iterator b (o.begin_connectionBands()), e (o.end_connectionBands());

        if (b != e)
        {
          connectionBands_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) connectionBands_next (o);
          }

          connectionBands_post (o);
        }

        else connectionBands_none (o);
      }

      void ORBResources::
      connectionBands (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ORBResources::Type::connectionBands_const_iterator b (o.begin_connectionBands()), e (o.end_connectionBands());

        if (b != e)
        {
          connectionBands_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) connectionBands_next (o);
          }

          connectionBands_post (o);
        }

        else connectionBands_none (o);
      }

      void ORBResources::
      connectionBands_pre (Type&)
      {
      }

      void ORBResources::
      connectionBands_pre (Type const&)
      {
      }

      void ORBResources::
      connectionBands_next (Type&)
      {
      }

      void ORBResources::
      connectionBands_next (Type const&)
      {
      }

      void ORBResources::
      connectionBands_post (Type&)
      {
      }

      void ORBResources::
      connectionBands_post (Type const&)
      {
      }

      void ORBResources::
      connectionBands_none (Type&)
      {
      }

      void ORBResources::
      connectionBands_none (Type const&)
      {
      }

      void ORBResources::
      post (Type&)
      {
      }

      void ORBResources::
      post (Type const&)
      {
      }

      // Priority
      //
      //

      void Priority::
      traverse (Type& o)
      {
        pre (o);
        post (o);
      }

      void Priority::
      traverse (Type const& o)
      {
        pre (o);
        post (o);
      }

      void Priority::
      pre (Type&)
      {
      }

      void Priority::
      pre (Type const&)
      {
      }

      void Priority::
      post (Type&)
      {
      }

      void Priority::
      post (Type const&)
      {
      }

      // ThreadpoolDef
      //
      //

      void ThreadpoolDef::
      traverse (Type& o)
      {
        pre (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        if (o.stacksize_p ()) stacksize (o);
        else stacksize_none (o);
        if (o.static_threads_p ()) static_threads (o);
        else static_threads_none (o);
        if (o.dynamic_threads_p ()) dynamic_threads (o);
        else dynamic_threads_none (o);
        if (o.default_priority_p ()) default_priority (o);
        else default_priority_none (o);
        if (o.allow_request_buffering_p ()) allow_request_buffering (o);
        else allow_request_buffering_none (o);
        if (o.max_buffered_requests_p ()) max_buffered_requests (o);
        else max_buffered_requests_none (o);
        if (o.max_request_buffered_size_p ()) max_request_buffered_size (o);
        else max_request_buffered_size_none (o);
        post (o);
      }

      void ThreadpoolDef::
      traverse (Type const& o)
      {
        pre (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        if (o.stacksize_p ()) stacksize (o);
        else stacksize_none (o);
        if (o.static_threads_p ()) static_threads (o);
        else static_threads_none (o);
        if (o.dynamic_threads_p ()) dynamic_threads (o);
        else dynamic_threads_none (o);
        if (o.default_priority_p ()) default_priority (o);
        else default_priority_none (o);
        if (o.allow_request_buffering_p ()) allow_request_buffering (o);
        else allow_request_buffering_none (o);
        if (o.max_buffered_requests_p ()) max_buffered_requests (o);
        else max_buffered_requests_none (o);
        if (o.max_request_buffered_size_p ()) max_request_buffered_size (o);
        else max_request_buffered_size_none (o);
        post (o);
      }

      void ThreadpoolDef::
      pre (Type&)
      {
      }

      void ThreadpoolDef::
      pre (Type const&)
      {
      }

      void ThreadpoolDef::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void ThreadpoolDef::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void ThreadpoolDef::
      id_none (Type&)
      {
      }

      void ThreadpoolDef::
      id_none (Type const&)
      {
      }

      void ThreadpoolDef::
      stacksize (Type& o)
      {
        dispatch (o.stacksize ());
      }

      void ThreadpoolDef::
      stacksize (Type const& o)
      {
        dispatch (o.stacksize ());
      }

      void ThreadpoolDef::
      stacksize_none (Type&)
      {
      }

      void ThreadpoolDef::
      stacksize_none (Type const&)
      {
      }

      void ThreadpoolDef::
      static_threads (Type& o)
      {
        dispatch (o.static_threads ());
      }

      void ThreadpoolDef::
      static_threads (Type const& o)
      {
        dispatch (o.static_threads ());
      }

      void ThreadpoolDef::
      static_threads_none (Type&)
      {
      }

      void ThreadpoolDef::
      static_threads_none (Type const&)
      {
      }

      void ThreadpoolDef::
      dynamic_threads (Type& o)
      {
        dispatch (o.dynamic_threads ());
      }

      void ThreadpoolDef::
      dynamic_threads (Type const& o)
      {
        dispatch (o.dynamic_threads ());
      }

      void ThreadpoolDef::
      dynamic_threads_none (Type&)
      {
      }

      void ThreadpoolDef::
      dynamic_threads_none (Type const&)
      {
      }

      void ThreadpoolDef::
      default_priority (Type& o)
      {
        dispatch (o.default_priority ());
      }

      void ThreadpoolDef::
      default_priority (Type const& o)
      {
        dispatch (o.default_priority ());
      }

      void ThreadpoolDef::
      default_priority_none (Type&)
      {
      }

      void ThreadpoolDef::
      default_priority_none (Type const&)
      {
      }

      void ThreadpoolDef::
      allow_request_buffering (Type& o)
      {
        dispatch (o.allow_request_buffering ());
      }

      void ThreadpoolDef::
      allow_request_buffering (Type const& o)
      {
        dispatch (o.allow_request_buffering ());
      }

      void ThreadpoolDef::
      allow_request_buffering_none (Type&)
      {
      }

      void ThreadpoolDef::
      allow_request_buffering_none (Type const&)
      {
      }

      void ThreadpoolDef::
      max_buffered_requests (Type& o)
      {
        dispatch (o.max_buffered_requests ());
      }

      void ThreadpoolDef::
      max_buffered_requests (Type const& o)
      {
        dispatch (o.max_buffered_requests ());
      }

      void ThreadpoolDef::
      max_buffered_requests_none (Type&)
      {
      }

      void ThreadpoolDef::
      max_buffered_requests_none (Type const&)
      {
      }

      void ThreadpoolDef::
      max_request_buffered_size (Type& o)
      {
        dispatch (o.max_request_buffered_size ());
      }

      void ThreadpoolDef::
      max_request_buffered_size (Type const& o)
      {
        dispatch (o.max_request_buffered_size ());
      }

      void ThreadpoolDef::
      max_request_buffered_size_none (Type&)
      {
      }

      void ThreadpoolDef::
      max_request_buffered_size_none (Type const&)
      {
      }

      void ThreadpoolDef::
      post (Type&)
      {
      }

      void ThreadpoolDef::
      post (Type const&)
      {
      }

      // ThreadpoolWithLanesDef
      //
      //

      void ThreadpoolWithLanesDef::
      traverse (Type& o)
      {
        pre (o);
        threadpoolLane (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        if (o.stacksize_p ()) stacksize (o);
        else stacksize_none (o);
        if (o.allow_borrowing_p ()) allow_borrowing (o);
        else allow_borrowing_none (o);
        if (o.allow_request_buffering_p ()) allow_request_buffering (o);
        else allow_request_buffering_none (o);
        if (o.max_buffered_requests_p ()) max_buffered_requests (o);
        else max_buffered_requests_none (o);
        if (o.max_request_buffered_size_p ()) max_request_buffered_size (o);
        else max_request_buffered_size_none (o);
        post (o);
      }

      void ThreadpoolWithLanesDef::
      traverse (Type const& o)
      {
        pre (o);
        threadpoolLane (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        if (o.stacksize_p ()) stacksize (o);
        else stacksize_none (o);
        if (o.allow_borrowing_p ()) allow_borrowing (o);
        else allow_borrowing_none (o);
        if (o.allow_request_buffering_p ()) allow_request_buffering (o);
        else allow_request_buffering_none (o);
        if (o.max_buffered_requests_p ()) max_buffered_requests (o);
        else max_buffered_requests_none (o);
        if (o.max_request_buffered_size_p ()) max_request_buffered_size (o);
        else max_request_buffered_size_none (o);
        post (o);
      }

      void ThreadpoolWithLanesDef::
      pre (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      pre (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane (Type& o)
      {
        // VC6 anathema strikes again
        //
        ThreadpoolWithLanesDef::Type::threadpoolLane_iterator b (o.begin_threadpoolLane()), e (o.end_threadpoolLane());

        if (b != e)
        {
          threadpoolLane_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) threadpoolLane_next (o);
          }

          threadpoolLane_post (o);
        }
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ThreadpoolWithLanesDef::Type::threadpoolLane_const_iterator b (o.begin_threadpoolLane()), e (o.end_threadpoolLane());

        if (b != e)
        {
          threadpoolLane_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) threadpoolLane_next (o);
          }

          threadpoolLane_post (o);
        }
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_pre (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_pre (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_next (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_next (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_post (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_post (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void ThreadpoolWithLanesDef::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void ThreadpoolWithLanesDef::
      id_none (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      id_none (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      stacksize (Type& o)
      {
        dispatch (o.stacksize ());
      }

      void ThreadpoolWithLanesDef::
      stacksize (Type const& o)
      {
        dispatch (o.stacksize ());
      }

      void ThreadpoolWithLanesDef::
      stacksize_none (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      stacksize_none (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      allow_borrowing (Type& o)
      {
        dispatch (o.allow_borrowing ());
      }

      void ThreadpoolWithLanesDef::
      allow_borrowing (Type const& o)
      {
        dispatch (o.allow_borrowing ());
      }

      void ThreadpoolWithLanesDef::
      allow_borrowing_none (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      allow_borrowing_none (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      allow_request_buffering (Type& o)
      {
        dispatch (o.allow_request_buffering ());
      }

      void ThreadpoolWithLanesDef::
      allow_request_buffering (Type const& o)
      {
        dispatch (o.allow_request_buffering ());
      }

      void ThreadpoolWithLanesDef::
      allow_request_buffering_none (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      allow_request_buffering_none (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      max_buffered_requests (Type& o)
      {
        dispatch (o.max_buffered_requests ());
      }

      void ThreadpoolWithLanesDef::
      max_buffered_requests (Type const& o)
      {
        dispatch (o.max_buffered_requests ());
      }

      void ThreadpoolWithLanesDef::
      max_buffered_requests_none (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      max_buffered_requests_none (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      max_request_buffered_size (Type& o)
      {
        dispatch (o.max_request_buffered_size ());
      }

      void ThreadpoolWithLanesDef::
      max_request_buffered_size (Type const& o)
      {
        dispatch (o.max_request_buffered_size ());
      }

      void ThreadpoolWithLanesDef::
      max_request_buffered_size_none (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      max_request_buffered_size_none (Type const&)
      {
      }

      void ThreadpoolWithLanesDef::
      post (Type&)
      {
      }

      void ThreadpoolWithLanesDef::
      post (Type const&)
      {
      }

      // ThreadpoolLaneDef
      //
      //

      void ThreadpoolLaneDef::
      traverse (Type& o)
      {
        pre (o);
        if (o.static_threads_p ()) static_threads (o);
        else static_threads_none (o);
        if (o.dynamic_threads_p ()) dynamic_threads (o);
        else dynamic_threads_none (o);
        if (o.priority_p ()) priority (o);
        else priority_none (o);
        post (o);
      }

      void ThreadpoolLaneDef::
      traverse (Type const& o)
      {
        pre (o);
        if (o.static_threads_p ()) static_threads (o);
        else static_threads_none (o);
        if (o.dynamic_threads_p ()) dynamic_threads (o);
        else dynamic_threads_none (o);
        if (o.priority_p ()) priority (o);
        else priority_none (o);
        post (o);
      }

      void ThreadpoolLaneDef::
      pre (Type&)
      {
      }

      void ThreadpoolLaneDef::
      pre (Type const&)
      {
      }

      void ThreadpoolLaneDef::
      static_threads (Type& o)
      {
        dispatch (o.static_threads ());
      }

      void ThreadpoolLaneDef::
      static_threads (Type const& o)
      {
        dispatch (o.static_threads ());
      }

      void ThreadpoolLaneDef::
      static_threads_none (Type&)
      {
      }

      void ThreadpoolLaneDef::
      static_threads_none (Type const&)
      {
      }

      void ThreadpoolLaneDef::
      dynamic_threads (Type& o)
      {
        dispatch (o.dynamic_threads ());
      }

      void ThreadpoolLaneDef::
      dynamic_threads (Type const& o)
      {
        dispatch (o.dynamic_threads ());
      }

      void ThreadpoolLaneDef::
      dynamic_threads_none (Type&)
      {
      }

      void ThreadpoolLaneDef::
      dynamic_threads_none (Type const&)
      {
      }

      void ThreadpoolLaneDef::
      priority (Type& o)
      {
        dispatch (o.priority ());
      }

      void ThreadpoolLaneDef::
      priority (Type const& o)
      {
        dispatch (o.priority ());
      }

      void ThreadpoolLaneDef::
      priority_none (Type&)
      {
      }

      void ThreadpoolLaneDef::
      priority_none (Type const&)
      {
      }

      void ThreadpoolLaneDef::
      post (Type&)
      {
      }

      void ThreadpoolLaneDef::
      post (Type const&)
      {
      }

      // ConnectionBandsDef
      //
      //

      void ConnectionBandsDef::
      traverse (Type& o)
      {
        pre (o);
        band (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void ConnectionBandsDef::
      traverse (Type const& o)
      {
        pre (o);
        band (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void ConnectionBandsDef::
      pre (Type&)
      {
      }

      void ConnectionBandsDef::
      pre (Type const&)
      {
      }

      void ConnectionBandsDef::
      band (Type& o)
      {
        // VC6 anathema strikes again
        //
        ConnectionBandsDef::Type::band_iterator b (o.begin_band()), e (o.end_band());

        if (b != e)
        {
          band_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) band_next (o);
          }

          band_post (o);
        }
      }

      void ConnectionBandsDef::
      band (Type const& o)
      {
        // VC6 anathema strikes again
        //
        ConnectionBandsDef::Type::band_const_iterator b (o.begin_band()), e (o.end_band());

        if (b != e)
        {
          band_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) band_next (o);
          }

          band_post (o);
        }
      }

      void ConnectionBandsDef::
      band_pre (Type&)
      {
      }

      void ConnectionBandsDef::
      band_pre (Type const&)
      {
      }

      void ConnectionBandsDef::
      band_next (Type&)
      {
      }

      void ConnectionBandsDef::
      band_next (Type const&)
      {
      }

      void ConnectionBandsDef::
      band_post (Type&)
      {
      }

      void ConnectionBandsDef::
      band_post (Type const&)
      {
      }

      void ConnectionBandsDef::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void ConnectionBandsDef::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void ConnectionBandsDef::
      id_none (Type&)
      {
      }

      void ConnectionBandsDef::
      id_none (Type const&)
      {
      }

      void ConnectionBandsDef::
      post (Type&)
      {
      }

      void ConnectionBandsDef::
      post (Type const&)
      {
      }

      // PriorityBandDef
      //
      //

      void PriorityBandDef::
      traverse (Type& o)
      {
        pre (o);
        if (o.low_p ()) low (o);
        else low_none (o);
        if (o.high_p ()) high (o);
        else high_none (o);
        post (o);
      }

      void PriorityBandDef::
      traverse (Type const& o)
      {
        pre (o);
        if (o.low_p ()) low (o);
        else low_none (o);
        if (o.high_p ()) high (o);
        else high_none (o);
        post (o);
      }

      void PriorityBandDef::
      pre (Type&)
      {
      }

      void PriorityBandDef::
      pre (Type const&)
      {
      }

      void PriorityBandDef::
      low (Type& o)
      {
        dispatch (o.low ());
      }

      void PriorityBandDef::
      low (Type const& o)
      {
        dispatch (o.low ());
      }

      void PriorityBandDef::
      low_none (Type&)
      {
      }

      void PriorityBandDef::
      low_none (Type const&)
      {
      }

      void PriorityBandDef::
      high (Type& o)
      {
        dispatch (o.high ());
      }

      void PriorityBandDef::
      high (Type const& o)
      {
        dispatch (o.high ());
      }

      void PriorityBandDef::
      high_none (Type&)
      {
      }

      void PriorityBandDef::
      high_none (Type const&)
      {
      }

      void PriorityBandDef::
      post (Type&)
      {
      }

      void PriorityBandDef::
      post (Type const&)
      {
      }

      // PolicySet
      //
      //

      void PolicySet::
      traverse (Type& o)
      {
        pre (o);
        priorityModel (o);
        threadpool (o);
        priorityBandedConnection (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void PolicySet::
      traverse (Type const& o)
      {
        pre (o);
        priorityModel (o);
        threadpool (o);
        priorityBandedConnection (o);
        if (o.id_p ()) id (o);
        else id_none (o);
        post (o);
      }

      void PolicySet::
      pre (Type&)
      {
      }

      void PolicySet::
      pre (Type const&)
      {
      }

      void PolicySet::
      priorityModel (Type& o)
      {
        // VC6 anathema strikes again
        //
        PolicySet::Type::priorityModel_iterator b (o.begin_priorityModel()), e (o.end_priorityModel());

        if (b != e)
        {
          priorityModel_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) priorityModel_next (o);
          }

          priorityModel_post (o);
        }

        else priorityModel_none (o);
      }

      void PolicySet::
      priorityModel (Type const& o)
      {
        // VC6 anathema strikes again
        //
        PolicySet::Type::priorityModel_const_iterator b (o.begin_priorityModel()), e (o.end_priorityModel());

        if (b != e)
        {
          priorityModel_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) priorityModel_next (o);
          }

          priorityModel_post (o);
        }

        else priorityModel_none (o);
      }

      void PolicySet::
      priorityModel_pre (Type&)
      {
      }

      void PolicySet::
      priorityModel_pre (Type const&)
      {
      }

      void PolicySet::
      priorityModel_next (Type&)
      {
      }

      void PolicySet::
      priorityModel_next (Type const&)
      {
      }

      void PolicySet::
      priorityModel_post (Type&)
      {
      }

      void PolicySet::
      priorityModel_post (Type const&)
      {
      }

      void PolicySet::
      priorityModel_none (Type&)
      {
      }

      void PolicySet::
      priorityModel_none (Type const&)
      {
      }

      void PolicySet::
      threadpool (Type& o)
      {
        // VC6 anathema strikes again
        //
        PolicySet::Type::threadpool_iterator b (o.begin_threadpool()), e (o.end_threadpool());

        if (b != e)
        {
          threadpool_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) threadpool_next (o);
          }

          threadpool_post (o);
        }

        else threadpool_none (o);
      }

      void PolicySet::
      threadpool (Type const& o)
      {
        // VC6 anathema strikes again
        //
        PolicySet::Type::threadpool_const_iterator b (o.begin_threadpool()), e (o.end_threadpool());

        if (b != e)
        {
          threadpool_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) threadpool_next (o);
          }

          threadpool_post (o);
        }

        else threadpool_none (o);
      }

      void PolicySet::
      threadpool_pre (Type&)
      {
      }

      void PolicySet::
      threadpool_pre (Type const&)
      {
      }

      void PolicySet::
      threadpool_next (Type&)
      {
      }

      void PolicySet::
      threadpool_next (Type const&)
      {
      }

      void PolicySet::
      threadpool_post (Type&)
      {
      }

      void PolicySet::
      threadpool_post (Type const&)
      {
      }

      void PolicySet::
      threadpool_none (Type&)
      {
      }

      void PolicySet::
      threadpool_none (Type const&)
      {
      }

      void PolicySet::
      priorityBandedConnection (Type& o)
      {
        // VC6 anathema strikes again
        //
        PolicySet::Type::priorityBandedConnection_iterator b (o.begin_priorityBandedConnection()), e (o.end_priorityBandedConnection());

        if (b != e)
        {
          priorityBandedConnection_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) priorityBandedConnection_next (o);
          }

          priorityBandedConnection_post (o);
        }

        else priorityBandedConnection_none (o);
      }

      void PolicySet::
      priorityBandedConnection (Type const& o)
      {
        // VC6 anathema strikes again
        //
        PolicySet::Type::priorityBandedConnection_const_iterator b (o.begin_priorityBandedConnection()), e (o.end_priorityBandedConnection());

        if (b != e)
        {
          priorityBandedConnection_pre (o);
          for (;
           b != e;
          )
          {
            dispatch (*b);
            if (++b != e) priorityBandedConnection_next (o);
          }

          priorityBandedConnection_post (o);
        }

        else priorityBandedConnection_none (o);
      }

      void PolicySet::
      priorityBandedConnection_pre (Type&)
      {
      }

      void PolicySet::
      priorityBandedConnection_pre (Type const&)
      {
      }

      void PolicySet::
      priorityBandedConnection_next (Type&)
      {
      }

      void PolicySet::
      priorityBandedConnection_next (Type const&)
      {
      }

      void PolicySet::
      priorityBandedConnection_post (Type&)
      {
      }

      void PolicySet::
      priorityBandedConnection_post (Type const&)
      {
      }

      void PolicySet::
      priorityBandedConnection_none (Type&)
      {
      }

      void PolicySet::
      priorityBandedConnection_none (Type const&)
      {
      }

      void PolicySet::
      id (Type& o)
      {
        dispatch (o.id ());
      }

      void PolicySet::
      id (Type const& o)
      {
        dispatch (o.id ());
      }

      void PolicySet::
      id_none (Type&)
      {
      }

      void PolicySet::
      id_none (Type const&)
      {
      }

      void PolicySet::
      post (Type&)
      {
      }

      void PolicySet::
      post (Type const&)
      {
      }

      // PriorityModelPolicyDef
      //
      //

      void PriorityModelPolicyDef::
      traverse (Type& o)
      {
        pre (o);
        priority_model (o);
        if (o.server_priority_p ()) server_priority (o);
        else server_priority_none (o);
        post (o);
      }

      void PriorityModelPolicyDef::
      traverse (Type const& o)
      {
        pre (o);
        priority_model (o);
        if (o.server_priority_p ()) server_priority (o);
        else server_priority_none (o);
        post (o);
      }

      void PriorityModelPolicyDef::
      pre (Type&)
      {
      }

      void PriorityModelPolicyDef::
      pre (Type const&)
      {
      }

      void PriorityModelPolicyDef::
      priority_model (Type& o)
      {
        dispatch (o.priority_model ());
      }

      void PriorityModelPolicyDef::
      priority_model (Type const& o)
      {
        dispatch (o.priority_model ());
      }

      void PriorityModelPolicyDef::
      server_priority (Type& o)
      {
        dispatch (o.server_priority ());
      }

      void PriorityModelPolicyDef::
      server_priority (Type const& o)
      {
        dispatch (o.server_priority ());
      }

      void PriorityModelPolicyDef::
      server_priority_none (Type&)
      {
      }

      void PriorityModelPolicyDef::
      server_priority_none (Type const&)
      {
      }

      void PriorityModelPolicyDef::
      post (Type&)
      {
      }

      void PriorityModelPolicyDef::
      post (Type const&)
      {
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    namespace Writer
    {
      // ServerResourcesDef
      //
      //

      ServerResourcesDef::
      ServerResourcesDef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ServerResourcesDef::
      ServerResourcesDef ()
      {
      }

      void ServerResourcesDef::
      traverse (Type const& o)
      {
        Traversal::ServerResourcesDef::traverse (o);
      }

      void ServerResourcesDef::
      cmdline (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("cmdline", "www.dre.vanderbilt.edu", top_ ()));
        Traversal::ServerResourcesDef::cmdline (o);
        pop_ ();
      }

      void ServerResourcesDef::
      svcconf (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("svcconf", "www.dre.vanderbilt.edu", top_ ()));
        Traversal::ServerResourcesDef::svcconf (o);
        pop_ ();
      }

      void ServerResourcesDef::
      orbConfigs (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("orbConfigs", "www.dre.vanderbilt.edu", top_ ()));
        Traversal::ServerResourcesDef::orbConfigs (o);
        pop_ ();
      }

      // ServerCmdlineOptions
      //
      //

      ServerCmdlineOptions::
      ServerCmdlineOptions (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ServerCmdlineOptions::
      ServerCmdlineOptions ()
      {
      }

      void ServerCmdlineOptions::
      traverse (Type const& o)
      {
        Traversal::ServerCmdlineOptions::traverse (o);
      }

      void ServerCmdlineOptions::
      arg_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("arg", "www.dre.vanderbilt.edu", top_ ()));
      }

      void ServerCmdlineOptions::
      arg_next (Type const& o)
      {
        arg_post (o);
        arg_pre (o);
      }

      void ServerCmdlineOptions::
      arg_post (Type const&)
      {
        pop_ ();
      }

      // ACESvcConf
      //
      //

      ACESvcConf::
      ACESvcConf (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ACESvcConf::
      ACESvcConf ()
      {
      }

      void ACESvcConf::
      traverse (Type const& o)
      {
        Traversal::ACESvcConf::traverse (o);
      }

      void ACESvcConf::
      uri (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("uri", "www.dre.vanderbilt.edu", top_ ()));
        Traversal::ACESvcConf::uri (o);
        pop_ ();
      }

      // ORBConfigs
      //
      //

      ORBConfigs::
      ORBConfigs (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ORBConfigs::
      ORBConfigs ()
      {
      }

      void ORBConfigs::
      traverse (Type const& o)
      {
        Traversal::ORBConfigs::traverse (o);
      }

      void ORBConfigs::
      resources (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("resources", "www.dre.vanderbilt.edu", top_ ()));
        Traversal::ORBConfigs::resources (o);
        pop_ ();
      }

      void ORBConfigs::
      policySet_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("policySet", "www.dre.vanderbilt.edu", top_ ()));
      }

      void ORBConfigs::
      policySet_next (Type const& o)
      {
        policySet_post (o);
        policySet_pre (o);
      }

      void ORBConfigs::
      policySet_post (Type const&)
      {
        pop_ ();
      }

      // ORBResources
      //
      //

      ORBResources::
      ORBResources (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ORBResources::
      ORBResources ()
      {
      }

      void ORBResources::
      traverse (Type const& o)
      {
        Traversal::ORBResources::traverse (o);
      }

      void ORBResources::
      threadpool_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("threadpool", "www.dre.vanderbilt.edu", top_ ()));
      }

      void ORBResources::
      threadpool_next (Type const& o)
      {
        threadpool_post (o);
        threadpool_pre (o);
      }

      void ORBResources::
      threadpool_post (Type const&)
      {
        pop_ ();
      }

      void ORBResources::
      threadpoolWithLanes_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("threadpoolWithLanes", "www.dre.vanderbilt.edu", top_ ()));
      }

      void ORBResources::
      threadpoolWithLanes_next (Type const& o)
      {
        threadpoolWithLanes_post (o);
        threadpoolWithLanes_pre (o);
      }

      void ORBResources::
      threadpoolWithLanes_post (Type const&)
      {
        pop_ ();
      }

      void ORBResources::
      connectionBands_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("connectionBands", "www.dre.vanderbilt.edu", top_ ()));
      }

      void ORBResources::
      connectionBands_next (Type const& o)
      {
        connectionBands_post (o);
        connectionBands_pre (o);
      }

      void ORBResources::
      connectionBands_post (Type const&)
      {
        pop_ ();
      }

      // Priority
      //
      //

      Priority::
      Priority (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      Priority::
      Priority ()
      {
      }

      void Priority::
      traverse (Type const& o)
      {
        ::XMLSchema::Writer::FundamentalType< ::XMLSchema::int_, ACE_TCHAR >::traverse (o);
        Traversal::Priority::traverse (o);
      }

      // ThreadpoolDef
      //
      //

      ThreadpoolDef::
      ThreadpoolDef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ThreadpoolDef::
      ThreadpoolDef ()
      {
      }

      void ThreadpoolDef::
      traverse (Type const& o)
      {
        Traversal::ThreadpoolDef::traverse (o);
      }

      void ThreadpoolDef::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("id", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolDef::id (o);
        attr_ (0);
      }

      void ThreadpoolDef::
      stacksize (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("stacksize", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolDef::stacksize (o);
        attr_ (0);
      }

      void ThreadpoolDef::
      static_threads (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("static_threads", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolDef::static_threads (o);
        attr_ (0);
      }

      void ThreadpoolDef::
      dynamic_threads (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("dynamic_threads", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolDef::dynamic_threads (o);
        attr_ (0);
      }

      void ThreadpoolDef::
      default_priority (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("default_priority", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolDef::default_priority (o);
        attr_ (0);
      }

      void ThreadpoolDef::
      allow_request_buffering (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("allow_request_buffering", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolDef::allow_request_buffering (o);
        attr_ (0);
      }

      void ThreadpoolDef::
      max_buffered_requests (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("max_buffered_requests", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolDef::max_buffered_requests (o);
        attr_ (0);
      }

      void ThreadpoolDef::
      max_request_buffered_size (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("max_request_buffered_size", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolDef::max_request_buffered_size (o);
        attr_ (0);
      }

      // ThreadpoolWithLanesDef
      //
      //

      ThreadpoolWithLanesDef::
      ThreadpoolWithLanesDef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ThreadpoolWithLanesDef::
      ThreadpoolWithLanesDef ()
      {
      }

      void ThreadpoolWithLanesDef::
      traverse (Type const& o)
      {
        Traversal::ThreadpoolWithLanesDef::traverse (o);
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("threadpoolLane", "www.dre.vanderbilt.edu", top_ ()));
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_next (Type const& o)
      {
        threadpoolLane_post (o);
        threadpoolLane_pre (o);
      }

      void ThreadpoolWithLanesDef::
      threadpoolLane_post (Type const&)
      {
        pop_ ();
      }

      void ThreadpoolWithLanesDef::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("id", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolWithLanesDef::id (o);
        attr_ (0);
      }

      void ThreadpoolWithLanesDef::
      stacksize (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("stacksize", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolWithLanesDef::stacksize (o);
        attr_ (0);
      }

      void ThreadpoolWithLanesDef::
      allow_borrowing (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("allow_borrowing", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolWithLanesDef::allow_borrowing (o);
        attr_ (0);
      }

      void ThreadpoolWithLanesDef::
      allow_request_buffering (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("allow_request_buffering", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolWithLanesDef::allow_request_buffering (o);
        attr_ (0);
      }

      void ThreadpoolWithLanesDef::
      max_buffered_requests (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("max_buffered_requests", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolWithLanesDef::max_buffered_requests (o);
        attr_ (0);
      }

      void ThreadpoolWithLanesDef::
      max_request_buffered_size (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("max_request_buffered_size", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolWithLanesDef::max_request_buffered_size (o);
        attr_ (0);
      }

      // ThreadpoolLaneDef
      //
      //

      ThreadpoolLaneDef::
      ThreadpoolLaneDef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ThreadpoolLaneDef::
      ThreadpoolLaneDef ()
      {
      }

      void ThreadpoolLaneDef::
      traverse (Type const& o)
      {
        Traversal::ThreadpoolLaneDef::traverse (o);
      }

      void ThreadpoolLaneDef::
      static_threads (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("static_threads", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolLaneDef::static_threads (o);
        attr_ (0);
      }

      void ThreadpoolLaneDef::
      dynamic_threads (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("dynamic_threads", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolLaneDef::dynamic_threads (o);
        attr_ (0);
      }

      void ThreadpoolLaneDef::
      priority (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("priority", "", top_ ());
        attr_ (&a);
        Traversal::ThreadpoolLaneDef::priority (o);
        attr_ (0);
      }

      // ConnectionBandsDef
      //
      //

      ConnectionBandsDef::
      ConnectionBandsDef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      ConnectionBandsDef::
      ConnectionBandsDef ()
      {
      }

      void ConnectionBandsDef::
      traverse (Type const& o)
      {
        Traversal::ConnectionBandsDef::traverse (o);
      }

      void ConnectionBandsDef::
      band_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("band", "www.dre.vanderbilt.edu", top_ ()));
      }

      void ConnectionBandsDef::
      band_next (Type const& o)
      {
        band_post (o);
        band_pre (o);
      }

      void ConnectionBandsDef::
      band_post (Type const&)
      {
        pop_ ();
      }

      void ConnectionBandsDef::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("id", "", top_ ());
        attr_ (&a);
        Traversal::ConnectionBandsDef::id (o);
        attr_ (0);
      }

      // PriorityBandDef
      //
      //

      PriorityBandDef::
      PriorityBandDef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      PriorityBandDef::
      PriorityBandDef ()
      {
      }

      void PriorityBandDef::
      traverse (Type const& o)
      {
        Traversal::PriorityBandDef::traverse (o);
      }

      void PriorityBandDef::
      low (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("low", "", top_ ());
        attr_ (&a);
        Traversal::PriorityBandDef::low (o);
        attr_ (0);
      }

      void PriorityBandDef::
      high (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("high", "", top_ ());
        attr_ (&a);
        Traversal::PriorityBandDef::high (o);
        attr_ (0);
      }

      // PolicySet
      //
      //

      PolicySet::
      PolicySet (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      PolicySet::
      PolicySet ()
      {
      }

      void PolicySet::
      traverse (Type const& o)
      {
        Traversal::PolicySet::traverse (o);
      }

      void PolicySet::
      priorityModel_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("priorityModel", "www.dre.vanderbilt.edu", top_ ()));
      }

      void PolicySet::
      priorityModel_next (Type const& o)
      {
        priorityModel_post (o);
        priorityModel_pre (o);
      }

      void PolicySet::
      priorityModel_post (Type const&)
      {
        pop_ ();
      }

      void PolicySet::
      threadpool_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("threadpool", "www.dre.vanderbilt.edu", top_ ()));
      }

      void PolicySet::
      threadpool_next (Type const& o)
      {
        threadpool_post (o);
        threadpool_pre (o);
      }

      void PolicySet::
      threadpool_post (Type const&)
      {
        pop_ ();
      }

      void PolicySet::
      priorityBandedConnection_pre (Type const&)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("priorityBandedConnection", "www.dre.vanderbilt.edu", top_ ()));
      }

      void PolicySet::
      priorityBandedConnection_next (Type const& o)
      {
        priorityBandedConnection_post (o);
        priorityBandedConnection_pre (o);
      }

      void PolicySet::
      priorityBandedConnection_post (Type const&)
      {
        pop_ ();
      }

      void PolicySet::
      id (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("id", "", top_ ());
        attr_ (&a);
        Traversal::PolicySet::id (o);
        attr_ (0);
      }

      // PriorityModel
      //
      //

      PriorityModel::
      PriorityModel (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      PriorityModel::
      PriorityModel ()
      {
      }

      void PriorityModel::
      traverse (Type const& o)
      {
        ::std::basic_string< ACE_TCHAR > s;

        if (o == ::CIAO::Config_Handlers::PriorityModel::SERVER_DECLARED) s = "SERVER_DECLARED";
        else if (o == ::CIAO::Config_Handlers::PriorityModel::CLIENT_PROPAGATED) s = "CLIENT_PROPAGATED";
        else 
        {
        }

        if (::XSCRT::XML::Attribute< ACE_TCHAR >* a = attr_ ())
        {
          a->value (s);
        }

        else
        {
          top_().value (s);
        }
      }

      // PriorityModelPolicyDef
      //
      //

      PriorityModelPolicyDef::
      PriorityModelPolicyDef (::XSCRT::XML::Element< ACE_TCHAR >& e)
      : ::XSCRT::Writer< ACE_TCHAR > (e)
      {
      }

      PriorityModelPolicyDef::
      PriorityModelPolicyDef ()
      {
      }

      void PriorityModelPolicyDef::
      traverse (Type const& o)
      {
        Traversal::PriorityModelPolicyDef::traverse (o);
      }

      void PriorityModelPolicyDef::
      priority_model (Type const& o)
      {
        push_ (::XSCRT::XML::Element< ACE_TCHAR > ("priority_model", "www.dre.vanderbilt.edu", top_ ()));
        Traversal::PriorityModelPolicyDef::priority_model (o);
        pop_ ();
      }

      void PriorityModelPolicyDef::
      server_priority (Type const& o)
      {
        ::XSCRT::XML::Attribute< ACE_TCHAR > a ("server_priority", "", top_ ());
        attr_ (&a);
        Traversal::PriorityModelPolicyDef::server_priority (o);
        attr_ (0);
      }
    }
  }
}

namespace CIAO
{
  namespace Config_Handlers
  {
    void
    ServerResources (::CIAO::Config_Handlers::ServerResourcesDef const& s, xercesc::DOMDocument* d)
    {
      ::XSCRT::XML::Element< ACE_TCHAR > e (d->getDocumentElement ());
      if (e.name () != "ServerResources")
      {
        throw 1;
      }

      struct W : virtual ::CIAO::Config_Handlers::Writer::ServerResourcesDef,
      virtual ::CIAO::Config_Handlers::Writer::ServerCmdlineOptions,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::string< ACE_TCHAR >, ACE_TCHAR >,
      virtual ::CIAO::Config_Handlers::Writer::ACESvcConf,
      virtual ::CIAO::Config_Handlers::Writer::ORBConfigs,
      virtual ::CIAO::Config_Handlers::Writer::ORBResources,
      virtual ::CIAO::Config_Handlers::Writer::ThreadpoolDef,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::ID< ACE_TCHAR >, ACE_TCHAR >,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::unsignedLong, ACE_TCHAR >,
      virtual ::CIAO::Config_Handlers::Writer::Priority,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::boolean, ACE_TCHAR >,
      virtual ::CIAO::Config_Handlers::Writer::ThreadpoolWithLanesDef,
      virtual ::CIAO::Config_Handlers::Writer::ThreadpoolLaneDef,
      virtual ::CIAO::Config_Handlers::Writer::ConnectionBandsDef,
      virtual ::CIAO::Config_Handlers::Writer::PriorityBandDef,
      virtual ::XMLSchema::Writer::FundamentalType< ::XMLSchema::int_, ACE_TCHAR >,
      virtual ::CIAO::Config_Handlers::Writer::PolicySet,
      virtual ::CIAO::Config_Handlers::Writer::PriorityModelPolicyDef,
      virtual ::CIAO::Config_Handlers::Writer::PriorityModel,
      virtual ::XMLSchema::Writer::IDREF< ACE_TCHAR >, 
      virtual ::XSCRT::Writer< ACE_TCHAR >
      {
        W (::XSCRT::XML::Element< ACE_TCHAR >& e)
        : ::XSCRT::Writer< ACE_TCHAR > (e)
        {
        }
      };

      W w (e);
      w.dispatch (s);
    }
  }
}

