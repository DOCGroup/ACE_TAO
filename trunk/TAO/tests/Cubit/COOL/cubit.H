/*
 * File generated by CHIC (CHIC-COMMON-970407)
 *        from: cubit.idl
*/
#ifndef _CUBIT_IDL_H
#define _CUBIT_IDL_H
#include "corba/cool.H"
// Copyright 1994-1995 by Sun Microsystems, Inc.


//=========================================================
//    interface Cubit
//=========================================================

class Cubit;
typedef Cubit* Cubit_ptr;


#ifndef _declare_Cubit_var
#define _declare_Cubit_var
class CubitMarshaler;
class Cubit_var : public CORBA__var {
    friend class CubitMarshaler;
    Cubit_ptr ptr_;
public:
        inline
    Cubit_var();
    Cubit_var(Cubit* ptr)
        : ptr_(ptr) {}
        inline
    Cubit_var(const Cubit_var& var);
        inline
    ~Cubit_var();
        inline void
    destroy();
        inline Cubit_var&
    operator =(const Cubit_var& var);
        inline Cubit_var& 
    operator =(Cubit_ptr ptr);
    operator Cubit_ptr() const
    {
        return ptr_;
    }
        Cubit_ptr 
    operator->() const
    {
        return ptr_;
    }
};
#endif


#ifndef _declare_Cubit_proxy
#define _declare_Cubit_proxy
class Cubit_proxy {
    Cubit_ptr* ptr_;
    CORBA_Boolean release_;
public:
    Cubit_proxy(Cubit_ptr* ptr, CORBA_Boolean rel)
        : ptr_(ptr), release_(rel) {}
        Cubit_ptr       
    operator =(Cubit_ptr ptr);
    operator Cubit_ptr() 
    {
        return *ptr_; 
    }
        static Cubit_ptr
    _duplicate(Cubit_ptr ptr);
        static void
    _release(Cubit_ptr ptr);
        static Cubit_ptr
    _nil();
};
#endif


#ifndef _declare_CubitMarshaler
#define _declare_CubitMarshaler
class CubitMarshaler {
public:
        static void 
    get(COOL_Marshaler& marshaler, Cubit_ptr& obj);
        static void 
    get(COOL_Marshaler& marshaler, Cubit_var& obj) 
    {
        CubitMarshaler::get(marshaler, obj.ptr_);
    }
        static void 
    put(COOL_Marshaler& marshaler, const Cubit_ptr obj);
        static void 
    put(COOL_Marshaler& marshaler, const Cubit_var& obj)
    {
        CubitMarshaler::put(marshaler, obj.ptr_);
    }
        static size_t
    size(COOL_Marshaler& marshaler, const Cubit_ptr obj);
        static size_t
    size(COOL_Marshaler& marshaler, const Cubit_var& obj)
    {
        return CubitMarshaler::size(marshaler, obj.ptr_);
    }
};
#endif

class Cubit : public virtual CORBA_Object {
public:

        virtual CORBA_Octet
    cube_octet(CORBA_Octet o,
               CORBA_Environment& env = _environment) const;


        virtual CORBA_Short
    cube_short(CORBA_Short s,
               CORBA_Environment& env = _environment) const;


        virtual CORBA_Long
    cube_long(CORBA_Long l,
              CORBA_Environment& env = _environment) const;


    //=========================================================
    // Structure Many
    //=========================================================

    class Many {
    public:
        CORBA_Octet     o;              // + 3 bytes padding (normally) ...
        CORBA_Long      l;
        CORBA_Short     s;              // + 2 bytes padding (normally) ...
    };

    class ManyMarshaler;
    class Many_var {
        friend class ManyMarshaler; 
        Many* ptr_;
    public:
        Many_var() 
            : ptr_(0) {}
        Many_var(Many* ptr) 
            : ptr_(ptr) {}
        Many_var(const Many_var& var)
            : ptr_(var.ptr_ ? new Many(*var.ptr_) : 0) {}
        ~Many_var() 
        {
            if (ptr_) delete ptr_;
        }
            Many_var&
        operator =(Many* ptr) 
        {
            if (ptr != ptr_) {        
                if (ptr_) delete ptr_;
                ptr_ = ptr;
            }
            return *this;
        }
            Many_var&
        operator =(const Many_var& var) 
        {
            if (var.ptr_ != ptr_) {
                if (ptr_) delete ptr_;
                ptr_ = var.ptr_ ? new Many(*(var.ptr_)) : 0;
            }
            return *this;
        }
            Many*
        operator ->() const 
        {
            return ptr_;
        }
        COOL_CONST_OPERATOR(Many);
        operator Many&() 
        {
            return *ptr_;
        }
    };


    class ManyMarshaler {
    public:
            static void 
        put(COOL_Marshaler& marshaler, const Many& obj);
            static void 
        put(COOL_Marshaler& marshaler, const Many* ptr)
        {
            ManyMarshaler::put(marshaler, *ptr);
        }
            static void 
        get(COOL_Marshaler& marshaler, Many& obj);
            static void 
        get(COOL_Marshaler& marshaler, Many*& ptr)
        {
            ptr = new Many;
            ManyMarshaler::get(marshaler, *ptr);
        }
            static size_t
        size(COOL_Marshaler&)
        {
            return 10;
        }
    };

    static CORBA_TypeCode_ptr _tc_Many;

        virtual Many
    cube_struct(const Many& values,
                CORBA_Environment& env = _environment) const;

    
    //=========================================================
    //    Enum discrim
    //=========================================================

    enum discrim {
        e_0th,
        e_1st,
        e_2nd,
        e_3rd,
        e_4th,
        e_5th
    };
    static CORBA_TypeCode_ptr _tc_discrim;
    class oneofMarshaler;
    class oneof {
    friend class oneofMarshaler;
public:
private:
    discrim discriminant_;
    CORBA_ULong initialized_;
    union {
        double align_;
        char value_[1];
            char value1_[sizeof(CORBA_Octet)];
            char value2_[sizeof(CORBA_Short)];
            char value3_[sizeof(CORBA_Long)];
            char value4_[sizeof(Many)];
            };
public:
        void
    destroy()
    {}
        void
    build(const oneof&); 
    oneof()
    {
        initialized_ = 0;
    }
    ~oneof()
    {
    }
    oneof(const oneof& u)
    {
        if (u.initialized_ > 0) {
            build(u);
        } else {
            initialized_ = 0;
        }
    }
        oneof&
    operator=(const oneof& u)
    {
        if (u.initialized_ > 0) {
            build(u);
        } else {
            initialized_ = 0;
        }
        return *this;
    }
        discrim
    _d() const 
    {
        return discriminant_;
    }
        void
    _d(discrim val);
        void
    o(CORBA_Octet val)
    {
        initialized_ = (CORBA_ULong) 1;
        discriminant_ = (discrim) e_0th;
        *((CORBA_Octet*)value_) = val;
    }
        CORBA_Octet
    o() const
    {
        return *((CORBA_Octet*)value_);
    }
        void
    s(CORBA_Short val)
    {
        initialized_ = (CORBA_ULong) 2;
        discriminant_ = (discrim) e_1st;
        *((CORBA_Short*)value_) = val;
    }
        CORBA_Short
    s() const
    {
        return *((CORBA_Short*)value_);
    }
        void
    l(CORBA_Long val)
    {
        initialized_ = (CORBA_ULong) 3;
        discriminant_ = (discrim) e_2nd;
        *((CORBA_Long*)value_) = val;
    }
        CORBA_Long
    l() const
    {
        return *((CORBA_Long*)value_);
    }
        void
    cm(const Many& val)
    {
        initialized_ = (CORBA_ULong) 4;
        discriminant_ = (discrim) 4;
        new(value_,_new_placement) Many(val);
    }
        const Many&
    cm() const
    {
        return *((Many*)value_);
    }
        Many&
    cm()
    {
         return *((Many*)value_);
     }
    };

    class oneof_var {
        friend class oneofMarshaler;
        oneof* ptr_;
    public:
        oneof_var() 
            : ptr_(0) {}    
        oneof_var(oneof* ptr) 
            : ptr_(ptr) {}
        oneof_var(const oneof_var& var) 
            : ptr_(var.ptr_ ? new oneof(*var.ptr_) : 0) {}
        ~oneof_var() 
        {
            if (ptr_) delete ptr_;
        }
            oneof_var&
        operator =(oneof* ptr) 
        {
            if (ptr != ptr_) {
                if (ptr_) delete ptr_;
                ptr_ = ptr;
            }
            return *this;
        }
            oneof_var&
        operator =(const oneof_var& var)
        {
            if (var.ptr_ != ptr_) {
                if (ptr_) delete ptr_;
                ptr_ = var.ptr_ ? new oneof(*(var.ptr_)) : 0;
            }
            return *this;
        }
            oneof*
        operator ->() const 
        {
            return ptr_;
        }
        COOL_CONST_OPERATOR(oneof);
        operator oneof&() 
        {
            return *ptr_;
        }
    };


    class oneofMarshaler {
    public:
            static void 
        put(COOL_Marshaler& marshaler, const oneof& obj);
            static void 
        put(COOL_Marshaler& marshaler, const oneof* ptr)
        {
            oneofMarshaler::put(marshaler, *ptr);
        }
            static void 
        get(COOL_Marshaler& marshaler, oneof& obj);
            static void 
        get(COOL_Marshaler& marshaler, oneof*& ptr)
        {
            ptr = new oneof;
            oneofMarshaler::get(marshaler, *ptr);
        }
            static size_t
        size(COOL_Marshaler&)
        {
            return 14;
        }
    };

    static CORBA_TypeCode_ptr _tc_oneof;

        virtual oneof
    cube_union(const oneof& values,
               CORBA_Environment& env = _environment) const;


        virtual void
    please_exit(CORBA_Environment& env = _environment) const;

    static const _COOL_InterfaceDesc coOperations;
    static const _COOL_FullInterfaceDesc coInterfaceDef[];
private:
    static Cubit coNilObject;
        virtual int
    _shiftVtbl(CORBA_Environment& _env) const;
protected:
    Cubit(const CORBA_Object& t)
        : CORBA_Object(t)
    {}
public:
    Cubit(_EmptyCtor)
        : CORBA_Object(_emptyCtor)
    {}
    Cubit(const _COOL_FullInterfaceDesc* idesc)
        : CORBA_Object(idesc)
    {}
    Cubit()
    {
        coInterface = coInterfaceDef;
    }
    Cubit(const Cubit& t)
        : CORBA_Object(t)
    {}
        virtual
    ~Cubit();
        Cubit*
    operator ->()
    {
        return this;
    }
        static Cubit_ptr
    _nil()
    {
        return &coNilObject;
    }
        static Cubit_ptr
    _duplicate(const Cubit_ptr obj)
    {
        return CORBA_is_nil(obj) == CORBA_TRUE ? _nil() : new Cubit(*obj);
    }
        static Cubit_ptr
    _narrow(const CORBA_Object_ptr obj)
    {
        return checkNarrow(obj, coInterfaceDef)
                   ? new Cubit(*obj) : _nil();
    }
        static Cubit_ptr
    _bind(const COOL_BindingData& bindingData,
          CORBA_Environment& _env = _environment)
    {
        Cubit_ptr obj = new Cubit();
        return bindObject(obj, bindingData, _env) == CORBA_TRUE ?       obj : _nil();}
};
extern const CORBA_TypeCode_ptr _tc_Cubit;


    inline void
operator <<=(CORBA_Any& any, const Cubit_ptr ptr)
{
    any.replace(_tc_Cubit, (void*) &ptr);
}


    inline CORBA_Boolean
operator >>=(const CORBA_Any& any, Cubit_ptr& ptr)
{
    return (any._type()->equal(_tc_Cubit) == CORBA_TRUE)
        ? (ptr = *(Cubit_ptr*) any.value(), CORBA_TRUE)
        : (ptr = (Cubit_ptr) NULL, CORBA_FALSE);
}



#ifndef _declare_Cubit_var_impl
#define _declare_Cubit_var_impl
    inline
Cubit_var::Cubit_var()
 : ptr_(Cubit::_nil())
{
}
    inline
Cubit_var::Cubit_var(const Cubit_var& var)
 : ptr_(Cubit::_duplicate(var.ptr_))
{
}
    inline
Cubit_var::~Cubit_var()
{
    CORBA_release(ptr_);
}
    inline void
Cubit_var::destroy()
{
    CORBA_release(ptr_);
}
    inline Cubit_var&
Cubit_var::operator =(const Cubit_var& var)
{
    if (ptr_ != var.ptr_) {
        CORBA_release(ptr_);
        ptr_ = Cubit::_duplicate(var.ptr_);
    }
    return *this;
}
    inline Cubit_var& 
Cubit_var::operator =(Cubit* ptr)
{
    if (ptr_ != ptr) {
        CORBA_release(ptr_);
        ptr_ = ptr;
    }
    return *this;
}
#endif



    inline void
operator <<=(CORBA_Any& any, const Cubit::Many& s)
{
    any.replace(Cubit::_tc_Many, (void*) &s);
}


    inline void
operator <<=(CORBA_Any& any, Cubit::Many* s)
{
    any.replace(Cubit::_tc_Many, (void*) s, CORBA_TRUE);
}


    inline CORBA_Boolean
operator >>=(const CORBA_Any& any, Cubit::Many*& p)
{
    return (any._type()->equal(Cubit::_tc_Many) == CORBA_TRUE)
        ? (p = (Cubit::Many*) any.value(), CORBA_TRUE)
        : (p = (Cubit::Many*) NULL, CORBA_FALSE);
}




    inline void
operator <<=(CORBA_Any& any, const Cubit::discrim s)
{
    any.replace(Cubit::_tc_discrim, (void*) &s);
}


    inline CORBA_Boolean
operator >>=(const CORBA_Any& any, Cubit::discrim& obj)
{
    return (any._type()->equal(Cubit::_tc_discrim) == CORBA_TRUE)
        ? (obj = *(Cubit::discrim*) any.value(), CORBA_TRUE)
        : CORBA_FALSE;
}




    inline void
operator <<=(CORBA_Any& any, const Cubit::oneof& s)
{
    any.replace(Cubit::_tc_oneof, (void*) &s);
}


    inline void
operator <<=(CORBA_Any& any, Cubit::oneof* s)
{
    any.replace(Cubit::_tc_oneof, (void*) s, CORBA_TRUE);
}


    inline CORBA_Boolean
operator >>=(const CORBA_Any& any, Cubit::oneof*& p)
{
    return (any._type()->equal(Cubit::_tc_oneof) == CORBA_TRUE)
        ? (p = (Cubit::oneof*) any.value(), CORBA_TRUE)
        : (p = (Cubit::oneof*) NULL, CORBA_FALSE);
}




#endif

