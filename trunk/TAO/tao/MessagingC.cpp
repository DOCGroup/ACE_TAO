/* -*- C++ -*- */
// $Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/MessagingC.h"
#include "tao/MessagingS.h"
#include "tao/POA_CORBA.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"

#if !defined (__ACE_INLINE__)
#include "tao/MessagingC.i"
#endif /* !defined INLINE */

ACE_RCSID(tao, MessagingC, "$Id$")

static const CORBA::Long _oc_Messaging_RebindMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x62696e64), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/RebindMode:1.0
  11, ACE_NTOHL (0x52656269), ACE_NTOHL (0x6e644d6f), ACE_NTOHL (0x64650000),  // name = RebindMode
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RebindMode (CORBA::tk_alias, sizeof (_oc_Messaging_RebindMode), (char *) &_oc_Messaging_RebindMode, 0, sizeof (Messaging::RebindMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RebindMode, &_tc_TAO_tc_Messaging_RebindMode)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, TRANSPARENT, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, NO_REBIND, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, NO_RECONNECT, 2)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_SyncScope[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5379), ACE_NTOHL (0x6e635363), ACE_NTOHL (0x6f70653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/SyncScope:1.0
  10, ACE_NTOHL (0x53796e63), ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65000000),  // name = SyncScope
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_SyncScope (CORBA::tk_alias, sizeof (_oc_Messaging_SyncScope), (char *) &_oc_Messaging_SyncScope, 0, sizeof (Messaging::SyncScope));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SyncScope, &_tc_TAO_tc_Messaging_SyncScope)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_NONE, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_WITH_TRANSPORT, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_WITH_SERVER, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYNC_WITH_TARGET, 3)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_RoutingType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/RoutingType:1.0
  12, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6754), ACE_NTOHL (0x79706500),  // name = RoutingType
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RoutingType (CORBA::tk_alias, sizeof (_oc_Messaging_RoutingType), (char *) &_oc_Messaging_RoutingType, 0, sizeof (Messaging::RoutingType));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RoutingType, &_tc_TAO_tc_Messaging_RoutingType)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, ROUTE_NONE, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, ROUTE_FORWARD, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::Short, ROUTE_STORE_AND_FORWARD, 2)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_Timeout[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  26, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5469), ACE_NTOHL (0x6d656f75), ACE_NTOHL (0x743a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/Timeout:1.0
  8, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x6f757400),  // name = Timeout
  CORBA::tk_alias, // typecode kind for typedefs
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x42617365), ACE_NTOHL (0x2f54696d), ACE_NTOHL (0x65543a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/TimeBase/TimeT:1.0
    6, ACE_NTOHL (0x54696d65), ACE_NTOHL (0x54000000),  // name = TimeT
    CORBA::tk_ulonglong,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_Timeout (CORBA::tk_alias, sizeof (_oc_Messaging_Timeout), (char *) &_oc_Messaging_Timeout, 0, sizeof (Messaging::Timeout));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Timeout, &_tc_TAO_tc_Messaging_Timeout)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_Priority[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5072), ACE_NTOHL (0x696f7269), ACE_NTOHL (0x74793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/Priority:1.0
  9, ACE_NTOHL (0x5072696f), ACE_NTOHL (0x72697479), ACE_NTOHL (0x0),  // name = Priority
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_Priority (CORBA::tk_alias, sizeof (_oc_Messaging_Priority), (char *) &_oc_Messaging_Priority, 0, sizeof (Messaging::Priority));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Priority, &_tc_TAO_tc_Messaging_Priority)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_Ordering[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f4f72), ACE_NTOHL (0x64657269), ACE_NTOHL (0x6e673a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/Ordering:1.0
  9, ACE_NTOHL (0x4f726465), ACE_NTOHL (0x72696e67), ACE_NTOHL (0x0),  // name = Ordering
  CORBA::tk_ushort,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_Ordering (CORBA::tk_alias, sizeof (_oc_Messaging_Ordering), (char *) &_oc_Messaging_Ordering, 0, sizeof (Messaging::Ordering));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Ordering, &_tc_TAO_tc_Messaging_Ordering)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::UShort)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::UShort, ORDER_ANY, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::UShort)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::UShort, ORDER_TEMPORAL, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::UShort)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::UShort, ORDER_PRIORITY, 4)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::UShort)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::UShort, ORDER_DEADLINE, 8)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REBIND_POLICY_TYPE, 23)
TAO_NAMESPACE_END
Messaging::RebindPolicy_ptr Messaging::RebindPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RebindPolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/RebindPolicy:1.0", env))
    return Messaging::RebindPolicy::_nil ();
  return Messaging::RebindPolicy::_unchecked_narrow (obj, env);
}

Messaging::RebindPolicy_ptr Messaging::RebindPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RebindPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RebindPolicy:1.0");
  if (servant == 0)
    return new Messaging::RebindPolicy(stub);
  return new POA_Messaging::_tao_collocated_RebindPolicy(
      ACE_reinterpret_cast(POA_Messaging::RebindPolicy_ptr, servant),
      stub
    );
}

Messaging::RebindMode Messaging::RebindPolicy::rebind_mode (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    Messaging::RebindMode _tao_retval = 0;

    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::RebindPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RebindPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::RebindPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RebindPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RebindPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x62696e64), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/RebindPolicy:1.0
  13, ACE_NTOHL (0x52656269), ACE_NTOHL (0x6e64506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = RebindPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RebindPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RebindPolicy), (char *) &_oc_Messaging_RebindPolicy, 0, sizeof (Messaging::RebindPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RebindPolicy, &_tc_TAO_tc_Messaging_RebindPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, SYNC_SCOPE_POLICY_TYPE, 24)
TAO_NAMESPACE_END
Messaging::SyncScopePolicy_ptr Messaging::SyncScopePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::SyncScopePolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/SyncScopePolicy:1.0", env))
    return Messaging::SyncScopePolicy::_nil ();
  return Messaging::SyncScopePolicy::_unchecked_narrow (obj, env);
}

Messaging::SyncScopePolicy_ptr Messaging::SyncScopePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::SyncScopePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/SyncScopePolicy:1.0");
  if (servant == 0)
    return new Messaging::SyncScopePolicy(stub);
  return new POA_Messaging::_tao_collocated_SyncScopePolicy(
      ACE_reinterpret_cast(POA_Messaging::SyncScopePolicy_ptr, servant),
      stub
    );
}

Messaging::SyncScope Messaging::SyncScopePolicy::synchronization (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    Messaging::SyncScope _tao_retval = 0;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::SyncScopePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/SyncScopePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::SyncScopePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/SyncScopePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_SyncScopePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5379), ACE_NTOHL (0x6e635363), ACE_NTOHL (0x6f706550), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/SyncScopePolicy:1.0
  16, ACE_NTOHL (0x53796e63), ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65506f6c), ACE_NTOHL (0x69637900),  // name = SyncScopePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_SyncScopePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_SyncScopePolicy), (char *) &_oc_Messaging_SyncScopePolicy, 0, sizeof (Messaging::SyncScopePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SyncScopePolicy, &_tc_TAO_tc_Messaging_SyncScopePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_PRIORITY_POLICY_TYPE, 25)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_PriorityRange[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5072), ACE_NTOHL (0x696f7269), ACE_NTOHL (0x74795261), ACE_NTOHL (0x6e67653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/PriorityRange:1.0
  14, ACE_NTOHL (0x5072696f), ACE_NTOHL (0x72697479), ACE_NTOHL (0x52616e67), ACE_NTOHL (0x65000000),  // name = PriorityRange
  2, // member count
    4, ACE_NTOHL (0x6d696e00),  // name = min
    CORBA::tk_alias, // typecode kind for typedefs
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5072), ACE_NTOHL (0x696f7269), ACE_NTOHL (0x74793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/Priority:1.0
      9, ACE_NTOHL (0x5072696f), ACE_NTOHL (0x72697479), ACE_NTOHL (0x0),  // name = Priority
      CORBA::tk_short,

    4, ACE_NTOHL (0x6d617800),  // name = max
    CORBA::tk_alias, // typecode kind for typedefs
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5072), ACE_NTOHL (0x696f7269), ACE_NTOHL (0x74793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/Priority:1.0
      9, ACE_NTOHL (0x5072696f), ACE_NTOHL (0x72697479), ACE_NTOHL (0x0),  // name = Priority
      CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_PriorityRange (CORBA::tk_struct, sizeof (_oc_Messaging_PriorityRange), (char *) &_oc_Messaging_PriorityRange, 0, sizeof (Messaging::PriorityRange));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PriorityRange, &_tc_TAO_tc_Messaging_PriorityRange)
TAO_NAMESPACE_END
Messaging::RequestPriorityPolicy_ptr Messaging::RequestPriorityPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestPriorityPolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/RequestPriorityPolicy:1.0", env))
    return Messaging::RequestPriorityPolicy::_nil ();
  return Messaging::RequestPriorityPolicy::_unchecked_narrow (obj, env);
}

Messaging::RequestPriorityPolicy_ptr Messaging::RequestPriorityPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestPriorityPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RequestPriorityPolicy:1.0");
  if (servant == 0)
    return new Messaging::RequestPriorityPolicy(stub);
  return new POA_Messaging::_tao_collocated_RequestPriorityPolicy(
      ACE_reinterpret_cast(POA_Messaging::RequestPriorityPolicy_ptr, servant),
      stub
    );
}

Messaging::PriorityRange Messaging::RequestPriorityPolicy::priority_range (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    Messaging::PriorityRange _tao_retval;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::RequestPriorityPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestPriorityPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::RequestPriorityPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestPriorityPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RequestPriorityPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74507269), ACE_NTOHL (0x6f726974), ACE_NTOHL (0x79506f6c), ACE_NTOHL (0x6963793a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/RequestPriorityPolicy:1.0
  22, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737450), ACE_NTOHL (0x72696f72), ACE_NTOHL (0x69747950), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = RequestPriorityPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RequestPriorityPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RequestPriorityPolicy), (char *) &_oc_Messaging_RequestPriorityPolicy, 0, sizeof (Messaging::RequestPriorityPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestPriorityPolicy, &_tc_TAO_tc_Messaging_RequestPriorityPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REPLY_PRIORITY_POLICY_TYPE, 26)
TAO_NAMESPACE_END
Messaging::ReplyPriorityPolicy_ptr Messaging::ReplyPriorityPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyPriorityPolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/ReplyPriorityPolicy:1.0", env))
    return Messaging::ReplyPriorityPolicy::_nil ();
  return Messaging::ReplyPriorityPolicy::_unchecked_narrow (obj, env);
}

Messaging::ReplyPriorityPolicy_ptr Messaging::ReplyPriorityPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyPriorityPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/ReplyPriorityPolicy:1.0");
  if (servant == 0)
    return new Messaging::ReplyPriorityPolicy(stub);
  return new POA_Messaging::_tao_collocated_ReplyPriorityPolicy(
      ACE_reinterpret_cast(POA_Messaging::ReplyPriorityPolicy_ptr, servant),
      stub
    );
}

Messaging::PriorityRange Messaging::ReplyPriorityPolicy::priority_range (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    Messaging::PriorityRange _tao_retval;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::ReplyPriorityPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyPriorityPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::ReplyPriorityPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyPriorityPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_ReplyPriorityPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x706c7950), ACE_NTOHL (0x72696f72), ACE_NTOHL (0x69747950), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/ReplyPriorityPolicy:1.0
  20, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x79507269), ACE_NTOHL (0x6f726974), ACE_NTOHL (0x79506f6c), ACE_NTOHL (0x69637900),  // name = ReplyPriorityPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ReplyPriorityPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_ReplyPriorityPolicy), (char *) &_oc_Messaging_ReplyPriorityPolicy, 0, sizeof (Messaging::ReplyPriorityPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyPriorityPolicy, &_tc_TAO_tc_Messaging_ReplyPriorityPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_START_TIME_POLICY_TYPE, 27)
TAO_NAMESPACE_END
Messaging::RequestStartTimePolicy_ptr Messaging::RequestStartTimePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestStartTimePolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/RequestStartTimePolicy:1.0", env))
    return Messaging::RequestStartTimePolicy::_nil ();
  return Messaging::RequestStartTimePolicy::_unchecked_narrow (obj, env);
}

Messaging::RequestStartTimePolicy_ptr Messaging::RequestStartTimePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestStartTimePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RequestStartTimePolicy:1.0");
  if (servant == 0)
    return new Messaging::RequestStartTimePolicy(stub);
  return new POA_Messaging::_tao_collocated_RequestStartTimePolicy(
      ACE_reinterpret_cast(POA_Messaging::RequestStartTimePolicy_ptr, servant),
      stub
    );
}

TimeBase::UtcT Messaging::RequestStartTimePolicy::start_time (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    TimeBase::UtcT _tao_retval;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::RequestStartTimePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestStartTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::RequestStartTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestStartTimePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RequestStartTimePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74537461), ACE_NTOHL (0x72745469), ACE_NTOHL (0x6d65506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/RequestStartTimePolicy:1.0
  23, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737453), ACE_NTOHL (0x74617274), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = RequestStartTimePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RequestStartTimePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RequestStartTimePolicy), (char *) &_oc_Messaging_RequestStartTimePolicy, 0, sizeof (Messaging::RequestStartTimePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestStartTimePolicy, &_tc_TAO_tc_Messaging_RequestStartTimePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_END_TIME_POLICY_TYPE, 28)
TAO_NAMESPACE_END
Messaging::RequestEndTimePolicy_ptr Messaging::RequestEndTimePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestEndTimePolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/RequestEndTimePolicy:1.0", env))
    return Messaging::RequestEndTimePolicy::_nil ();
  return Messaging::RequestEndTimePolicy::_unchecked_narrow (obj, env);
}

Messaging::RequestEndTimePolicy_ptr Messaging::RequestEndTimePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RequestEndTimePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RequestEndTimePolicy:1.0");
  if (servant == 0)
    return new Messaging::RequestEndTimePolicy(stub);
  return new POA_Messaging::_tao_collocated_RequestEndTimePolicy(
      ACE_reinterpret_cast(POA_Messaging::RequestEndTimePolicy_ptr, servant),
      stub
    );
}

TimeBase::UtcT Messaging::RequestEndTimePolicy::end_time (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    TimeBase::UtcT _tao_retval;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::RequestEndTimePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RequestEndTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::RequestEndTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RequestEndTimePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RequestEndTimePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74456e64), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/RequestEndTimePolicy:1.0
  21, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737445), ACE_NTOHL (0x6e645469), ACE_NTOHL (0x6d65506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = RequestEndTimePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RequestEndTimePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RequestEndTimePolicy), (char *) &_oc_Messaging_RequestEndTimePolicy, 0, sizeof (Messaging::RequestEndTimePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestEndTimePolicy, &_tc_TAO_tc_Messaging_RequestEndTimePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REPLY_START_TIME_POLICY_TYPE, 29)
TAO_NAMESPACE_END
Messaging::ReplyStartTimePolicy_ptr Messaging::ReplyStartTimePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyStartTimePolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/ReplyStartTimePolicy:1.0", env))
    return Messaging::ReplyStartTimePolicy::_nil ();
  return Messaging::ReplyStartTimePolicy::_unchecked_narrow (obj, env);
}

Messaging::ReplyStartTimePolicy_ptr Messaging::ReplyStartTimePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyStartTimePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/ReplyStartTimePolicy:1.0");
  if (servant == 0)
    return new Messaging::ReplyStartTimePolicy(stub);
  return new POA_Messaging::_tao_collocated_ReplyStartTimePolicy(
      ACE_reinterpret_cast(POA_Messaging::ReplyStartTimePolicy_ptr, servant),
      stub
    );
}

TimeBase::UtcT Messaging::ReplyStartTimePolicy::start_time (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    TimeBase::UtcT _tao_retval;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::ReplyStartTimePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyStartTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::ReplyStartTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyStartTimePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_ReplyStartTimePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x706c7953), ACE_NTOHL (0x74617274), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/ReplyStartTimePolicy:1.0
  21, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x79537461), ACE_NTOHL (0x72745469), ACE_NTOHL (0x6d65506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = ReplyStartTimePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ReplyStartTimePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_ReplyStartTimePolicy), (char *) &_oc_Messaging_ReplyStartTimePolicy, 0, sizeof (Messaging::ReplyStartTimePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyStartTimePolicy, &_tc_TAO_tc_Messaging_ReplyStartTimePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REPLY_END_TIME_POLICY_TYPE, 30)
TAO_NAMESPACE_END
Messaging::ReplyEndTimePolicy_ptr Messaging::ReplyEndTimePolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyEndTimePolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/ReplyEndTimePolicy:1.0", env))
    return Messaging::ReplyEndTimePolicy::_nil ();
  return Messaging::ReplyEndTimePolicy::_unchecked_narrow (obj, env);
}

Messaging::ReplyEndTimePolicy_ptr Messaging::ReplyEndTimePolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyEndTimePolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/ReplyEndTimePolicy:1.0");
  if (servant == 0)
    return new Messaging::ReplyEndTimePolicy(stub);
  return new POA_Messaging::_tao_collocated_ReplyEndTimePolicy(
      ACE_reinterpret_cast(POA_Messaging::ReplyEndTimePolicy_ptr, servant),
      stub
    );
}

TimeBase::UtcT Messaging::ReplyEndTimePolicy::end_time (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    TimeBase::UtcT _tao_retval;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::ReplyEndTimePolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyEndTimePolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::ReplyEndTimePolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyEndTimePolicy:1.0";
}

static const CORBA::Long _oc_Messaging_ReplyEndTimePolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x706c7945), ACE_NTOHL (0x6e645469), ACE_NTOHL (0x6d65506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/ReplyEndTimePolicy:1.0
  19, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x79456e64), ACE_NTOHL (0x54696d65), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = ReplyEndTimePolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ReplyEndTimePolicy (CORBA::tk_objref, sizeof (_oc_Messaging_ReplyEndTimePolicy), (char *) &_oc_Messaging_ReplyEndTimePolicy, 0, sizeof (Messaging::ReplyEndTimePolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyEndTimePolicy, &_tc_TAO_tc_Messaging_ReplyEndTimePolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, RELATIVE_REQ_TIMEOUT_POLICY_TYPE, 31)
TAO_NAMESPACE_END
Messaging::RelativeRequestTimeoutPolicy_ptr Messaging::RelativeRequestTimeoutPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RelativeRequestTimeoutPolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/RelativeRequestTimeoutPolicy:1.0", env))
    return Messaging::RelativeRequestTimeoutPolicy::_nil ();
  return Messaging::RelativeRequestTimeoutPolicy::_unchecked_narrow (obj, env);
}

Messaging::RelativeRequestTimeoutPolicy_ptr Messaging::RelativeRequestTimeoutPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RelativeRequestTimeoutPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RelativeRequestTimeoutPolicy:1.0");
  if (servant == 0)
    return new Messaging::RelativeRequestTimeoutPolicy(stub);
  return new POA_Messaging::_tao_collocated_RelativeRequestTimeoutPolicy(
      ACE_reinterpret_cast(POA_Messaging::RelativeRequestTimeoutPolicy_ptr, servant),
      stub
    );
}

TimeBase::TimeT Messaging::RelativeRequestTimeoutPolicy::relative_expiry (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    TimeBase::TimeT _tao_retval = 0;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::RelativeRequestTimeoutPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::RelativeRequestTimeoutPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RelativeRequestTimeoutPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RelativeRequestTimeoutPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x6c617469), ACE_NTOHL (0x76655265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x7454696d), ACE_NTOHL (0x656f7574), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/RelativeRequestTimeoutPolicy:1.0
  29, ACE_NTOHL (0x52656c61), ACE_NTOHL (0x74697665), ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737454), ACE_NTOHL (0x696d656f), ACE_NTOHL (0x7574506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = RelativeRequestTimeoutPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RelativeRequestTimeoutPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RelativeRequestTimeoutPolicy), (char *) &_oc_Messaging_RelativeRequestTimeoutPolicy, 0, sizeof (Messaging::RelativeRequestTimeoutPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RelativeRequestTimeoutPolicy, &_tc_TAO_tc_Messaging_RelativeRequestTimeoutPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, RELATIVE_RT_TIMEOUT_POLICY_TYPE, 32)
TAO_NAMESPACE_END
Messaging::RelativeRoundtripTimeoutPolicy_ptr Messaging::RelativeRoundtripTimeoutPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0", env))
    return Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
  return Messaging::RelativeRoundtripTimeoutPolicy::_unchecked_narrow (obj, env);
}

Messaging::RelativeRoundtripTimeoutPolicy_ptr Messaging::RelativeRoundtripTimeoutPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RelativeRoundtripTimeoutPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0");
  if (servant == 0)
    return new Messaging::RelativeRoundtripTimeoutPolicy(stub);
  return new POA_Messaging::_tao_collocated_RelativeRoundtripTimeoutPolicy(
      ACE_reinterpret_cast(POA_Messaging::RelativeRoundtripTimeoutPolicy_ptr, servant),
      stub
    );
}

TimeBase::TimeT Messaging::RelativeRoundtripTimeoutPolicy::relative_expiry (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    TimeBase::TimeT _tao_retval = 0;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::RelativeRoundtripTimeoutPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::RelativeRoundtripTimeoutPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RelativeRoundtripTimeoutPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x6c617469), ACE_NTOHL (0x7665526f), ACE_NTOHL (0x756e6474), ACE_NTOHL (0x72697054), ACE_NTOHL (0x696d656f), ACE_NTOHL (0x7574506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/RelativeRoundtripTimeoutPolicy:1.0
  31, ACE_NTOHL (0x52656c61), ACE_NTOHL (0x74697665), ACE_NTOHL (0x526f756e), ACE_NTOHL (0x64747269), ACE_NTOHL (0x7054696d), ACE_NTOHL (0x656f7574), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = RelativeRoundtripTimeoutPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RelativeRoundtripTimeoutPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RelativeRoundtripTimeoutPolicy), (char *) &_oc_Messaging_RelativeRoundtripTimeoutPolicy, 0, sizeof (Messaging::RelativeRoundtripTimeoutPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RelativeRoundtripTimeoutPolicy, &_tc_TAO_tc_Messaging_RelativeRoundtripTimeoutPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, ROUTING_POLICY_TYPE, 33)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_RoutingTypeRange[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67547970), ACE_NTOHL (0x6552616e), ACE_NTOHL (0x67653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/RoutingTypeRange:1.0
  17, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6754), ACE_NTOHL (0x79706552), ACE_NTOHL (0x616e6765), ACE_NTOHL (0x0),  // name = RoutingTypeRange
  2, // member count
    4, ACE_NTOHL (0x6d696e00),  // name = min
    CORBA::tk_alias, // typecode kind for typedefs
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/RoutingType:1.0
      12, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6754), ACE_NTOHL (0x79706500),  // name = RoutingType
      CORBA::tk_short,

    4, ACE_NTOHL (0x6d617800),  // name = max
    CORBA::tk_alias, // typecode kind for typedefs
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67547970), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/RoutingType:1.0
      12, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6754), ACE_NTOHL (0x79706500),  // name = RoutingType
      CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RoutingTypeRange (CORBA::tk_struct, sizeof (_oc_Messaging_RoutingTypeRange), (char *) &_oc_Messaging_RoutingTypeRange, 0, sizeof (Messaging::RoutingTypeRange));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RoutingTypeRange, &_tc_TAO_tc_Messaging_RoutingTypeRange)
TAO_NAMESPACE_END
Messaging::RoutingPolicy_ptr Messaging::RoutingPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RoutingPolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/RoutingPolicy:1.0", env))
    return Messaging::RoutingPolicy::_nil ();
  return Messaging::RoutingPolicy::_unchecked_narrow (obj, env);
}

Messaging::RoutingPolicy_ptr Messaging::RoutingPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::RoutingPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/RoutingPolicy:1.0");
  if (servant == 0)
    return new Messaging::RoutingPolicy(stub);
  return new POA_Messaging::_tao_collocated_RoutingPolicy(
      ACE_reinterpret_cast(POA_Messaging::RoutingPolicy_ptr, servant),
      stub
    );
}

Messaging::RoutingTypeRange Messaging::RoutingPolicy::routing_range (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    Messaging::RoutingTypeRange _tao_retval;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::RoutingPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/RoutingPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::RoutingPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/RoutingPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_RoutingPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f526f), ACE_NTOHL (0x7574696e), ACE_NTOHL (0x67506f6c), ACE_NTOHL (0x6963793a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/RoutingPolicy:1.0
  14, ACE_NTOHL (0x526f7574), ACE_NTOHL (0x696e6750), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = RoutingPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_RoutingPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_RoutingPolicy), (char *) &_oc_Messaging_RoutingPolicy, 0, sizeof (Messaging::RoutingPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RoutingPolicy, &_tc_TAO_tc_Messaging_RoutingPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, MAX_HOPS_POLICY_TYPE, 34)
TAO_NAMESPACE_END
Messaging::MaxHopsPolicy_ptr Messaging::MaxHopsPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::MaxHopsPolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/MaxHopsPolicy:1.0", env))
    return Messaging::MaxHopsPolicy::_nil ();
  return Messaging::MaxHopsPolicy::_unchecked_narrow (obj, env);
}

Messaging::MaxHopsPolicy_ptr Messaging::MaxHopsPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::MaxHopsPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/MaxHopsPolicy:1.0");
  if (servant == 0)
    return new Messaging::MaxHopsPolicy(stub);
  return new POA_Messaging::_tao_collocated_MaxHopsPolicy(
      ACE_reinterpret_cast(POA_Messaging::MaxHopsPolicy_ptr, servant),
      stub
    );
}

CORBA::UShort Messaging::MaxHopsPolicy::max_hops (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    CORBA::UShort _tao_retval = 0;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::MaxHopsPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/MaxHopsPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::MaxHopsPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/MaxHopsPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_MaxHopsPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f4d61), ACE_NTOHL (0x78486f70), ACE_NTOHL (0x73506f6c), ACE_NTOHL (0x6963793a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:Messaging/MaxHopsPolicy:1.0
  14, ACE_NTOHL (0x4d617848), ACE_NTOHL (0x6f707350), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = MaxHopsPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_MaxHopsPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_MaxHopsPolicy), (char *) &_oc_Messaging_MaxHopsPolicy, 0, sizeof (Messaging::MaxHopsPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_MaxHopsPolicy, &_tc_TAO_tc_Messaging_MaxHopsPolicy)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, QUEUE_ORDER_POLICY_TYPE, 35)
TAO_NAMESPACE_END
Messaging::QueueOrderPolicy_ptr Messaging::QueueOrderPolicy::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::QueueOrderPolicy::_nil ();
  if (!obj->_is_a ("IDL:Messaging/QueueOrderPolicy:1.0", env))
    return Messaging::QueueOrderPolicy::_nil ();
  return Messaging::QueueOrderPolicy::_unchecked_narrow (obj, env);
}

Messaging::QueueOrderPolicy_ptr Messaging::QueueOrderPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::QueueOrderPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/QueueOrderPolicy:1.0");
  if (servant == 0)
    return new Messaging::QueueOrderPolicy(stub);
  return new POA_Messaging::_tao_collocated_QueueOrderPolicy(
      ACE_reinterpret_cast(POA_Messaging::QueueOrderPolicy_ptr, servant),
      stub
    );
}

Messaging::Ordering Messaging::QueueOrderPolicy::allowed_orders (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    Messaging::Ordering _tao_retval = 0;
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);
}

CORBA::Boolean Messaging::QueueOrderPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/QueueOrderPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::QueueOrderPolicy::_interface_repository_id (void) const
{
  return "IDL:Messaging/QueueOrderPolicy:1.0";
}

static const CORBA::Long _oc_Messaging_QueueOrderPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5175), ACE_NTOHL (0x6575654f), ACE_NTOHL (0x72646572), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/QueueOrderPolicy:1.0
  17, ACE_NTOHL (0x51756575), ACE_NTOHL (0x654f7264), ACE_NTOHL (0x6572506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = QueueOrderPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_QueueOrderPolicy (CORBA::tk_objref, sizeof (_oc_Messaging_QueueOrderPolicy), (char *) &_oc_Messaging_QueueOrderPolicy, 0, sizeof (Messaging::QueueOrderPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_QueueOrderPolicy, &_tc_TAO_tc_Messaging_QueueOrderPolicy)
TAO_NAMESPACE_END
static const CORBA::Long _oc_Messaging_PolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/PolicyValue:1.0
  12, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756500),  // name = PolicyValue
  2, // member count
    6, ACE_NTOHL (0x70747970), ACE_NTOHL (0x65000000),  // name = ptype
    CORBA::tk_alias, // typecode kind for typedefs
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x54797065), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/PolicyType:1.0
      11, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795479), ACE_NTOHL (0x70650000),  // name = PolicyType
      CORBA::tk_ulong,

    7, ACE_NTOHL (0x7076616c), ACE_NTOHL (0x75650000),  // name = pvalue
    CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

    0,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_PolicyValue (CORBA::tk_struct, sizeof (_oc_Messaging_PolicyValue), (char *) &_oc_Messaging_PolicyValue, 0, sizeof (Messaging::PolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyValue, &_tc_TAO_tc_Messaging_PolicyValue)
TAO_NAMESPACE_END

#if !defined (_MESSAGING_POLICYVALUE__TAO_SEQ_OCTET_CS_)
#define _MESSAGING_POLICYVALUE__TAO_SEQ_OCTET_CS_

// *************************************************************
// Messaging::PolicyValue::_tao_seq_Octet
// *************************************************************

Messaging::PolicyValue::_tao_seq_Octet::_tao_seq_Octet (void)
{}
Messaging::PolicyValue::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max) // uses max size
  : TAO_Unbounded_Sequence<CORBA::Octet> (max)
{}
Messaging::PolicyValue::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : TAO_Unbounded_Sequence<CORBA::Octet> (max, length, buffer, release)
{}
Messaging::PolicyValue::_tao_seq_Octet::_tao_seq_Octet (const _tao_seq_Octet &seq) // copy ctor
  : TAO_Unbounded_Sequence<CORBA::Octet> (seq)
{}
Messaging::PolicyValue::_tao_seq_Octet::~_tao_seq_Octet (void) // dtor
{}

static const CORBA::Long _oc_Messaging_PolicyValue__tao_seq_Octet[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

  0,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_PolicyValue__tao_seq_Octet (CORBA::tk_sequence, sizeof (_oc_Messaging_PolicyValue__tao_seq_Octet), (char *) &_oc_Messaging_PolicyValue__tao_seq_Octet, 0, sizeof (Messaging::PolicyValue::_tao_seq_Octet));
CORBA::TypeCode_ptr Messaging::PolicyValue::_tc__tao_seq_Octet = &_tc_TAO_tc_Messaging_PolicyValue__tao_seq_Octet;

// *************************************************************
// Messaging::PolicyValueSeq
// *************************************************************

Messaging::PolicyValueSeq::PolicyValueSeq (void)
{}
Messaging::PolicyValueSeq::PolicyValueSeq (CORBA::ULong max) // uses max size
  : TAO_Unbounded_Sequence<Messaging::PolicyValue> (max)
{}
Messaging::PolicyValueSeq::PolicyValueSeq (CORBA::ULong max, CORBA::ULong length, Messaging::PolicyValue *buffer, CORBA::Boolean release)
  : TAO_Unbounded_Sequence<Messaging::PolicyValue> (max, length, buffer, release)
{}
Messaging::PolicyValueSeq::PolicyValueSeq (const PolicyValueSeq &seq) // copy ctor
  : TAO_Unbounded_Sequence<Messaging::PolicyValue> (seq)
{}
Messaging::PolicyValueSeq::~PolicyValueSeq (void) // dtor
{}


#endif /* end #if !defined */

static const CORBA::Long _oc_Messaging_PolicyValueSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/PolicyValueSeq:1.0
  15, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756553), ACE_NTOHL (0x65710000),  // name = PolicyValueSeq
  CORBA::tk_sequence, // typecode kind
  192, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    176, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/PolicyValue:1.0
      12, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756500),  // name = PolicyValue
      2, // member count
        6, ACE_NTOHL (0x70747970), ACE_NTOHL (0x65000000),  // name = ptype
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x54797065), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/PolicyType:1.0
          11, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795479), ACE_NTOHL (0x70650000),  // name = PolicyType
          CORBA::tk_ulong,

        7, ACE_NTOHL (0x7076616c), ACE_NTOHL (0x75650000),  // name = pvalue
        CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

        0,
      0,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_PolicyValueSeq (CORBA::tk_alias, sizeof (_oc_Messaging_PolicyValueSeq), (char *) &_oc_Messaging_PolicyValueSeq, 0, sizeof (Messaging::PolicyValueSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyValueSeq, &_tc_TAO_tc_Messaging_PolicyValueSeq)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, TAG_POLICIES, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, INVOCATION_POLICIES, 2)
TAO_NAMESPACE_END

// ****************************************************************

#if defined(TAO_POLLER)
static const CORBA::Long _oc_Messaging_ExceptionHolder[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f4578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e48), ACE_NTOHL (0x6f6c6465), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:Messaging/ExceptionHolder:1.0
  16, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e486f6c), ACE_NTOHL (0x64657200),  // name = ExceptionHolder
  3, // member count
    20, ACE_NTOHL (0x69735f73), ACE_NTOHL (0x79737465), ACE_NTOHL (0x6d5f6578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e00),  // name = is_system_exception
    CORBA::tk_boolean,

    11, ACE_NTOHL (0x62797465), ACE_NTOHL (0x5f6f7264), ACE_NTOHL (0x65720000),  // name = byte_order
    CORBA::tk_boolean,

    20, ACE_NTOHL (0x6d617273), ACE_NTOHL (0x68616c65), ACE_NTOHL (0x645f6578), ACE_NTOHL (0x63657074), ACE_NTOHL (0x696f6e00),  // name = marshaled_exception
    CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

    0,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ExceptionHolder (CORBA::tk_struct, sizeof (_oc_Messaging_ExceptionHolder), (char *) &_oc_Messaging_ExceptionHolder, 0, sizeof (Messaging::ExceptionHolder));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionHolder, &_tc_TAO_tc_Messaging_ExceptionHolder)
TAO_NAMESPACE_END

// *************************************************************
// Messaging::ExceptionHolder::_tao_seq_Octet
// *************************************************************

Messaging::ExceptionHolder::_tao_seq_Octet::_tao_seq_Octet (void)
{}
Messaging::ExceptionHolder::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max) // uses max size
  : TAO_Unbounded_Sequence<CORBA::Octet> (max)
{}
Messaging::ExceptionHolder::_tao_seq_Octet::_tao_seq_Octet (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : TAO_Unbounded_Sequence<CORBA::Octet> (max, length, buffer, release)
{}
Messaging::ExceptionHolder::_tao_seq_Octet::_tao_seq_Octet (const _tao_seq_Octet &seq) // copy ctor
  : TAO_Unbounded_Sequence<CORBA::Octet> (seq)
{}
Messaging::ExceptionHolder::_tao_seq_Octet::~_tao_seq_Octet (void) // dtor
{}

static const CORBA::Long _oc_Messaging_ExceptionHolder__tao_seq_Octet[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

  0,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ExceptionHolder__tao_seq_Octet (CORBA::tk_sequence, sizeof (_oc_Messaging_ExceptionHolder__tao_seq_Octet), (char *) &_oc_Messaging_ExceptionHolder__tao_seq_Octet, 0, sizeof (Messaging::ExceptionHolder::_tao_seq_Octet));
CORBA::TypeCode_ptr Messaging::ExceptionHolder::_tc__tao_seq_Octet = &_tc_TAO_tc_Messaging_ExceptionHolder__tao_seq_Octet;

// ****************************************************************

Messaging::ReplyHandler_ptr Messaging::ReplyHandler::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyHandler::_nil ();
  if (!obj->_is_a ("IDL:Messaging/ReplyHandler:1.0", env))
    return Messaging::ReplyHandler::_nil ();
  return Messaging::ReplyHandler::_unchecked_narrow (obj, env);
}

Messaging::ReplyHandler_ptr Messaging::ReplyHandler::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::ReplyHandler::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/ReplyHandler:1.0");
  if (servant == 0)
    return new Messaging::ReplyHandler(stub);
  return new POA_Messaging::_tao_collocated_ReplyHandler(
      ACE_reinterpret_cast(POA_Messaging::ReplyHandler_ptr, servant),
      stub
    );
}

CORBA::Boolean Messaging::ReplyHandler::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/ReplyHandler:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::ReplyHandler::_interface_repository_id (void) const
{
  return "IDL:Messaging/ReplyHandler:1.0";
}

static const CORBA::Long _oc_Messaging_ReplyHandler[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f5265), ACE_NTOHL (0x706c7948), ACE_NTOHL (0x616e646c), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:Messaging/ReplyHandler:1.0
  13, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x7948616e), ACE_NTOHL (0x646c6572), ACE_NTOHL (0x0),  // name = ReplyHandler,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_ReplyHandler (CORBA::tk_objref, sizeof (_oc_Messaging_ReplyHandler), (char *) &_oc_Messaging_ReplyHandler, 0, sizeof (Messaging::ReplyHandler));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyHandler, &_tc_TAO_tc_Messaging_ReplyHandler)
TAO_NAMESPACE_END


Messaging::Poller_ptr Messaging::Poller::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::Poller::_nil ();
  if (!obj->_is_a ("IDL:Messaging/Poller:1.0", env))
    return Messaging::Poller::_nil ();
  return Messaging::Poller::_unchecked_narrow (obj, env);
}

Messaging::Poller_ptr Messaging::Poller::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &env
  )
{
  if (CORBA::is_nil (obj))
    return Messaging::Poller::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:Messaging/Poller:1.0");
  if (servant == 0)
    return new Messaging::Poller(stub);
  return new POA_Messaging::_tao_collocated_Poller(
      ACE_reinterpret_cast(POA_Messaging::Poller_ptr, servant),
      stub
    );
}

CORBA::Object_ptr Messaging::Poller::operation_target (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    CORBA::Object_ptr _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""operation_target",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

char * Messaging::Poller::operation_name (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    char *_tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""operation_name",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

Messaging::ReplyHandler_ptr Messaging::Poller::associated_handler (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    Messaging::ReplyHandler_ptr _tao_retval = Messaging::ReplyHandler::_nil ();

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""associated_handler",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

void Messaging::Poller::associated_handler (
    Messaging::ReplyHandler_ptr associated_handler,
    CORBA::Environment &ACE_TRY_ENV
  )
{

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INV_OBJREF (CORBA::COMPLETED_NO));


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_""associated_handler",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

    TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
    if (!(
          (_tao_out << associated_handler)
      ))
      ACE_THROW (CORBA::MARSHAL (CORBA::COMPLETED_NO));

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK;

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW (CORBA::UNKNOWN (CORBA::COMPLETED_YES));

    }
    break;

  }

}

CORBA::Boolean Messaging::Poller::is_from_poller (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    CORBA::Boolean _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""is_from_poller",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Object_ptr Messaging::Poller::target (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    CORBA::Object_ptr _tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""target",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

char * Messaging::Poller::op_name (
    CORBA::Environment &ACE_TRY_ENV
  )
{
    char *_tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (CORBA::COMPLETED_NO), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""op_name",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean Messaging::Poller::_is_a (const CORBA::Char *value, CORBA::Environment &env)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:Messaging/Poller:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Pollable:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (env))))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, env); // remote call
}

const char* Messaging::Poller::_interface_repository_id (void) const
{
  return "IDL:Messaging/Poller:1.0";
}

static const CORBA::Long _oc_Messaging_Poller[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  25, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x4d657373), ACE_NTOHL (0x6167696e), ACE_NTOHL (0x672f506f), ACE_NTOHL (0x6c6c6572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:Messaging/Poller:1.0
  7, ACE_NTOHL (0x506f6c6c), ACE_NTOHL (0x65720000),  // name = Poller,
};
static CORBA::TypeCode _tc_TAO_tc_Messaging_Poller (CORBA::tk_objref, sizeof (_oc_Messaging_Poller), (char *) &_oc_Messaging_Poller, 0, sizeof (Messaging::Poller));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (Messaging)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Poller, &_tc_TAO_tc_Messaging_Poller)
TAO_NAMESPACE_END
#endif

// ****************************************************************

void operator<<= (CORBA::Any &_tao_any, const Messaging::PriorityRange &_tao_elem) // copying
{
  Messaging::PriorityRange *_any_val;
  ACE_NEW (_any_val, Messaging::PriorityRange (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_PriorityRange, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::PriorityRange *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_PriorityRange, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::PriorityRange *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (Messaging::_tc_PriorityRange, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PriorityRange *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PriorityRange, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (Messaging::_tc_PriorityRange, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (Messaging::_tc_PriorityRange, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

void operator<<= (CORBA::Any &_tao_any, const Messaging::RoutingTypeRange &_tao_elem) // copying
{
  Messaging::RoutingTypeRange *_any_val;
  ACE_NEW (_any_val, Messaging::RoutingTypeRange (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_RoutingTypeRange, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::RoutingTypeRange *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_RoutingTypeRange, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::RoutingTypeRange *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (Messaging::_tc_RoutingTypeRange, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::RoutingTypeRange *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::RoutingTypeRange, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (Messaging::_tc_RoutingTypeRange, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (Messaging::_tc_RoutingTypeRange, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

void operator<<= (CORBA::Any &_tao_any, const Messaging::PolicyValue &_tao_elem) // copying
{
  Messaging::PolicyValue *_any_val;
  ACE_NEW (_any_val, Messaging::PolicyValue (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_PolicyValue, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::PolicyValue *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_PolicyValue, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::PolicyValue *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (Messaging::_tc_PolicyValue, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PolicyValue *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PolicyValue, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (Messaging::_tc_PolicyValue, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (Messaging::_tc_PolicyValue, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

void operator<<= (
    CORBA::Any &_tao_any,
    const Messaging::PolicyValueSeq &_tao_elem
  ) // copying
{
  Messaging::PolicyValueSeq *_tao_any_val;
  ACE_NEW (_tao_any_val, Messaging::PolicyValueSeq (_tao_elem));
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_PolicyValueSeq, _tao_any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::PolicyValueSeq *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_PolicyValueSeq, _tao_elem, 0, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::PolicyValueSeq *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (Messaging::_tc_PolicyValueSeq, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::PolicyValueSeq *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::PolicyValueSeq, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (Messaging::_tc_PolicyValueSeq, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (Messaging::_tc_PolicyValueSeq, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

#if defined(TAO_POLLER)
void operator<<= (CORBA::Any &_tao_any, const Messaging::ExceptionHolder &_tao_elem) // copying
{
  Messaging::ExceptionHolder *_any_val;
  ACE_NEW (_any_val, Messaging::ExceptionHolder (_tao_elem));
  if (!_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_ExceptionHolder, _any_val, 1, ACE_TRY_ENV); // copy the value
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, Messaging::ExceptionHolder *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (Messaging::_tc_ExceptionHolder, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::ExceptionHolder *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (Messaging::_tc_ExceptionHolder, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (Messaging::ExceptionHolder *)_tao_any.value ();
      return 1;
      }
    else
    {
      ACE_NEW_RETURN (_tao_elem, Messaging::ExceptionHolder, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (Messaging::_tc_ExceptionHolder, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (Messaging::_tc_ExceptionHolder, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

void operator<<= (CORBA::Any &_tao_any, Messaging::ReplyHandler_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::ReplyHandler::_duplicate (_tao_elem);
    _tao_any.replace (Messaging::_tc_ReplyHandler, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::ReplyHandler_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::ReplyHandler::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (Messaging::_tc_ReplyHandler, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (Messaging::_tc_ReplyHandler, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = Messaging::ReplyHandler::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (Messaging::_tc_ReplyHandler, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

// ****************************************************************

void operator<<= (CORBA::Any &_tao_any, Messaging::Poller_ptr _tao_elem)
{
  CORBA::Object_ptr *_tao_obj_ptr = 0;
  ACE_TRY_NEW_ENV
  {
    ACE_NEW (_tao_obj_ptr, CORBA::Object_ptr);
    *_tao_obj_ptr = Messaging::Poller::_duplicate (_tao_elem);
    _tao_any.replace (Messaging::_tc_Poller, _tao_obj_ptr, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_obj_ptr;
  }
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, Messaging::Poller_ptr &_tao_elem)
{
  CORBA::Object_ptr *tmp = 0;
  ACE_TRY_NEW_ENV
  {
    _tao_elem = Messaging::Poller::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (Messaging::_tc_Poller, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    TAO_InputCDR stream (_tao_any._tao_get_cdr ());
    CORBA::Object_var _tao_obj_var;
    ACE_NEW_RETURN (tmp, CORBA::Object_ptr, 0);
    if (stream.decode (Messaging::_tc_Poller, &_tao_obj_var.out (), 0, ACE_TRY_ENV)
       == CORBA::TypeCode::TRAVERSE_CONTINUE)
    {
      _tao_elem = Messaging::Poller::_narrow (_tao_obj_var.in (), ACE_TRY_ENV);
      ACE_TRY_CHECK;
      *tmp = (CORBA::Object_ptr) _tao_elem;  // any owns the object
      ((CORBA::Any *)&_tao_any)->replace (Messaging::_tc_Poller, tmp, 1, ACE_TRY_ENV);
      ACE_TRY_CHECK;
      return 1;
    }
    // failure
  }
  ACE_CATCHANY
  {
    delete tmp;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}
#endif /* TAO_POLLER */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class TAO_Object_Field_T<Messaging::RebindPolicy>;
  template class TAO_Object_Field_T<Messaging::SyncScopePolicy>;
  template class TAO_Object_Field_T<Messaging::RequestPriorityPolicy>;
  template class TAO_Object_Field_T<Messaging::ReplyPriorityPolicy>;
  template class TAO_Object_Field_T<Messaging::RequestStartTimePolicy>;
  template class TAO_Object_Field_T<Messaging::RequestEndTimePolicy>;
  template class TAO_Object_Field_T<Messaging::ReplyStartTimePolicy>;
  template class TAO_Object_Field_T<Messaging::ReplyEndTimePolicy>;
  template class TAO_Object_Field_T<Messaging::RelativeRequestTimeoutPolicy>;
  template class TAO_Object_Field_T<Messaging::RelativeRoundtripTimeoutPolicy>;
  template class TAO_Object_Field_T<Messaging::RoutingPolicy>;
  template class TAO_Object_Field_T<Messaging::MaxHopsPolicy>;
  template class TAO_Object_Field_T<Messaging::QueueOrderPolicy>;
#if defined(TAO_POLLER)
  template class TAO_Object_Field_T<Messaging::ReplyHandler>;
  template class TAO_Object_Field_T<Messaging::Poller>;
#endif /* TAO_POLLER */

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

#  pragma instantiate TAO_Object_Field_T<Messaging::RebindPolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::SyncScopePolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::RequestPriorityPolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::ReplyPriorityPolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::RequestStartTimePolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::RequestEndTimePolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::ReplyStartTimePolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::ReplyEndTimePolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::RelativeRequestTimeoutPolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::RelativeRoundtripTimeoutPolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::RoutingPolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::MaxHopsPolicy>
#  pragma instantiate TAO_Object_Field_T<Messaging::QueueOrderPolicy>
#if defined(TAO_POLLER)
#  pragma instantiate TAO_Object_Field_T<Messaging::ReplyHandler>
#  pragma instantiate TAO_Object_Field_T<Messaging::Poller>
#endif /* TAO_POLLER */

#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */
