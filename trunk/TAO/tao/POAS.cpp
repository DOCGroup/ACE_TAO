// $Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/corba.h"

#if !defined (__ACE_INLINE__)
#include "POAS.i"
#endif // !defined INLINE

static const TAO_operation_db_entry PortableServer_ThreadPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ThreadPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ThreadPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ThreadPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::ThreadPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::ThreadPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ThreadPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_ThreadPolicy_optable_pool [_tao_PortableServer_ThreadPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ThreadPolicy_allocator (_tao_PortableServer_ThreadPolicy_optable_pool, _tao_PortableServer_ThreadPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ThreadPolicy_optable (PortableServer_ThreadPolicy_operations, 5, 10, &_tao_PortableServer_ThreadPolicy_allocator);

// skeleton constructor
POA_PortableServer::ThreadPolicy::ThreadPolicy (void)
{
  this->optable_ = &tao_PortableServer_ThreadPolicy_optable;
}

void POA_PortableServer::ThreadPolicy::_get_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
    )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_ThreadPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_ThreadPolicyValue, 0, 0}
  }; // PortableServer_ThreadPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_ThreadPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_ThreadPolicy_value_paramdata};

  POA_PortableServer::ThreadPolicy *_tao_impl = (POA_PortableServer::ThreadPolicy *)_tao_object_reference;
  PortableServer::ThreadPolicyValue _tao_retval;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &_get_PortableServer_ThreadPolicy_value_calldata,
    &_tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &_get_PortableServer_ThreadPolicy_value_calldata,
    &_tao_retval
  );
}

void POA_PortableServer::ThreadPolicy::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
    )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ThreadPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ThreadPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ThreadPolicy_is_a_paramdata};
  POA_PortableServer::ThreadPolicy_ptr  _tao_impl = (POA_PortableServer::ThreadPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_ThreadPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_ThreadPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ThreadPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ThreadPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ThreadPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ThreadPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ThreadPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ThreadPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ThreadPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ThreadPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ThreadPolicy::_tao_collocated_ThreadPolicy (
    POA_PortableServer::ThreadPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ThreadPolicy) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ThreadPolicy_ptr POA_PortableServer::_tao_collocated_ThreadPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ThreadPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}


CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ThreadPolicy::copy (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->copy (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_ThreadPolicy::destroy (
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->destroy (
       _tao_orb_environment
    );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ThreadPolicy::policy_type (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::ThreadPolicyValue
POA_PortableServer::_tao_collocated_ThreadPolicy::value (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::ThreadPolicy*
POA_PortableServer::ThreadPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ThreadPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_LifespanPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::LifespanPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::LifespanPolicy::copy_skel},
  {"destroy", &POA_PortableServer::LifespanPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::LifespanPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::LifespanPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_LifespanPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_LifespanPolicy_optable_pool [_tao_PortableServer_LifespanPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_LifespanPolicy_allocator (_tao_PortableServer_LifespanPolicy_optable_pool, _tao_PortableServer_LifespanPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_LifespanPolicy_optable (PortableServer_LifespanPolicy_operations, 5, 10, &_tao_PortableServer_LifespanPolicy_allocator);

// skeleton constructor
POA_PortableServer::LifespanPolicy::LifespanPolicy (void)
{
  this->optable_ = &tao_PortableServer_LifespanPolicy_optable;
}

void POA_PortableServer::LifespanPolicy::_get_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
)
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_LifespanPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_LifespanPolicyValue, 0, 0}
  }; // PortableServer_LifespanPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_LifespanPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_LifespanPolicy_value_paramdata};

  POA_PortableServer::LifespanPolicy *_tao_impl = (POA_PortableServer::LifespanPolicy *)_tao_object_reference;
  PortableServer::LifespanPolicyValue _tao_retval;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &_get_PortableServer_LifespanPolicy_value_calldata,
    &_tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &_get_PortableServer_LifespanPolicy_value_calldata,
    &_tao_retval
  );
}

void POA_PortableServer::LifespanPolicy::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_LifespanPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_LifespanPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_LifespanPolicy_is_a_paramdata};
  POA_PortableServer::LifespanPolicy_ptr  _tao_impl = (POA_PortableServer::LifespanPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_LifespanPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_LifespanPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::LifespanPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/LifespanPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::LifespanPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/LifespanPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::LifespanPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::LifespanPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::LifespanPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/LifespanPolicy:1.0";
}

POA_PortableServer::_tao_collocated_LifespanPolicy::_tao_collocated_LifespanPolicy (
    POA_PortableServer::LifespanPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, LifespanPolicy) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::LifespanPolicy_ptr POA_PortableServer::_tao_collocated_LifespanPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_LifespanPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_LifespanPolicy::copy (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->copy (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_LifespanPolicy::destroy (
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->destroy (
       _tao_orb_environment
    );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_LifespanPolicy::policy_type (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::LifespanPolicyValue
POA_PortableServer::_tao_collocated_LifespanPolicy::value (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::LifespanPolicy*
POA_PortableServer::LifespanPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_LifespanPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_IdUniquenessPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::IdUniquenessPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::IdUniquenessPolicy::copy_skel},
  {"destroy", &POA_PortableServer::IdUniquenessPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::IdUniquenessPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::IdUniquenessPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_IdUniquenessPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_IdUniquenessPolicy_optable_pool [_tao_PortableServer_IdUniquenessPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_IdUniquenessPolicy_allocator (_tao_PortableServer_IdUniquenessPolicy_optable_pool, _tao_PortableServer_IdUniquenessPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_IdUniquenessPolicy_optable (PortableServer_IdUniquenessPolicy_operations, 5, 10, &_tao_PortableServer_IdUniquenessPolicy_allocator);

// skeleton constructor
POA_PortableServer::IdUniquenessPolicy::IdUniquenessPolicy (void)
{
  this->optable_ = &tao_PortableServer_IdUniquenessPolicy_optable;
}

void POA_PortableServer::IdUniquenessPolicy::_get_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
)
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_IdUniquenessPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_IdUniquenessPolicyValue, 0, 0}
  }; // PortableServer_IdUniquenessPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_IdUniquenessPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_IdUniquenessPolicy_value_paramdata};

  POA_PortableServer::IdUniquenessPolicy *_tao_impl = (POA_PortableServer::IdUniquenessPolicy *)_tao_object_reference;
  PortableServer::IdUniquenessPolicyValue _tao_retval;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &_get_PortableServer_IdUniquenessPolicy_value_calldata,
    &_tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &_get_PortableServer_IdUniquenessPolicy_value_calldata,
    &_tao_retval
  );
}

void POA_PortableServer::IdUniquenessPolicy::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_IdUniquenessPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_IdUniquenessPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_IdUniquenessPolicy_is_a_paramdata};
  POA_PortableServer::IdUniquenessPolicy_ptr  _tao_impl = (POA_PortableServer::IdUniquenessPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_IdUniquenessPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_IdUniquenessPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::IdUniquenessPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/IdUniquenessPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::IdUniquenessPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/IdUniquenessPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::IdUniquenessPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::IdUniquenessPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::IdUniquenessPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/IdUniquenessPolicy:1.0";
}

POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_tao_collocated_IdUniquenessPolicy (
    POA_PortableServer::IdUniquenessPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, IdUniquenessPolicy) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::IdUniquenessPolicy_ptr POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_IdUniquenessPolicy::copy (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->copy (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_IdUniquenessPolicy::destroy (
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->destroy (
       _tao_orb_environment
    );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_IdUniquenessPolicy::policy_type (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::IdUniquenessPolicyValue
POA_PortableServer::_tao_collocated_IdUniquenessPolicy::value (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::IdUniquenessPolicy*
POA_PortableServer::IdUniquenessPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_IdUniquenessPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_IdAssignmentPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::IdAssignmentPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::IdAssignmentPolicy::copy_skel},
  {"destroy", &POA_PortableServer::IdAssignmentPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::IdAssignmentPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::IdAssignmentPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_IdAssignmentPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_IdAssignmentPolicy_optable_pool [_tao_PortableServer_IdAssignmentPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_IdAssignmentPolicy_allocator (_tao_PortableServer_IdAssignmentPolicy_optable_pool, _tao_PortableServer_IdAssignmentPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_IdAssignmentPolicy_optable (PortableServer_IdAssignmentPolicy_operations, 5, 10, &_tao_PortableServer_IdAssignmentPolicy_allocator);

// skeleton constructor
POA_PortableServer::IdAssignmentPolicy::IdAssignmentPolicy (void)
{
  this->optable_ = &tao_PortableServer_IdAssignmentPolicy_optable;
}

void POA_PortableServer::IdAssignmentPolicy::_get_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
)
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_IdAssignmentPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_IdAssignmentPolicyValue, 0, 0}
  }; // PortableServer_IdAssignmentPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_IdAssignmentPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_IdAssignmentPolicy_value_paramdata};

  POA_PortableServer::IdAssignmentPolicy *_tao_impl = (POA_PortableServer::IdAssignmentPolicy *)_tao_object_reference;
  PortableServer::IdAssignmentPolicyValue _tao_retval;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &_get_PortableServer_IdAssignmentPolicy_value_calldata,
    &_tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &_get_PortableServer_IdAssignmentPolicy_value_calldata,
    &_tao_retval
  );
}

void POA_PortableServer::IdAssignmentPolicy::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_IdAssignmentPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_IdAssignmentPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_IdAssignmentPolicy_is_a_paramdata};
  POA_PortableServer::IdAssignmentPolicy_ptr  _tao_impl = (POA_PortableServer::IdAssignmentPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_IdAssignmentPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_IdAssignmentPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::IdAssignmentPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/IdAssignmentPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::IdAssignmentPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/IdAssignmentPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::IdAssignmentPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::IdAssignmentPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::IdAssignmentPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/IdAssignmentPolicy:1.0";
}

POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_tao_collocated_IdAssignmentPolicy (
    POA_PortableServer::IdAssignmentPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, IdAssignmentPolicy) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::IdAssignmentPolicy_ptr POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_IdAssignmentPolicy::copy (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->copy (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_IdAssignmentPolicy::destroy (
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->destroy (
       _tao_orb_environment
    );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_IdAssignmentPolicy::policy_type (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::IdAssignmentPolicyValue
POA_PortableServer::_tao_collocated_IdAssignmentPolicy::value (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::IdAssignmentPolicy*
POA_PortableServer::IdAssignmentPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_IdAssignmentPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_ImplicitActivationPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ImplicitActivationPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ImplicitActivationPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ImplicitActivationPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::ImplicitActivationPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::ImplicitActivationPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ImplicitActivationPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_ImplicitActivationPolicy_optable_pool [_tao_PortableServer_ImplicitActivationPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ImplicitActivationPolicy_allocator (_tao_PortableServer_ImplicitActivationPolicy_optable_pool, _tao_PortableServer_ImplicitActivationPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ImplicitActivationPolicy_optable (PortableServer_ImplicitActivationPolicy_operations, 5, 10, &_tao_PortableServer_ImplicitActivationPolicy_allocator);

// skeleton constructor
POA_PortableServer::ImplicitActivationPolicy::ImplicitActivationPolicy (void)
{
  this->optable_ = &tao_PortableServer_ImplicitActivationPolicy_optable;
}

void POA_PortableServer::ImplicitActivationPolicy::_get_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
    )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_ImplicitActivationPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_ImplicitActivationPolicyValue, 0, 0}
  }; // PortableServer_ImplicitActivationPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_ImplicitActivationPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_ImplicitActivationPolicy_value_paramdata};

  POA_PortableServer::ImplicitActivationPolicy *_tao_impl = (POA_PortableServer::ImplicitActivationPolicy *)_tao_object_reference;
  PortableServer::ImplicitActivationPolicyValue _tao_retval;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &_get_PortableServer_ImplicitActivationPolicy_value_calldata,
    &_tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &_get_PortableServer_ImplicitActivationPolicy_value_calldata,
    &_tao_retval
  );
}

void POA_PortableServer::ImplicitActivationPolicy::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ImplicitActivationPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ImplicitActivationPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ImplicitActivationPolicy_is_a_paramdata};
  POA_PortableServer::ImplicitActivationPolicy_ptr  _tao_impl = (POA_PortableServer::ImplicitActivationPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_ImplicitActivationPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_ImplicitActivationPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ImplicitActivationPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ImplicitActivationPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ImplicitActivationPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ImplicitActivationPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ImplicitActivationPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ImplicitActivationPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ImplicitActivationPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ImplicitActivationPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_tao_collocated_ImplicitActivationPolicy (
    POA_PortableServer::ImplicitActivationPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ImplicitActivationPolicy) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ImplicitActivationPolicy_ptr POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::copy (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->copy (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::destroy (
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->destroy (
       _tao_orb_environment
    );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::policy_type (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::ImplicitActivationPolicyValue
POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::value (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::ImplicitActivationPolicy*
POA_PortableServer::ImplicitActivationPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ImplicitActivationPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantRetentionPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::ServantRetentionPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::ServantRetentionPolicy::copy_skel},
  {"destroy", &POA_PortableServer::ServantRetentionPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::ServantRetentionPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::ServantRetentionPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ServantRetentionPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_ServantRetentionPolicy_optable_pool [_tao_PortableServer_ServantRetentionPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ServantRetentionPolicy_allocator (_tao_PortableServer_ServantRetentionPolicy_optable_pool, _tao_PortableServer_ServantRetentionPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantRetentionPolicy_optable (PortableServer_ServantRetentionPolicy_operations, 5, 10, &_tao_PortableServer_ServantRetentionPolicy_allocator);

// skeleton constructor
POA_PortableServer::ServantRetentionPolicy::ServantRetentionPolicy (void)
{
  this->optable_ = &tao_PortableServer_ServantRetentionPolicy_optable;
}

void POA_PortableServer::ServantRetentionPolicy::_get_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
)
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_ServantRetentionPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_ServantRetentionPolicyValue, 0, 0}
  }; // PortableServer_ServantRetentionPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_ServantRetentionPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_ServantRetentionPolicy_value_paramdata};

  POA_PortableServer::ServantRetentionPolicy *_tao_impl = (POA_PortableServer::ServantRetentionPolicy *)_tao_object_reference;
  PortableServer::ServantRetentionPolicyValue _tao_retval;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &_get_PortableServer_ServantRetentionPolicy_value_calldata,
    &_tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &_get_PortableServer_ServantRetentionPolicy_value_calldata,
    &_tao_retval
  );
}

void POA_PortableServer::ServantRetentionPolicy::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ServantRetentionPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantRetentionPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantRetentionPolicy_is_a_paramdata};
  POA_PortableServer::ServantRetentionPolicy_ptr  _tao_impl = (POA_PortableServer::ServantRetentionPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_ServantRetentionPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_ServantRetentionPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ServantRetentionPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantRetentionPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ServantRetentionPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantRetentionPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantRetentionPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantRetentionPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ServantRetentionPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantRetentionPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_tao_collocated_ServantRetentionPolicy (
    POA_PortableServer::ServantRetentionPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ServantRetentionPolicy) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ServantRetentionPolicy_ptr POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ServantRetentionPolicy::copy (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->copy (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_ServantRetentionPolicy::destroy (
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->destroy (
       _tao_orb_environment
    );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ServantRetentionPolicy::policy_type (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::ServantRetentionPolicyValue
POA_PortableServer::_tao_collocated_ServantRetentionPolicy::value (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::ServantRetentionPolicy*
POA_PortableServer::ServantRetentionPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantRetentionPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_RequestProcessingPolicy_operations [] = {
  {"_get_value", &POA_PortableServer::RequestProcessingPolicy::_get_value_skel},
  {"copy", &POA_PortableServer::RequestProcessingPolicy::copy_skel},
  {"destroy", &POA_PortableServer::RequestProcessingPolicy::destroy_skel},
  {"_get_policy_type", &POA_PortableServer::RequestProcessingPolicy::_get_policy_type_skel},
  {"_is_a", &POA_PortableServer::RequestProcessingPolicy::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_RequestProcessingPolicy_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (15);
static char _tao_PortableServer_RequestProcessingPolicy_optable_pool [_tao_PortableServer_RequestProcessingPolicy_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_RequestProcessingPolicy_allocator (_tao_PortableServer_RequestProcessingPolicy_optable_pool, _tao_PortableServer_RequestProcessingPolicy_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_RequestProcessingPolicy_optable (PortableServer_RequestProcessingPolicy_operations, 5, 10, &_tao_PortableServer_RequestProcessingPolicy_allocator);

// skeleton constructor
POA_PortableServer::RequestProcessingPolicy::RequestProcessingPolicy (void)
{
  this->optable_ = &tao_PortableServer_RequestProcessingPolicy_optable;
}

void POA_PortableServer::RequestProcessingPolicy::_get_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
)
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel _get_PortableServer_RequestProcessingPolicy_value_paramdata [] =
  {
    {PortableServer::_tc_RequestProcessingPolicyValue, 0, 0}
  }; // PortableServer_RequestProcessingPolicy_value_paramdata

  static const TAO_Call_Data_Skel _get_PortableServer_RequestProcessingPolicy_value_calldata =
  {"_get_value", 1, 1, _get_PortableServer_RequestProcessingPolicy_value_paramdata};

  POA_PortableServer::RequestProcessingPolicy *_tao_impl = (POA_PortableServer::RequestProcessingPolicy *)_tao_object_reference;
  PortableServer::RequestProcessingPolicyValue _tao_retval;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &_get_PortableServer_RequestProcessingPolicy_value_calldata,
    &_tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->value (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &_get_PortableServer_RequestProcessingPolicy_value_calldata,
    &_tao_retval
  );
}

void POA_PortableServer::RequestProcessingPolicy::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_RequestProcessingPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_RequestProcessingPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_RequestProcessingPolicy_is_a_paramdata};
  POA_PortableServer::RequestProcessingPolicy_ptr  _tao_impl = (POA_PortableServer::RequestProcessingPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_RequestProcessingPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_RequestProcessingPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::RequestProcessingPolicy::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/RequestProcessingPolicy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Policy:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::RequestProcessingPolicy::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/RequestProcessingPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::RequestProcessingPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::RequestProcessingPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::RequestProcessingPolicy::_interface_repository_id (void) const
{
  return "IDL:PortableServer/RequestProcessingPolicy:1.0";
}

POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_tao_collocated_RequestProcessingPolicy (
    POA_PortableServer::RequestProcessingPolicy_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, RequestProcessingPolicy) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::RequestProcessingPolicy_ptr POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_RequestProcessingPolicy::copy (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->copy (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_RequestProcessingPolicy::destroy (
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->destroy (
       _tao_orb_environment
    );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_RequestProcessingPolicy::policy_type (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->policy_type (_tao_orb_environment);
}

PortableServer::RequestProcessingPolicyValue
POA_PortableServer::_tao_collocated_RequestProcessingPolicy::value (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->value(_tao_orb_environment);
}

PortableServer::RequestProcessingPolicy*
POA_PortableServer::RequestProcessingPolicy::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_RequestProcessingPolicy (this, stub);
}

static const TAO_operation_db_entry PortableServer_POAManager_operations [] = {
  {"_is_a", &POA_PortableServer::POAManager::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_POAManager_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_POAManager_optable_pool [_tao_PortableServer_POAManager_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_POAManager_allocator (_tao_PortableServer_POAManager_optable_pool, _tao_PortableServer_POAManager_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_POAManager_optable (PortableServer_POAManager_operations, 1, 1, &_tao_PortableServer_POAManager_allocator);

// skeleton constructor
POA_PortableServer::POAManager::POAManager (void)
{
  this->optable_ = &tao_PortableServer_POAManager_optable;
}

void POA_PortableServer::POAManager::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_POAManager_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_POAManager_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_POAManager_is_a_paramdata};
  POA_PortableServer::POAManager_ptr  _tao_impl = (POA_PortableServer::POAManager_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_POAManager_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_POAManager_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::POAManager::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/POAManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::POAManager::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/POAManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::POAManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::POAManager::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::POAManager::_interface_repository_id (void) const
{
  return "IDL:PortableServer/POAManager:1.0";
}

POA_PortableServer::_tao_collocated_POAManager::_tao_collocated_POAManager (
    POA_PortableServer::POAManager_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, POAManager) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::POAManager_ptr POA_PortableServer::_tao_collocated_POAManager::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_POAManager::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POAManager::activate (
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->activate (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POAManager::hold_requests (
    CORBA::Boolean wait_for_completion,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->hold_requests (
      wait_for_completion,
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POAManager::discard_requests (
    CORBA::Boolean wait_for_completion,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->discard_requests (
      wait_for_completion,
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POAManager::deactivate (
    CORBA::Boolean etherealize_objects,
    CORBA::Boolean wait_for_completion,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->deactivate (
      etherealize_objects,
      wait_for_completion,
       _tao_orb_environment
    );
}


PortableServer::POAManager*
POA_PortableServer::POAManager::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_POAManager (this, stub);
}

static const TAO_operation_db_entry PortableServer_AdapterActivator_operations [] = {
  {"_is_a", &POA_PortableServer::AdapterActivator::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_AdapterActivator_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_AdapterActivator_optable_pool [_tao_PortableServer_AdapterActivator_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_AdapterActivator_allocator (_tao_PortableServer_AdapterActivator_optable_pool, _tao_PortableServer_AdapterActivator_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_AdapterActivator_optable (PortableServer_AdapterActivator_operations, 1, 1, &_tao_PortableServer_AdapterActivator_allocator);

// skeleton constructor
POA_PortableServer::AdapterActivator::AdapterActivator (void)
{
  this->optable_ = &tao_PortableServer_AdapterActivator_optable;
}

void POA_PortableServer::AdapterActivator::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_AdapterActivator_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_AdapterActivator_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_AdapterActivator_is_a_paramdata};
  POA_PortableServer::AdapterActivator_ptr  _tao_impl = (POA_PortableServer::AdapterActivator_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_AdapterActivator_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_AdapterActivator_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::AdapterActivator::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/AdapterActivator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::AdapterActivator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/AdapterActivator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::AdapterActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::AdapterActivator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::AdapterActivator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/AdapterActivator:1.0";
}

POA_PortableServer::_tao_collocated_AdapterActivator::_tao_collocated_AdapterActivator (
    POA_PortableServer::AdapterActivator_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, AdapterActivator) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::AdapterActivator_ptr POA_PortableServer::_tao_collocated_AdapterActivator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_AdapterActivator::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

CORBA::Boolean POA_PortableServer::_tao_collocated_AdapterActivator::unknown_adapter (
    PortableServer::POA_ptr  parent,
    const char* name,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->unknown_adapter (
      parent,
      name,
       _tao_orb_environment
    );
}


PortableServer::AdapterActivator*
POA_PortableServer::AdapterActivator::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_AdapterActivator (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantManager_operations [] = {
  {"_is_a", &POA_PortableServer::ServantManager::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ServantManager_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_ServantManager_optable_pool [_tao_PortableServer_ServantManager_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ServantManager_allocator (_tao_PortableServer_ServantManager_optable_pool, _tao_PortableServer_ServantManager_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantManager_optable (PortableServer_ServantManager_operations, 1, 1, &_tao_PortableServer_ServantManager_allocator);

// skeleton constructor
POA_PortableServer::ServantManager::ServantManager (void)
{
  this->optable_ = &tao_PortableServer_ServantManager_optable;
}

void POA_PortableServer::ServantManager::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ServantManager_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantManager_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantManager_is_a_paramdata};
  POA_PortableServer::ServantManager_ptr  _tao_impl = (POA_PortableServer::ServantManager_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_ServantManager_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_ServantManager_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ServantManager::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ServantManager::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantManager::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ServantManager::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantManager:1.0";
}

POA_PortableServer::_tao_collocated_ServantManager::_tao_collocated_ServantManager (
    POA_PortableServer::ServantManager_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ServantManager) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ServantManager_ptr POA_PortableServer::_tao_collocated_ServantManager::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantManager::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}


PortableServer::ServantManager*
POA_PortableServer::ServantManager::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantManager (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantActivator_operations [] = {
  {"_is_a", &POA_PortableServer::ServantActivator::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ServantActivator_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_ServantActivator_optable_pool [_tao_PortableServer_ServantActivator_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ServantActivator_allocator (_tao_PortableServer_ServantActivator_optable_pool, _tao_PortableServer_ServantActivator_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantActivator_optable (PortableServer_ServantActivator_operations, 1, 1, &_tao_PortableServer_ServantActivator_allocator);

// skeleton constructor
POA_PortableServer::ServantActivator::ServantActivator (void)
{
  this->optable_ = &tao_PortableServer_ServantActivator_optable;
}

void POA_PortableServer::ServantActivator::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ServantActivator_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantActivator_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantActivator_is_a_paramdata};
  POA_PortableServer::ServantActivator_ptr  _tao_impl = (POA_PortableServer::ServantActivator_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_ServantActivator_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_ServantActivator_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ServantActivator::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantActivator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ServantActivator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantActivator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantActivator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ServantActivator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantActivator:1.0";
}

POA_PortableServer::_tao_collocated_ServantActivator::_tao_collocated_ServantActivator (
    POA_PortableServer::ServantActivator_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ServantActivator) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_PortableServer, _tao_collocated_ServantManager) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ServantActivator_ptr POA_PortableServer::_tao_collocated_ServantActivator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantActivator::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_ServantActivator::incarnate (
    const PortableServer::ObjectId & oid,
    PortableServer::POA_ptr  adapter,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->incarnate (
      oid,
      adapter,
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_ServantActivator::etherealize (
    const PortableServer::ObjectId & oid,
    PortableServer::POA_ptr  adapter,
    PortableServer::Servant serv,
    CORBA::Boolean cleanup_in_progress,
    CORBA::Boolean remaining_activations,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->etherealize (
      oid,
      adapter,
      serv,
      cleanup_in_progress,
      remaining_activations,
       _tao_orb_environment
    );
}


PortableServer::ServantActivator*
POA_PortableServer::ServantActivator::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantActivator (this, stub);
}

static const TAO_operation_db_entry PortableServer_ServantLocator_operations [] = {
  {"_is_a", &POA_PortableServer::ServantLocator::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_ServantLocator_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_ServantLocator_optable_pool [_tao_PortableServer_ServantLocator_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_ServantLocator_allocator (_tao_PortableServer_ServantLocator_optable_pool, _tao_PortableServer_ServantLocator_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_ServantLocator_optable (PortableServer_ServantLocator_operations, 1, 1, &_tao_PortableServer_ServantLocator_allocator);

// skeleton constructor
POA_PortableServer::ServantLocator::ServantLocator (void)
{
  this->optable_ = &tao_PortableServer_ServantLocator_optable;
}

void POA_PortableServer::ServantLocator::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_ServantLocator_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantLocator_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantLocator_is_a_paramdata};
  POA_PortableServer::ServantLocator_ptr  _tao_impl = (POA_PortableServer::ServantLocator_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_ServantLocator_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_ServantLocator_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::ServantLocator::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantLocator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/ServantManager:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::ServantLocator::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantLocator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantLocator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::ServantLocator::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::ServantLocator::_interface_repository_id (void) const
{
  return "IDL:PortableServer/ServantLocator:1.0";
}

POA_PortableServer::_tao_collocated_ServantLocator::_tao_collocated_ServantLocator (
    POA_PortableServer::ServantLocator_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, ServantLocator) (stub, servant, CORBA::B_TRUE),
    ACE_NESTED_CLASS (POA_PortableServer, _tao_collocated_ServantManager) (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::ServantLocator_ptr POA_PortableServer::_tao_collocated_ServantLocator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantLocator::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_ServantLocator::preinvoke (
    const PortableServer::ObjectId & oid,
    PortableServer::POA_ptr  adapter,
    const char * operation,
    PortableServer::ServantLocator::Cookie & the_cookie,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->preinvoke (
      oid,
      adapter,
      operation,
      the_cookie,
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_ServantLocator::postinvoke (
    const PortableServer::ObjectId & oid,
    PortableServer::POA_ptr  adapter,
    const char * operation,
    PortableServer::ServantLocator::Cookie the_cookie,
    PortableServer::Servant the_servant,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->postinvoke (
      oid,
      adapter,
      operation,
      the_cookie,
      the_servant,
       _tao_orb_environment
    );
}


PortableServer::ServantLocator*
POA_PortableServer::ServantLocator::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_ServantLocator (this, stub);
}

static const TAO_operation_db_entry PortableServer_POA_operations [] = {
  {"_is_a", &POA_PortableServer::POA::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_POA_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (2);
static char _tao_PortableServer_POA_optable_pool [_tao_PortableServer_POA_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_POA_allocator (_tao_PortableServer_POA_optable_pool, _tao_PortableServer_POA_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_POA_optable (PortableServer_POA_operations, 1, 1, &_tao_PortableServer_POA_allocator);

// skeleton constructor
POA_PortableServer::POA::POA (void)
{
  this->optable_ = &tao_PortableServer_POA_optable;
}

void POA_PortableServer::POA::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_POA_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_POA_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_POA_is_a_paramdata};
  POA_PortableServer::POA_ptr  _tao_impl = (POA_PortableServer::POA_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_POA_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_POA_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::POA::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/POA:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::POA::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/POA:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::POA_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::POA::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::POA::_interface_repository_id (void) const
{
  return "IDL:PortableServer/POA:1.0";
}

POA_PortableServer::_tao_collocated_POA::_tao_collocated_POA (
    POA_PortableServer::POA_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, POA) (stub, servant, CORBA::B_TRUE),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_POA::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::create_POA (
    const char* adapter_name,
    PortableServer::POAManager_ptr  a_POAManager,
    const CORBA::PolicyList & policies,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_POA (
      adapter_name,
      a_POAManager,
      policies,
       _tao_orb_environment
    );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::find_POA (
    const char* adapter_name,
    CORBA::Boolean activate_it,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->find_POA (
      adapter_name,
      activate_it,
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::destroy (
    CORBA::Boolean etherealize_objects,
    CORBA::Boolean wait_for_completion,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->destroy (
      etherealize_objects,
      wait_for_completion,
       _tao_orb_environment
    );
}

PortableServer::ThreadPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_thread_policy (
    PortableServer::ThreadPolicyValue value,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_thread_policy (
      value,
       _tao_orb_environment
    );
}

PortableServer::LifespanPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_lifespan_policy (
    PortableServer::LifespanPolicyValue value,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_lifespan_policy (
      value,
       _tao_orb_environment
    );
}

PortableServer::IdUniquenessPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_id_uniqueness_policy (
    PortableServer::IdUniquenessPolicyValue value,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_id_uniqueness_policy (
      value,
       _tao_orb_environment
    );
}

PortableServer::IdAssignmentPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_id_assignment_policy (
    PortableServer::IdAssignmentPolicyValue value,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_id_assignment_policy (
      value,
       _tao_orb_environment
    );
}

PortableServer::ImplicitActivationPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_implicit_activation_policy (
    PortableServer::ImplicitActivationPolicyValue value,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_implicit_activation_policy (
      value,
       _tao_orb_environment
    );
}

PortableServer::ServantRetentionPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_servant_retention_policy (
    PortableServer::ServantRetentionPolicyValue value,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_servant_retention_policy (
      value,
       _tao_orb_environment
    );
}

PortableServer::RequestProcessingPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_request_processing_policy (
    PortableServer::RequestProcessingPolicyValue value,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_request_processing_policy (
      value,
       _tao_orb_environment
    );
}

char*
POA_PortableServer::_tao_collocated_POA::the_name (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->the_name(_tao_orb_environment);
}
PortableServer::POA_ptr
POA_PortableServer::_tao_collocated_POA::the_parent (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->the_parent(_tao_orb_environment);
}
PortableServer::POAManager_ptr
POA_PortableServer::_tao_collocated_POA::the_POAManager (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->the_POAManager(_tao_orb_environment);
}
PortableServer::AdapterActivator_ptr
POA_PortableServer::_tao_collocated_POA::the_activator (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->the_activator(_tao_orb_environment);
}

void POA_PortableServer::_tao_collocated_POA::the_activator (
    PortableServer::AdapterActivator_ptr _tao_value,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->the_activator (
      _tao_value,
      _tao_orb_environment
    );
}

PortableServer::ServantManager_ptr POA_PortableServer::_tao_collocated_POA::get_servant_manager (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->get_servant_manager (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::set_servant_manager (
    PortableServer::ServantManager_ptr  imgr,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->set_servant_manager (
      imgr,
       _tao_orb_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::get_servant (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->get_servant (
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::set_servant (
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->set_servant (
      p_servant,
       _tao_orb_environment
    );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::activate_object (
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->activate_object (
      p_servant,
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::activate_object_with_id (
    const PortableServer::ObjectId & id,
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->activate_object_with_id (
      id,
      p_servant,
       _tao_orb_environment
    );
}

void POA_PortableServer::_tao_collocated_POA::deactivate_object (
    const PortableServer::ObjectId & oid,
    CORBA::Environment &_tao_orb_environment
  )
{
  this->servant_->deactivate_object (
      oid,
       _tao_orb_environment
    );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::create_reference (
    const char *intf,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_reference (
      intf,
       _tao_orb_environment
    );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::create_reference_with_id (
    const PortableServer::ObjectId & oid,
    const char *intf,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->create_reference_with_id (
      oid,
      intf,
       _tao_orb_environment
    );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::servant_to_id (
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->servant_to_id (
      p_servant,
       _tao_orb_environment
    );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::servant_to_reference (
    PortableServer::Servant p_servant,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->servant_to_reference (
      p_servant,
       _tao_orb_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::reference_to_servant (
    CORBA::Object_ptr  reference,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->reference_to_servant (
      reference,
       _tao_orb_environment
    );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::reference_to_id (
    CORBA::Object_ptr  reference,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->reference_to_id (
      reference,
       _tao_orb_environment
    );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::id_to_servant (
    const PortableServer::ObjectId & oid,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->id_to_servant (
      oid,
       _tao_orb_environment
    );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::id_to_reference (
    const PortableServer::ObjectId & oid,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->id_to_reference (
      oid,
       _tao_orb_environment
    );
}


PortableServer::POA*
POA_PortableServer::POA::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_POA (this, stub);
}

static const TAO_operation_db_entry PortableServer_Current_operations [] = {
  {"get_POA", &POA_PortableServer::Current::get_POA_skel},
  {"get_object_id", &POA_PortableServer::Current::get_object_id_skel},
  {"_is_a", &POA_PortableServer::Current::_is_a_skel}
};

static const CORBA::Long _tao_PortableServer_Current_optable_size = sizeof (ACE_Hash_Map_Entry<const char *, TAO_Skeleton>) * (9);
static char _tao_PortableServer_Current_optable_pool [_tao_PortableServer_Current_optable_size];
static ACE_Static_Allocator_Base _tao_PortableServer_Current_allocator (_tao_PortableServer_Current_optable_pool, _tao_PortableServer_Current_optable_size);
static TAO_Dynamic_Hash_OpTable tao_PortableServer_Current_optable (PortableServer_Current_operations, 3, 6, &_tao_PortableServer_Current_allocator);

// skeleton constructor
POA_PortableServer::Current::Current (void)
{
  this->optable_ = &tao_PortableServer_Current_optable;
}

void POA_PortableServer::Current::get_POA_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
)
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_Current_get_POA_paramdata [] =
  {
    {PortableServer::_tc_POA, 0, 0}
  }; // PortableServer_Current_get_POA_paramdata

  static const TAO_Call_Data_Skel PortableServer_Current_get_POA_calldata =
  {"get_POA", 1, 1, PortableServer_Current_get_POA_paramdata};

  POA_PortableServer::Current *_tao_impl = (POA_PortableServer::Current *)_tao_object_reference;
  CORBA::Object_ptr _tao_retval = CORBA::Object::_nil ();
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_Current_get_POA_calldata,
    &_tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->get_POA (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_Current_get_POA_calldata,
    &_tao_retval
  );
}

void POA_PortableServer::Current::get_object_id_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference,
    void * /* context */,
    CORBA::Environment &_tao_orb_environment
)
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_Current_get_object_id_paramdata [] =
  {
    {PortableServer::_tc_ObjectId, 0, 0}
  }; // PortableServer_Current_get_object_id_paramdata

  static const TAO_Call_Data_Skel PortableServer_Current_get_object_id_calldata =
  {"get_object_id", 1, 1, PortableServer_Current_get_object_id_paramdata};

  POA_PortableServer::Current *_tao_impl = (POA_PortableServer::Current *)_tao_object_reference;
  PortableServer::ObjectId *_tao_retval = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_Current_get_object_id_calldata,
    _tao_retval
  );
  if (_tao_orb_environment.exception ()) return;
  _tao_retval = _tao_impl->get_object_id (
    _tao_skel_environment
  );
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_Current_get_object_id_calldata,
    _tao_retval
  );
}

void POA_PortableServer::Current::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * _tao_object_reference,
    void * /*context*/,
    CORBA::Environment &_tao_orb_environment
  )
{
  CORBA::Environment _tao_skel_environment;
  static const TAO_Param_Data_Skel PortableServer_Current_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_Current_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_Current_is_a_paramdata};
  POA_PortableServer::Current_ptr  _tao_impl = (POA_PortableServer::Current_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  char *_tao_value = 0;
  _tao_server_request.demarshal (
    _tao_orb_environment,
    &PortableServer_Current_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  if (_tao_orb_environment.exception () != 0) return;
  _tao_retval = _tao_impl->_is_a (_tao_value, _tao_skel_environment);
  _tao_server_request.marshal (
    _tao_orb_environment,
    _tao_skel_environment,
    &PortableServer_Current_is_a_calldata,
    &_tao_retval,
    &_tao_value
  );
  CORBA::string_free (_tao_value);
}

CORBA::Boolean POA_PortableServer::Current::_is_a (
    const char* value,
    CORBA::Environment &_tao_orb_environment
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableServer/Current:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:CORBA/Current:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_orb_environment))))
      return CORBA::B_TRUE;
    else
      return CORBA::B_FALSE;
}

void* POA_PortableServer::Current::_downcast (
    const char* logical_type_id
  )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:PortableServer/Current:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Current_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:CORBA/Current:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Current_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_PortableServer::Current::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &env)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    env.exception (new CORBA_BAD_OPERATION (CORBA::COMPLETED_NO));
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
  }
else
  	skel (req, this, context, env);
}

const char* POA_PortableServer::Current::_interface_repository_id (void) const
{
  return "IDL:PortableServer/Current:1.0";
}

POA_PortableServer::_tao_collocated_Current::_tao_collocated_Current (
    POA_PortableServer::Current_ptr  servant,
    STUB_Object *stub
  )
  : ACE_NESTED_CLASS (PortableServer, Current) (stub, servant, CORBA::B_TRUE),
    POA_CORBA::_tao_collocated_Current (servant, stub),
    CORBA_Object (stub, servant, CORBA::B_TRUE),
    servant_ (servant)
{
}

POA_PortableServer::Current_ptr POA_PortableServer::_tao_collocated_Current::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_Current::_is_a (
    const char* logical_type_id,
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->_is_a (
      logical_type_id,
      _tao_orb_environment
    );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_Current::get_POA (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->get_POA (
       _tao_orb_environment
    );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_Current::get_object_id (
    CORBA::Environment &_tao_orb_environment
  )
{
  return this->servant_->get_object_id (
       _tao_orb_environment
    );
}


PortableServer::Current*
POA_PortableServer::Current::_this (CORBA_Environment &_env)
{
  STUB_Object *stub = this->_create_stub (_env);
  if (_env.exception () != 0)
    return 0;
  return new POA_PortableServer::_tao_collocated_Current (this, stub);
}
