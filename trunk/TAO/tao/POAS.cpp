// $Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/POAS.h"
#include "tao/Server_Request.h"
#include "tao/Operation_Table.h"
#include "tao/ORB_Core.h"
#include "tao/ORB.h"

#if !defined (__ACE_INLINE__)
#include "tao/POAS.i"
#endif // !defined INLINE

ACE_RCSID(tao, POAS, "$Id$")

#if !defined (TAO_HAS_MINIMUM_CORBA)

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
class TAO_PortableServer_ThreadPolicy_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 0:12:47 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_PortableServer_ThreadPolicy_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_PortableServer_ThreadPolicy_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17,  0, 17,  0, 17,  0,
      0,  0, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,  0, 17, 17, 17,
     17,  0, 17, 17, 17, 17, 17, 17,
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_PortableServer_ThreadPolicy_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 16,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0}, {"",0}, {"",0}, {"",0},
      {"copy",  &POA_PortableServer::ThreadPolicy::copy_skel},
      {"_is_a",  &POA_PortableServer::ThreadPolicy::_is_a_skel},
      {"",0},
      {"destroy",       &POA_PortableServer::ThreadPolicy::destroy_skel},
      {"",0}, {"",0},
      {"_get_value",    &POA_PortableServer::ThreadPolicy::_get_value_skel},
      {"",0}, {"",0},
      {"_non_existent",  &POA_PortableServer::ThreadPolicy::_non_existent_skel},
      {"",0}, {"",0},
      {"_get_policy_type",      &POA_PortableServer::ThreadPolicy::_get_policy_type_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 0:12:47 */
TAO_PortableServer_ThreadPolicy_Perfect_Hash_OpTable tao_PortableServer_ThreadPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

// skeleton constructor
POA_PortableServer::ThreadPolicy::ThreadPolicy (void)
{
#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  this->optable_ = &tao_PortableServer_ThreadPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::ThreadPolicy::_get_value_skel (
                                                        CORBA::ServerRequest &_tao_server_request,
                                                        void *_tao_object_reference,
                                                        void * /* context */,
                                                        CORBA::Environment &ACE_TRY_ENV
                                                        )
{
  POA_PortableServer::ThreadPolicy *_tao_impl = (POA_PortableServer::ThreadPolicy *)_tao_object_reference;
  PortableServer::ThreadPolicyValue _tao_retval;
  _tao_retval = _tao_impl->value (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );
}

void POA_PortableServer::ThreadPolicy::_is_a_skel (
                                                   CORBA::ServerRequest &_tao_server_request,
                                                   void * _tao_object_reference,
                                                   void * /*context*/,
                                                   CORBA::Environment &ACE_TRY_ENV
                                                   )
{
  static const TAO_Param_Data_Skel PortableServer_ThreadPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ThreadPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ThreadPolicy_is_a_paramdata};
  POA_PortableServer::ThreadPolicy_ptr  _tao_impl = (POA_PortableServer::ThreadPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
    ACE_TRY_ENV,
    &PortableServer_ThreadPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_ThreadPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
}

void POA_PortableServer::ThreadPolicy::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * /* _tao_object_reference */ ,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel PortableServer_ThreadPolicy_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ThreadPolicy_non_existent_calldata =
  {"_non_existent", 1, 1, PortableServer_ThreadPolicy_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_ThreadPolicy_non_existent_calldata,
    &_tao_retval
  );
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean POA_PortableServer::ThreadPolicy::_is_a (
                                                        const char* value,
                                                        CORBA::Environment &ACE_TRY_ENV
                                                        )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ThreadPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ThreadPolicy::_downcast (
                                                   const char* logical_type_id
                                                   )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/ThreadPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ThreadPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::ThreadPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

const char* POA_PortableServer::ThreadPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ThreadPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ThreadPolicy::_tao_collocated_ThreadPolicy (
                                                                                POA_PortableServer::ThreadPolicy_ptr  servant,
                                                                                TAO_Stub *stub
                                                                                )
  : ACE_NESTED_CLASS (PortableServer, ThreadPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ThreadPolicy_ptr POA_PortableServer::_tao_collocated_ThreadPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ThreadPolicy::_is_a (
                                                                        const char* logical_type_id,
                                                                        CORBA::Environment &ACE_TRY_ENV
                                                                        )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}


CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ThreadPolicy::copy (
                                                                          CORBA::Environment &ACE_TRY_ENV
                                                                          )
{
  return this->servant_->copy (
                               ACE_TRY_ENV
                               );
}

void POA_PortableServer::_tao_collocated_ThreadPolicy::destroy (
                                                                CORBA::Environment &ACE_TRY_ENV
                                                                )
{
  this->servant_->destroy (
                           ACE_TRY_ENV
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ThreadPolicy::policy_type (
                                                                                 CORBA::Environment &ACE_TRY_ENV
                                                                                 )
{
  return this->servant_->policy_type (ACE_TRY_ENV);
}

PortableServer::ThreadPolicyValue
POA_PortableServer::_tao_collocated_ThreadPolicy::value (
                                                         CORBA::Environment &ACE_TRY_ENV
                                                         )
{
  return this->servant_->value(ACE_TRY_ENV);
}

PortableServer::ThreadPolicy*
POA_PortableServer::ThreadPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  PortableServer::ThreadPolicy *retval = 
    PortableServer::ThreadPolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_ThreadPolicy (this, 
                                                                    stub),
                  PortableServer::ThreadPolicy::_nil ());

  return retval;
}

#endif /* TAO_HAS_MINIMUM_CORBA */

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
class TAO_PortableServer_LifespanPolicy_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 0:12:47 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_PortableServer_LifespanPolicy_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_PortableServer_LifespanPolicy_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17,  0, 17,  0, 17,  0,
      0,  0, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,  0, 17, 17, 17,
     17,  0, 17, 17, 17, 17, 17, 17,
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_PortableServer_LifespanPolicy_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 16,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0}, {"",0}, {"",0}, {"",0},
      {"copy",  &POA_PortableServer::LifespanPolicy::copy_skel},
      {"_is_a",  &POA_PortableServer::LifespanPolicy::_is_a_skel},
      {"",0},
      {"destroy",       &POA_PortableServer::LifespanPolicy::destroy_skel},
      {"",0}, {"",0},
      {"_get_value",    &POA_PortableServer::LifespanPolicy::_get_value_skel},
      {"",0}, {"",0},
      {"_non_existent",  &POA_PortableServer::LifespanPolicy::_non_existent_skel},
      {"",0}, {"",0},
      {"_get_policy_type",      &POA_PortableServer::LifespanPolicy::_get_policy_type_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 0:12:47 */
TAO_PortableServer_LifespanPolicy_Perfect_Hash_OpTable tao_PortableServer_LifespanPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

// skeleton constructor
POA_PortableServer::LifespanPolicy::LifespanPolicy (void)
{
#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  this->optable_ = &tao_PortableServer_LifespanPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::LifespanPolicy::_get_value_skel (
                                                          CORBA::ServerRequest &_tao_server_request,
                                                          void *_tao_object_reference,
                                                          void * /* context */,
                                                          CORBA::Environment &ACE_TRY_ENV
                                                          )
{
  POA_PortableServer::LifespanPolicy *_tao_impl = (POA_PortableServer::LifespanPolicy *)_tao_object_reference;
  PortableServer::LifespanPolicyValue _tao_retval;
  _tao_retval = _tao_impl->value (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_PortableServer::LifespanPolicy::_is_a_skel (
                                                     CORBA::ServerRequest &_tao_server_request,
                                                     void * _tao_object_reference,
                                                     void * /*context*/,
                                                     CORBA::Environment &ACE_TRY_ENV
                                                     )
{
  static const TAO_Param_Data_Skel PortableServer_LifespanPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_LifespanPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_LifespanPolicy_is_a_paramdata};
  POA_PortableServer::LifespanPolicy_ptr  _tao_impl = (POA_PortableServer::LifespanPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
    ACE_TRY_ENV,
    &PortableServer_LifespanPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_LifespanPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
}

void POA_PortableServer::LifespanPolicy::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * /* _tao_object_reference */ ,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel PortableServer_LifespanPolicy_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_LifespanPolicy_non_existent_calldata =
  {"_non_existent", 1, 1, PortableServer_LifespanPolicy_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_LifespanPolicy_non_existent_calldata,
    &_tao_retval
  );
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean POA_PortableServer::LifespanPolicy::_is_a (
                                                          const char* value,
                                                          CORBA::Environment &ACE_TRY_ENV
                                                          )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/LifespanPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::LifespanPolicy::_downcast (
                                                     const char* logical_type_id
                                                     )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/LifespanPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::LifespanPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::LifespanPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

const char* POA_PortableServer::LifespanPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/LifespanPolicy:1.0";
}

POA_PortableServer::_tao_collocated_LifespanPolicy::_tao_collocated_LifespanPolicy (
                                                                                    POA_PortableServer::LifespanPolicy_ptr  servant,
                                                                                    TAO_Stub *stub
                                                                                    )
  : ACE_NESTED_CLASS (PortableServer, LifespanPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::LifespanPolicy_ptr POA_PortableServer::_tao_collocated_LifespanPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_LifespanPolicy::_is_a (
                                                                          const char* logical_type_id,
                                                                          CORBA::Environment &ACE_TRY_ENV
                                                                          )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_LifespanPolicy::copy (
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  return this->servant_->copy (
                               ACE_TRY_ENV
                               );
}

void POA_PortableServer::_tao_collocated_LifespanPolicy::destroy (
                                                                  CORBA::Environment &ACE_TRY_ENV
                                                                  )
{
  this->servant_->destroy (
                           ACE_TRY_ENV
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_LifespanPolicy::policy_type (
                                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                                   )
{
  return this->servant_->policy_type (ACE_TRY_ENV);
}

PortableServer::LifespanPolicyValue
POA_PortableServer::_tao_collocated_LifespanPolicy::value (
                                                           CORBA::Environment &ACE_TRY_ENV
                                                           )
{
  return this->servant_->value(ACE_TRY_ENV);
}

PortableServer::LifespanPolicy*
POA_PortableServer::LifespanPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  PortableServer::LifespanPolicy *retval = 
    PortableServer::LifespanPolicy::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_LifespanPolicy (this, 
                                                                      stub),
                  PortableServer::LifespanPolicy::_nil ());

  return retval;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
class TAO_PortableServer_IdUniquenessPolicy_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 0:12:47 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_PortableServer_IdUniquenessPolicy_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_PortableServer_IdUniquenessPolicy_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17,  0, 17,  0, 17,  0,
      0,  0, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,  0, 17, 17, 17,
     17,  0, 17, 17, 17, 17, 17, 17,
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_PortableServer_IdUniquenessPolicy_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 16,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0}, {"",0}, {"",0}, {"",0},
      {"copy",  &POA_PortableServer::IdUniquenessPolicy::copy_skel},
      {"_is_a",  &POA_PortableServer::IdUniquenessPolicy::_is_a_skel},
      {"",0},
      {"destroy",       &POA_PortableServer::IdUniquenessPolicy::destroy_skel},
      {"",0}, {"",0},
      {"_get_value",    &POA_PortableServer::IdUniquenessPolicy::_get_value_skel},
      {"",0}, {"",0},
      {"_non_existent",  &POA_PortableServer::IdUniquenessPolicy::_non_existent_skel},
      {"",0}, {"",0},
      {"_get_policy_type",      &POA_PortableServer::IdUniquenessPolicy::_get_policy_type_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 0:12:47 */
TAO_PortableServer_IdUniquenessPolicy_Perfect_Hash_OpTable tao_PortableServer_IdUniquenessPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

// skeleton constructor
POA_PortableServer::IdUniquenessPolicy::IdUniquenessPolicy (void)
{
#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  this->optable_ = &tao_PortableServer_IdUniquenessPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::IdUniquenessPolicy::_get_value_skel (
                                                              CORBA::ServerRequest &_tao_server_request,
                                                              void *_tao_object_reference,
                                                              void * /* context */,
                                                              CORBA::Environment &ACE_TRY_ENV
                                                              )
{
  POA_PortableServer::IdUniquenessPolicy *_tao_impl = (POA_PortableServer::IdUniquenessPolicy *)_tao_object_reference;
  PortableServer::IdUniquenessPolicyValue _tao_retval;
  _tao_retval = _tao_impl->value (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_PortableServer::IdUniquenessPolicy::_is_a_skel (
                                                         CORBA::ServerRequest &_tao_server_request,
                                                         void * _tao_object_reference,
                                                         void * /*context*/,
                                                         CORBA::Environment &ACE_TRY_ENV
                                                         )
{
  static const TAO_Param_Data_Skel PortableServer_IdUniquenessPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_IdUniquenessPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_IdUniquenessPolicy_is_a_paramdata};
  POA_PortableServer::IdUniquenessPolicy_ptr  _tao_impl = (POA_PortableServer::IdUniquenessPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
    ACE_TRY_ENV,
    &PortableServer_IdUniquenessPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_IdUniquenessPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
}

void POA_PortableServer::IdUniquenessPolicy::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * /* _tao_object_reference */ ,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel PortableServer_IdUniquenessPolicy_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_IdUniquenessPolicy_non_existent_calldata =
  {"_non_existent", 1, 1, PortableServer_IdUniquenessPolicy_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_IdUniquenessPolicy_non_existent_calldata,
    &_tao_retval
  );
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean POA_PortableServer::IdUniquenessPolicy::_is_a (
                                                              const char* value,
                                                              CORBA::Environment &ACE_TRY_ENV
                                                              )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::IdUniquenessPolicy::_downcast (
                                                         const char* logical_type_id
                                                         )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::IdUniquenessPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::IdUniquenessPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

const char* POA_PortableServer::IdUniquenessPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0";
}

POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_tao_collocated_IdUniquenessPolicy (
                                                                                            POA_PortableServer::IdUniquenessPolicy_ptr  servant,
                                                                                            TAO_Stub *stub
                                                                                            )
  : ACE_NESTED_CLASS (PortableServer, IdUniquenessPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::IdUniquenessPolicy_ptr POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_IdUniquenessPolicy::_is_a (
                                                                              const char* logical_type_id,
                                                                              CORBA::Environment &ACE_TRY_ENV
                                                                              )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_IdUniquenessPolicy::copy (
                                                                                CORBA::Environment &ACE_TRY_ENV
                                                                                )
{
  return this->servant_->copy (
                               ACE_TRY_ENV
                               );
}

void POA_PortableServer::_tao_collocated_IdUniquenessPolicy::destroy (
                                                                      CORBA::Environment &ACE_TRY_ENV
                                                                      )
{
  this->servant_->destroy (
                           ACE_TRY_ENV
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_IdUniquenessPolicy::policy_type (
                                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                                       )
{
  return this->servant_->policy_type (ACE_TRY_ENV);
}

PortableServer::IdUniquenessPolicyValue
POA_PortableServer::_tao_collocated_IdUniquenessPolicy::value (
                                                               CORBA::Environment &ACE_TRY_ENV
                                                               )
{
  return this->servant_->value(ACE_TRY_ENV);
}


PortableServer::IdUniquenessPolicy*
POA_PortableServer::IdUniquenessPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  PortableServer::IdUniquenessPolicy *retval = 
    PortableServer::IdUniquenessPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_PortableServer::_tao_collocated_IdUniquenessPolicy (this, 
                                                              stub),
      PortableServer::IdUniquenessPolicy::_nil ()
    );

  return retval;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
class TAO_PortableServer_IdAssignmentPolicy_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 0:12:47 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_PortableServer_IdAssignmentPolicy_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_PortableServer_IdAssignmentPolicy_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17,  0, 17,  0, 17,  0,
      0,  0, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,  0, 17, 17, 17,
     17,  0, 17, 17, 17, 17, 17, 17,
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_PortableServer_IdAssignmentPolicy_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 16,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0}, {"",0}, {"",0}, {"",0},
      {"copy",  &POA_PortableServer::IdAssignmentPolicy::copy_skel},
      {"_is_a",  &POA_PortableServer::IdAssignmentPolicy::_is_a_skel},
      {"",0},
      {"destroy",       &POA_PortableServer::IdAssignmentPolicy::destroy_skel},
      {"",0}, {"",0},
      {"_get_value",    &POA_PortableServer::IdAssignmentPolicy::_get_value_skel},
      {"",0}, {"",0},
      {"_non_existent",  &POA_PortableServer::IdAssignmentPolicy::_non_existent_skel},
      {"",0}, {"",0},
      {"_get_policy_type",      &POA_PortableServer::IdAssignmentPolicy::_get_policy_type_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 0:12:47 */
TAO_PortableServer_IdAssignmentPolicy_Perfect_Hash_OpTable tao_PortableServer_IdAssignmentPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

// skeleton constructor
POA_PortableServer::IdAssignmentPolicy::IdAssignmentPolicy (void)
{
#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  this->optable_ = &tao_PortableServer_IdAssignmentPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::IdAssignmentPolicy::_get_value_skel (
                                                              CORBA::ServerRequest &_tao_server_request,
                                                              void *_tao_object_reference,
                                                              void * /* context */,
                                                              CORBA::Environment &ACE_TRY_ENV
                                                              )
{
  POA_PortableServer::IdAssignmentPolicy *_tao_impl = (POA_PortableServer::IdAssignmentPolicy *)_tao_object_reference;
  PortableServer::IdAssignmentPolicyValue _tao_retval;
  _tao_retval = _tao_impl->value (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_PortableServer::IdAssignmentPolicy::_is_a_skel (
                                                         CORBA::ServerRequest &_tao_server_request,
                                                         void * _tao_object_reference,
                                                         void * /*context*/,
                                                         CORBA::Environment &ACE_TRY_ENV
                                                         )
{
  static const TAO_Param_Data_Skel PortableServer_IdAssignmentPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_IdAssignmentPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_IdAssignmentPolicy_is_a_paramdata};
  POA_PortableServer::IdAssignmentPolicy_ptr  _tao_impl = (POA_PortableServer::IdAssignmentPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
    ACE_TRY_ENV,
    &PortableServer_IdAssignmentPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_IdAssignmentPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
}

void POA_PortableServer::IdAssignmentPolicy::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * /* _tao_object_reference */ ,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel PortableServer_IdAssignmentPolicy_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_IdAssignmentPolicy_non_existent_calldata =
  {"_non_existent", 1, 1, PortableServer_IdAssignmentPolicy_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_IdAssignmentPolicy_non_existent_calldata,
    &_tao_retval
  );
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean POA_PortableServer::IdAssignmentPolicy::_is_a (
                                                              const char* value,
                                                              CORBA::Environment &ACE_TRY_ENV
                                                              )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::IdAssignmentPolicy::_downcast (
                                                         const char* logical_type_id
                                                         )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::IdAssignmentPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::IdAssignmentPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

const char* POA_PortableServer::IdAssignmentPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0";
}

POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_tao_collocated_IdAssignmentPolicy (
                                                                                            POA_PortableServer::IdAssignmentPolicy_ptr  servant,
                                                                                            TAO_Stub *stub
                                                                                            )
  : ACE_NESTED_CLASS (PortableServer, IdAssignmentPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::IdAssignmentPolicy_ptr POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_IdAssignmentPolicy::_is_a (
                                                                              const char* logical_type_id,
                                                                              CORBA::Environment &ACE_TRY_ENV
                                                                              )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_IdAssignmentPolicy::copy (
                                                                                CORBA::Environment &ACE_TRY_ENV
                                                                                )
{
  return this->servant_->copy (
                               ACE_TRY_ENV
                               );
}

void POA_PortableServer::_tao_collocated_IdAssignmentPolicy::destroy (
                                                                      CORBA::Environment &ACE_TRY_ENV
                                                                      )
{
  this->servant_->destroy (
                           ACE_TRY_ENV
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_IdAssignmentPolicy::policy_type (
                                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                                       )
{
  return this->servant_->policy_type (ACE_TRY_ENV);
}

PortableServer::IdAssignmentPolicyValue
POA_PortableServer::_tao_collocated_IdAssignmentPolicy::value (
                                                               CORBA::Environment &ACE_TRY_ENV
                                                               )
{
  return this->servant_->value(ACE_TRY_ENV);
}

PortableServer::IdAssignmentPolicy*
POA_PortableServer::IdAssignmentPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  PortableServer::IdAssignmentPolicy *retval = 
    PortableServer::IdAssignmentPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_PortableServer::_tao_collocated_IdAssignmentPolicy (this, 
                                                              stub),
      PortableServer::IdAssignmentPolicy::_nil ()
    );

  return retval;
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
class TAO_PortableServer_ImplicitActivationPolicy_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 0:12:47 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_PortableServer_ImplicitActivationPolicy_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_PortableServer_ImplicitActivationPolicy_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17,  0, 17,  0, 17,  0,
      0,  0, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,  0, 17, 17, 17,
     17,  0, 17, 17, 17, 17, 17, 17,
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_PortableServer_ImplicitActivationPolicy_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 16,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0}, {"",0}, {"",0}, {"",0},
      {"copy",  &POA_PortableServer::ImplicitActivationPolicy::copy_skel},
      {"_is_a",  &POA_PortableServer::ImplicitActivationPolicy::_is_a_skel},
      {"",0},
      {"destroy",       &POA_PortableServer::ImplicitActivationPolicy::destroy_skel},
      {"",0}, {"",0},
      {"_get_value",    &POA_PortableServer::ImplicitActivationPolicy::_get_value_skel},
      {"",0}, {"",0},
      {"_non_existent",  &POA_PortableServer::ImplicitActivationPolicy::_non_existent_skel},
      {"",0}, {"",0},
      {"_get_policy_type",      &POA_PortableServer::ImplicitActivationPolicy::_get_policy_type_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 0:12:47 */
TAO_PortableServer_ImplicitActivationPolicy_Perfect_Hash_OpTable tao_PortableServer_ImplicitActivationPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

// skeleton constructor
POA_PortableServer::ImplicitActivationPolicy::ImplicitActivationPolicy (void)
{
#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  this->optable_ = &tao_PortableServer_ImplicitActivationPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::ImplicitActivationPolicy::_get_value_skel (
                                                                    CORBA::ServerRequest &_tao_server_request,
                                                                    void *_tao_object_reference,
                                                                    void * /* context */,
                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                    )
{
  POA_PortableServer::ImplicitActivationPolicy *_tao_impl = (POA_PortableServer::ImplicitActivationPolicy *)_tao_object_reference;
  PortableServer::ImplicitActivationPolicyValue _tao_retval;
  _tao_retval = _tao_impl->value (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_PortableServer::ImplicitActivationPolicy::_is_a_skel (
                                                               CORBA::ServerRequest &_tao_server_request,
                                                               void * _tao_object_reference,
                                                               void * /*context*/,
                                                               CORBA::Environment &ACE_TRY_ENV
                                                               )
{
  static const TAO_Param_Data_Skel PortableServer_ImplicitActivationPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ImplicitActivationPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ImplicitActivationPolicy_is_a_paramdata};
  POA_PortableServer::ImplicitActivationPolicy_ptr  _tao_impl = (POA_PortableServer::ImplicitActivationPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
    ACE_TRY_ENV,
    &PortableServer_ImplicitActivationPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_ImplicitActivationPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
}

void POA_PortableServer::ImplicitActivationPolicy::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * /* _tao_object_reference */ ,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel PortableServer_ImplicitActivationPolicy_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ImplicitActivationPolicy_non_existent_calldata =
  {"_non_existent", 1, 1, PortableServer_ImplicitActivationPolicy_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_ImplicitActivationPolicy_non_existent_calldata,
    &_tao_retval
  );
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean POA_PortableServer::ImplicitActivationPolicy::_is_a (
                                                                    const char* value,
                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                    )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ImplicitActivationPolicy::_downcast (
                                                               const char* logical_type_id
                                                               )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ImplicitActivationPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::ImplicitActivationPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

const char* POA_PortableServer::ImplicitActivationPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_tao_collocated_ImplicitActivationPolicy (
                                                                                                        POA_PortableServer::ImplicitActivationPolicy_ptr  servant,
                                                                                                        TAO_Stub *stub
                                                                                                        )
  : ACE_NESTED_CLASS (PortableServer, ImplicitActivationPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ImplicitActivationPolicy_ptr POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::_is_a (
                                                                                    const char* logical_type_id,
                                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                                    )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::copy (
                                                                                      CORBA::Environment &ACE_TRY_ENV
                                                                                      )
{
  return this->servant_->copy (
                               ACE_TRY_ENV
                               );
}

void POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::destroy (
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  this->servant_->destroy (
                           ACE_TRY_ENV
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::policy_type (
                                                                                             CORBA::Environment &ACE_TRY_ENV
                                                                                             )
{
  return this->servant_->policy_type (ACE_TRY_ENV);
}

PortableServer::ImplicitActivationPolicyValue
POA_PortableServer::_tao_collocated_ImplicitActivationPolicy::value (
                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                     )
{
  return this->servant_->value(ACE_TRY_ENV);
}

PortableServer::ImplicitActivationPolicy*
POA_PortableServer::ImplicitActivationPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  PortableServer::ImplicitActivationPolicy *retval = 
    PortableServer::ImplicitActivationPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_PortableServer::_tao_collocated_ImplicitActivationPolicy (this, 
                                                                    stub),
      PortableServer::ImplicitActivationPolicy::_nil ()
    );

  return retval;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
class TAO_PortableServer_ServantRetentionPolicy_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 0:12:47 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_PortableServer_ServantRetentionPolicy_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_PortableServer_ServantRetentionPolicy_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17,  0, 17,  0, 17,  0,
      0,  0, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,  0, 17, 17, 17,
     17,  0, 17, 17, 17, 17, 17, 17,
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_PortableServer_ServantRetentionPolicy_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 16,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0}, {"",0}, {"",0}, {"",0},
      {"copy",  &POA_PortableServer::ServantRetentionPolicy::copy_skel},
      {"_is_a",  &POA_PortableServer::ServantRetentionPolicy::_is_a_skel},
      {"",0},
      {"destroy",       &POA_PortableServer::ServantRetentionPolicy::destroy_skel},
      {"",0}, {"",0},
      {"_get_value",    &POA_PortableServer::ServantRetentionPolicy::_get_value_skel},
      {"",0}, {"",0},
      {"_non_existent",  &POA_PortableServer::ServantRetentionPolicy::_non_existent_skel},
      {"",0}, {"",0},
      {"_get_policy_type",      &POA_PortableServer::ServantRetentionPolicy::_get_policy_type_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 0:12:47 */
TAO_PortableServer_ServantRetentionPolicy_Perfect_Hash_OpTable tao_PortableServer_ServantRetentionPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

// skeleton constructor
POA_PortableServer::ServantRetentionPolicy::ServantRetentionPolicy (void)
{
#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  this->optable_ = &tao_PortableServer_ServantRetentionPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::ServantRetentionPolicy::_get_value_skel (
                                                                  CORBA::ServerRequest &_tao_server_request,
                                                                  void *_tao_object_reference,
                                                                  void * /* context */,
                                                                  CORBA::Environment &ACE_TRY_ENV
                                                                  )
{
  POA_PortableServer::ServantRetentionPolicy *_tao_impl = (POA_PortableServer::ServantRetentionPolicy *)_tao_object_reference;
  PortableServer::ServantRetentionPolicyValue _tao_retval;
  _tao_retval = _tao_impl->value (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_PortableServer::ServantRetentionPolicy::_is_a_skel (
                                                             CORBA::ServerRequest &_tao_server_request,
                                                             void * _tao_object_reference,
                                                             void * /*context*/,
                                                             CORBA::Environment &ACE_TRY_ENV
                                                             )
{
  static const TAO_Param_Data_Skel PortableServer_ServantRetentionPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantRetentionPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_ServantRetentionPolicy_is_a_paramdata};
  POA_PortableServer::ServantRetentionPolicy_ptr  _tao_impl = (POA_PortableServer::ServantRetentionPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
    ACE_TRY_ENV,
    &PortableServer_ServantRetentionPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_ServantRetentionPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
}

void POA_PortableServer::ServantRetentionPolicy::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * /* _tao_object_reference */ ,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel PortableServer_ServantRetentionPolicy_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_ServantRetentionPolicy_non_existent_calldata =
  {"_non_existent", 1, 1, PortableServer_ServantRetentionPolicy_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_ServantRetentionPolicy_non_existent_calldata,
    &_tao_retval
  );
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean POA_PortableServer::ServantRetentionPolicy::_is_a (
                                                                  const char* value,
                                                                  CORBA::Environment &ACE_TRY_ENV
                                                                  )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ServantRetentionPolicy::_downcast (
                                                             const char* logical_type_id
                                                             )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantRetentionPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::ServantRetentionPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

const char* POA_PortableServer::ServantRetentionPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0";
}

POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_tao_collocated_ServantRetentionPolicy (
                                                                                                    POA_PortableServer::ServantRetentionPolicy_ptr  servant,
                                                                                                    TAO_Stub *stub
                                                                                                    )
  : ACE_NESTED_CLASS (PortableServer, ServantRetentionPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ServantRetentionPolicy_ptr POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantRetentionPolicy::_is_a (
                                                                                  const char* logical_type_id,
                                                                                  CORBA::Environment &ACE_TRY_ENV
                                                                                  )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_ServantRetentionPolicy::copy (
                                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                                    )
{
  return this->servant_->copy (
                               ACE_TRY_ENV
                               );
}

void POA_PortableServer::_tao_collocated_ServantRetentionPolicy::destroy (
                                                                          CORBA::Environment &ACE_TRY_ENV
                                                                          )
{
  this->servant_->destroy (
                           ACE_TRY_ENV
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_ServantRetentionPolicy::policy_type (
                                                                                           CORBA::Environment &ACE_TRY_ENV
                                                                                           )
{
  return this->servant_->policy_type (ACE_TRY_ENV);
}

PortableServer::ServantRetentionPolicyValue
POA_PortableServer::_tao_collocated_ServantRetentionPolicy::value (
                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                   )
{
  return this->servant_->value(ACE_TRY_ENV);
}

PortableServer::ServantRetentionPolicy*
POA_PortableServer::ServantRetentionPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  PortableServer::ServantRetentionPolicy *retval = 
    PortableServer::ServantRetentionPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_PortableServer::_tao_collocated_ServantRetentionPolicy (this, 
                                                                  stub),
      PortableServer::ServantRetentionPolicy::_nil ()
    );

  return retval;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
class TAO_PortableServer_RequestProcessingPolicy_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 0:12:47 */
/* C++ code produced by gperf version 2.7 (GNU C++ version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -a -o -t -p -K opname_ -L C++ -Z TAO_PortableServer_RequestProcessingPolicy_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_PortableServer_RequestProcessingPolicy_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17,  0, 17,  0, 17,  0,
      0,  0, 17, 17, 17, 17, 17, 17, 17, 17,
     17, 17, 17, 17, 17, 17,  0, 17, 17, 17,
     17,  0, 17, 17, 17, 17, 17, 17,
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_PortableServer_RequestProcessingPolicy_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 16,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 16,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0}, {"",0}, {"",0}, {"",0},
      {"copy",  &POA_PortableServer::RequestProcessingPolicy::copy_skel},
      {"_is_a",  &POA_PortableServer::RequestProcessingPolicy::_is_a_skel},
      {"",0},
      {"destroy",       &POA_PortableServer::RequestProcessingPolicy::destroy_skel},
      {"",0}, {"",0},
      {"_get_value",    &POA_PortableServer::RequestProcessingPolicy::_get_value_skel},
      {"",0}, {"",0},
      {"_non_existent",  &POA_PortableServer::RequestProcessingPolicy::_non_existent_skel},
      {"",0}, {"",0},
      {"_get_policy_type",      &POA_PortableServer::RequestProcessingPolicy::_get_policy_type_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 0:12:47 */
TAO_PortableServer_RequestProcessingPolicy_Perfect_Hash_OpTable tao_PortableServer_RequestProcessingPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

// skeleton constructor
POA_PortableServer::RequestProcessingPolicy::RequestProcessingPolicy (void)
{
#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  this->optable_ = &tao_PortableServer_RequestProcessingPolicy_optable;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::RequestProcessingPolicy::_get_value_skel (
                                                                   CORBA::ServerRequest &_tao_server_request,
                                                                   void *_tao_object_reference,
                                                                   void * /* context */,
                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                   )
{
  POA_PortableServer::RequestProcessingPolicy *_tao_impl = (POA_PortableServer::RequestProcessingPolicy *)_tao_object_reference;
  PortableServer::RequestProcessingPolicyValue _tao_retval;
  _tao_retval = _tao_impl->value (
    ACE_TRY_ENV
  );
  ACE_CHECK;
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_PortableServer::RequestProcessingPolicy::_is_a_skel (
                                                              CORBA::ServerRequest &_tao_server_request,
                                                              void * _tao_object_reference,
                                                              void * /*context*/,
                                                              CORBA::Environment &ACE_TRY_ENV
                                                              )
{
  static const TAO_Param_Data_Skel PortableServer_RequestProcessingPolicy_is_a_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0},
    {CORBA::_tc_string, CORBA::ARG_IN, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_RequestProcessingPolicy_is_a_calldata =
  {"_is_a", 1, 2, PortableServer_RequestProcessingPolicy_is_a_paramdata};
  POA_PortableServer::RequestProcessingPolicy_ptr  _tao_impl = (POA_PortableServer::RequestProcessingPolicy_ptr) _tao_object_reference;
  CORBA::Boolean _tao_retval;
  CORBA::String_var _tao_value;
  _tao_server_request.demarshal (
    ACE_TRY_ENV,
    &PortableServer_RequestProcessingPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
  ACE_CHECK;
  _tao_retval = _tao_impl->_is_a (_tao_value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_RequestProcessingPolicy_is_a_calldata,
    &_tao_retval,
    &_tao_value.inout ()
  );
}

void POA_PortableServer::RequestProcessingPolicy::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request,
    void * /* _tao_object_reference */ ,
    void * /*context*/,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  static const TAO_Param_Data_Skel PortableServer_RequestProcessingPolicy_non_existent_paramdata [] =
  {
    {CORBA::_tc_boolean, 0, 0}
  };
  static const TAO_Call_Data_Skel PortableServer_RequestProcessingPolicy_non_existent_calldata =
  {"_non_existent", 1, 1, PortableServer_RequestProcessingPolicy_non_existent_paramdata};
  CORBA::Boolean _tao_retval = 0;
  _tao_server_request.marshal (
    ACE_TRY_ENV,
    &PortableServer_RequestProcessingPolicy_non_existent_calldata,
    &_tao_retval
  );
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean POA_PortableServer::RequestProcessingPolicy::_is_a (
                                                                   const char* value,
                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                   )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::RequestProcessingPolicy::_downcast (
                                                              const char* logical_type_id
                                                              )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::RequestProcessingPolicy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/Policy:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Policy_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
void POA_PortableServer::RequestProcessingPolicy::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

const char* POA_PortableServer::RequestProcessingPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0";
}

POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_tao_collocated_RequestProcessingPolicy (
                                                                                                      POA_PortableServer::RequestProcessingPolicy_ptr  servant,
                                                                                                      TAO_Stub *stub
                                                                                                      )
  : ACE_NESTED_CLASS (PortableServer, RequestProcessingPolicy) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA, _tao_collocated_Policy) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::RequestProcessingPolicy_ptr POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_RequestProcessingPolicy::_is_a (
                                                                                   const char* logical_type_id,
                                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                                   )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::Policy_ptr POA_PortableServer::_tao_collocated_RequestProcessingPolicy::copy (
                                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                                     )
{
  return this->servant_->copy (
                               ACE_TRY_ENV
                               );
}

void POA_PortableServer::_tao_collocated_RequestProcessingPolicy::destroy (
                                                                           CORBA::Environment &ACE_TRY_ENV
                                                                           )
{
  this->servant_->destroy (
                           ACE_TRY_ENV
                           );
}

CORBA::PolicyType POA_PortableServer::_tao_collocated_RequestProcessingPolicy::policy_type (
                                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                                            )
{
  return this->servant_->policy_type (ACE_TRY_ENV);
}

PortableServer::RequestProcessingPolicyValue
POA_PortableServer::_tao_collocated_RequestProcessingPolicy::value (
                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                    )
{
  return this->servant_->value(ACE_TRY_ENV);
}

PortableServer::RequestProcessingPolicy*
POA_PortableServer::RequestProcessingPolicy::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);

  PortableServer::RequestProcessingPolicy *retval = 
    PortableServer::RequestProcessingPolicy::_nil ();

  ACE_NEW_RETURN (
      retval,
      POA_PortableServer::_tao_collocated_RequestProcessingPolicy (this, 
                                                                   stub),
      PortableServer::RequestProcessingPolicy::_nil ()
    );

  return retval;
}

#endif /* TAO_HAS_MINIMUM_CORBA */

// skeleton constructor
POA_PortableServer::POAManager::POAManager (void)
{
}

CORBA::Boolean POA_PortableServer::POAManager::_is_a (
                                                      const char* value,
                                                      CORBA::Environment &ACE_TRY_ENV
                                                      )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/POAManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::POAManager::_downcast (
                                                 const char* logical_type_id
                                                 )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/POAManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::POAManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_PortableServer::POAManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/POAManager:1.0";
}

POA_PortableServer::_tao_collocated_POAManager::_tao_collocated_POAManager (
                                                                            POA_PortableServer::POAManager_ptr  servant,
                                                                            TAO_Stub *stub
                                                                            )
  : ACE_NESTED_CLASS (PortableServer, POAManager) (stub, servant, 1),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::POAManager_ptr POA_PortableServer::_tao_collocated_POAManager::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_POAManager::_is_a (
                                                                      const char* logical_type_id,
                                                                      CORBA::Environment &ACE_TRY_ENV
                                                                      )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

void POA_PortableServer::_tao_collocated_POAManager::activate (
                                                               CORBA::Environment &ACE_TRY_ENV
                                                               )
{
  this->servant_->activate (
                            ACE_TRY_ENV
                            );
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

void POA_PortableServer::_tao_collocated_POAManager::hold_requests (
                                                                    CORBA::Boolean wait_for_completion,
                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                    )
{
  this->servant_->hold_requests (
                                 wait_for_completion,
                                 ACE_TRY_ENV
                                 );
}

void POA_PortableServer::_tao_collocated_POAManager::discard_requests (
                                                                       CORBA::Boolean wait_for_completion,
                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                       )
{
  this->servant_->discard_requests (
                                    wait_for_completion,
                                    ACE_TRY_ENV
                                    );
}

void POA_PortableServer::_tao_collocated_POAManager::deactivate (
                                                                 CORBA::Boolean etherealize_objects,
                                                                 CORBA::Boolean wait_for_completion,
                                                                 CORBA::Environment &ACE_TRY_ENV
                                                                 )
{
  this->servant_->deactivate (
                              etherealize_objects,
                              wait_for_completion,
                              ACE_TRY_ENV
                              );
}

#endif /* TAO_HAS_MINIMUM_CORBA */

PortableServer::POAManager::State
POA_PortableServer::_tao_collocated_POAManager:: get_state(CORBA::Environment &ACE_TRY_ENV)
{
  return this->servant_->get_state (ACE_TRY_ENV);
}

PortableServer::POAManager*
POA_PortableServer::POAManager::_this (CORBA_Environment &)
{
  PortableServer::POAManager *retval = 
    PortableServer::POAManager::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_POAManager (this,
                                                                  0),
                  PortableServer::POAManager::_nil ());


  return retval;
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

// skeleton constructor
POA_PortableServer::AdapterActivator::AdapterActivator (void)
{
}

CORBA::Boolean POA_PortableServer::AdapterActivator::_is_a (
                                                            const char* value,
                                                            CORBA::Environment &ACE_TRY_ENV
                                                            )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/AdapterActivator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::AdapterActivator::_downcast (
                                                       const char* logical_type_id
                                                       )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/AdapterActivator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::AdapterActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_PortableServer::AdapterActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/AdapterActivator:1.0";
}

POA_PortableServer::_tao_collocated_AdapterActivator::_tao_collocated_AdapterActivator (
                                                                                        POA_PortableServer::AdapterActivator_ptr  servant,
                                                                                        TAO_Stub *stub
                                                                                        )
  : ACE_NESTED_CLASS (PortableServer, AdapterActivator) (stub, servant, 1),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::AdapterActivator_ptr POA_PortableServer::_tao_collocated_AdapterActivator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_AdapterActivator::_is_a (
                                                                            const char* logical_type_id,
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

CORBA::Boolean POA_PortableServer::_tao_collocated_AdapterActivator::unknown_adapter (
                                                                                      PortableServer::POA_ptr  parent,
                                                                                      const char* name,
                                                                                      CORBA::Environment &ACE_TRY_ENV
                                                                                      )
{
  return this->servant_->unknown_adapter (
                                          parent,
                                          name,
                                          ACE_TRY_ENV
                                          );
}


PortableServer::AdapterActivator*
POA_PortableServer::AdapterActivator::_this (CORBA_Environment &)
{
  PortableServer::AdapterActivator *retval = 
    PortableServer::AdapterActivator::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_AdapterActivator (this,
                                                                        0),
                  PortableServer::AdapterActivator::_nil ());


  return retval;
}

// skeleton constructor
POA_PortableServer::ServantManager::ServantManager (void)
{
}

CORBA::Boolean POA_PortableServer::ServantManager::_is_a (
                                                          const char* value,
                                                          CORBA::Environment &ACE_TRY_ENV
                                                          )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ServantManager::_downcast (
                                                     const char* logical_type_id
                                                     )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_PortableServer::ServantManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantManager:1.0";
}

POA_PortableServer::_tao_collocated_ServantManager::_tao_collocated_ServantManager (
                                                                                    POA_PortableServer::ServantManager_ptr  servant,
                                                                                    TAO_Stub *stub
                                                                                    )
  : ACE_NESTED_CLASS (PortableServer, ServantManager) (stub, servant, 1),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ServantManager_ptr POA_PortableServer::_tao_collocated_ServantManager::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantManager::_is_a (
                                                                          const char* logical_type_id,
                                                                          CORBA::Environment &ACE_TRY_ENV
                                                                          )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}


PortableServer::ServantManager*
POA_PortableServer::ServantManager::_this (CORBA_Environment &)
{
  PortableServer::ServantManager *retval = 
    PortableServer::ServantManager::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_ServantManager (this,
                                                                      0),
                  PortableServer::ServantManager::_nil ());


  return retval;
}

// skeleton constructor
POA_PortableServer::ServantActivator::ServantActivator (void)
{
}

CORBA::Boolean POA_PortableServer::ServantActivator::_is_a (
                                                            const char* value,
                                                            CORBA::Environment &ACE_TRY_ENV
                                                            )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantActivator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ServantActivator::_downcast (
                                                       const char* logical_type_id
                                                       )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/ServantActivator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantActivator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_PortableServer::ServantActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantActivator:1.0";
}

POA_PortableServer::_tao_collocated_ServantActivator::_tao_collocated_ServantActivator (
                                                                                        POA_PortableServer::ServantActivator_ptr  servant,
                                                                                        TAO_Stub *stub
                                                                                        )
  : ACE_NESTED_CLASS (PortableServer, ServantActivator) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_PortableServer, _tao_collocated_ServantManager) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ServantActivator_ptr POA_PortableServer::_tao_collocated_ServantActivator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantActivator::_is_a (
                                                                            const char* logical_type_id,
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_ServantActivator::incarnate (
                                                                                         const PortableServer::ObjectId & oid,
                                                                                         PortableServer::POA_ptr  adapter,
                                                                                         CORBA::Environment &ACE_TRY_ENV
                                                                                         )
{
  return this->servant_->incarnate (
                                    oid,
                                    adapter,
                                    ACE_TRY_ENV
                                    );
}

void POA_PortableServer::_tao_collocated_ServantActivator::etherealize (
                                                                        const PortableServer::ObjectId & oid,
                                                                        PortableServer::POA_ptr  adapter,
                                                                        PortableServer::Servant serv,
                                                                        CORBA::Boolean cleanup_in_progress,
                                                                        CORBA::Boolean remaining_activations,
                                                                        CORBA::Environment &ACE_TRY_ENV
                                                                        )
{
  this->servant_->etherealize (
                               oid,
                               adapter,
                               serv,
                               cleanup_in_progress,
                               remaining_activations,
                               ACE_TRY_ENV
                               );
}


PortableServer::ServantActivator*
POA_PortableServer::ServantActivator::_this (CORBA_Environment &)
{
  PortableServer::ServantActivator *retval = 
    PortableServer::ServantActivator::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_ServantActivator (this,
                                                                        0),
                  PortableServer::ServantActivator::_nil ());


  return retval;
}

// skeleton constructor
POA_PortableServer::ServantLocator::ServantLocator (void)
{
}

CORBA::Boolean POA_PortableServer::ServantLocator::_is_a (
                                                          const char* value,
                                                          CORBA::Environment &ACE_TRY_ENV
                                                          )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantLocator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::ServantLocator::_downcast (
                                                     const char* logical_type_id
                                                     )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/ServantLocator:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantLocator_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/ServantManager:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::ServantManager_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_PortableServer::ServantLocator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantLocator:1.0";
}

POA_PortableServer::_tao_collocated_ServantLocator::_tao_collocated_ServantLocator (
                                                                                    POA_PortableServer::ServantLocator_ptr  servant,
                                                                                    TAO_Stub *stub
                                                                                    )
  : ACE_NESTED_CLASS (PortableServer, ServantLocator) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_PortableServer, _tao_collocated_ServantManager) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::ServantLocator_ptr POA_PortableServer::_tao_collocated_ServantLocator::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_ServantLocator::_is_a (
                                                                          const char* logical_type_id,
                                                                          CORBA::Environment &ACE_TRY_ENV
                                                                          )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_ServantLocator::preinvoke (
                                                                                       const PortableServer::ObjectId & oid,
                                                                                       PortableServer::POA_ptr  adapter,
                                                                                       const char * operation,
                                                                                       PortableServer::ServantLocator::Cookie & the_cookie,
                                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                                       )
{
  return this->servant_->preinvoke (
                                    oid,
                                    adapter,
                                    operation,
                                    the_cookie,
                                    ACE_TRY_ENV
                                    );
}

void POA_PortableServer::_tao_collocated_ServantLocator::postinvoke (
                                                                     const PortableServer::ObjectId & oid,
                                                                     PortableServer::POA_ptr  adapter,
                                                                     const char * operation,
                                                                     PortableServer::ServantLocator::Cookie the_cookie,
                                                                     PortableServer::Servant the_servant,
                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                     )
{
  this->servant_->postinvoke (
                              oid,
                              adapter,
                              operation,
                              the_cookie,
                              the_servant,
                              ACE_TRY_ENV
                              );
}


PortableServer::ServantLocator*
POA_PortableServer::ServantLocator::_this (CORBA_Environment &)
{
  PortableServer::ServantLocator *retval = 
    PortableServer::ServantLocator::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_ServantLocator (this,
                                                                      0),
                  PortableServer::ServantLocator::_nil ());


  return retval;
}

#endif /* TAO_HAS_MINIMUM_CORBA */

// skeleton constructor
POA_PortableServer::POA::POA (void)
{
}

CORBA::Boolean POA_PortableServer::POA::_is_a (
                                               const char* value,
                                               CORBA::Environment &ACE_TRY_ENV
                                               )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/POA:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::POA::_downcast (
                                          const char* logical_type_id
                                          )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/POA:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::POA_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_PortableServer::POA::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/POA:1.0";
}

POA_PortableServer::_tao_collocated_POA::_tao_collocated_POA (
                                                              POA_PortableServer::POA_ptr  servant,
                                                              TAO_Stub *stub
                                                              )
  : ACE_NESTED_CLASS (PortableServer, POA) (stub, servant, 1),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_POA::_is_a (
                                                               const char* logical_type_id,
                                                               CORBA::Environment &ACE_TRY_ENV
                                                               )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::create_POA (
                                                                             const char* adapter_name,
                                                                             PortableServer::POAManager_ptr  a_POAManager,
                                                                             const CORBA::PolicyList & policies,
                                                                             CORBA::Environment &ACE_TRY_ENV
                                                                             )
{
  return this->servant_->create_POA (
                                     adapter_name,
                                     a_POAManager,
                                     policies,
                                     ACE_TRY_ENV
                                     );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_POA::find_POA (
                                                                           const char* adapter_name,
                                                                           CORBA::Boolean activate_it,
                                                                           CORBA::Environment &ACE_TRY_ENV
                                                                           )
{
  return this->servant_->find_POA (
                                   adapter_name,
                                   activate_it,
                                   ACE_TRY_ENV
                                   );
}

void POA_PortableServer::_tao_collocated_POA::destroy (
                                                       CORBA::Boolean etherealize_objects,
                                                       CORBA::Boolean wait_for_completion,
                                                       CORBA::Environment &ACE_TRY_ENV
                                                       )
{
  this->servant_->destroy (
                           etherealize_objects,
                           wait_for_completion,
                           ACE_TRY_ENV
                           );
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

PortableServer::ThreadPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_thread_policy (
                                                                                                PortableServer::ThreadPolicyValue value,
                                                                                                CORBA::Environment &ACE_TRY_ENV
                                                                                                )
{
  return this->servant_->create_thread_policy (
                                               value,
                                               ACE_TRY_ENV
                                               );
}

#endif /* TAO_HAS_MINIMUM_CORBA */

PortableServer::LifespanPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_lifespan_policy (
                                                                                                    PortableServer::LifespanPolicyValue value,
                                                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                                                    )
{
  return this->servant_->create_lifespan_policy (
                                                 value,
                                                 ACE_TRY_ENV
                                                 );
}

PortableServer::IdUniquenessPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_id_uniqueness_policy (
                                                                                                             PortableServer::IdUniquenessPolicyValue value,
                                                                                                             CORBA::Environment &ACE_TRY_ENV
                                                                                                             )
{
  return this->servant_->create_id_uniqueness_policy (
                                                      value,
                                                      ACE_TRY_ENV
                                                      );
}

PortableServer::IdAssignmentPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_id_assignment_policy (
                                                                                                             PortableServer::IdAssignmentPolicyValue value,
                                                                                                             CORBA::Environment &ACE_TRY_ENV
                                                                                                             )
{
  return this->servant_->create_id_assignment_policy (
                                                      value,
                                                      ACE_TRY_ENV
                                                      );
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

PortableServer::ImplicitActivationPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_implicit_activation_policy (
                                                                                                                         PortableServer::ImplicitActivationPolicyValue value,
                                                                                                                         CORBA::Environment &ACE_TRY_ENV
                                                                                                                         )
{
  return this->servant_->create_implicit_activation_policy (
                                                            value,
                                                            ACE_TRY_ENV
                                                            );
}

PortableServer::ServantRetentionPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_servant_retention_policy (
                                                                                                                     PortableServer::ServantRetentionPolicyValue value,
                                                                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                                                                     )
{
  return this->servant_->create_servant_retention_policy (
                                                          value,
                                                          ACE_TRY_ENV
                                                          );
}

PortableServer::RequestProcessingPolicy_ptr POA_PortableServer::_tao_collocated_POA::create_request_processing_policy (
                                                                                                                       PortableServer::RequestProcessingPolicyValue value,
                                                                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                                                                       )
{
  return this->servant_->create_request_processing_policy (
                                                           value,
                                                           ACE_TRY_ENV
                                                           );
}

#endif /* TAO_HAS_MINIMUM_CORBA */

char*
POA_PortableServer::_tao_collocated_POA::the_name (
                                                   CORBA::Environment &ACE_TRY_ENV
                                                   )
{
  return this->servant_->the_name(ACE_TRY_ENV);
}
PortableServer::POA_ptr
POA_PortableServer::_tao_collocated_POA::the_parent (
                                                     CORBA::Environment &ACE_TRY_ENV
                                                     )
{
  return this->servant_->the_parent(ACE_TRY_ENV);
}
PortableServer::POAManager_ptr
POA_PortableServer::_tao_collocated_POA::the_POAManager (
                                                         CORBA::Environment &ACE_TRY_ENV
                                                         )
{
  return this->servant_->the_POAManager(ACE_TRY_ENV);
}

#if !defined (TAO_HAS_MINIMUM_CORBA)

PortableServer::AdapterActivator_ptr
POA_PortableServer::_tao_collocated_POA::the_activator (
                                                        CORBA::Environment &ACE_TRY_ENV
                                                        )
{
  return this->servant_->the_activator(ACE_TRY_ENV);
}

void POA_PortableServer::_tao_collocated_POA::the_activator (
                                                             PortableServer::AdapterActivator_ptr _tao_value,
                                                             CORBA::Environment &ACE_TRY_ENV
                                                             )
{
  this->servant_->the_activator (
                                 _tao_value,
                                 ACE_TRY_ENV
                                 );
}

PortableServer::ServantManager_ptr POA_PortableServer::_tao_collocated_POA::get_servant_manager (
                                                                                                 CORBA::Environment &ACE_TRY_ENV
                                                                                                 )
{
  return this->servant_->get_servant_manager (
                                              ACE_TRY_ENV
                                              );
}

void POA_PortableServer::_tao_collocated_POA::set_servant_manager (
                                                                   PortableServer::ServantManager_ptr  imgr,
                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                   )
{
  this->servant_->set_servant_manager (
                                       imgr,
                                       ACE_TRY_ENV
                                       );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::get_servant (
                                                                              CORBA::Environment &ACE_TRY_ENV
                                                                              )
{
  return this->servant_->get_servant (
                                      ACE_TRY_ENV
                                      );
}

void POA_PortableServer::_tao_collocated_POA::set_servant (
                                                           PortableServer::Servant p_servant,
                                                           CORBA::Environment &ACE_TRY_ENV
                                                           )
{
  this->servant_->set_servant (
                               p_servant,
                               ACE_TRY_ENV
                               );
}

#endif /* TAO_HAS_MINIMUM_CORBA */

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::activate_object (
                                                                                     PortableServer::Servant p_servant,
                                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                                     )
{
  return this->servant_->activate_object (
                                          p_servant,
                                          ACE_TRY_ENV
                                          );
}

void POA_PortableServer::_tao_collocated_POA::activate_object_with_id (
                                                                       const PortableServer::ObjectId & id,
                                                                       PortableServer::Servant p_servant,
                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                       )
{
  this->servant_->activate_object_with_id (
                                           id,
                                           p_servant,
                                           ACE_TRY_ENV
                                           );
}

void POA_PortableServer::_tao_collocated_POA::deactivate_object (
                                                                 const PortableServer::ObjectId & oid,
                                                                 CORBA::Environment &ACE_TRY_ENV
                                                                 )
{
  this->servant_->deactivate_object (
                                     oid,
                                     ACE_TRY_ENV
                                     );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::create_reference (
                                                                             const char *intf,
                                                                             CORBA::Environment &ACE_TRY_ENV
                                                                             )
{
  return this->servant_->create_reference (
                                           intf,
                                           ACE_TRY_ENV
                                           );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::create_reference_with_id (
                                                                                     const PortableServer::ObjectId & oid,
                                                                                     const char *intf,
                                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                                     )
{
  return this->servant_->create_reference_with_id (
                                                   oid,
                                                   intf,
                                                   ACE_TRY_ENV
                                                   );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::servant_to_id (
                                                                                   PortableServer::Servant p_servant,
                                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                                   )
{
  return this->servant_->servant_to_id (
                                        p_servant,
                                        ACE_TRY_ENV
                                        );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::servant_to_reference (
                                                                                 PortableServer::Servant p_servant,
                                                                                 CORBA::Environment &ACE_TRY_ENV
                                                                                 )
{
  return this->servant_->servant_to_reference (
                                               p_servant,
                                               ACE_TRY_ENV
                                               );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::reference_to_servant (
                                                                                       CORBA::Object_ptr  reference,
                                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                                       )
{
  return this->servant_->reference_to_servant (
                                               reference,
                                               ACE_TRY_ENV
                                               );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_POA::reference_to_id (
                                                                                     CORBA::Object_ptr  reference,
                                                                                     CORBA::Environment &ACE_TRY_ENV
                                                                                     )
{
  return this->servant_->reference_to_id (
                                          reference,
                                          ACE_TRY_ENV
                                          );
}

PortableServer::Servant POA_PortableServer::_tao_collocated_POA::id_to_servant (
                                                                                const PortableServer::ObjectId & oid,
                                                                                CORBA::Environment &ACE_TRY_ENV
                                                                                )
{
  return this->servant_->id_to_servant (
                                        oid,
                                        ACE_TRY_ENV
                                        );
}

CORBA::Object_ptr POA_PortableServer::_tao_collocated_POA::id_to_reference (
                                                                            const PortableServer::ObjectId & oid,
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  return this->servant_->id_to_reference (
                                          oid,
                                          ACE_TRY_ENV
                                          );
}


PortableServer::POA*
POA_PortableServer::POA::_this (CORBA_Environment &)
{
  PortableServer::POA *retval = 
    PortableServer::POA::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_POA (this,
                                                           0),
                  PortableServer::POA::_nil ());


  return retval;
}

// skeleton constructor
POA_PortableServer::Current::Current (void)
{
}

CORBA::Boolean POA_PortableServer::Current::_is_a (
                                                   const char* value,
                                                   CORBA::Environment &ACE_TRY_ENV
                                                   )
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Current:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Current:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
    return 1;
  else
    return 0;
}

void* POA_PortableServer::Current::_downcast (
                                              const char* logical_type_id
                                              )
{
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/PortableServer/Current:1.0") == 0)
    return ACE_static_cast (POA_PortableServer::Current_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Current:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Current_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

const char* POA_PortableServer::Current::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/Current:1.0";
}

POA_PortableServer::_tao_collocated_Current::_tao_collocated_Current (
                                                                      POA_PortableServer::Current_ptr  servant,
                                                                      TAO_Stub *stub
                                                                      )
  : ACE_NESTED_CLASS (PortableServer, Current) (stub, servant, 1),
    ACE_NESTED_CLASS (POA_CORBA,_tao_collocated_Current) (servant, stub),
    CORBA_Object (stub, servant, 1),
    servant_ (servant)
{
}

POA_PortableServer::Current_ptr POA_PortableServer::_tao_collocated_Current::_get_servant (void) const
{
  return this->servant_;
}

CORBA::Boolean POA_PortableServer::_tao_collocated_Current::_is_a (
                                                                   const char* logical_type_id,
                                                                   CORBA::Environment &ACE_TRY_ENV
                                                                   )
{
  return this->servant_->_is_a (
                                logical_type_id,
                                ACE_TRY_ENV
                                );
}

PortableServer::POA_ptr POA_PortableServer::_tao_collocated_Current::get_POA (
                                                                              CORBA::Environment &ACE_TRY_ENV
                                                                              )
{
  return this->servant_->get_POA (
                                  ACE_TRY_ENV
                                  );
}

PortableServer::ObjectId * POA_PortableServer::_tao_collocated_Current::get_object_id (
                                                                                       CORBA::Environment &ACE_TRY_ENV
                                                                                       )
{
  return this->servant_->get_object_id (
                                        ACE_TRY_ENV
                                        );
}


PortableServer::Current*
POA_PortableServer::Current::_this (CORBA_Environment &)
{
  PortableServer::Current *retval = 
    PortableServer::Current::_nil ();

  ACE_NEW_RETURN (retval,
                  POA_PortableServer::_tao_collocated_Current (this,
                                                               0),
                  PortableServer::Current::_nil ());


  return retval;
}
