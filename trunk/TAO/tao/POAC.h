// $Id$
//
// ============================================================================
//
// = LIBRARY
//    TAO
//
// = FILENAME
//    POAC.h
//
// = DESCRIPTION
//
//    POA stubs. This code generated by the The ACE ORB (TAO) IDL
//    Compiler and is not meant to be read.
//
// ============================================================================

#ifndef TAO_IDL_POAC_H
#define TAO_IDL_POAC_H
#include "ace/pre.h"

#include "tao/PolicyC.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "tao/CurrentC.h"
#include "tao/Exception.h"
#include "tao/Environment.h"
#include "tao/CDR.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export
#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

class TAO_ServantBase;
class TAO_ServantBase_var;
class TAO_RefCountServantBase;
class TAO_Local_ServantBase;
class TAO_Locality_Constrained_ServantBase;
class TAO_DynamicImplementation;

TAO_NAMESPACE PortableServer{

  typedef TAO_ServantBase ServantBase;
  typedef TAO_ServantBase_var ServantBase_var;
  typedef TAO_RefCountServantBase RefCountServantBase;
  typedef ServantBase *Servant;

  typedef TAO_Local_ServantBase LocalServantBase;
  typedef TAO_Locality_Constrained_ServantBase LocalityConstrainedServantBase;
  typedef TAO_DynamicImplementation DynamicImplementation;


  class POA;

#if !defined (_PORTABLESERVER_POA___PTR_CH_)
#define _PORTABLESERVER_POA___PTR_CH_

  typedef POA *POA_ptr;

#endif /* end #if !defined */


#if !defined (_PORTABLESERVER_POA___VAR_CH_)
#define _PORTABLESERVER_POA___VAR_CH_

  class TAO_Export POA_var : public TAO_Base_var
  {
  public:
    POA_var (void); // default constructor
    POA_var (POA_ptr);
    POA_var (const POA_var &); // copy constructor
    ~POA_var (void); // destructor

    POA_var &operator= (POA_ptr);
    POA_var &operator= (const POA_var &);
    POA_ptr operator-> (void) const;

    operator const POA_ptr &() const;
    operator POA_ptr &();
    // in, inout, out, _retn
    POA_ptr in (void) const;
    POA_ptr &inout (void);
    POA_ptr &out (void);
    POA_ptr _retn (void);
    POA_ptr ptr (void) const;

  private:
    POA_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    POA_var (const TAO_Base_var &rhs);
    POA_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA___OUT_CH_)
#define _PORTABLESERVER_POA___OUT_CH_

  class TAO_Export POA_out
  {
  public:
    POA_out (POA_ptr &);
    POA_out (POA_var &);
    POA_out (const POA_out &);
    POA_out &operator= (POA_out &);
    POA_out &operator= (const POA_var &);
    POA_out &operator= (POA_ptr);
    operator POA_ptr &();
    POA_ptr &ptr (void);
    POA_ptr operator-> (void);

  private:
    POA_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER__TAO_SEQ_OCTET_CH_)
#define _PORTABLESERVER__TAO_SEQ_OCTET_CH_

  // *************************************************************
  // _tao_seq_Octet
  // *************************************************************

  typedef TAO_Unbounded_Sequence<CORBA::Octet > _tao_seq_Octet;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc__tao_seq_Octet;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER__TAO_SEQ_OCTET___VAR_CH_)
#define _PORTABLESERVER__TAO_SEQ_OCTET___VAR_CH_

  // *************************************************************
  // class PortableServer::_tao_seq_Octet_var
  // *************************************************************

  class TAO_Export _tao_seq_Octet_var
  {
  public:
    _tao_seq_Octet_var (void); // default constructor
    _tao_seq_Octet_var (_tao_seq_Octet *);
    _tao_seq_Octet_var (const _tao_seq_Octet_var &); // copy constructor
    ~_tao_seq_Octet_var (void); // destructor

    _tao_seq_Octet_var &operator= (_tao_seq_Octet *);
    _tao_seq_Octet_var &operator= (const _tao_seq_Octet_var &);
    _tao_seq_Octet *operator-> (void);
    const _tao_seq_Octet *operator-> (void) const;

    operator const _tao_seq_Octet &() const;
    operator _tao_seq_Octet &();
    operator _tao_seq_Octet &() const;
    CORBA::Octet &operator[] (CORBA::ULong slot);
    // in, inout, out, _retn
    const _tao_seq_Octet &in (void) const;
    _tao_seq_Octet &inout (void);
    _tao_seq_Octet *&out (void);
    _tao_seq_Octet *_retn (void);
    _tao_seq_Octet *ptr (void) const;

  private:
    _tao_seq_Octet *ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER__TAO_SEQ_OCTET___OUT_CH_)
#define _PORTABLESERVER__TAO_SEQ_OCTET___OUT_CH_

  class TAO_Export _tao_seq_Octet_out
  {
  public:
    _tao_seq_Octet_out (_tao_seq_Octet *&);
    _tao_seq_Octet_out (_tao_seq_Octet_var &);
    _tao_seq_Octet_out (const _tao_seq_Octet_out &);
    _tao_seq_Octet_out &operator= (_tao_seq_Octet_out &);
    _tao_seq_Octet_out &operator= (_tao_seq_Octet *);
    operator _tao_seq_Octet *&();
    _tao_seq_Octet *&ptr (void);
    _tao_seq_Octet *operator-> (void);
    CORBA::Octet &operator[] (CORBA::ULong slot);

  private:
    _tao_seq_Octet *&ptr_;
    // assignment from T_var not allowed
    void operator= (const _tao_seq_Octet_var &);
  };

#endif /* end #if !defined */

  typedef _tao_seq_Octet ObjectId;
  typedef _tao_seq_Octet_var ObjectId_var;
  typedef _tao_seq_Octet_out ObjectId_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ObjectId;

#if (TAO_HAS_MINIMUM_CORBA == 0)

#if !defined (_PORTABLESERVER_FORWARDREQUEST_CH_)
#define _PORTABLESERVER_FORWARDREQUEST_CH_

  class TAO_Export ForwardRequest : public CORBA_UserException
  {
  public:
    ForwardRequest (void); // default ctor
    ForwardRequest (const ForwardRequest &); // copy ctor
    ~ForwardRequest (void); // dtor
    ForwardRequest &operator= (const ForwardRequest &);

    virtual void _raise (void);

    virtual void _tao_encode (TAO_OutputCDR &cdr,
                              CORBA::Environment &) const;
    virtual void _tao_decode (TAO_InputCDR &cdr,
                              CORBA::Environment &);

    static ForwardRequest *_downcast (CORBA::Exception *);
    static void _tao_any_destructor (void*);

    ForwardRequest(
        const CORBA::Object_ptr  _tao_forward_reference
      );

    CORBA::Object_var forward_reference;

    // = TAO extension
    static CORBA::Exception *_alloc (void);

  }; // exception PortableServer::ForwardRequest

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ForwardRequest;


#endif /* end #if !defined */

#endif /* TAO_HAS_MINIMUM_CORBA */

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong THREAD_POLICY_ID;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong LIFESPAN_POLICY_ID;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong ID_UNIQUENESS_POLICY_ID;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong ID_ASSIGNMENT_POLICY_ID;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong IMPLICIT_ACTIVATION_POLICY_ID;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong SERVANT_RETENTION_POLICY_ID;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong REQUEST_PROCESSING_POLICY_ID;

  enum ThreadPolicyValue
  {
    ORB_CTRL_MODEL,
    SINGLE_THREAD_MODEL
  };

#if (TAO_HAS_MINIMUM_POA == 0)

  typedef ThreadPolicyValue &ThreadPolicyValue_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ThreadPolicyValue;


#if !defined (_PORTABLESERVER_THREADPOLICY___PTR_CH_)
#define _PORTABLESERVER_THREADPOLICY___PTR_CH_

  class ThreadPolicy;
  typedef ThreadPolicy *ThreadPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_THREADPOLICY___VAR_CH_)
#define _PORTABLESERVER_THREADPOLICY___VAR_CH_

  class TAO_Export ThreadPolicy_var : public TAO_Base_var
  {
  public:
    ThreadPolicy_var (void); // default constructor
    ThreadPolicy_var (ThreadPolicy_ptr);
    ThreadPolicy_var (const ThreadPolicy_var &); // copy constructor
    ~ThreadPolicy_var (void); // destructor

    ThreadPolicy_var &operator= (ThreadPolicy_ptr);
    ThreadPolicy_var &operator= (const ThreadPolicy_var &);
    ThreadPolicy_ptr operator-> (void) const;

    operator const ThreadPolicy_ptr &() const;
    operator ThreadPolicy_ptr &();
    // in, inout, out, _retn
    ThreadPolicy_ptr in (void) const;
    ThreadPolicy_ptr &inout (void);
    ThreadPolicy_ptr &out (void);
    ThreadPolicy_ptr _retn (void);
    ThreadPolicy_ptr ptr (void) const;

  private:
    ThreadPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ThreadPolicy_var (const TAO_Base_var &rhs);
    ThreadPolicy_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_THREADPOLICY___OUT_CH_)
#define _PORTABLESERVER_THREADPOLICY___OUT_CH_

  class TAO_Export ThreadPolicy_out
  {
  public:
    ThreadPolicy_out (ThreadPolicy_ptr &);
    ThreadPolicy_out (ThreadPolicy_var &);
    ThreadPolicy_out (const ThreadPolicy_out &);
    ThreadPolicy_out &operator= (ThreadPolicy_out &);
    ThreadPolicy_out &operator= (const ThreadPolicy_var &);
    ThreadPolicy_out &operator= (ThreadPolicy_ptr);
    operator ThreadPolicy_ptr &();
    ThreadPolicy_ptr &ptr (void);
    ThreadPolicy_ptr operator-> (void);

  private:
    ThreadPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_THREADPOLICY_CH_)
#define _PORTABLESERVER_THREADPOLICY_CH_

  class TAO_Export ThreadPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ThreadPolicy_ptr _ptr_type;
    typedef ThreadPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ThreadPolicy_ptr _duplicate (ThreadPolicy_ptr obj);
    static ThreadPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static ThreadPolicy_ptr _nil (void);
    static void _tao_any_destructor (void*);

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
    virtual ThreadPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
#else
    virtual ThreadPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    ThreadPolicy (TAO_Stub *objref = 0,
                  TAO_ServantBase *servant = 0,
                  CORBA::Boolean collocated = 0);
  public:
    virtual ~ThreadPolicy (void);
  private:
    ThreadPolicy (const ThreadPolicy&);
    void operator= (const ThreadPolicy&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ThreadPolicy;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

  enum LifespanPolicyValue
  {
    TRANSIENT,
    PERSISTENT
  };
  typedef LifespanPolicyValue &LifespanPolicyValue_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_LifespanPolicyValue;


#if !defined (_PORTABLESERVER_LIFESPANPOLICY___PTR_CH_)
#define _PORTABLESERVER_LIFESPANPOLICY___PTR_CH_

  class LifespanPolicy;
  typedef LifespanPolicy *LifespanPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_LIFESPANPOLICY___VAR_CH_)
#define _PORTABLESERVER_LIFESPANPOLICY___VAR_CH_

  class TAO_Export LifespanPolicy_var : public TAO_Base_var
  {
  public:
    LifespanPolicy_var (void); // default constructor
    LifespanPolicy_var (LifespanPolicy_ptr);
    LifespanPolicy_var (const LifespanPolicy_var &); // copy constructor
    ~LifespanPolicy_var (void); // destructor

    LifespanPolicy_var &operator= (LifespanPolicy_ptr);
    LifespanPolicy_var &operator= (const LifespanPolicy_var &);
    LifespanPolicy_ptr operator-> (void) const;

    operator const LifespanPolicy_ptr &() const;
    operator LifespanPolicy_ptr &();
    // in, inout, out, _retn
    LifespanPolicy_ptr in (void) const;
    LifespanPolicy_ptr &inout (void);
    LifespanPolicy_ptr &out (void);
    LifespanPolicy_ptr _retn (void);
    LifespanPolicy_ptr ptr (void) const;

  private:
    LifespanPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    LifespanPolicy_var (const TAO_Base_var &rhs);
    LifespanPolicy_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_LIFESPANPOLICY___OUT_CH_)
#define _PORTABLESERVER_LIFESPANPOLICY___OUT_CH_

  class TAO_Export LifespanPolicy_out
  {
  public:
    LifespanPolicy_out (LifespanPolicy_ptr &);
    LifespanPolicy_out (LifespanPolicy_var &);
    LifespanPolicy_out (const LifespanPolicy_out &);
    LifespanPolicy_out &operator= (LifespanPolicy_out &);
    LifespanPolicy_out &operator= (const LifespanPolicy_var &);
    LifespanPolicy_out &operator= (LifespanPolicy_ptr);
    operator LifespanPolicy_ptr &();
    LifespanPolicy_ptr &ptr (void);
    LifespanPolicy_ptr operator-> (void);

  private:
    LifespanPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_LIFESPANPOLICY_CH_)
#define _PORTABLESERVER_LIFESPANPOLICY_CH_

  class TAO_Export LifespanPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef LifespanPolicy_ptr _ptr_type;
    typedef LifespanPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static LifespanPolicy_ptr _duplicate (LifespanPolicy_ptr obj);
    static LifespanPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static LifespanPolicy_ptr _nil (void);
    static void _tao_any_destructor (void*);

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
    virtual LifespanPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
#else
    virtual LifespanPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    LifespanPolicy (
                    TAO_Stub *objref = 0,
                    TAO_ServantBase *servant = 0,
                    CORBA::Boolean collocated = 0
                    );
  public:
    virtual ~LifespanPolicy (void);
  private:
    LifespanPolicy (const LifespanPolicy&);
    void operator= (const LifespanPolicy&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_LifespanPolicy;

  enum IdUniquenessPolicyValue
  {
    UNIQUE_ID,
    MULTIPLE_ID
  };
  typedef IdUniquenessPolicyValue &IdUniquenessPolicyValue_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_IdUniquenessPolicyValue;


#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY___PTR_CH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY___PTR_CH_

  class IdUniquenessPolicy;
  typedef IdUniquenessPolicy *IdUniquenessPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY___VAR_CH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY___VAR_CH_

  class TAO_Export IdUniquenessPolicy_var : public TAO_Base_var
  {
  public:
    IdUniquenessPolicy_var (void); // default constructor
    IdUniquenessPolicy_var (IdUniquenessPolicy_ptr);
    IdUniquenessPolicy_var (const IdUniquenessPolicy_var &); // copy constructor
    ~IdUniquenessPolicy_var (void); // destructor

    IdUniquenessPolicy_var &operator= (IdUniquenessPolicy_ptr);
    IdUniquenessPolicy_var &operator= (const IdUniquenessPolicy_var &);
    IdUniquenessPolicy_ptr operator-> (void) const;

    operator const IdUniquenessPolicy_ptr &() const;
    operator IdUniquenessPolicy_ptr &();
    // in, inout, out, _retn
    IdUniquenessPolicy_ptr in (void) const;
    IdUniquenessPolicy_ptr &inout (void);
    IdUniquenessPolicy_ptr &out (void);
    IdUniquenessPolicy_ptr _retn (void);
    IdUniquenessPolicy_ptr ptr (void) const;

  private:
    IdUniquenessPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    IdUniquenessPolicy_var (const TAO_Base_var &rhs);
    IdUniquenessPolicy_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY___OUT_CH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY___OUT_CH_

  class TAO_Export IdUniquenessPolicy_out
  {
  public:
    IdUniquenessPolicy_out (IdUniquenessPolicy_ptr &);
    IdUniquenessPolicy_out (IdUniquenessPolicy_var &);
    IdUniquenessPolicy_out (const IdUniquenessPolicy_out &);
    IdUniquenessPolicy_out &operator= (IdUniquenessPolicy_out &);
    IdUniquenessPolicy_out &operator= (const IdUniquenessPolicy_var &);
    IdUniquenessPolicy_out &operator= (IdUniquenessPolicy_ptr);
    operator IdUniquenessPolicy_ptr &();
    IdUniquenessPolicy_ptr &ptr (void);
    IdUniquenessPolicy_ptr operator-> (void);

  private:
    IdUniquenessPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDUNIQUENESSPOLICY_CH_)
#define _PORTABLESERVER_IDUNIQUENESSPOLICY_CH_

  class TAO_Export IdUniquenessPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef IdUniquenessPolicy_ptr _ptr_type;
    typedef IdUniquenessPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static IdUniquenessPolicy_ptr _duplicate (IdUniquenessPolicy_ptr obj);
    static IdUniquenessPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static IdUniquenessPolicy_ptr _nil (void);
    static void _tao_any_destructor (void*);

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
    virtual IdUniquenessPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
#else
    virtual IdUniquenessPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    IdUniquenessPolicy (
                        TAO_Stub *objref = 0,
                        TAO_ServantBase *servant = 0,
                        CORBA::Boolean collocated = 0
                        );
  public:
    virtual ~IdUniquenessPolicy (void);
  private:
    IdUniquenessPolicy (const IdUniquenessPolicy&);
    void operator= (const IdUniquenessPolicy&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_IdUniquenessPolicy;

  enum IdAssignmentPolicyValue
  {
    USER_ID,
    SYSTEM_ID
  };
  typedef IdAssignmentPolicyValue &IdAssignmentPolicyValue_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_IdAssignmentPolicyValue;


#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY___PTR_CH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY___PTR_CH_

  class IdAssignmentPolicy;
  typedef IdAssignmentPolicy *IdAssignmentPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY___VAR_CH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY___VAR_CH_

  class TAO_Export IdAssignmentPolicy_var : public TAO_Base_var
  {
  public:
    IdAssignmentPolicy_var (void); // default constructor
    IdAssignmentPolicy_var (IdAssignmentPolicy_ptr);
    IdAssignmentPolicy_var (const IdAssignmentPolicy_var &); // copy constructor
    ~IdAssignmentPolicy_var (void); // destructor

    IdAssignmentPolicy_var &operator= (IdAssignmentPolicy_ptr);
    IdAssignmentPolicy_var &operator= (const IdAssignmentPolicy_var &);
    IdAssignmentPolicy_ptr operator-> (void) const;

    operator const IdAssignmentPolicy_ptr &() const;
    operator IdAssignmentPolicy_ptr &();
    // in, inout, out, _retn
    IdAssignmentPolicy_ptr in (void) const;
    IdAssignmentPolicy_ptr &inout (void);
    IdAssignmentPolicy_ptr &out (void);
    IdAssignmentPolicy_ptr _retn (void);
    IdAssignmentPolicy_ptr ptr (void) const;

  private:
    IdAssignmentPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    IdAssignmentPolicy_var (const TAO_Base_var &rhs);
    IdAssignmentPolicy_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY___OUT_CH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY___OUT_CH_

  class TAO_Export IdAssignmentPolicy_out
  {
  public:
    IdAssignmentPolicy_out (IdAssignmentPolicy_ptr &);
    IdAssignmentPolicy_out (IdAssignmentPolicy_var &);
    IdAssignmentPolicy_out (const IdAssignmentPolicy_out &);
    IdAssignmentPolicy_out &operator= (IdAssignmentPolicy_out &);
    IdAssignmentPolicy_out &operator= (const IdAssignmentPolicy_var &);
    IdAssignmentPolicy_out &operator= (IdAssignmentPolicy_ptr);
    operator IdAssignmentPolicy_ptr &();
    IdAssignmentPolicy_ptr &ptr (void);
    IdAssignmentPolicy_ptr operator-> (void);

  private:
    IdAssignmentPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IDASSIGNMENTPOLICY_CH_)
#define _PORTABLESERVER_IDASSIGNMENTPOLICY_CH_

  class TAO_Export IdAssignmentPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef IdAssignmentPolicy_ptr _ptr_type;
    typedef IdAssignmentPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static IdAssignmentPolicy_ptr _duplicate (IdAssignmentPolicy_ptr obj);
    static IdAssignmentPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static IdAssignmentPolicy_ptr _nil (void);
    static void _tao_any_destructor (void*);

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
    virtual IdAssignmentPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
#else
    virtual IdAssignmentPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    IdAssignmentPolicy (
                        TAO_Stub *objref = 0,
                        TAO_ServantBase *servant = 0,
                        CORBA::Boolean collocated = 0
                        );
  public:
    virtual ~IdAssignmentPolicy (void);
  private:
    IdAssignmentPolicy (const IdAssignmentPolicy&);
    void operator= (const IdAssignmentPolicy&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_IdAssignmentPolicy;

  enum ImplicitActivationPolicyValue
  {
    IMPLICIT_ACTIVATION,
    NO_IMPLICIT_ACTIVATION
  };

#if (TAO_HAS_MINIMUM_POA == 0)

  typedef ImplicitActivationPolicyValue &ImplicitActivationPolicyValue_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ImplicitActivationPolicyValue;


#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY___PTR_CH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY___PTR_CH_

  class ImplicitActivationPolicy;
  typedef ImplicitActivationPolicy *ImplicitActivationPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY___VAR_CH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY___VAR_CH_

  class TAO_Export ImplicitActivationPolicy_var : public TAO_Base_var
  {
  public:
    ImplicitActivationPolicy_var (void); // default constructor
    ImplicitActivationPolicy_var (ImplicitActivationPolicy_ptr);
    ImplicitActivationPolicy_var (const ImplicitActivationPolicy_var &); // copy constructor
    ~ImplicitActivationPolicy_var (void); // destructor

    ImplicitActivationPolicy_var &operator= (ImplicitActivationPolicy_ptr);
    ImplicitActivationPolicy_var &operator= (const ImplicitActivationPolicy_var &);
    ImplicitActivationPolicy_ptr operator-> (void) const;

    operator const ImplicitActivationPolicy_ptr &() const;
    operator ImplicitActivationPolicy_ptr &();
    // in, inout, out, _retn
    ImplicitActivationPolicy_ptr in (void) const;
    ImplicitActivationPolicy_ptr &inout (void);
    ImplicitActivationPolicy_ptr &out (void);
    ImplicitActivationPolicy_ptr _retn (void);
    ImplicitActivationPolicy_ptr ptr (void) const;

  private:
    ImplicitActivationPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ImplicitActivationPolicy_var (const TAO_Base_var &rhs);
    ImplicitActivationPolicy_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY___OUT_CH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY___OUT_CH_

  class TAO_Export ImplicitActivationPolicy_out
  {
  public:
    ImplicitActivationPolicy_out (ImplicitActivationPolicy_ptr &);
    ImplicitActivationPolicy_out (ImplicitActivationPolicy_var &);
    ImplicitActivationPolicy_out (const ImplicitActivationPolicy_out &);
    ImplicitActivationPolicy_out &operator= (ImplicitActivationPolicy_out &);
    ImplicitActivationPolicy_out &operator= (const ImplicitActivationPolicy_var &);
    ImplicitActivationPolicy_out &operator= (ImplicitActivationPolicy_ptr);
    operator ImplicitActivationPolicy_ptr &();
    ImplicitActivationPolicy_ptr &ptr (void);
    ImplicitActivationPolicy_ptr operator-> (void);

  private:
    ImplicitActivationPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_IMPLICITACTIVATIONPOLICY_CH_)
#define _PORTABLESERVER_IMPLICITACTIVATIONPOLICY_CH_

  class TAO_Export ImplicitActivationPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ImplicitActivationPolicy_ptr _ptr_type;
    typedef ImplicitActivationPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ImplicitActivationPolicy_ptr _duplicate (ImplicitActivationPolicy_ptr obj);
    static ImplicitActivationPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static ImplicitActivationPolicy_ptr _nil (void);
    static void _tao_any_destructor (void*);

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
    virtual ImplicitActivationPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
#else
    virtual ImplicitActivationPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    ImplicitActivationPolicy (
                              TAO_Stub *objref = 0,
                              TAO_ServantBase *servant = 0,
                              CORBA::Boolean collocated = 0
                              );
  public:
    virtual ~ImplicitActivationPolicy (void);
  private:
    ImplicitActivationPolicy (const ImplicitActivationPolicy&);
    void operator= (const ImplicitActivationPolicy&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ImplicitActivationPolicy;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

  enum ServantRetentionPolicyValue
  {
    RETAIN,
    NON_RETAIN
  };

#if (TAO_HAS_MINIMUM_POA == 0)

  typedef ServantRetentionPolicyValue &ServantRetentionPolicyValue_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ServantRetentionPolicyValue;


#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY___PTR_CH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY___PTR_CH_

  class ServantRetentionPolicy;
  typedef ServantRetentionPolicy *ServantRetentionPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY___VAR_CH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY___VAR_CH_

  class TAO_Export ServantRetentionPolicy_var : public TAO_Base_var
  {
  public:
    ServantRetentionPolicy_var (void); // default constructor
    ServantRetentionPolicy_var (ServantRetentionPolicy_ptr);
    ServantRetentionPolicy_var (const ServantRetentionPolicy_var &); // copy constructor
    ~ServantRetentionPolicy_var (void); // destructor

    ServantRetentionPolicy_var &operator= (ServantRetentionPolicy_ptr);
    ServantRetentionPolicy_var &operator= (const ServantRetentionPolicy_var &);
    ServantRetentionPolicy_ptr operator-> (void) const;

    operator const ServantRetentionPolicy_ptr &() const;
    operator ServantRetentionPolicy_ptr &();
    // in, inout, out, _retn
    ServantRetentionPolicy_ptr in (void) const;
    ServantRetentionPolicy_ptr &inout (void);
    ServantRetentionPolicy_ptr &out (void);
    ServantRetentionPolicy_ptr _retn (void);
    ServantRetentionPolicy_ptr ptr (void) const;

  private:
    ServantRetentionPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ServantRetentionPolicy_var (const TAO_Base_var &rhs);
    ServantRetentionPolicy_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY___OUT_CH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY___OUT_CH_

  class TAO_Export ServantRetentionPolicy_out
  {
  public:
    ServantRetentionPolicy_out (ServantRetentionPolicy_ptr &);
    ServantRetentionPolicy_out (ServantRetentionPolicy_var &);
    ServantRetentionPolicy_out (const ServantRetentionPolicy_out &);
    ServantRetentionPolicy_out &operator= (ServantRetentionPolicy_out &);
    ServantRetentionPolicy_out &operator= (const ServantRetentionPolicy_var &);
    ServantRetentionPolicy_out &operator= (ServantRetentionPolicy_ptr);
    operator ServantRetentionPolicy_ptr &();
    ServantRetentionPolicy_ptr &ptr (void);
    ServantRetentionPolicy_ptr operator-> (void);

  private:
    ServantRetentionPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTRETENTIONPOLICY_CH_)
#define _PORTABLESERVER_SERVANTRETENTIONPOLICY_CH_

  class TAO_Export ServantRetentionPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantRetentionPolicy_ptr _ptr_type;
    typedef ServantRetentionPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ServantRetentionPolicy_ptr _duplicate (ServantRetentionPolicy_ptr obj);
    static ServantRetentionPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static ServantRetentionPolicy_ptr _nil (void);
    static void _tao_any_destructor (void*);

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
    virtual ServantRetentionPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
#else
    virtual ServantRetentionPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    ServantRetentionPolicy (
                            TAO_Stub *objref = 0,
                            TAO_ServantBase *servant = 0,
                            CORBA::Boolean collocated = 0
                            );
  public:
    virtual ~ServantRetentionPolicy (void);
  private:
    ServantRetentionPolicy (const ServantRetentionPolicy&);
    void operator= (const ServantRetentionPolicy&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ServantRetentionPolicy;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

  enum RequestProcessingPolicyValue
  {
    USE_ACTIVE_OBJECT_MAP_ONLY,
    USE_DEFAULT_SERVANT,
    USE_SERVANT_MANAGER
  };

#if (TAO_HAS_MINIMUM_POA == 0)

  typedef RequestProcessingPolicyValue &RequestProcessingPolicyValue_out;
  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestProcessingPolicyValue;


#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY___PTR_CH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY___PTR_CH_

  class RequestProcessingPolicy;
  typedef RequestProcessingPolicy *RequestProcessingPolicy_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY___VAR_CH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY___VAR_CH_

  class TAO_Export RequestProcessingPolicy_var : public TAO_Base_var
  {
  public:
    RequestProcessingPolicy_var (void); // default constructor
    RequestProcessingPolicy_var (RequestProcessingPolicy_ptr);
    RequestProcessingPolicy_var (const RequestProcessingPolicy_var &); // copy constructor
    ~RequestProcessingPolicy_var (void); // destructor

    RequestProcessingPolicy_var &operator= (RequestProcessingPolicy_ptr);
    RequestProcessingPolicy_var &operator= (const RequestProcessingPolicy_var &);
    RequestProcessingPolicy_ptr operator-> (void) const;

    operator const RequestProcessingPolicy_ptr &() const;
    operator RequestProcessingPolicy_ptr &();
    // in, inout, out, _retn
    RequestProcessingPolicy_ptr in (void) const;
    RequestProcessingPolicy_ptr &inout (void);
    RequestProcessingPolicy_ptr &out (void);
    RequestProcessingPolicy_ptr _retn (void);
    RequestProcessingPolicy_ptr ptr (void) const;

  private:
    RequestProcessingPolicy_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    RequestProcessingPolicy_var (const TAO_Base_var &rhs);
    RequestProcessingPolicy_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY___OUT_CH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY___OUT_CH_

  class TAO_Export RequestProcessingPolicy_out
  {
  public:
    RequestProcessingPolicy_out (RequestProcessingPolicy_ptr &);
    RequestProcessingPolicy_out (RequestProcessingPolicy_var &);
    RequestProcessingPolicy_out (const RequestProcessingPolicy_out &);
    RequestProcessingPolicy_out &operator= (RequestProcessingPolicy_out &);
    RequestProcessingPolicy_out &operator= (const RequestProcessingPolicy_var &);
    RequestProcessingPolicy_out &operator= (RequestProcessingPolicy_ptr);
    operator RequestProcessingPolicy_ptr &();
    RequestProcessingPolicy_ptr &ptr (void);
    RequestProcessingPolicy_ptr operator-> (void);

  private:
    RequestProcessingPolicy_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_REQUESTPROCESSINGPOLICY_CH_)
#define _PORTABLESERVER_REQUESTPROCESSINGPOLICY_CH_

  class TAO_Export RequestProcessingPolicy: public virtual CORBA::Policy
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef RequestProcessingPolicy_ptr _ptr_type;
    typedef RequestProcessingPolicy_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static RequestProcessingPolicy_ptr _duplicate (RequestProcessingPolicy_ptr obj);
    static RequestProcessingPolicy_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static RequestProcessingPolicy_ptr _nil (void);
    static void _tao_any_destructor (void*);

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
    virtual RequestProcessingPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
#else
    virtual RequestProcessingPolicyValue value (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    RequestProcessingPolicy (
                             TAO_Stub *objref = 0,
                             TAO_ServantBase *servant = 0,
                             CORBA::Boolean collocated = 0
                             );
  public:
    virtual ~RequestProcessingPolicy (void);
  private:
    RequestProcessingPolicy (const RequestProcessingPolicy&);
    void operator= (const RequestProcessingPolicy&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_RequestProcessingPolicy;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

#if !defined (_PORTABLESERVER_POAMANAGER___PTR_CH_)
#define _PORTABLESERVER_POAMANAGER___PTR_CH_

  class POAManager;
  typedef POAManager *POAManager_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POAMANAGER___VAR_CH_)
#define _PORTABLESERVER_POAMANAGER___VAR_CH_

  class TAO_Export POAManager_var : public TAO_Base_var
  {
  public:
    POAManager_var (void); // default constructor
    POAManager_var (POAManager_ptr);
    POAManager_var (const POAManager_var &); // copy constructor
    ~POAManager_var (void); // destructor

    POAManager_var &operator= (POAManager_ptr);
    POAManager_var &operator= (const POAManager_var &);
    POAManager_ptr operator-> (void) const;

    operator const POAManager_ptr &() const;
    operator POAManager_ptr &();
    // in, inout, out, _retn
    POAManager_ptr in (void) const;
    POAManager_ptr &inout (void);
    POAManager_ptr &out (void);
    POAManager_ptr _retn (void);
    POAManager_ptr ptr (void) const;

  private:
    POAManager_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    POAManager_var (const TAO_Base_var &rhs);
    POAManager_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POAMANAGER___OUT_CH_)
#define _PORTABLESERVER_POAMANAGER___OUT_CH_

  class TAO_Export POAManager_out
  {
  public:
    POAManager_out (POAManager_ptr &);
    POAManager_out (POAManager_var &);
    POAManager_out (const POAManager_out &);
    POAManager_out &operator= (POAManager_out &);
    POAManager_out &operator= (const POAManager_var &);
    POAManager_out &operator= (POAManager_ptr);
    operator POAManager_ptr &();
    POAManager_ptr &ptr (void);
    POAManager_ptr operator-> (void);

  private:
    POAManager_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POAMANAGER_CH_)
#define _PORTABLESERVER_POAMANAGER_CH_

  class TAO_Export POAManager: public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef POAManager_ptr _ptr_type;
    typedef POAManager_var _var_type;
  #endif /* __GNUC__ */

    enum State {
      HOLDING,
      ACTIVE,
      DISCARDING,
      INACTIVE
    };
    static CORBA::TypeCode_ptr _tc_State;

    // the static operations
    static POAManager_ptr _duplicate (POAManager_ptr obj);
    static POAManager_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static POAManager_ptr _nil (void);
    static void _tao_any_destructor (void*);


#if !defined (_PORTABLESERVER_POAMANAGER_ADAPTERINACTIVE_CH_)
#define _PORTABLESERVER_POAMANAGER_ADAPTERINACTIVE_CH_

    class TAO_Export AdapterInactive : public CORBA_UserException
    {
    public:
      AdapterInactive (void); // default ctor
      AdapterInactive (const AdapterInactive &); // copy ctor
      ~AdapterInactive (void); // dtor
      AdapterInactive &operator= (const AdapterInactive &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static AdapterInactive *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);
    }; // exception PortableServer::POAManager::AdapterInactive

    friend void operator<<= (CORBA::Any &, const AdapterInactive &); // copying version
    friend void operator<<= (CORBA::Any &, AdapterInactive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, AdapterInactive *&);
    static CORBA::TypeCode_ptr _tc_AdapterInactive;

#endif /* end #if !defined */

    virtual void  activate (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;

#if (TAO_HAS_MINIMUM_POA == 0)

    virtual void  hold_requests (CORBA::Boolean wait_for_completion, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  discard_requests (CORBA::Boolean wait_for_completion, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  deactivate (CORBA::Boolean etherealize_objects, CORBA::Boolean wait_for_completion, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

    virtual State get_state (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    POAManager (
                TAO_Stub *objref = 0,
                TAO_ServantBase *servant = 0,
                CORBA::Boolean collocated = 0
                );
  public:
    virtual ~POAManager (void);
  private:
    POAManager (const POAManager&);
    void operator= (const POAManager&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_POAManager;

#if (TAO_HAS_MINIMUM_POA == 0)

#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR___PTR_CH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR___PTR_CH_

  class AdapterActivator;
  typedef AdapterActivator *AdapterActivator_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR___VAR_CH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR___VAR_CH_

  class TAO_Export AdapterActivator_var : public TAO_Base_var
  {
  public:
    AdapterActivator_var (void); // default constructor
    AdapterActivator_var (AdapterActivator_ptr);
    AdapterActivator_var (const AdapterActivator_var &); // copy constructor
    ~AdapterActivator_var (void); // destructor

    AdapterActivator_var &operator= (AdapterActivator_ptr);
    AdapterActivator_var &operator= (const AdapterActivator_var &);
    AdapterActivator_ptr operator-> (void) const;

    operator const AdapterActivator_ptr &() const;
    operator AdapterActivator_ptr &();
    // in, inout, out, _retn
    AdapterActivator_ptr in (void) const;
    AdapterActivator_ptr &inout (void);
    AdapterActivator_ptr &out (void);
    AdapterActivator_ptr _retn (void);
    AdapterActivator_ptr ptr (void) const;

  private:
    AdapterActivator_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    AdapterActivator_var (const TAO_Base_var &rhs);
    AdapterActivator_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR___OUT_CH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR___OUT_CH_

  class TAO_Export AdapterActivator_out
  {
  public:
    AdapterActivator_out (AdapterActivator_ptr &);
    AdapterActivator_out (AdapterActivator_var &);
    AdapterActivator_out (const AdapterActivator_out &);
    AdapterActivator_out &operator= (AdapterActivator_out &);
    AdapterActivator_out &operator= (const AdapterActivator_var &);
    AdapterActivator_out &operator= (AdapterActivator_ptr);
    operator AdapterActivator_ptr &();
    AdapterActivator_ptr &ptr (void);
    AdapterActivator_ptr operator-> (void);

  private:
    AdapterActivator_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_ADAPTERACTIVATOR_CH_)
#define _PORTABLESERVER_ADAPTERACTIVATOR_CH_

  class TAO_Export AdapterActivator: public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef AdapterActivator_ptr _ptr_type;
    typedef AdapterActivator_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static AdapterActivator_ptr _duplicate (AdapterActivator_ptr obj);
    static AdapterActivator_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static AdapterActivator_ptr _nil (void);
    static void _tao_any_destructor (void*);

    virtual CORBA::Boolean  unknown_adapter (POA_ptr parent, const char *name, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    AdapterActivator (
                      TAO_Stub *objref = 0,
                      TAO_ServantBase *servant = 0,
                      CORBA::Boolean collocated = 0
                      );
  public:
    virtual ~AdapterActivator (void);
  private:
    AdapterActivator (const AdapterActivator&);
    void operator= (const AdapterActivator&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_AdapterActivator;


#if !defined (_PORTABLESERVER_SERVANTMANAGER___PTR_CH_)
#define _PORTABLESERVER_SERVANTMANAGER___PTR_CH_

  class ServantManager;
  typedef ServantManager *ServantManager_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTMANAGER___VAR_CH_)
#define _PORTABLESERVER_SERVANTMANAGER___VAR_CH_

  class TAO_Export ServantManager_var : public TAO_Base_var
  {
  public:
    ServantManager_var (void); // default constructor
    ServantManager_var (ServantManager_ptr);
    ServantManager_var (const ServantManager_var &); // copy constructor
    ~ServantManager_var (void); // destructor

    ServantManager_var &operator= (ServantManager_ptr);
    ServantManager_var &operator= (const ServantManager_var &);
    ServantManager_ptr operator-> (void) const;

    operator const ServantManager_ptr &() const;
    operator ServantManager_ptr &();
    // in, inout, out, _retn
    ServantManager_ptr in (void) const;
    ServantManager_ptr &inout (void);
    ServantManager_ptr &out (void);
    ServantManager_ptr _retn (void);
    ServantManager_ptr ptr (void) const;

  private:
    ServantManager_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ServantManager_var (const TAO_Base_var &rhs);
    ServantManager_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */


#if !defined (_PORTABLESERVER_SERVANTMANAGER___OUT_CH_)
#define _PORTABLESERVER_SERVANTMANAGER___OUT_CH_

  class TAO_Export ServantManager_out
  {
  public:
    ServantManager_out (ServantManager_ptr &);
    ServantManager_out (ServantManager_var &);
    ServantManager_out (const ServantManager_out &);
    ServantManager_out &operator= (ServantManager_out &);
    ServantManager_out &operator= (const ServantManager_var &);
    ServantManager_out &operator= (ServantManager_ptr);
    operator ServantManager_ptr &();
    ServantManager_ptr &ptr (void);
    ServantManager_ptr operator-> (void);

  private:
    ServantManager_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTMANAGER_CH_)
#define _PORTABLESERVER_SERVANTMANAGER_CH_

  class TAO_Export ServantManager: public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantManager_ptr _ptr_type;
    typedef ServantManager_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ServantManager_ptr _duplicate (ServantManager_ptr obj);
    static ServantManager_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static ServantManager_ptr _nil (void);
    static void _tao_any_destructor (void*);

    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    ServantManager (
                    TAO_Stub *objref = 0,
                    TAO_ServantBase *servant = 0,
                    CORBA::Boolean collocated = 0
                    );
  public:
    virtual ~ServantManager (void);
  private:
    ServantManager (const ServantManager&);
    void operator= (const ServantManager&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ServantManager;


#if !defined (_PORTABLESERVER_SERVANTACTIVATOR___PTR_CH_)
#define _PORTABLESERVER_SERVANTACTIVATOR___PTR_CH_

  class ServantActivator;
  typedef ServantActivator *ServantActivator_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTACTIVATOR___VAR_CH_)
#define _PORTABLESERVER_SERVANTACTIVATOR___VAR_CH_

  class TAO_Export ServantActivator_var : public TAO_Base_var
  {
  public:
    ServantActivator_var (void); // default constructor
    ServantActivator_var (ServantActivator_ptr);
    ServantActivator_var (const ServantActivator_var &); // copy constructor
    ~ServantActivator_var (void); // destructor

    ServantActivator_var &operator= (ServantActivator_ptr);
    ServantActivator_var &operator= (const ServantActivator_var &);
    ServantActivator_ptr operator-> (void) const;

    operator const ServantActivator_ptr &() const;
    operator ServantActivator_ptr &();
    // in, inout, out, _retn
    ServantActivator_ptr in (void) const;
    ServantActivator_ptr &inout (void);
    ServantActivator_ptr &out (void);
    ServantActivator_ptr _retn (void);
    ServantActivator_ptr ptr (void) const;

  private:
    ServantActivator_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ServantActivator_var (const TAO_Base_var &rhs);
    ServantActivator_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTACTIVATOR___OUT_CH_)
#define _PORTABLESERVER_SERVANTACTIVATOR___OUT_CH_

  class TAO_Export ServantActivator_out
  {
  public:
    ServantActivator_out (ServantActivator_ptr &);
    ServantActivator_out (ServantActivator_var &);
    ServantActivator_out (const ServantActivator_out &);
    ServantActivator_out &operator= (ServantActivator_out &);
    ServantActivator_out &operator= (const ServantActivator_var &);
    ServantActivator_out &operator= (ServantActivator_ptr);
    operator ServantActivator_ptr &();
    ServantActivator_ptr &ptr (void);
    ServantActivator_ptr operator-> (void);

  private:
    ServantActivator_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTACTIVATOR_CH_)
#define _PORTABLESERVER_SERVANTACTIVATOR_CH_

  class TAO_Export ServantActivator: public virtual ServantManager
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantActivator_ptr _ptr_type;
    typedef ServantActivator_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ServantActivator_ptr _duplicate (ServantActivator_ptr obj);
    static ServantActivator_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static ServantActivator_ptr _nil (void);
    static void _tao_any_destructor (void*);

    virtual Servant  incarnate (const ObjectId &oid, POA_ptr adapter, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  etherealize (const ObjectId &oid, POA_ptr adapter, Servant serv, CORBA::Boolean cleanup_in_progress, CORBA::Boolean remaining_activations, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    ServantActivator (
                      TAO_Stub *objref = 0,
                      TAO_ServantBase *servant = 0,
                      CORBA::Boolean collocated = 0
                      );
  public:
    virtual ~ServantActivator (void);
  private:
    ServantActivator (const ServantActivator&);
    void operator= (const ServantActivator&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ServantActivator;


#if !defined (_PORTABLESERVER_SERVANTLOCATOR___PTR_CH_)
#define _PORTABLESERVER_SERVANTLOCATOR___PTR_CH_

  class ServantLocator;
  typedef ServantLocator *ServantLocator_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTLOCATOR___VAR_CH_)
#define _PORTABLESERVER_SERVANTLOCATOR___VAR_CH_

  class TAO_Export ServantLocator_var : public TAO_Base_var
  {
  public:
    ServantLocator_var (void); // default constructor
    ServantLocator_var (ServantLocator_ptr);
    ServantLocator_var (const ServantLocator_var &); // copy constructor
    ~ServantLocator_var (void); // destructor

    ServantLocator_var &operator= (ServantLocator_ptr);
    ServantLocator_var &operator= (const ServantLocator_var &);
    ServantLocator_ptr operator-> (void) const;

    operator const ServantLocator_ptr &() const;
    operator ServantLocator_ptr &();
    // in, inout, out, _retn
    ServantLocator_ptr in (void) const;
    ServantLocator_ptr &inout (void);
    ServantLocator_ptr &out (void);
    ServantLocator_ptr _retn (void);
    ServantLocator_ptr ptr (void) const;

  private:
    ServantLocator_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    ServantLocator_var (const TAO_Base_var &rhs);
    ServantLocator_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTLOCATOR___OUT_CH_)
#define _PORTABLESERVER_SERVANTLOCATOR___OUT_CH_

  class TAO_Export ServantLocator_out
  {
  public:
    ServantLocator_out (ServantLocator_ptr &);
    ServantLocator_out (ServantLocator_var &);
    ServantLocator_out (const ServantLocator_out &);
    ServantLocator_out &operator= (ServantLocator_out &);
    ServantLocator_out &operator= (const ServantLocator_var &);
    ServantLocator_out &operator= (ServantLocator_ptr);
    operator ServantLocator_ptr &();
    ServantLocator_ptr &ptr (void);
    ServantLocator_ptr operator-> (void);

  private:
    ServantLocator_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_SERVANTLOCATOR_CH_)
#define _PORTABLESERVER_SERVANTLOCATOR_CH_

  class TAO_Export ServantLocator: public virtual ServantManager
  {
  public:

    typedef void *Cookie;

  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef ServantLocator_ptr _ptr_type;
    typedef ServantLocator_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static ServantLocator_ptr _duplicate (ServantLocator_ptr obj);
    static ServantLocator_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static ServantLocator_ptr _nil (void);
    static void _tao_any_destructor (void*);

    virtual Servant  preinvoke (const ObjectId &oid, POA_ptr adapter, const char *operation, Cookie & the_cookie, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  postinvoke (const ObjectId &oid, POA_ptr adapter, const char *operation, Cookie the_cookie, Servant the_servant, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    ServantLocator (
                    TAO_Stub *objref = 0,
                    TAO_ServantBase *servant = 0,
                    CORBA::Boolean collocated = 0
                    );
  public:
    virtual ~ServantLocator (void);
  private:
    ServantLocator (const ServantLocator&);
    void operator= (const ServantLocator&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ServantLocator;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

#if !defined (_PORTABLESERVER_POA___PTR_CH_)
#define _PORTABLESERVER_POA___PTR_CH_

  class POA;
  typedef POA *POA_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA___VAR_CH_)
#define _PORTABLESERVER_POA___VAR_CH_

  class TAO_Export POA_var : public TAO_Base_var
  {
  public:
    POA_var (void); // default constructor
    POA_var (POA_ptr);
    POA_var (const POA_var &); // copy constructor
    ~POA_var (void); // destructor

    POA_var &operator= (POA_ptr);
    POA_var &operator= (const POA_var &);
    POA_ptr operator-> (void) const;

    operator const POA_ptr &() const;
    operator POA_ptr &();
    // in, inout, out, _retn
    POA_ptr in (void) const;
    POA_ptr &inout (void);
    POA_ptr &out (void);
    POA_ptr _retn (void);
    POA_ptr ptr (void) const;

  private:
    POA_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    POA_var (const TAO_Base_var &rhs);
    POA_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA___OUT_CH_)
#define _PORTABLESERVER_POA___OUT_CH_

  class TAO_Export POA_out
  {
  public:
    POA_out (POA_ptr &);
    POA_out (POA_var &);
    POA_out (const POA_out &);
    POA_out &operator= (POA_out &);
    POA_out &operator= (const POA_var &);
    POA_out &operator= (POA_ptr);
    operator POA_ptr &();
    POA_ptr &ptr (void);
    POA_ptr operator-> (void);

  private:
    POA_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_CH_)
#define _PORTABLESERVER_POA_CH_

  class TAO_Export POA : public virtual ACE_CORBA_1 (Object)
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef POA_ptr _ptr_type;
    typedef POA_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static POA_ptr _duplicate (POA_ptr obj);
    static POA_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static POA_ptr _nil (void);
    static void _tao_any_destructor (void*);


#if !defined (_PORTABLESERVER_POA_ADAPTERALREADYEXISTS___PTR_CH_)
#define _PORTABLESERVER_POA_ADAPTERALREADYEXISTS___PTR_CH_

    class AdapterAlreadyExists;
    typedef AdapterAlreadyExists *AdapterAlreadyExists_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_ADAPTERALREADYEXISTS_CH_)
#define _PORTABLESERVER_POA_ADAPTERALREADYEXISTS_CH_

    class TAO_Export AdapterAlreadyExists : public CORBA_UserException
    {
    public:
      AdapterAlreadyExists (void); // default ctor
      AdapterAlreadyExists (const AdapterAlreadyExists &); // copy ctor
      ~AdapterAlreadyExists (void); // dtor
      AdapterAlreadyExists &operator= (const AdapterAlreadyExists &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static AdapterAlreadyExists *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);
    }; // exception PortableServer::POA::AdapterAlreadyExists

    friend void operator<<= (CORBA::Any &, const AdapterAlreadyExists &); // copying version
    friend void operator<<= (CORBA::Any &, AdapterAlreadyExists*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, AdapterAlreadyExists *&);
    static CORBA::TypeCode_ptr _tc_AdapterAlreadyExists;

#endif /* end #if !defined */

#if (TAO_HAS_MINIMUM_POA == 0)

#if !defined (_PORTABLESERVER_POA_ADAPTERINACTIVE_CH_)
#define _PORTABLESERVER_POA_ADAPTERINACTIVE_CH_

    class TAO_Export AdapterInactive : public CORBA_UserException
    {
    public:
      AdapterInactive (void); // default ctor
      AdapterInactive (const AdapterInactive &); // copy ctor
      ~AdapterInactive (void); // dtor
      AdapterInactive &operator= (const AdapterInactive &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static AdapterInactive *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::AdapterInactive

    friend void operator<<= (CORBA::Any &, const AdapterInactive &); // copying version
    friend void operator<<= (CORBA::Any &, AdapterInactive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, AdapterInactive *&);
    static CORBA::TypeCode_ptr _tc_AdapterInactive;

#endif /* end #if !defined */

#endif /* TAO_HAS_MINIMUM_POA == 0 */

#if !defined (_PORTABLESERVER_POA_ADAPTERNONEXISTENT_CH_)
#define _PORTABLESERVER_POA_ADAPTERNONEXISTENT_CH_

    class TAO_Export AdapterNonExistent : public CORBA_UserException
    {
    public:
      AdapterNonExistent (void); // default ctor
      AdapterNonExistent (const AdapterNonExistent &); // copy ctor
      ~AdapterNonExistent (void); // dtor
      AdapterNonExistent &operator= (const AdapterNonExistent &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static AdapterNonExistent *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::AdapterNonExistent

    friend void operator<<= (CORBA::Any &, const AdapterNonExistent &); // copying version
    friend void operator<<= (CORBA::Any &, AdapterNonExistent*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, AdapterNonExistent *&);
    static CORBA::TypeCode_ptr _tc_AdapterNonExistent;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_INVALIDPOLICY_CH_)
#define _PORTABLESERVER_POA_INVALIDPOLICY_CH_

    class TAO_Export InvalidPolicy : public CORBA_UserException
    {
    public:
      InvalidPolicy (void); // default ctor
      InvalidPolicy (const InvalidPolicy &); // copy ctor
      ~InvalidPolicy (void); // dtor
      InvalidPolicy &operator= (const InvalidPolicy &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static InvalidPolicy *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      InvalidPolicy(
          CORBA::UShort _tao_index
        );

      CORBA::UShort index;

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::InvalidPolicy

    friend void operator<<= (CORBA::Any &, const InvalidPolicy &); // copying version
    friend void operator<<= (CORBA::Any &, InvalidPolicy*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, InvalidPolicy *&);
    static CORBA::TypeCode_ptr _tc_InvalidPolicy;

#endif /* end #if !defined */

#if (TAO_HAS_MINIMUM_POA == 0)

#if !defined (_PORTABLESERVER_POA_NOSERVANT_CH_)
#define _PORTABLESERVER_POA_NOSERVANT_CH_

    class TAO_Export NoServant : public CORBA_UserException
    {
    public:
      NoServant (void); // default ctor
      NoServant (const NoServant &); // copy ctor
      ~NoServant (void); // dtor
      NoServant &operator= (const NoServant &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static NoServant *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::NoServant

    friend void operator<<= (CORBA::Any &, const NoServant &); // copying version
    friend void operator<<= (CORBA::Any &, NoServant*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, NoServant *&);
    static CORBA::TypeCode_ptr _tc_NoServant;

#endif /* end #if !defined */

#endif /* TAO_HAS_MINIMUM_POA == 0 */

#if !defined (_PORTABLESERVER_POA_OBJECTALREADYACTIVE_CH_)
#define _PORTABLESERVER_POA_OBJECTALREADYACTIVE_CH_

    class TAO_Export ObjectAlreadyActive : public CORBA_UserException
    {
    public:
      ObjectAlreadyActive (void); // default ctor
      ObjectAlreadyActive (const ObjectAlreadyActive &); // copy ctor
      ~ObjectAlreadyActive (void); // dtor
      ObjectAlreadyActive &operator= (const ObjectAlreadyActive &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static ObjectAlreadyActive *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::ObjectAlreadyActive

    friend void operator<<= (CORBA::Any &, const ObjectAlreadyActive &); // copying version
    friend void operator<<= (CORBA::Any &, ObjectAlreadyActive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, ObjectAlreadyActive *&);
    static CORBA::TypeCode_ptr _tc_ObjectAlreadyActive;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_OBJECTNOTACTIVE_CH_)
#define _PORTABLESERVER_POA_OBJECTNOTACTIVE_CH_

    class TAO_Export ObjectNotActive : public CORBA_UserException
    {
    public:
      ObjectNotActive (void); // default ctor
      ObjectNotActive (const ObjectNotActive &); // copy ctor
      ~ObjectNotActive (void); // dtor
      ObjectNotActive &operator= (const ObjectNotActive &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static ObjectNotActive *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::ObjectNotActive

    friend void operator<<= (CORBA::Any &, const ObjectNotActive &); // copying version
    friend void operator<<= (CORBA::Any &, ObjectNotActive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, ObjectNotActive *&);
    static CORBA::TypeCode_ptr _tc_ObjectNotActive;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_SERVANTALREADYACTIVE_CH_)
#define _PORTABLESERVER_POA_SERVANTALREADYACTIVE_CH_

    class TAO_Export ServantAlreadyActive : public CORBA_UserException
    {
    public:
      ServantAlreadyActive (void); // default ctor
      ServantAlreadyActive (const ServantAlreadyActive &); // copy ctor
      ~ServantAlreadyActive (void); // dtor
      ServantAlreadyActive &operator= (const ServantAlreadyActive &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static ServantAlreadyActive *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::ServantAlreadyActive

    friend void operator<<= (CORBA::Any &, const ServantAlreadyActive &); // copying version
    friend void operator<<= (CORBA::Any &, ServantAlreadyActive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, ServantAlreadyActive *&);
    static CORBA::TypeCode_ptr _tc_ServantAlreadyActive;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_SERVANTNOTACTIVE_CH_)
#define _PORTABLESERVER_POA_SERVANTNOTACTIVE_CH_

    class TAO_Export ServantNotActive : public CORBA_UserException
    {
    public:
      ServantNotActive (void); // default ctor
      ServantNotActive (const ServantNotActive &); // copy ctor
      ~ServantNotActive (void); // dtor
      ServantNotActive &operator= (const ServantNotActive &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static ServantNotActive *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::ServantNotActive

    friend void operator<<= (CORBA::Any &, const ServantNotActive &); // copying version
    friend void operator<<= (CORBA::Any &, ServantNotActive*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, ServantNotActive *&);
    static CORBA::TypeCode_ptr _tc_ServantNotActive;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_WRONGADAPTER_CH_)
#define _PORTABLESERVER_POA_WRONGADAPTER_CH_

    class TAO_Export WrongAdapter : public CORBA_UserException
    {
    public:
      WrongAdapter (void); // default ctor
      WrongAdapter (const WrongAdapter &); // copy ctor
      ~WrongAdapter (void); // dtor
      WrongAdapter &operator= (const WrongAdapter &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static WrongAdapter *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::WrongAdapter

    friend void operator<<= (CORBA::Any &, const WrongAdapter &); // copying version
    friend void operator<<= (CORBA::Any &, WrongAdapter*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, WrongAdapter *&);
    static CORBA::TypeCode_ptr _tc_WrongAdapter;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_POA_WRONGPOLICY_CH_)
#define _PORTABLESERVER_POA_WRONGPOLICY_CH_

    class TAO_Export WrongPolicy : public CORBA_UserException
    {
    public:
      WrongPolicy (void); // default ctor
      WrongPolicy (const WrongPolicy &); // copy ctor
      ~WrongPolicy (void); // dtor
      WrongPolicy &operator= (const WrongPolicy &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static WrongPolicy *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::POA::WrongPolicy

    friend void operator<<= (CORBA::Any &, const WrongPolicy &); // copying version
    friend void operator<<= (CORBA::Any &, WrongPolicy*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, WrongPolicy *&);
    static CORBA::TypeCode_ptr _tc_WrongPolicy;

#endif /* end #if !defined */

    virtual POA_ptr  create_POA (const char *adapter_name, POAManager_ptr a_POAManager, const CORBA::PolicyList &policies, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual POA_ptr  find_POA (const char *adapter_name, CORBA::Boolean activate_it, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  destroy (CORBA::Boolean etherealize_objects, CORBA::Boolean wait_for_completion, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;

#if (TAO_HAS_MINIMUM_POA == 0)

    virtual ThreadPolicy_ptr  create_thread_policy (ThreadPolicyValue value, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

    virtual LifespanPolicy_ptr  create_lifespan_policy (LifespanPolicyValue value, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual IdUniquenessPolicy_ptr  create_id_uniqueness_policy (IdUniquenessPolicyValue value, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual IdAssignmentPolicy_ptr  create_id_assignment_policy (IdAssignmentPolicyValue value, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;

#if (TAO_HAS_MINIMUM_POA == 0)

    virtual ImplicitActivationPolicy_ptr  create_implicit_activation_policy (ImplicitActivationPolicyValue value, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual ServantRetentionPolicy_ptr  create_servant_retention_policy (ServantRetentionPolicyValue value, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual RequestProcessingPolicy_ptr  create_request_processing_policy (RequestProcessingPolicyValue value, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

    virtual char * the_name (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual POA_ptr  the_parent (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual POAManager_ptr  the_POAManager (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;

#if (TAO_HAS_MINIMUM_POA == 0)

    virtual AdapterActivator_ptr  the_activator (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void the_activator(AdapterActivator_ptr the_activator, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual ServantManager_ptr  get_servant_manager (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  set_servant_manager (ServantManager_ptr imgr, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual Servant  get_servant (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  set_servant (Servant p_servant, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

    virtual ObjectId * activate_object (Servant p_servant, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  activate_object_with_id (const ObjectId &id, Servant p_servant, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual void  deactivate_object (const ObjectId &oid, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Object_ptr  create_reference (const char *intf, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Object_ptr  create_reference_with_id (const ObjectId &oid, const char *intf, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual ObjectId * servant_to_id (Servant p_servant, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Object_ptr  servant_to_reference (Servant p_servant, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual Servant  reference_to_servant (CORBA::Object_ptr reference, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual ObjectId * reference_to_id (CORBA::Object_ptr reference, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual Servant  id_to_servant (const ObjectId &oid, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Object_ptr  id_to_reference (const ObjectId &oid, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()) = 0;
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    POA (
         TAO_Stub *objref = 0,
         TAO_ServantBase *servant = 0,
         CORBA::Boolean collocated = 0
         );
  public:
    virtual ~POA (void);
  private:
    POA (const POA&);
    void operator= (const POA&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_POA;


#if !defined (_PORTABLESERVER_CURRENT___PTR_CH_)
#define _PORTABLESERVER_CURRENT___PTR_CH_

  class Current;
  typedef Current *Current_ptr;

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_CURRENT___VAR_CH_)
#define _PORTABLESERVER_CURRENT___VAR_CH_

  class TAO_Export Current_var : public TAO_Base_var
  {
  public:
    Current_var (void); // default constructor
    Current_var (Current_ptr);
    Current_var (const Current_var &); // copy constructor
    ~Current_var (void); // destructor

    Current_var &operator= (Current_ptr);
    Current_var &operator= (const Current_var &);
    Current_ptr operator-> (void) const;

    operator const Current_ptr &() const;
    operator Current_ptr &();
    // in, inout, out, _retn
    Current_ptr in (void) const;
    Current_ptr &inout (void);
    Current_ptr &out (void);
    Current_ptr _retn (void);
    Current_ptr ptr (void) const;

  private:
    Current_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    Current_var (const TAO_Base_var &rhs);
    Current_var &operator= (const TAO_Base_var &rhs);
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_CURRENT___OUT_CH_)
#define _PORTABLESERVER_CURRENT___OUT_CH_

  class TAO_Export Current_out
  {
  public:
    Current_out (Current_ptr &);
    Current_out (Current_var &);
    Current_out (const Current_out &);
    Current_out &operator= (Current_out &);
    Current_out &operator= (const Current_var &);
    Current_out &operator= (Current_ptr);
    operator Current_ptr &();
    Current_ptr &ptr (void);
    Current_ptr operator-> (void);

  private:
    Current_ptr &ptr_;
  };

#endif /* end #if !defined */

#if !defined (_PORTABLESERVER_CURRENT_CH_)
#define _PORTABLESERVER_CURRENT_CH_

  class TAO_Export Current: public virtual CORBA::Current
  {
  public:
  #if !defined(__GNUC__) || __GNUC__ > 2 || __GNUC_MINOR__ >= 8
    typedef Current_ptr _ptr_type;
    typedef Current_var _var_type;
  #endif /* __GNUC__ */

    // the static operations
    static Current_ptr _duplicate (Current_ptr obj);
    static Current_ptr _narrow (CORBA::Object_ptr obj, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    static Current_ptr _nil (void);

    static void _tao_any_destructor (void*);

#if !defined (_PORTABLESERVER_CURRENT_NOCONTEXT_CH_)
#define _PORTABLESERVER_CURRENT_NOCONTEXT_CH_

    class TAO_Export NoContext : public CORBA_UserException
    {
    public:
      NoContext (void); // default ctor
      NoContext (const NoContext &); // copy ctor
      ~NoContext (void); // dtor
      NoContext &operator= (const NoContext &);
      virtual void _raise (void);

      virtual void _tao_encode (TAO_OutputCDR &cdr,
                                CORBA::Environment &) const;
      virtual void _tao_decode (TAO_InputCDR &cdr,
                                CORBA::Environment &);

      static NoContext *_downcast (CORBA::Exception *);
      static void _tao_any_destructor (void*);

      // = TAO extension
      static CORBA::Exception *_alloc (void);

    }; // exception PortableServer::Current::NoContext

    friend void operator<<= (CORBA::Any &, const NoContext &); // copying version
    friend void operator<<= (CORBA::Any &, NoContext*); // noncopying version
    friend CORBA::Boolean operator>>= (const CORBA::Any &, NoContext *&);
    static CORBA::TypeCode_ptr _tc_NoContext;

#endif /* end #if !defined */

    virtual POA_ptr  get_POA (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual ObjectId * get_object_id (CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual CORBA::Boolean _is_a (const CORBA::Char *type_id, CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ());
    virtual const char* _interface_repository_id (void) const;
  protected:
    Current (
             TAO_Stub *objref = 0,
             TAO_ServantBase *servant = 0,
             CORBA::Boolean collocated = 0
             );
  public:
    virtual ~Current (void);
  private:
    Current (const Current&);
    void operator= (const Current&);
  };

#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Current;

  TAO_NAMESPACE_STORAGE_CLASS char *ObjectId_to_string (const PortableServer::ObjectId &id);
  TAO_NAMESPACE_STORAGE_CLASS CORBA::WChar *ObjectId_to_wstring (const PortableServer::ObjectId &id);
  TAO_NAMESPACE_STORAGE_CLASS PortableServer::ObjectId *string_to_ObjectId (const char *id);
  TAO_NAMESPACE_STORAGE_CLASS PortableServer::ObjectId *wstring_to_ObjectId (const CORBA::WChar *id);

}
TAO_NAMESPACE_CLOSE

TAO_Export void operator<<= (CORBA::Any &, const PortableServer::ObjectId &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ObjectId*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ObjectId *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::ObjectId *&);

#if (TAO_HAS_MINIMUM_CORBA == 0)

TAO_Export void operator<<= (CORBA::Any &, const PortableServer::ForwardRequest &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ForwardRequest*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ForwardRequest *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::ForwardRequest *&);

#endif /* TAO_HAS_MINIMUM_CORBA */

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export void operator<<= (CORBA::Any &, PortableServer::ThreadPolicyValue);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ThreadPolicyValue &);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ThreadPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ThreadPolicy *&);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

TAO_Export void operator<<= (CORBA::Any &, PortableServer::LifespanPolicyValue);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::LifespanPolicyValue &);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::LifespanPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::LifespanPolicy *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::IdUniquenessPolicyValue);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::IdUniquenessPolicyValue &);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::IdUniquenessPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::IdUniquenessPolicy *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::IdAssignmentPolicyValue);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::IdAssignmentPolicyValue &);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::IdAssignmentPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::IdAssignmentPolicy *&);

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export void operator<<= (CORBA::Any &, PortableServer::ImplicitActivationPolicyValue);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ImplicitActivationPolicyValue &);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ImplicitActivationPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ImplicitActivationPolicy *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ServantRetentionPolicyValue);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ServantRetentionPolicyValue &);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ServantRetentionPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ServantRetentionPolicy *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::RequestProcessingPolicyValue);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::RequestProcessingPolicyValue &);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::RequestProcessingPolicy_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::RequestProcessingPolicy *&);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::AdapterAlreadyExists &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::AdapterAlreadyExists*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::AdapterAlreadyExists *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::AdapterAlreadyExists *&);

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::AdapterInactive &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::AdapterInactive*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::AdapterInactive *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::AdapterInactive *&);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::AdapterNonExistent &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::AdapterNonExistent*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::AdapterNonExistent *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::AdapterNonExistent *&);
TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::InvalidPolicy &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::InvalidPolicy*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::InvalidPolicy *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::InvalidPolicy *&);

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::NoServant &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::NoServant*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::NoServant *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::NoServant *&);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::ObjectAlreadyActive &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::ObjectAlreadyActive*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::ObjectAlreadyActive *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::ObjectAlreadyActive *&);
TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::ObjectNotActive &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::ObjectNotActive*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::ObjectNotActive *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::ObjectNotActive *&);
TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::ServantAlreadyActive &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::ServantAlreadyActive*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::ServantAlreadyActive *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::ServantAlreadyActive *&);
TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::ServantNotActive &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::ServantNotActive*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::ServantNotActive *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::ServantNotActive *&);
TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::WrongAdapter &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::WrongAdapter*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::WrongAdapter *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::WrongAdapter *&);
TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POA::WrongPolicy &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA::WrongPolicy*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA::WrongPolicy *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POA::WrongPolicy *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::Current_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::Current *&);
TAO_Export void operator<<= (CORBA::Any &, const PortableServer::Current::NoContext &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::Current::NoContext*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::Current::NoContext *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::Current::NoContext *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POAManager_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POAManager *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POAManager::State);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POAManager::State &);
TAO_Export void operator<<= (CORBA::Any &, const PortableServer::POAManager::AdapterInactive &); // copying version
TAO_Export void operator<<= (CORBA::Any &, PortableServer::POAManager::AdapterInactive*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POAManager::AdapterInactive *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const PortableServer::POAManager::AdapterInactive *&);

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export void operator<<= (CORBA::Any &, PortableServer::AdapterActivator_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::AdapterActivator *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ServantManager_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ServantManager *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ServantActivator_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ServantActivator *&);
TAO_Export void operator<<= (CORBA::Any &, PortableServer::ServantLocator_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::ServantLocator *&);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

TAO_Export void operator<<= (CORBA::Any &, PortableServer::POA_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, PortableServer::POA *&);

#if defined (__ACE_INLINE__)
#include "tao/POAC.i"
#else

// POA's policies.

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ThreadPolicyValue &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ThreadPolicyValue &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ThreadPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ThreadPolicy_ptr &);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::LifespanPolicyValue &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::LifespanPolicyValue &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::LifespanPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::LifespanPolicy_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::IdUniquenessPolicyValue &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::IdUniquenessPolicyValue &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::IdUniquenessPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::IdUniquenessPolicy_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::IdAssignmentPolicyValue &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::IdAssignmentPolicyValue &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::IdAssignmentPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::IdAssignmentPolicy_ptr &);

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ImplicitActivationPolicyValue &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ImplicitActivationPolicyValue &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ImplicitActivationPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ImplicitActivationPolicy_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ServantRetentionPolicyValue &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ServantRetentionPolicyValue &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ServantRetentionPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ServantRetentionPolicy_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::RequestProcessingPolicyValue &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::RequestProcessingPolicyValue &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::RequestProcessingPolicy_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::RequestProcessingPolicy_ptr &);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// POA's exceptions.
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &strm, const PortableServer::POA::AdapterAlreadyExists &_tao_aggregate);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::AdapterAlreadyExists &);

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::AdapterNonExistent &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::AdapterNonExistent &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::InvalidPolicy &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::InvalidPolicy &);

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::NoServant &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::NoServant &);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::ObjectAlreadyActive &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::ObjectAlreadyActive &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::ObjectNotActive &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::ObjectNotActive &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::ServantAlreadyActive &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::ServantAlreadyActive &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::ServantNotActive &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::ServantNotActive &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::WrongAdapter &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::WrongAdapter &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA::WrongPolicy &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA::WrongPolicy &);

// POA::Current && its exception.
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::Current_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::Current_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::Current::NoContext &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::Current::NoContext &);

#if (TAO_HAS_MINIMUM_CORBA == 0)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ForwardRequest &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ForwardRequest &);

#endif /* TAO_HAS_MINIMUM_CORBA */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POAManager_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POAManager_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POAManager::State &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POAManager::State &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POAManager::AdapterInactive &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POAManager::AdapterInactive &);

#if (TAO_HAS_MINIMUM_POA == 0)

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::AdapterActivator_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::AdapterActivator_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ServantManager_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ServantManager_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ServantActivator_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ServantActivator_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::ServantLocator_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::ServantLocator_ptr &);

#endif /* TAO_HAS_MINIMUM_POA == 0 */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const PortableServer::POA_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, PortableServer::POA_ptr &);

#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */
#include "ace/post.h"
#endif /* TAO_IDL_POAC_H */
