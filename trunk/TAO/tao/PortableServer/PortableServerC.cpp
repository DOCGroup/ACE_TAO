// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_codegen.cpp:314


#include "PortableServerC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#include "POA.h"

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "PortableServerC.i"
#endif /* !defined INLINE */

char *
PortableServer::ObjectId_to_string (const PortableServer::ObjectId &id)
{
  return TAO_POA::ObjectId_to_string (id);
}

CORBA::WChar *
PortableServer::ObjectId_to_wstring (const PortableServer::ObjectId &id)
{
  return TAO_POA::ObjectId_to_wstring (id);
}

PortableServer::ObjectId *
PortableServer::string_to_ObjectId (const char *id)
{
  return TAO_POA::string_to_ObjectId (id);
}

PortableServer::ObjectId *
PortableServer::wstring_to_ObjectId (const CORBA::WChar *id)
{
  return TAO_POA::wstring_to_ObjectId (id);
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:49

PortableServer::POAList::POAList (void)
{}

PortableServer::POAList::POAList (CORBA::ULong max)
  : TAO_Unbounded_Object_Sequence<
        PortableServer::POA,
        PortableServer::POA_var,
        PortableServer::tao_POA_life,
        PortableServer::tao_POA_cast
      >
    (max)
{}

PortableServer::POAList::POAList (
    CORBA::ULong max,
    CORBA::ULong length,
    PortableServer::POA_ptr* buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Object_Sequence<
        PortableServer::POA,
        PortableServer::POA_var,
        PortableServer::tao_POA_life,
        PortableServer::tao_POA_cast
      >
    (max, length, buffer, release)
{}

PortableServer::POAList::POAList (const POAList &seq)
  : TAO_Unbounded_Object_Sequence<
        PortableServer::POA,
        PortableServer::POA_var,
        PortableServer::tao_POA_life,
        PortableServer::tao_POA_cast
      >
    (seq)
{}

PortableServer::POAList::~POAList (void)
{}

void PortableServer::POAList::_tao_any_destructor (void *_tao_void_pointer)
{
  POAList *tmp = ACE_static_cast (POAList*, _tao_void_pointer);
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_MngSeq_Var_T<
      PortableServer::POAList,
      TAO_Object_Manager<
          PortableServer::POA,
          PortableServer::POA_var,
          PortableServer::tao_POA_life
        >
    >;

template class
  TAO_MngSeq_Out_T<
      PortableServer::POAList,
      PortableServer::POAList_var,
      TAO_Object_Manager<
          PortableServer::POA,
          PortableServer::POA_var,
          PortableServer::tao_POA_life
        >
    >;

template class TAO_Unbounded_Object_Sequence<PortableServer::POA,
                                             TAO_Objref_Var_T<PortableServer::POA, PortableServer::tao_POA_life>,
                                             PortableServer::tao_POA_life,
                                             PortableServer::tao_POA_cast>;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
    TAO_MngSeq_Var_T< \
        PortableServer::POAList, \
        TAO_Object_Manager< \
            PortableServer::POA, \
            PortableServer::POA_var, \
            PortableServer::tao_POA_life \
          > \
      >

# pragma instantiate TAO_Unbounded_Object_Sequence<PortableServer::POA,
      TAO_Objref_Var_T<PortableServer::POA, PortableServer::tao_POA_life>,
      PortableServer::tao_POA_life, PortableServer::tao_POA_cast>

# pragma instantiate \
    TAO_Seq_Out_T< \
        PortableServer::POAList, \
        PortableServer::POAList_var, \
        TAO_Object_Manager< \
            PortableServer::POA, \
            PortableServer::POA_var, \
            PortableServer::tao_POA_life \
          > \
      >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

  static const CORBA::Long _oc_PortableServer_POAList[] =
  {
        TAO_ENCAP_BYTE_ORDER, // byte order
    39,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x506f7274),
    ACE_NTOHL (0x61626c65),
    ACE_NTOHL (0x53657276),
    ACE_NTOHL (0x65722f50),
    ACE_NTOHL (0x4f414c69),
    ACE_NTOHL (0x73743a32),
    ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/POAList:2.3
        8,
    ACE_NTOHL (0x504f414c),
    ACE_NTOHL (0x69737400),  // name = POAList
        CORBA::tk_sequence, // typecode kind
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x506f7274),
        ACE_NTOHL (0x61626c65),
        ACE_NTOHL (0x53657276),
        ACE_NTOHL (0x65722f50),
        ACE_NTOHL (0x4f413a32),
        ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/POA:2.3
                4,
        ACE_NTOHL (0x504f4100),  // name = POA

      0U,

};

  static CORBA::TypeCode _tc_TAO_tc_PortableServer_POAList (
      CORBA::tk_alias,
      sizeof (_oc_PortableServer_POAList),
      (char *) &_oc_PortableServer_POAList,
      0,
      sizeof (PortableServer::POAList)
    );

  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (PortableServer)
  TAO_NAMESPACE_DEFINE (
      ::CORBA::TypeCode_ptr,
      _tc_POAList,
      &_tc_TAO_tc_PortableServer_POAList
    )
  TAO_NAMESPACE_END

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

  static const CORBA::Long _oc_PortableServer_ObjectId[] =
  {
        TAO_ENCAP_BYTE_ORDER, // byte order
    40,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x506f7274),
    ACE_NTOHL (0x61626c65),
    ACE_NTOHL (0x53657276),
    ACE_NTOHL (0x65722f4f),
    ACE_NTOHL (0x626a6563),
    ACE_NTOHL (0x7449643a),
    ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/ObjectId:2.3
        9,
    ACE_NTOHL (0x4f626a65),
    ACE_NTOHL (0x63744964),
    ACE_NTOHL (0x0),  // name = ObjectId
        CORBA::tk_alias, // typecode kind for typedefs
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x434f5242),
      ACE_NTOHL (0x412f4f63),
      ACE_NTOHL (0x74657453),
      ACE_NTOHL (0x65713a31),
      ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
            9,
      ACE_NTOHL (0x4f637465),
      ACE_NTOHL (0x74536571),
      ACE_NTOHL (0x0),  // name = OctetSeq
            CORBA::tk_sequence, // typecode kind
      12, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_octet,

        0U,


};

  static CORBA::TypeCode _tc_TAO_tc_PortableServer_ObjectId (
      CORBA::tk_alias,
      sizeof (_oc_PortableServer_ObjectId),
      (char *) &_oc_PortableServer_ObjectId,
      0,
      sizeof (PortableServer::ObjectId)
    );

  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (PortableServer)
  TAO_NAMESPACE_DEFINE (
      ::CORBA::TypeCode_ptr,
      _tc_ObjectId,
      &_tc_TAO_tc_PortableServer_ObjectId
    )
  TAO_NAMESPACE_END

#if (TAO_HAS_MINIMUM_CORBA == 0)

  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

  PortableServer::ForwardRequest::ForwardRequest (void)
    : CORBA::UserException (
          "IDL:omg.org/PortableServer/ForwardRequest:2.3",
          "ForwardRequest"
        )
  {
  }

  PortableServer::ForwardRequest::~ForwardRequest (void)
  {
  }

  PortableServer::ForwardRequest::ForwardRequest (const ::PortableServer::ForwardRequest &_tao_excp)
    : CORBA::UserException (
          _tao_excp._rep_id (),
          _tao_excp._name ()
        )
  {
    this->forward_reference = CORBA::Object::_duplicate (_tao_excp.forward_reference.in ());
  }

  PortableServer::ForwardRequest&
  PortableServer::ForwardRequest::operator= (const ::PortableServer::ForwardRequest &_tao_excp)
  {
    this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
    this->forward_reference = CORBA::Object::_duplicate (_tao_excp.forward_reference.in ());
    return *this;
  }

  void PortableServer::ForwardRequest::_tao_any_destructor (void *_tao_void_pointer)
  {
    ForwardRequest *tmp = ACE_static_cast (ForwardRequest*, _tao_void_pointer);
    delete tmp;
  }

  PortableServer::ForwardRequest *
  PortableServer::ForwardRequest::_downcast (CORBA::Exception *_tao_excp)
  {
    if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/ForwardRequest:2.3", _tao_excp->_rep_id ()))
      {
        return ACE_dynamic_cast (ForwardRequest *, _tao_excp);
      }
    else
      {
        return 0;
      }
  }

  CORBA::Exception *PortableServer::ForwardRequest::_alloc (void)
  {
    CORBA::Exception *retval = 0;
    ACE_NEW_RETURN (retval, ::PortableServer::ForwardRequest, 0);
    return retval;
  }

  CORBA::Exception *
  PortableServer::ForwardRequest::_tao_duplicate (void) const
  {
    CORBA::Exception *result;
    ACE_NEW_RETURN (
        result,
        ::PortableServer::ForwardRequest (*this),
        0
      );
    return result;
  }

  void PortableServer::ForwardRequest::_raise (void)
  {
    TAO_RAISE (*this);
  }

  void PortableServer::ForwardRequest::_tao_encode (
      TAO_OutputCDR &cdr
      ACE_ENV_ARG_DECL
    ) const
  {
    if (cdr << *this)
      {
        return;
      }

    ACE_THROW (CORBA::MARSHAL ());
  }

  void PortableServer::ForwardRequest::_tao_decode (
      TAO_InputCDR &cdr
      ACE_ENV_ARG_DECL
    )
  {
    if (cdr >> *this)
      {
        return;
      }

    ACE_THROW (CORBA::MARSHAL ());
  }



  // TAO_IDL - Generated from
  // W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_ctor.cpp:66

  PortableServer::ForwardRequest::ForwardRequest (
      const CORBA::Object_ptr  _tao_forward_reference
    )  : CORBA::UserException (
          "IDL:omg.org/PortableServer/ForwardRequest:2.3",
          "ForwardRequest"
        )
{
  this->forward_reference = CORBA::Object::_duplicate (_tao_forward_reference);
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::ForwardRequest::_type (void) const
{
  return ::PortableServer::_tc_ForwardRequest;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ForwardRequest[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f46),
  ACE_NTOHL (0x6f727761),
  ACE_NTOHL (0x72645265),
  ACE_NTOHL (0x71756573),
  ACE_NTOHL (0x743a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/ForwardRequest:2.3
    15,
  ACE_NTOHL (0x466f7277),
  ACE_NTOHL (0x61726452),
  ACE_NTOHL (0x65717565),
  ACE_NTOHL (0x73740000),  // name = ForwardRequest
  1, // member count
    18,
  ACE_NTOHL (0x666f7277),
  ACE_NTOHL (0x6172645f),
  ACE_NTOHL (0x72656665),
  ACE_NTOHL (0x72656e63),
  ACE_NTOHL (0x65000000),  // name = forward_reference
    CORBA::tk_objref,
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a),
    ACE_NTOHL (0x6f6d672e),
    ACE_NTOHL (0x6f72672f),
    ACE_NTOHL (0x434f5242),
    ACE_NTOHL (0x412f4f62),
    ACE_NTOHL (0x6a656374),
    ACE_NTOHL (0x3a312e30),
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
        7,
    ACE_NTOHL (0x4f626a65),
    ACE_NTOHL (0x63740000),  // name = Object

};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ForwardRequest (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_ForwardRequest),
    (char *) &_oc_PortableServer_ForwardRequest,
    0,
    sizeof (PortableServer::ForwardRequest)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ForwardRequest,
    &_tc_TAO_tc_PortableServer_ForwardRequest
  )
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_CORBA == 0 */

#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::NotAGroupObject::NotAGroupObject (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/NotAGroupObject:2.3",
        "NotAGroupObject"
      )
{
}

PortableServer::NotAGroupObject::~NotAGroupObject (void)
{
}

PortableServer::NotAGroupObject::NotAGroupObject (const ::PortableServer::NotAGroupObject &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::NotAGroupObject&
PortableServer::NotAGroupObject::operator= (const ::PortableServer::NotAGroupObject &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::NotAGroupObject::_tao_any_destructor (void *_tao_void_pointer)
{
  NotAGroupObject *tmp = ACE_static_cast (NotAGroupObject*, _tao_void_pointer);
  delete tmp;
}

PortableServer::NotAGroupObject *
PortableServer::NotAGroupObject::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/NotAGroupObject:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (NotAGroupObject *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::NotAGroupObject::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::NotAGroupObject, 0);
  return retval;
}

CORBA::Exception *
PortableServer::NotAGroupObject::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::NotAGroupObject (*this),
      0
    );
  return result;
}

void PortableServer::NotAGroupObject::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::NotAGroupObject::_tao_encode (
    TAO_OutputCDR &cdr
    ACE_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }

  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::NotAGroupObject::_tao_decode (
    TAO_InputCDR &cdr
    ACE_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }

  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::NotAGroupObject::_type (void) const
{
  return ::PortableServer::_tc_NotAGroupObject;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_NotAGroupObject[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f4e),
  ACE_NTOHL (0x6f744147),
  ACE_NTOHL (0x726f7570),
  ACE_NTOHL (0x4f626a65),
  ACE_NTOHL (0x63743a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/NotAGroupObject:2.3
    16,
  ACE_NTOHL (0x4e6f7441),
  ACE_NTOHL (0x47726f75),
  ACE_NTOHL (0x704f626a),
  ACE_NTOHL (0x65637400),  // name = NotAGroupObject
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_NotAGroupObject (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_NotAGroupObject),
    (char *) &_oc_PortableServer_NotAGroupObject,
    0,
    sizeof (PortableServer::NotAGroupObject)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_NotAGroupObject,
    &_tc_TAO_tc_PortableServer_NotAGroupObject
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/sequence_cs.cpp:49

PortableServer::IDs::IDs (void)
{}

PortableServer::IDs::IDs (CORBA::ULong max)
  : TAO_Unbounded_Sequence<
        PortableServer::ObjectId
      >
    (max)
{}

PortableServer::IDs::IDs (
    CORBA::ULong max,
    CORBA::ULong length,
    PortableServer::ObjectId* buffer,
    CORBA::Boolean release
  )
  : TAO_Unbounded_Sequence<
        PortableServer::ObjectId
      >
    (max, length, buffer, release)
{}

PortableServer::IDs::IDs (const IDs &seq)
  : TAO_Unbounded_Sequence<
        PortableServer::ObjectId
      >
    (seq)
{}

PortableServer::IDs::~IDs (void)
{}

void PortableServer::IDs::_tao_any_destructor (void *_tao_void_pointer)
{
  IDs *tmp = ACE_static_cast (IDs*, _tao_void_pointer);
  delete tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)

template class
  TAO_VarSeq_Var_T<
      PortableServer::IDs,
      PortableServer::ObjectId
    >;

template class TAO_Seq_Var_Base_T<PortableServer::IDs,
                                  PortableServer::ObjectId>;

template class
  TAO_Seq_Out_T<
      PortableServer::IDs,
      PortableServer::IDs_var,
      PortableServer::ObjectId
    >;

#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)

# pragma instantiate \
  TAO_VarSeq_Var_T< \
      PortableServer::IDs, \
      PortableServer::ObjectId \
    >
# pragma instantiate TAO_Seq_Var_Base_T<PortableServer::IDs,
      PortableServer::ObjectId>
# pragma instantiate \
  TAO_Seq_Out_T< \
      PortableServer::IDs, \
      PortableServer::IDs_var, \
      PortableServer::ObjectId \
    >

#endif /* !ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_IDs[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f49),
  ACE_NTOHL (0x44733a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/IDs:2.3
    4,
  ACE_NTOHL (0x49447300),  // name = IDs
    CORBA::tk_sequence, // typecode kind
  164, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    148, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40,
      ACE_NTOHL (0x49444c3a),
      ACE_NTOHL (0x6f6d672e),
      ACE_NTOHL (0x6f72672f),
      ACE_NTOHL (0x506f7274),
      ACE_NTOHL (0x61626c65),
      ACE_NTOHL (0x53657276),
      ACE_NTOHL (0x65722f4f),
      ACE_NTOHL (0x626a6563),
      ACE_NTOHL (0x7449643a),
      ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/ObjectId:2.3
            9,
      ACE_NTOHL (0x4f626a65),
      ACE_NTOHL (0x63744964),
      ACE_NTOHL (0x0),  // name = ObjectId
            CORBA::tk_alias, // typecode kind for typedefs
      76, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31,
        ACE_NTOHL (0x49444c3a),
        ACE_NTOHL (0x6f6d672e),
        ACE_NTOHL (0x6f72672f),
        ACE_NTOHL (0x434f5242),
        ACE_NTOHL (0x412f4f63),
        ACE_NTOHL (0x74657453),
        ACE_NTOHL (0x65713a31),
        ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
                9,
        ACE_NTOHL (0x4f637465),
        ACE_NTOHL (0x74536571),
        ACE_NTOHL (0x0),  // name = OctetSeq
                CORBA::tk_sequence, // typecode kind
        12, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_octet,

          0U,



    0U,

};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_IDs (
    CORBA::tk_alias,
    sizeof (_oc_PortableServer_IDs),
    (char *) &_oc_PortableServer_IDs,
    0,
    sizeof (PortableServer::IDs)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_IDs,
    &_tc_TAO_tc_PortableServer_IDs
  )
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_POA == 0 */

#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ThreadPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f54),
  ACE_NTOHL (0x68726561),
  ACE_NTOHL (0x64506f6c),
  ACE_NTOHL (0x69637956),
  ACE_NTOHL (0x616c7565),
  ACE_NTOHL (0x3a322e33),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/ThreadPolicyValue:2.3
  18,
  ACE_NTOHL (0x54687265),
  ACE_NTOHL (0x6164506f),
  ACE_NTOHL (0x6c696379),
  ACE_NTOHL (0x56616c75),
  ACE_NTOHL (0x65000000),  // name = ThreadPolicyValue
  2, // member count
  15,
  ACE_NTOHL (0x4f52425f),
  ACE_NTOHL (0x4354524c),
  ACE_NTOHL (0x5f4d4f44),
  ACE_NTOHL (0x454c0000),  // name = ORB_CTRL_MODEL
  20,
  ACE_NTOHL (0x53494e47),
  ACE_NTOHL (0x4c455f54),
  ACE_NTOHL (0x48524541),
  ACE_NTOHL (0x445f4d4f),
  ACE_NTOHL (0x44454c00),  // name = SINGLE_THREAD_MODEL
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ThreadPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_ThreadPolicyValue),
    (char *) &_oc_PortableServer_ThreadPolicyValue,
    0,
    sizeof (PortableServer::ThreadPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ThreadPolicyValue,
    &_tc_TAO_tc_PortableServer_ThreadPolicyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::ThreadPolicy::_tao_class_id = 0;

PortableServer::ThreadPolicy_ptr
PortableServer::tao_ThreadPolicy_life::tao_duplicate (
    PortableServer::ThreadPolicy_ptr p
  )
{
  return PortableServer::ThreadPolicy::_duplicate (p);
}

void
PortableServer::tao_ThreadPolicy_life::tao_release (
    PortableServer::ThreadPolicy_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::ThreadPolicy_ptr
PortableServer::tao_ThreadPolicy_life::tao_nil (
    void
  )
{
  return PortableServer::ThreadPolicy::_nil ();
}

CORBA::Boolean
PortableServer::tao_ThreadPolicy_life::tao_marshal (
    PortableServer::ThreadPolicy_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::ThreadPolicy_ptr
PortableServer::tao_ThreadPolicy_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::ThreadPolicy::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_ThreadPolicy_cast::tao_upcast (
    void *src
  )
{
  PortableServer::ThreadPolicy **tmp =
    ACE_static_cast (PortableServer::ThreadPolicy **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::ThreadPolicy,
        PortableServer::tao_ThreadPolicy_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::ThreadPolicy,
        PortableServer::tao_ThreadPolicy_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::ThreadPolicy, \
        PortableServer::tao_ThreadPolicy_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::ThreadPolicy, \
        PortableServer::tao_ThreadPolicy_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::ThreadPolicy::ThreadPolicy (void)
{}

PortableServer::ThreadPolicy::~ThreadPolicy (void)
{}

void
PortableServer::ThreadPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  ThreadPolicy *tmp = ACE_static_cast (ThreadPolicy *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ThreadPolicy::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ThreadPolicy::_nil ();
    }

  return
      ACE_reinterpret_cast (
          ThreadPolicy_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ThreadPolicy::_tao_class_id
                )
            )
        );
}

PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy::_duplicate (ThreadPolicy_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::ThreadPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, ThreadPolicy)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Policy::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Policy_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::ThreadPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ThreadPolicy:2.3";
}

CORBA::Boolean
PortableServer::ThreadPolicy::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ThreadPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  44,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f54),
  ACE_NTOHL (0x68726561),
  ACE_NTOHL (0x64506f6c),
  ACE_NTOHL (0x6963793a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/ThreadPolicy:2.3
    13,
  ACE_NTOHL (0x54687265),
  ACE_NTOHL (0x6164506f),
  ACE_NTOHL (0x6c696379),
  ACE_NTOHL (0x0),  // name = ThreadPolicy
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ThreadPolicy (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_ThreadPolicy),
    (char *) &_oc_PortableServer_ThreadPolicy,
    0,
    sizeof (PortableServer::ThreadPolicy)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ThreadPolicy,
    &_tc_TAO_tc_PortableServer_ThreadPolicy
  )
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_LifespanPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f4c),
  ACE_NTOHL (0x69666573),
  ACE_NTOHL (0x70616e50),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x7956616c),
  ACE_NTOHL (0x75653a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/LifespanPolicyValue:2.3
  20,
  ACE_NTOHL (0x4c696665),
  ACE_NTOHL (0x7370616e),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63795661),
  ACE_NTOHL (0x6c756500),  // name = LifespanPolicyValue
  2, // member count
  10,
  ACE_NTOHL (0x5452414e),
  ACE_NTOHL (0x5349454e),
  ACE_NTOHL (0x54000000),  // name = TRANSIENT
  11,
  ACE_NTOHL (0x50455253),
  ACE_NTOHL (0x49535445),
  ACE_NTOHL (0x4e540000),  // name = PERSISTENT
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_LifespanPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_LifespanPolicyValue),
    (char *) &_oc_PortableServer_LifespanPolicyValue,
    0,
    sizeof (PortableServer::LifespanPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_LifespanPolicyValue,
    &_tc_TAO_tc_PortableServer_LifespanPolicyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::LifespanPolicy::_tao_class_id = 0;

PortableServer::LifespanPolicy_ptr
PortableServer::tao_LifespanPolicy_life::tao_duplicate (
    PortableServer::LifespanPolicy_ptr p
  )
{
  return PortableServer::LifespanPolicy::_duplicate (p);
}

void
PortableServer::tao_LifespanPolicy_life::tao_release (
    PortableServer::LifespanPolicy_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::LifespanPolicy_ptr
PortableServer::tao_LifespanPolicy_life::tao_nil (
    void
  )
{
  return PortableServer::LifespanPolicy::_nil ();
}

CORBA::Boolean
PortableServer::tao_LifespanPolicy_life::tao_marshal (
    PortableServer::LifespanPolicy_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::LifespanPolicy_ptr
PortableServer::tao_LifespanPolicy_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::LifespanPolicy::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_LifespanPolicy_cast::tao_upcast (
    void *src
  )
{
  PortableServer::LifespanPolicy **tmp =
    ACE_static_cast (PortableServer::LifespanPolicy **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::LifespanPolicy,
        PortableServer::tao_LifespanPolicy_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::LifespanPolicy,
        PortableServer::tao_LifespanPolicy_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::LifespanPolicy, \
        PortableServer::tao_LifespanPolicy_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::LifespanPolicy, \
        PortableServer::tao_LifespanPolicy_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::LifespanPolicy::LifespanPolicy (void)
{}

PortableServer::LifespanPolicy::~LifespanPolicy (void)
{}

void
PortableServer::LifespanPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  LifespanPolicy *tmp = ACE_static_cast (LifespanPolicy *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return LifespanPolicy::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return LifespanPolicy::_nil ();
    }

  return
      ACE_reinterpret_cast (
          LifespanPolicy_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &LifespanPolicy::_tao_class_id
                )
            )
        );
}

PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy::_duplicate (LifespanPolicy_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::LifespanPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, LifespanPolicy)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Policy::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Policy_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::LifespanPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/LifespanPolicy:2.3";
}

CORBA::Boolean
PortableServer::LifespanPolicy::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_LifespanPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f4c),
  ACE_NTOHL (0x69666573),
  ACE_NTOHL (0x70616e50),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x793a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/LifespanPolicy:2.3
    15,
  ACE_NTOHL (0x4c696665),
  ACE_NTOHL (0x7370616e),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63790000),  // name = LifespanPolicy
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_LifespanPolicy (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_LifespanPolicy),
    (char *) &_oc_PortableServer_LifespanPolicy,
    0,
    sizeof (PortableServer::LifespanPolicy)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_LifespanPolicy,
    &_tc_TAO_tc_PortableServer_LifespanPolicy
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_IdUniquenessPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f49),
  ACE_NTOHL (0x64556e69),
  ACE_NTOHL (0x7175656e),
  ACE_NTOHL (0x65737350),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x7956616c),
  ACE_NTOHL (0x75653a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/IdUniquenessPolicyValue:2.3
  24,
  ACE_NTOHL (0x4964556e),
  ACE_NTOHL (0x69717565),
  ACE_NTOHL (0x6e657373),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63795661),
  ACE_NTOHL (0x6c756500),  // name = IdUniquenessPolicyValue
  2, // member count
  10,
  ACE_NTOHL (0x554e4951),
  ACE_NTOHL (0x55455f49),
  ACE_NTOHL (0x44000000),  // name = UNIQUE_ID
  12,
  ACE_NTOHL (0x4d554c54),
  ACE_NTOHL (0x49504c45),
  ACE_NTOHL (0x5f494400),  // name = MULTIPLE_ID
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdUniquenessPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_IdUniquenessPolicyValue),
    (char *) &_oc_PortableServer_IdUniquenessPolicyValue,
    0,
    sizeof (PortableServer::IdUniquenessPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_IdUniquenessPolicyValue,
    &_tc_TAO_tc_PortableServer_IdUniquenessPolicyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::IdUniquenessPolicy::_tao_class_id = 0;

PortableServer::IdUniquenessPolicy_ptr
PortableServer::tao_IdUniquenessPolicy_life::tao_duplicate (
    PortableServer::IdUniquenessPolicy_ptr p
  )
{
  return PortableServer::IdUniquenessPolicy::_duplicate (p);
}

void
PortableServer::tao_IdUniquenessPolicy_life::tao_release (
    PortableServer::IdUniquenessPolicy_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::IdUniquenessPolicy_ptr
PortableServer::tao_IdUniquenessPolicy_life::tao_nil (
    void
  )
{
  return PortableServer::IdUniquenessPolicy::_nil ();
}

CORBA::Boolean
PortableServer::tao_IdUniquenessPolicy_life::tao_marshal (
    PortableServer::IdUniquenessPolicy_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::IdUniquenessPolicy_ptr
PortableServer::tao_IdUniquenessPolicy_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::IdUniquenessPolicy::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_IdUniquenessPolicy_cast::tao_upcast (
    void *src
  )
{
  PortableServer::IdUniquenessPolicy **tmp =
    ACE_static_cast (PortableServer::IdUniquenessPolicy **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::IdUniquenessPolicy,
        PortableServer::tao_IdUniquenessPolicy_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::IdUniquenessPolicy,
        PortableServer::tao_IdUniquenessPolicy_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::IdUniquenessPolicy, \
        PortableServer::tao_IdUniquenessPolicy_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::IdUniquenessPolicy, \
        PortableServer::tao_IdUniquenessPolicy_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::IdUniquenessPolicy::IdUniquenessPolicy (void)
{}

PortableServer::IdUniquenessPolicy::~IdUniquenessPolicy (void)
{}

void
PortableServer::IdUniquenessPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  IdUniquenessPolicy *tmp = ACE_static_cast (IdUniquenessPolicy *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return IdUniquenessPolicy::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return IdUniquenessPolicy::_nil ();
    }

  return
      ACE_reinterpret_cast (
          IdUniquenessPolicy_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &IdUniquenessPolicy::_tao_class_id
                )
            )
        );
}

PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy::_duplicate (IdUniquenessPolicy_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::IdUniquenessPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, IdUniquenessPolicy)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Policy::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Policy_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::IdUniquenessPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/IdUniquenessPolicy:2.3";
}

CORBA::Boolean
PortableServer::IdUniquenessPolicy::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_IdUniquenessPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f49),
  ACE_NTOHL (0x64556e69),
  ACE_NTOHL (0x7175656e),
  ACE_NTOHL (0x65737350),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x793a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/IdUniquenessPolicy:2.3
    19,
  ACE_NTOHL (0x4964556e),
  ACE_NTOHL (0x69717565),
  ACE_NTOHL (0x6e657373),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63790000),  // name = IdUniquenessPolicy
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdUniquenessPolicy (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_IdUniquenessPolicy),
    (char *) &_oc_PortableServer_IdUniquenessPolicy,
    0,
    sizeof (PortableServer::IdUniquenessPolicy)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_IdUniquenessPolicy,
    &_tc_TAO_tc_PortableServer_IdUniquenessPolicy
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_IdAssignmentPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f49),
  ACE_NTOHL (0x64417373),
  ACE_NTOHL (0x69676e6d),
  ACE_NTOHL (0x656e7450),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x7956616c),
  ACE_NTOHL (0x75653a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/IdAssignmentPolicyValue:2.3
  24,
  ACE_NTOHL (0x49644173),
  ACE_NTOHL (0x7369676e),
  ACE_NTOHL (0x6d656e74),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63795661),
  ACE_NTOHL (0x6c756500),  // name = IdAssignmentPolicyValue
  2, // member count
  8,
  ACE_NTOHL (0x55534552),
  ACE_NTOHL (0x5f494400),  // name = USER_ID
  10,
  ACE_NTOHL (0x53595354),
  ACE_NTOHL (0x454d5f49),
  ACE_NTOHL (0x44000000),  // name = SYSTEM_ID
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdAssignmentPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_IdAssignmentPolicyValue),
    (char *) &_oc_PortableServer_IdAssignmentPolicyValue,
    0,
    sizeof (PortableServer::IdAssignmentPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_IdAssignmentPolicyValue,
    &_tc_TAO_tc_PortableServer_IdAssignmentPolicyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::IdAssignmentPolicy::_tao_class_id = 0;

PortableServer::IdAssignmentPolicy_ptr
PortableServer::tao_IdAssignmentPolicy_life::tao_duplicate (
    PortableServer::IdAssignmentPolicy_ptr p
  )
{
  return PortableServer::IdAssignmentPolicy::_duplicate (p);
}

void
PortableServer::tao_IdAssignmentPolicy_life::tao_release (
    PortableServer::IdAssignmentPolicy_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::IdAssignmentPolicy_ptr
PortableServer::tao_IdAssignmentPolicy_life::tao_nil (
    void
  )
{
  return PortableServer::IdAssignmentPolicy::_nil ();
}

CORBA::Boolean
PortableServer::tao_IdAssignmentPolicy_life::tao_marshal (
    PortableServer::IdAssignmentPolicy_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::IdAssignmentPolicy_ptr
PortableServer::tao_IdAssignmentPolicy_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::IdAssignmentPolicy::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_IdAssignmentPolicy_cast::tao_upcast (
    void *src
  )
{
  PortableServer::IdAssignmentPolicy **tmp =
    ACE_static_cast (PortableServer::IdAssignmentPolicy **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::IdAssignmentPolicy,
        PortableServer::tao_IdAssignmentPolicy_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::IdAssignmentPolicy,
        PortableServer::tao_IdAssignmentPolicy_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::IdAssignmentPolicy, \
        PortableServer::tao_IdAssignmentPolicy_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::IdAssignmentPolicy, \
        PortableServer::tao_IdAssignmentPolicy_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::IdAssignmentPolicy::IdAssignmentPolicy (void)
{}

PortableServer::IdAssignmentPolicy::~IdAssignmentPolicy (void)
{}

void
PortableServer::IdAssignmentPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  IdAssignmentPolicy *tmp = ACE_static_cast (IdAssignmentPolicy *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return IdAssignmentPolicy::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return IdAssignmentPolicy::_nil ();
    }

  return
      ACE_reinterpret_cast (
          IdAssignmentPolicy_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &IdAssignmentPolicy::_tao_class_id
                )
            )
        );
}

PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy::_duplicate (IdAssignmentPolicy_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::IdAssignmentPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, IdAssignmentPolicy)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Policy::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Policy_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::IdAssignmentPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/IdAssignmentPolicy:2.3";
}

CORBA::Boolean
PortableServer::IdAssignmentPolicy::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_IdAssignmentPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  50,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f49),
  ACE_NTOHL (0x64417373),
  ACE_NTOHL (0x69676e6d),
  ACE_NTOHL (0x656e7450),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x793a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/IdAssignmentPolicy:2.3
    19,
  ACE_NTOHL (0x49644173),
  ACE_NTOHL (0x7369676e),
  ACE_NTOHL (0x6d656e74),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63790000),  // name = IdAssignmentPolicy
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdAssignmentPolicy (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_IdAssignmentPolicy),
    (char *) &_oc_PortableServer_IdAssignmentPolicy,
    0,
    sizeof (PortableServer::IdAssignmentPolicy)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_IdAssignmentPolicy,
    &_tc_TAO_tc_PortableServer_IdAssignmentPolicy
  )
TAO_NAMESPACE_END

#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ImplicitActivationPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  61,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f49),
  ACE_NTOHL (0x6d706c69),
  ACE_NTOHL (0x63697441),
  ACE_NTOHL (0x63746976),
  ACE_NTOHL (0x6174696f),
  ACE_NTOHL (0x6e506f6c),
  ACE_NTOHL (0x69637956),
  ACE_NTOHL (0x616c7565),
  ACE_NTOHL (0x3a322e33),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/ImplicitActivationPolicyValue:2.3
  30,
  ACE_NTOHL (0x496d706c),
  ACE_NTOHL (0x69636974),
  ACE_NTOHL (0x41637469),
  ACE_NTOHL (0x76617469),
  ACE_NTOHL (0x6f6e506f),
  ACE_NTOHL (0x6c696379),
  ACE_NTOHL (0x56616c75),
  ACE_NTOHL (0x65000000),  // name = ImplicitActivationPolicyValue
  2, // member count
  20,
  ACE_NTOHL (0x494d504c),
  ACE_NTOHL (0x49434954),
  ACE_NTOHL (0x5f414354),
  ACE_NTOHL (0x49564154),
  ACE_NTOHL (0x494f4e00),  // name = IMPLICIT_ACTIVATION
  23,
  ACE_NTOHL (0x4e4f5f49),
  ACE_NTOHL (0x4d504c49),
  ACE_NTOHL (0x4349545f),
  ACE_NTOHL (0x41435449),
  ACE_NTOHL (0x56415449),
  ACE_NTOHL (0x4f4e0000),  // name = NO_IMPLICIT_ACTIVATION
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ImplicitActivationPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_ImplicitActivationPolicyValue),
    (char *) &_oc_PortableServer_ImplicitActivationPolicyValue,
    0,
    sizeof (PortableServer::ImplicitActivationPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ImplicitActivationPolicyValue,
    &_tc_TAO_tc_PortableServer_ImplicitActivationPolicyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::ImplicitActivationPolicy::_tao_class_id = 0;

PortableServer::ImplicitActivationPolicy_ptr
PortableServer::tao_ImplicitActivationPolicy_life::tao_duplicate (
    PortableServer::ImplicitActivationPolicy_ptr p
  )
{
  return PortableServer::ImplicitActivationPolicy::_duplicate (p);
}

void
PortableServer::tao_ImplicitActivationPolicy_life::tao_release (
    PortableServer::ImplicitActivationPolicy_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::ImplicitActivationPolicy_ptr
PortableServer::tao_ImplicitActivationPolicy_life::tao_nil (
    void
  )
{
  return PortableServer::ImplicitActivationPolicy::_nil ();
}

CORBA::Boolean
PortableServer::tao_ImplicitActivationPolicy_life::tao_marshal (
    PortableServer::ImplicitActivationPolicy_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::ImplicitActivationPolicy_ptr
PortableServer::tao_ImplicitActivationPolicy_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::ImplicitActivationPolicy::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_ImplicitActivationPolicy_cast::tao_upcast (
    void *src
  )
{
  PortableServer::ImplicitActivationPolicy **tmp =
    ACE_static_cast (PortableServer::ImplicitActivationPolicy **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::ImplicitActivationPolicy,
        PortableServer::tao_ImplicitActivationPolicy_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::ImplicitActivationPolicy,
        PortableServer::tao_ImplicitActivationPolicy_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::ImplicitActivationPolicy, \
        PortableServer::tao_ImplicitActivationPolicy_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::ImplicitActivationPolicy, \
        PortableServer::tao_ImplicitActivationPolicy_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::ImplicitActivationPolicy::ImplicitActivationPolicy (void)
{}

PortableServer::ImplicitActivationPolicy::~ImplicitActivationPolicy (void)
{}

void
PortableServer::ImplicitActivationPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  ImplicitActivationPolicy *tmp = ACE_static_cast (ImplicitActivationPolicy *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ImplicitActivationPolicy::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ImplicitActivationPolicy::_nil ();
    }

  return
      ACE_reinterpret_cast (
          ImplicitActivationPolicy_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ImplicitActivationPolicy::_tao_class_id
                )
            )
        );
}

PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy::_duplicate (ImplicitActivationPolicy_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::ImplicitActivationPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, ImplicitActivationPolicy)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Policy::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Policy_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::ImplicitActivationPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ImplicitActivationPolicy:2.3";
}

CORBA::Boolean
PortableServer::ImplicitActivationPolicy::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ImplicitActivationPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  56,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f49),
  ACE_NTOHL (0x6d706c69),
  ACE_NTOHL (0x63697441),
  ACE_NTOHL (0x63746976),
  ACE_NTOHL (0x6174696f),
  ACE_NTOHL (0x6e506f6c),
  ACE_NTOHL (0x6963793a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/ImplicitActivationPolicy:2.3
    25,
  ACE_NTOHL (0x496d706c),
  ACE_NTOHL (0x69636974),
  ACE_NTOHL (0x41637469),
  ACE_NTOHL (0x76617469),
  ACE_NTOHL (0x6f6e506f),
  ACE_NTOHL (0x6c696379),
  ACE_NTOHL (0x0),  // name = ImplicitActivationPolicy
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ImplicitActivationPolicy (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_ImplicitActivationPolicy),
    (char *) &_oc_PortableServer_ImplicitActivationPolicy,
    0,
    sizeof (PortableServer::ImplicitActivationPolicy)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ImplicitActivationPolicy,
    &_tc_TAO_tc_PortableServer_ImplicitActivationPolicy
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ServantRetentionPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  59,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f53),
  ACE_NTOHL (0x65727661),
  ACE_NTOHL (0x6e745265),
  ACE_NTOHL (0x74656e74),
  ACE_NTOHL (0x696f6e50),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x7956616c),
  ACE_NTOHL (0x75653a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/ServantRetentionPolicyValue:2.3
  28,
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x616e7452),
  ACE_NTOHL (0x6574656e),
  ACE_NTOHL (0x74696f6e),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63795661),
  ACE_NTOHL (0x6c756500),  // name = ServantRetentionPolicyValue
  2, // member count
  7,
  ACE_NTOHL (0x52455441),
  ACE_NTOHL (0x494e0000),  // name = RETAIN
  11,
  ACE_NTOHL (0x4e4f4e5f),
  ACE_NTOHL (0x52455441),
  ACE_NTOHL (0x494e0000),  // name = NON_RETAIN
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantRetentionPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_ServantRetentionPolicyValue),
    (char *) &_oc_PortableServer_ServantRetentionPolicyValue,
    0,
    sizeof (PortableServer::ServantRetentionPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ServantRetentionPolicyValue,
    &_tc_TAO_tc_PortableServer_ServantRetentionPolicyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::ServantRetentionPolicy::_tao_class_id = 0;

PortableServer::ServantRetentionPolicy_ptr
PortableServer::tao_ServantRetentionPolicy_life::tao_duplicate (
    PortableServer::ServantRetentionPolicy_ptr p
  )
{
  return PortableServer::ServantRetentionPolicy::_duplicate (p);
}

void
PortableServer::tao_ServantRetentionPolicy_life::tao_release (
    PortableServer::ServantRetentionPolicy_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::ServantRetentionPolicy_ptr
PortableServer::tao_ServantRetentionPolicy_life::tao_nil (
    void
  )
{
  return PortableServer::ServantRetentionPolicy::_nil ();
}

CORBA::Boolean
PortableServer::tao_ServantRetentionPolicy_life::tao_marshal (
    PortableServer::ServantRetentionPolicy_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::ServantRetentionPolicy_ptr
PortableServer::tao_ServantRetentionPolicy_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::ServantRetentionPolicy::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_ServantRetentionPolicy_cast::tao_upcast (
    void *src
  )
{
  PortableServer::ServantRetentionPolicy **tmp =
    ACE_static_cast (PortableServer::ServantRetentionPolicy **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::ServantRetentionPolicy,
        PortableServer::tao_ServantRetentionPolicy_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::ServantRetentionPolicy,
        PortableServer::tao_ServantRetentionPolicy_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::ServantRetentionPolicy, \
        PortableServer::tao_ServantRetentionPolicy_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::ServantRetentionPolicy, \
        PortableServer::tao_ServantRetentionPolicy_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::ServantRetentionPolicy::ServantRetentionPolicy (void)
{}

PortableServer::ServantRetentionPolicy::~ServantRetentionPolicy (void)
{}

void
PortableServer::ServantRetentionPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  ServantRetentionPolicy *tmp = ACE_static_cast (ServantRetentionPolicy *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ServantRetentionPolicy::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ServantRetentionPolicy::_nil ();
    }

  return
      ACE_reinterpret_cast (
          ServantRetentionPolicy_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ServantRetentionPolicy::_tao_class_id
                )
            )
        );
}

PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy::_duplicate (ServantRetentionPolicy_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::ServantRetentionPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, ServantRetentionPolicy)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Policy::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Policy_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::ServantRetentionPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantRetentionPolicy:2.3";
}

CORBA::Boolean
PortableServer::ServantRetentionPolicy::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ServantRetentionPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f53),
  ACE_NTOHL (0x65727661),
  ACE_NTOHL (0x6e745265),
  ACE_NTOHL (0x74656e74),
  ACE_NTOHL (0x696f6e50),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x793a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/ServantRetentionPolicy:2.3
    23,
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x616e7452),
  ACE_NTOHL (0x6574656e),
  ACE_NTOHL (0x74696f6e),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63790000),  // name = ServantRetentionPolicy
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantRetentionPolicy (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_ServantRetentionPolicy),
    (char *) &_oc_PortableServer_ServantRetentionPolicy,
    0,
    sizeof (PortableServer::ServantRetentionPolicy)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ServantRetentionPolicy,
    &_tc_TAO_tc_PortableServer_ServantRetentionPolicy
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_RequestProcessingPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  60,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f52),
  ACE_NTOHL (0x65717565),
  ACE_NTOHL (0x73745072),
  ACE_NTOHL (0x6f636573),
  ACE_NTOHL (0x73696e67),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63795661),
  ACE_NTOHL (0x6c75653a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/RequestProcessingPolicyValue:2.3
  29,
  ACE_NTOHL (0x52657175),
  ACE_NTOHL (0x65737450),
  ACE_NTOHL (0x726f6365),
  ACE_NTOHL (0x7373696e),
  ACE_NTOHL (0x67506f6c),
  ACE_NTOHL (0x69637956),
  ACE_NTOHL (0x616c7565),
  ACE_NTOHL (0x0),  // name = RequestProcessingPolicyValue
  3, // member count
  27,
  ACE_NTOHL (0x5553455f),
  ACE_NTOHL (0x41435449),
  ACE_NTOHL (0x56455f4f),
  ACE_NTOHL (0x424a4543),
  ACE_NTOHL (0x545f4d41),
  ACE_NTOHL (0x505f4f4e),
  ACE_NTOHL (0x4c590000),  // name = USE_ACTIVE_OBJECT_MAP_ONLY
  20,
  ACE_NTOHL (0x5553455f),
  ACE_NTOHL (0x44454641),
  ACE_NTOHL (0x554c545f),
  ACE_NTOHL (0x53455256),
  ACE_NTOHL (0x414e5400),  // name = USE_DEFAULT_SERVANT
  20,
  ACE_NTOHL (0x5553455f),
  ACE_NTOHL (0x53455256),
  ACE_NTOHL (0x414e545f),
  ACE_NTOHL (0x4d414e41),
  ACE_NTOHL (0x47455200),  // name = USE_SERVANT_MANAGER
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_RequestProcessingPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_RequestProcessingPolicyValue),
    (char *) &_oc_PortableServer_RequestProcessingPolicyValue,
    0,
    sizeof (PortableServer::RequestProcessingPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_RequestProcessingPolicyValue,
    &_tc_TAO_tc_PortableServer_RequestProcessingPolicyValue
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::RequestProcessingPolicy::_tao_class_id = 0;

PortableServer::RequestProcessingPolicy_ptr
PortableServer::tao_RequestProcessingPolicy_life::tao_duplicate (
    PortableServer::RequestProcessingPolicy_ptr p
  )
{
  return PortableServer::RequestProcessingPolicy::_duplicate (p);
}

void
PortableServer::tao_RequestProcessingPolicy_life::tao_release (
    PortableServer::RequestProcessingPolicy_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::RequestProcessingPolicy_ptr
PortableServer::tao_RequestProcessingPolicy_life::tao_nil (
    void
  )
{
  return PortableServer::RequestProcessingPolicy::_nil ();
}

CORBA::Boolean
PortableServer::tao_RequestProcessingPolicy_life::tao_marshal (
    PortableServer::RequestProcessingPolicy_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::RequestProcessingPolicy_ptr
PortableServer::tao_RequestProcessingPolicy_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::RequestProcessingPolicy::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_RequestProcessingPolicy_cast::tao_upcast (
    void *src
  )
{
  PortableServer::RequestProcessingPolicy **tmp =
    ACE_static_cast (PortableServer::RequestProcessingPolicy **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::RequestProcessingPolicy,
        PortableServer::tao_RequestProcessingPolicy_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::RequestProcessingPolicy,
        PortableServer::tao_RequestProcessingPolicy_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::RequestProcessingPolicy, \
        PortableServer::tao_RequestProcessingPolicy_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::RequestProcessingPolicy, \
        PortableServer::tao_RequestProcessingPolicy_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::RequestProcessingPolicy::RequestProcessingPolicy (void)
{}

PortableServer::RequestProcessingPolicy::~RequestProcessingPolicy (void)
{}

void
PortableServer::RequestProcessingPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  RequestProcessingPolicy *tmp = ACE_static_cast (RequestProcessingPolicy *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return RequestProcessingPolicy::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return RequestProcessingPolicy::_nil ();
    }

  return
      ACE_reinterpret_cast (
          RequestProcessingPolicy_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &RequestProcessingPolicy::_tao_class_id
                )
            )
        );
}

PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy::_duplicate (RequestProcessingPolicy_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::RequestProcessingPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, RequestProcessingPolicy)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Policy::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Policy_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::RequestProcessingPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/RequestProcessingPolicy:2.3";
}

CORBA::Boolean
PortableServer::RequestProcessingPolicy::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_RequestProcessingPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f52),
  ACE_NTOHL (0x65717565),
  ACE_NTOHL (0x73745072),
  ACE_NTOHL (0x6f636573),
  ACE_NTOHL (0x73696e67),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63793a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/RequestProcessingPolicy:2.3
    24,
  ACE_NTOHL (0x52657175),
  ACE_NTOHL (0x65737450),
  ACE_NTOHL (0x726f6365),
  ACE_NTOHL (0x7373696e),
  ACE_NTOHL (0x67506f6c),
  ACE_NTOHL (0x69637900),  // name = RequestProcessingPolicy
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_RequestProcessingPolicy (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_RequestProcessingPolicy),
    (char *) &_oc_PortableServer_RequestProcessingPolicy,
    0,
    sizeof (PortableServer::RequestProcessingPolicy)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_RequestProcessingPolicy,
    &_tc_TAO_tc_PortableServer_RequestProcessingPolicy
  )
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::POAManager::_tao_class_id = 0;

PortableServer::POAManager_ptr
PortableServer::tao_POAManager_life::tao_duplicate (
    PortableServer::POAManager_ptr p
  )
{
  return PortableServer::POAManager::_duplicate (p);
}

void
PortableServer::tao_POAManager_life::tao_release (
    PortableServer::POAManager_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::POAManager_ptr
PortableServer::tao_POAManager_life::tao_nil (
    void
  )
{
  return PortableServer::POAManager::_nil ();
}

CORBA::Boolean
PortableServer::tao_POAManager_life::tao_marshal (
    PortableServer::POAManager_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::POAManager_ptr
PortableServer::tao_POAManager_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::POAManager::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_POAManager_cast::tao_upcast (
    void *src
  )
{
  PortableServer::POAManager **tmp =
    ACE_static_cast (PortableServer::POAManager **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::POAManager,
        PortableServer::tao_POAManager_life
      >;

template class TAO_Seq_Var_Base_T<PortableServer::POAList,
    TAO_Object_Manager<PortableServer::POA,
                       TAO_Objref_Var_T<PortableServer::POA,
                                        PortableServer::tao_POA_life>,
                       PortableServer::tao_POA_life> >;
template class
    TAO_Objref_Out_T<
        PortableServer::POAManager,
        PortableServer::tao_POAManager_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::POAManager, \
        PortableServer::tao_POAManager_life \
      >

# pragma instantiate TAO_Seq_Var_Base_T<PortableServer::POAList,
      TAO_Object_Manager<PortableServer::POA,
                         TAO_Objref_Var_T<PortableServer::POA,
                                          PortableServer::tao_POA_life>,
                         PortableServer::tao_POA_life> >

# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::POAManager, \
        PortableServer::tao_POAManager_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::POAManager::POAManager (void)
{}

PortableServer::POAManager::~POAManager (void)
{}

void
PortableServer::POAManager::_tao_any_destructor (void *_tao_void_pointer)
{
  POAManager *tmp = ACE_static_cast (POAManager *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::POAManager_ptr
PortableServer::POAManager::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return POAManager::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::POAManager_ptr
PortableServer::POAManager::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return POAManager::_nil ();
    }

  return
      ACE_reinterpret_cast (
          POAManager_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &POAManager::_tao_class_id
                )
            )
        );
}

PortableServer::POAManager_ptr
PortableServer::POAManager::_duplicate (POAManager_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::POAManager::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, POAManager)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::POAManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/POAManager:2.3";
}

CORBA::Boolean
PortableServer::POAManager::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POAManager::AdapterInactive::AdapterInactive (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POAManager/AdapterInactive:2.3",
        "AdapterInactive"
      )
{
}

PortableServer::POAManager::AdapterInactive::~AdapterInactive (void)
{
}

PortableServer::POAManager::AdapterInactive::AdapterInactive (const ::PortableServer::POAManager::AdapterInactive &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POAManager::AdapterInactive&
PortableServer::POAManager::AdapterInactive::operator= (const ::PortableServer::POAManager::AdapterInactive &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POAManager::AdapterInactive::_tao_any_destructor (void *_tao_void_pointer)
{
  AdapterInactive *tmp = ACE_static_cast (AdapterInactive*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POAManager::AdapterInactive *
PortableServer::POAManager::AdapterInactive::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POAManager/AdapterInactive:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (AdapterInactive *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POAManager::AdapterInactive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POAManager::AdapterInactive, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POAManager::AdapterInactive::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POAManager::AdapterInactive (*this),
      0
    );
  return result;
}

void PortableServer::POAManager::AdapterInactive::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POAManager::AdapterInactive::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POAManager::AdapterInactive::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POAManager::AdapterInactive::_type (void) const
{
  return ::PortableServer::POAManager::_tc_AdapterInactive;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POAManager_AdapterInactive[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  58,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f414d61),
  ACE_NTOHL (0x6e616765),
  ACE_NTOHL (0x722f4164),
  ACE_NTOHL (0x61707465),
  ACE_NTOHL (0x72496e61),
  ACE_NTOHL (0x63746976),
  ACE_NTOHL (0x653a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/POAManager/AdapterInactive:2.3
    16,
  ACE_NTOHL (0x41646170),
  ACE_NTOHL (0x74657249),
  ACE_NTOHL (0x6e616374),
  ACE_NTOHL (0x69766500),  // name = AdapterInactive
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POAManager_AdapterInactive (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POAManager_AdapterInactive),
    (char *) &_oc_PortableServer_POAManager_AdapterInactive,
    0,
    sizeof (PortableServer::POAManager::AdapterInactive)
  );

::CORBA::TypeCode_ptr PortableServer::POAManager::_tc_AdapterInactive =
  &_tc_TAO_tc_PortableServer_POAManager_AdapterInactive;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POAManager[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  42,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f414d61),
  ACE_NTOHL (0x6e616765),
  ACE_NTOHL (0x723a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/POAManager:2.3
    11,
  ACE_NTOHL (0x504f414d),
  ACE_NTOHL (0x616e6167),
  ACE_NTOHL (0x65720000),  // name = POAManager
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POAManager (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_POAManager),
    (char *) &_oc_PortableServer_POAManager,
    0,
    sizeof (PortableServer::POAManager)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_POAManager,
    &_tc_TAO_tc_PortableServer_POAManager
  )
TAO_NAMESPACE_END

#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::AdapterActivator::_tao_class_id = 0;

PortableServer::AdapterActivator_ptr
PortableServer::tao_AdapterActivator_life::tao_duplicate (
    PortableServer::AdapterActivator_ptr p
  )
{
  return PortableServer::AdapterActivator::_duplicate (p);
}

void
PortableServer::tao_AdapterActivator_life::tao_release (
    PortableServer::AdapterActivator_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::AdapterActivator_ptr
PortableServer::tao_AdapterActivator_life::tao_nil (
    void
  )
{
  return PortableServer::AdapterActivator::_nil ();
}

CORBA::Boolean
PortableServer::tao_AdapterActivator_life::tao_marshal (
    PortableServer::AdapterActivator_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::AdapterActivator_ptr
PortableServer::tao_AdapterActivator_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::AdapterActivator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_AdapterActivator_cast::tao_upcast (
    void *src
  )
{
  PortableServer::AdapterActivator **tmp =
    ACE_static_cast (PortableServer::AdapterActivator **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::AdapterActivator,
        PortableServer::tao_AdapterActivator_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::AdapterActivator,
        PortableServer::tao_AdapterActivator_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::AdapterActivator, \
        PortableServer::tao_AdapterActivator_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::AdapterActivator, \
        PortableServer::tao_AdapterActivator_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::AdapterActivator::AdapterActivator (void)
{}

PortableServer::AdapterActivator::~AdapterActivator (void)
{}

void
PortableServer::AdapterActivator::_tao_any_destructor (void *_tao_void_pointer)
{
  AdapterActivator *tmp = ACE_static_cast (AdapterActivator *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return AdapterActivator::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return AdapterActivator::_nil ();
    }

  return
      ACE_reinterpret_cast (
          AdapterActivator_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &AdapterActivator::_tao_class_id
                )
            )
        );
}

PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator::_duplicate (AdapterActivator_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::AdapterActivator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, AdapterActivator)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::AdapterActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/AdapterActivator:2.3";
}

CORBA::Boolean
PortableServer::AdapterActivator::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_AdapterActivator[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f41),
  ACE_NTOHL (0x64617074),
  ACE_NTOHL (0x65724163),
  ACE_NTOHL (0x74697661),
  ACE_NTOHL (0x746f723a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/AdapterActivator:2.3
    17,
  ACE_NTOHL (0x41646170),
  ACE_NTOHL (0x74657241),
  ACE_NTOHL (0x63746976),
  ACE_NTOHL (0x61746f72),
  ACE_NTOHL (0x0),  // name = AdapterActivator
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_AdapterActivator (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_AdapterActivator),
    (char *) &_oc_PortableServer_AdapterActivator,
    0,
    sizeof (PortableServer::AdapterActivator)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_AdapterActivator,
    &_tc_TAO_tc_PortableServer_AdapterActivator
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::ServantManager::_tao_class_id = 0;

PortableServer::ServantManager_ptr
PortableServer::tao_ServantManager_life::tao_duplicate (
    PortableServer::ServantManager_ptr p
  )
{
  return PortableServer::ServantManager::_duplicate (p);
}

void
PortableServer::tao_ServantManager_life::tao_release (
    PortableServer::ServantManager_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::ServantManager_ptr
PortableServer::tao_ServantManager_life::tao_nil (
    void
  )
{
  return PortableServer::ServantManager::_nil ();
}

CORBA::Boolean
PortableServer::tao_ServantManager_life::tao_marshal (
    PortableServer::ServantManager_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::ServantManager_ptr
PortableServer::tao_ServantManager_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::ServantManager::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_ServantManager_cast::tao_upcast (
    void *src
  )
{
  PortableServer::ServantManager **tmp =
    ACE_static_cast (PortableServer::ServantManager **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::ServantManager,
        PortableServer::tao_ServantManager_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::ServantManager,
        PortableServer::tao_ServantManager_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::ServantManager, \
        PortableServer::tao_ServantManager_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::ServantManager, \
        PortableServer::tao_ServantManager_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::ServantManager::ServantManager (void)
{}

PortableServer::ServantManager::~ServantManager (void)
{}

void
PortableServer::ServantManager::_tao_any_destructor (void *_tao_void_pointer)
{
  ServantManager *tmp = ACE_static_cast (ServantManager *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::ServantManager_ptr
PortableServer::ServantManager::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ServantManager::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::ServantManager_ptr
PortableServer::ServantManager::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ServantManager::_nil ();
    }

  return
      ACE_reinterpret_cast (
          ServantManager_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ServantManager::_tao_class_id
                )
            )
        );
}

PortableServer::ServantManager_ptr
PortableServer::ServantManager::_duplicate (ServantManager_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::ServantManager::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, ServantManager)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::ServantManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantManager:2.3";
}

CORBA::Boolean
PortableServer::ServantManager::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ServantManager[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f53),
  ACE_NTOHL (0x65727661),
  ACE_NTOHL (0x6e744d61),
  ACE_NTOHL (0x6e616765),
  ACE_NTOHL (0x723a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/ServantManager:2.3
    15,
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x616e744d),
  ACE_NTOHL (0x616e6167),
  ACE_NTOHL (0x65720000),  // name = ServantManager
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantManager (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_ServantManager),
    (char *) &_oc_PortableServer_ServantManager,
    0,
    sizeof (PortableServer::ServantManager)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ServantManager,
    &_tc_TAO_tc_PortableServer_ServantManager
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::ServantActivator::_tao_class_id = 0;

PortableServer::ServantActivator_ptr
PortableServer::tao_ServantActivator_life::tao_duplicate (
    PortableServer::ServantActivator_ptr p
  )
{
  return PortableServer::ServantActivator::_duplicate (p);
}

void
PortableServer::tao_ServantActivator_life::tao_release (
    PortableServer::ServantActivator_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::ServantActivator_ptr
PortableServer::tao_ServantActivator_life::tao_nil (
    void
  )
{
  return PortableServer::ServantActivator::_nil ();
}

CORBA::Boolean
PortableServer::tao_ServantActivator_life::tao_marshal (
    PortableServer::ServantActivator_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::ServantActivator_ptr
PortableServer::tao_ServantActivator_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::ServantActivator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_ServantActivator_cast::tao_upcast (
    void *src
  )
{
  PortableServer::ServantActivator **tmp =
    ACE_static_cast (PortableServer::ServantActivator **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::ServantActivator,
        PortableServer::tao_ServantActivator_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::ServantActivator,
        PortableServer::tao_ServantActivator_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::ServantActivator, \
        PortableServer::tao_ServantActivator_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::ServantActivator, \
        PortableServer::tao_ServantActivator_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::ServantActivator::ServantActivator (void)
{}

PortableServer::ServantActivator::~ServantActivator (void)
{}

void
PortableServer::ServantActivator::_tao_any_destructor (void *_tao_void_pointer)
{
  ServantActivator *tmp = ACE_static_cast (ServantActivator *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::ServantActivator_ptr
PortableServer::ServantActivator::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ServantActivator::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::ServantActivator_ptr
PortableServer::ServantActivator::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ServantActivator::_nil ();
    }

  return
      ACE_reinterpret_cast (
          ServantActivator_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ServantActivator::_tao_class_id
                )
            )
        );
}

PortableServer::ServantActivator_ptr
PortableServer::ServantActivator::_duplicate (ServantActivator_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::ServantActivator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, ServantActivator)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, ServantManager)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                PortableServer::ServantManager_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::ServantActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantActivator:2.3";
}

CORBA::Boolean
PortableServer::ServantActivator::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ServantActivator[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f53),
  ACE_NTOHL (0x65727661),
  ACE_NTOHL (0x6e744163),
  ACE_NTOHL (0x74697661),
  ACE_NTOHL (0x746f723a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/ServantActivator:2.3
    17,
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x616e7441),
  ACE_NTOHL (0x63746976),
  ACE_NTOHL (0x61746f72),
  ACE_NTOHL (0x0),  // name = ServantActivator
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantActivator (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_ServantActivator),
    (char *) &_oc_PortableServer_ServantActivator,
    0,
    sizeof (PortableServer::ServantActivator)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ServantActivator,
    &_tc_TAO_tc_PortableServer_ServantActivator
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::ServantLocator::_tao_class_id = 0;

PortableServer::ServantLocator_ptr
PortableServer::tao_ServantLocator_life::tao_duplicate (
    PortableServer::ServantLocator_ptr p
  )
{
  return PortableServer::ServantLocator::_duplicate (p);
}

void
PortableServer::tao_ServantLocator_life::tao_release (
    PortableServer::ServantLocator_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::ServantLocator_ptr
PortableServer::tao_ServantLocator_life::tao_nil (
    void
  )
{
  return PortableServer::ServantLocator::_nil ();
}

CORBA::Boolean
PortableServer::tao_ServantLocator_life::tao_marshal (
    PortableServer::ServantLocator_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::ServantLocator_ptr
PortableServer::tao_ServantLocator_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::ServantLocator::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_ServantLocator_cast::tao_upcast (
    void *src
  )
{
  PortableServer::ServantLocator **tmp =
    ACE_static_cast (PortableServer::ServantLocator **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::ServantLocator,
        PortableServer::tao_ServantLocator_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::ServantLocator,
        PortableServer::tao_ServantLocator_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::ServantLocator, \
        PortableServer::tao_ServantLocator_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::ServantLocator, \
        PortableServer::tao_ServantLocator_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::ServantLocator::ServantLocator (void)
{}

PortableServer::ServantLocator::~ServantLocator (void)
{}

void
PortableServer::ServantLocator::_tao_any_destructor (void *_tao_void_pointer)
{
  ServantLocator *tmp = ACE_static_cast (ServantLocator *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::ServantLocator_ptr
PortableServer::ServantLocator::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return ServantLocator::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::ServantLocator_ptr
PortableServer::ServantLocator::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return ServantLocator::_nil ();
    }

  return
      ACE_reinterpret_cast (
          ServantLocator_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &ServantLocator::_tao_class_id
                )
            )
        );
}

PortableServer::ServantLocator_ptr
PortableServer::ServantLocator::_duplicate (ServantLocator_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::ServantLocator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, ServantLocator)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, ServantManager)::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                PortableServer::ServantManager_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::ServantLocator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantLocator:2.3";
}

CORBA::Boolean
PortableServer::ServantLocator::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_ServantLocator[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f53),
  ACE_NTOHL (0x65727661),
  ACE_NTOHL (0x6e744c6f),
  ACE_NTOHL (0x6361746f),
  ACE_NTOHL (0x723a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/ServantLocator:2.3
    15,
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x616e744c),
  ACE_NTOHL (0x6f636174),
  ACE_NTOHL (0x6f720000),  // name = ServantLocator
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantLocator (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_ServantLocator),
    (char *) &_oc_PortableServer_ServantLocator,
    0,
    sizeof (PortableServer::ServantLocator)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_ServantLocator,
    &_tc_TAO_tc_PortableServer_ServantLocator
  )
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::POA::_tao_class_id = 0;

PortableServer::POA_ptr
PortableServer::tao_POA_life::tao_duplicate (
    PortableServer::POA_ptr p
  )
{
  return PortableServer::POA::_duplicate (p);
}

void
PortableServer::tao_POA_life::tao_release (
    PortableServer::POA_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::POA_ptr
PortableServer::tao_POA_life::tao_nil (
    void
  )
{
  return PortableServer::POA::_nil ();
}

CORBA::Boolean
PortableServer::tao_POA_life::tao_marshal (
    PortableServer::POA_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::POA_ptr
PortableServer::tao_POA_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::POA::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_POA_cast::tao_upcast (
    void *src
  )
{
  PortableServer::POA **tmp =
    ACE_static_cast (PortableServer::POA **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::POA,
        PortableServer::tao_POA_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::POA,
        PortableServer::tao_POA_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::POA, \
        PortableServer::tao_POA_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::POA, \
        PortableServer::tao_POA_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::POA::POA (void)
{}

PortableServer::POA::~POA (void)
{}

void
PortableServer::POA::_tao_any_destructor (void *_tao_void_pointer)
{
  POA *tmp = ACE_static_cast (POA *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::POA_ptr
PortableServer::POA::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return POA::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::POA_ptr
PortableServer::POA::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return POA::_nil ();
    }

  return
      ACE_reinterpret_cast (
          POA_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &POA::_tao_class_id
                )
            )
        );
}

PortableServer::POA_ptr
PortableServer::POA::_duplicate (POA_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::POA::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, POA)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::POA::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/POA:2.3";
}

CORBA::Boolean
PortableServer::POA::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::AdapterAlreadyExists::AdapterAlreadyExists (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/AdapterAlreadyExists:2.3",
        "AdapterAlreadyExists"
      )
{
}

PortableServer::POA::AdapterAlreadyExists::~AdapterAlreadyExists (void)
{
}

PortableServer::POA::AdapterAlreadyExists::AdapterAlreadyExists (const ::PortableServer::POA::AdapterAlreadyExists &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::AdapterAlreadyExists&
PortableServer::POA::AdapterAlreadyExists::operator= (const ::PortableServer::POA::AdapterAlreadyExists &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::AdapterAlreadyExists::_tao_any_destructor (void *_tao_void_pointer)
{
  AdapterAlreadyExists *tmp = ACE_static_cast (AdapterAlreadyExists*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::AdapterAlreadyExists *
PortableServer::POA::AdapterAlreadyExists::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/AdapterAlreadyExists:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (AdapterAlreadyExists *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::AdapterAlreadyExists::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::AdapterAlreadyExists, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::AdapterAlreadyExists::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::AdapterAlreadyExists (*this),
      0
    );
  return result;
}

void PortableServer::POA::AdapterAlreadyExists::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::AdapterAlreadyExists::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::AdapterAlreadyExists::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::AdapterAlreadyExists::_type (void) const
{
  return ::PortableServer::POA::_tc_AdapterAlreadyExists;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_AdapterAlreadyExists[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  56,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f41),
  ACE_NTOHL (0x64617074),
  ACE_NTOHL (0x6572416c),
  ACE_NTOHL (0x72656164),
  ACE_NTOHL (0x79457869),
  ACE_NTOHL (0x7374733a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/POA/AdapterAlreadyExists:2.3
    21,
  ACE_NTOHL (0x41646170),
  ACE_NTOHL (0x74657241),
  ACE_NTOHL (0x6c726561),
  ACE_NTOHL (0x64794578),
  ACE_NTOHL (0x69737473),
  ACE_NTOHL (0x0),  // name = AdapterAlreadyExists
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_AdapterAlreadyExists (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_AdapterAlreadyExists),
    (char *) &_oc_PortableServer_POA_AdapterAlreadyExists,
    0,
    sizeof (PortableServer::POA::AdapterAlreadyExists)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_AdapterAlreadyExists =
  &_tc_TAO_tc_PortableServer_POA_AdapterAlreadyExists;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::AdapterNonExistent::AdapterNonExistent (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/AdapterNonExistent:2.3",
        "AdapterNonExistent"
      )
{
}

PortableServer::POA::AdapterNonExistent::~AdapterNonExistent (void)
{
}

PortableServer::POA::AdapterNonExistent::AdapterNonExistent (const ::PortableServer::POA::AdapterNonExistent &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::AdapterNonExistent&
PortableServer::POA::AdapterNonExistent::operator= (const ::PortableServer::POA::AdapterNonExistent &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::AdapterNonExistent::_tao_any_destructor (void *_tao_void_pointer)
{
  AdapterNonExistent *tmp = ACE_static_cast (AdapterNonExistent*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::AdapterNonExistent *
PortableServer::POA::AdapterNonExistent::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/AdapterNonExistent:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (AdapterNonExistent *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::AdapterNonExistent::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::AdapterNonExistent, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::AdapterNonExistent::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::AdapterNonExistent (*this),
      0
    );
  return result;
}

void PortableServer::POA::AdapterNonExistent::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::AdapterNonExistent::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::AdapterNonExistent::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::AdapterNonExistent::_type (void) const
{
  return ::PortableServer::POA::_tc_AdapterNonExistent;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_AdapterNonExistent[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  54,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f41),
  ACE_NTOHL (0x64617074),
  ACE_NTOHL (0x65724e6f),
  ACE_NTOHL (0x6e457869),
  ACE_NTOHL (0x7374656e),
  ACE_NTOHL (0x743a322e),
  ACE_NTOHL (0x33000000),  // repository ID = IDL:omg.org/PortableServer/POA/AdapterNonExistent:2.3
    19,
  ACE_NTOHL (0x41646170),
  ACE_NTOHL (0x7465724e),
  ACE_NTOHL (0x6f6e4578),
  ACE_NTOHL (0x69737465),
  ACE_NTOHL (0x6e740000),  // name = AdapterNonExistent
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_AdapterNonExistent (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_AdapterNonExistent),
    (char *) &_oc_PortableServer_POA_AdapterNonExistent,
    0,
    sizeof (PortableServer::POA::AdapterNonExistent)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_AdapterNonExistent =
  &_tc_TAO_tc_PortableServer_POA_AdapterNonExistent;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::InvalidPolicy::InvalidPolicy (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/InvalidPolicy:2.3",
        "InvalidPolicy"
      )
{
}

PortableServer::POA::InvalidPolicy::~InvalidPolicy (void)
{
}

PortableServer::POA::InvalidPolicy::InvalidPolicy (const ::PortableServer::POA::InvalidPolicy &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->index = _tao_excp.index;
}

PortableServer::POA::InvalidPolicy&
PortableServer::POA::InvalidPolicy::operator= (const ::PortableServer::POA::InvalidPolicy &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  this->index = _tao_excp.index;
  return *this;
}

void PortableServer::POA::InvalidPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  InvalidPolicy *tmp = ACE_static_cast (InvalidPolicy*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::InvalidPolicy *
PortableServer::POA::InvalidPolicy::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/InvalidPolicy:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (InvalidPolicy *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::InvalidPolicy::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::InvalidPolicy, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::InvalidPolicy::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::InvalidPolicy (*this),
      0
    );
  return result;
}

void PortableServer::POA::InvalidPolicy::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::InvalidPolicy::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::InvalidPolicy::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}



// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_ctor.cpp:66

PortableServer::POA::InvalidPolicy::InvalidPolicy (
    CORBA::UShort _tao_index
  )  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/InvalidPolicy:2.3",
        "InvalidPolicy"
      )
{
  this->index = _tao_index;
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::InvalidPolicy::_type (void) const
{
  return ::PortableServer::POA::_tc_InvalidPolicy;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_InvalidPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f49),
  ACE_NTOHL (0x6e76616c),
  ACE_NTOHL (0x6964506f),
  ACE_NTOHL (0x6c696379),
  ACE_NTOHL (0x3a322e33),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/POA/InvalidPolicy:2.3
    14,
  ACE_NTOHL (0x496e7661),
  ACE_NTOHL (0x6c696450),
  ACE_NTOHL (0x6f6c6963),
  ACE_NTOHL (0x79000000),  // name = InvalidPolicy
  1, // member count
    6,
  ACE_NTOHL (0x696e6465),
  ACE_NTOHL (0x78000000),  // name = index
    CORBA::tk_ushort,

};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_InvalidPolicy (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_InvalidPolicy),
    (char *) &_oc_PortableServer_POA_InvalidPolicy,
    0,
    sizeof (PortableServer::POA::InvalidPolicy)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_InvalidPolicy =
  &_tc_TAO_tc_PortableServer_POA_InvalidPolicy;

#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::NoServant::NoServant (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/NoServant:2.3",
        "NoServant"
      )
{
}

PortableServer::POA::NoServant::~NoServant (void)
{
}

PortableServer::POA::NoServant::NoServant (const ::PortableServer::POA::NoServant &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::NoServant&
PortableServer::POA::NoServant::operator= (const ::PortableServer::POA::NoServant &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::NoServant::_tao_any_destructor (void *_tao_void_pointer)
{
  NoServant *tmp = ACE_static_cast (NoServant*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::NoServant *
PortableServer::POA::NoServant::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/NoServant:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (NoServant *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::NoServant::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::NoServant, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::NoServant::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::NoServant (*this),
      0
    );
  return result;
}

void PortableServer::POA::NoServant::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::NoServant::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::NoServant::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::NoServant::_type (void) const
{
  return ::PortableServer::POA::_tc_NoServant;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_NoServant[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f4e),
  ACE_NTOHL (0x6f536572),
  ACE_NTOHL (0x76616e74),
  ACE_NTOHL (0x3a322e33),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/POA/NoServant:2.3
    10,
  ACE_NTOHL (0x4e6f5365),
  ACE_NTOHL (0x7276616e),
  ACE_NTOHL (0x74000000),  // name = NoServant
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_NoServant (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_NoServant),
    (char *) &_oc_PortableServer_POA_NoServant,
    0,
    sizeof (PortableServer::POA::NoServant)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_NoServant =
  &_tc_TAO_tc_PortableServer_POA_NoServant;

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::ObjectAlreadyActive::ObjectAlreadyActive (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/ObjectAlreadyActive:2.3",
        "ObjectAlreadyActive"
      )
{
}

PortableServer::POA::ObjectAlreadyActive::~ObjectAlreadyActive (void)
{
}

PortableServer::POA::ObjectAlreadyActive::ObjectAlreadyActive (const ::PortableServer::POA::ObjectAlreadyActive &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::ObjectAlreadyActive&
PortableServer::POA::ObjectAlreadyActive::operator= (const ::PortableServer::POA::ObjectAlreadyActive &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::ObjectAlreadyActive::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectAlreadyActive *tmp = ACE_static_cast (ObjectAlreadyActive*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::ObjectAlreadyActive *
PortableServer::POA::ObjectAlreadyActive::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ObjectAlreadyActive:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (ObjectAlreadyActive *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::ObjectAlreadyActive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::ObjectAlreadyActive, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::ObjectAlreadyActive::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::ObjectAlreadyActive (*this),
      0
    );
  return result;
}

void PortableServer::POA::ObjectAlreadyActive::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::ObjectAlreadyActive::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::ObjectAlreadyActive::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::ObjectAlreadyActive::_type (void) const
{
  return ::PortableServer::POA::_tc_ObjectAlreadyActive;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_ObjectAlreadyActive[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f4f),
  ACE_NTOHL (0x626a6563),
  ACE_NTOHL (0x74416c72),
  ACE_NTOHL (0x65616479),
  ACE_NTOHL (0x41637469),
  ACE_NTOHL (0x76653a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/POA/ObjectAlreadyActive:2.3
    20,
  ACE_NTOHL (0x4f626a65),
  ACE_NTOHL (0x6374416c),
  ACE_NTOHL (0x72656164),
  ACE_NTOHL (0x79416374),
  ACE_NTOHL (0x69766500),  // name = ObjectAlreadyActive
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_ObjectAlreadyActive (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_ObjectAlreadyActive),
    (char *) &_oc_PortableServer_POA_ObjectAlreadyActive,
    0,
    sizeof (PortableServer::POA::ObjectAlreadyActive)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_ObjectAlreadyActive =
  &_tc_TAO_tc_PortableServer_POA_ObjectAlreadyActive;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::ObjectNotActive::ObjectNotActive (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/ObjectNotActive:2.3",
        "ObjectNotActive"
      )
{
}

PortableServer::POA::ObjectNotActive::~ObjectNotActive (void)
{
}

PortableServer::POA::ObjectNotActive::ObjectNotActive (const ::PortableServer::POA::ObjectNotActive &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::ObjectNotActive&
PortableServer::POA::ObjectNotActive::operator= (const ::PortableServer::POA::ObjectNotActive &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::ObjectNotActive::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectNotActive *tmp = ACE_static_cast (ObjectNotActive*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::ObjectNotActive *
PortableServer::POA::ObjectNotActive::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ObjectNotActive:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (ObjectNotActive *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::ObjectNotActive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::ObjectNotActive, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::ObjectNotActive::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::ObjectNotActive (*this),
      0
    );
  return result;
}

void PortableServer::POA::ObjectNotActive::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::ObjectNotActive::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::ObjectNotActive::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::ObjectNotActive::_type (void) const
{
  return ::PortableServer::POA::_tc_ObjectNotActive;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_ObjectNotActive[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f4f),
  ACE_NTOHL (0x626a6563),
  ACE_NTOHL (0x744e6f74),
  ACE_NTOHL (0x41637469),
  ACE_NTOHL (0x76653a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/POA/ObjectNotActive:2.3
    16,
  ACE_NTOHL (0x4f626a65),
  ACE_NTOHL (0x63744e6f),
  ACE_NTOHL (0x74416374),
  ACE_NTOHL (0x69766500),  // name = ObjectNotActive
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_ObjectNotActive (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_ObjectNotActive),
    (char *) &_oc_PortableServer_POA_ObjectNotActive,
    0,
    sizeof (PortableServer::POA::ObjectNotActive)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_ObjectNotActive =
  &_tc_TAO_tc_PortableServer_POA_ObjectNotActive;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::ServantAlreadyActive::ServantAlreadyActive (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/ServantAlreadyActive:2.3",
        "ServantAlreadyActive"
      )
{
}

PortableServer::POA::ServantAlreadyActive::~ServantAlreadyActive (void)
{
}

PortableServer::POA::ServantAlreadyActive::ServantAlreadyActive (const ::PortableServer::POA::ServantAlreadyActive &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::ServantAlreadyActive&
PortableServer::POA::ServantAlreadyActive::operator= (const ::PortableServer::POA::ServantAlreadyActive &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::ServantAlreadyActive::_tao_any_destructor (void *_tao_void_pointer)
{
  ServantAlreadyActive *tmp = ACE_static_cast (ServantAlreadyActive*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::ServantAlreadyActive *
PortableServer::POA::ServantAlreadyActive::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ServantAlreadyActive:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (ServantAlreadyActive *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::ServantAlreadyActive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::ServantAlreadyActive, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::ServantAlreadyActive::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::ServantAlreadyActive (*this),
      0
    );
  return result;
}

void PortableServer::POA::ServantAlreadyActive::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::ServantAlreadyActive::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::ServantAlreadyActive::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::ServantAlreadyActive::_type (void) const
{
  return ::PortableServer::POA::_tc_ServantAlreadyActive;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_ServantAlreadyActive[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  56,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f53),
  ACE_NTOHL (0x65727661),
  ACE_NTOHL (0x6e74416c),
  ACE_NTOHL (0x72656164),
  ACE_NTOHL (0x79416374),
  ACE_NTOHL (0x6976653a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/POA/ServantAlreadyActive:2.3
    21,
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x616e7441),
  ACE_NTOHL (0x6c726561),
  ACE_NTOHL (0x64794163),
  ACE_NTOHL (0x74697665),
  ACE_NTOHL (0x0),  // name = ServantAlreadyActive
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_ServantAlreadyActive (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_ServantAlreadyActive),
    (char *) &_oc_PortableServer_POA_ServantAlreadyActive,
    0,
    sizeof (PortableServer::POA::ServantAlreadyActive)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_ServantAlreadyActive =
  &_tc_TAO_tc_PortableServer_POA_ServantAlreadyActive;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::ServantNotActive::ServantNotActive (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/ServantNotActive:2.3",
        "ServantNotActive"
      )
{
}

PortableServer::POA::ServantNotActive::~ServantNotActive (void)
{
}

PortableServer::POA::ServantNotActive::ServantNotActive (const ::PortableServer::POA::ServantNotActive &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::ServantNotActive&
PortableServer::POA::ServantNotActive::operator= (const ::PortableServer::POA::ServantNotActive &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::ServantNotActive::_tao_any_destructor (void *_tao_void_pointer)
{
  ServantNotActive *tmp = ACE_static_cast (ServantNotActive*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::ServantNotActive *
PortableServer::POA::ServantNotActive::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ServantNotActive:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (ServantNotActive *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::ServantNotActive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::ServantNotActive, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::ServantNotActive::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::ServantNotActive (*this),
      0
    );
  return result;
}

void PortableServer::POA::ServantNotActive::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::ServantNotActive::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::ServantNotActive::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::ServantNotActive::_type (void) const
{
  return ::PortableServer::POA::_tc_ServantNotActive;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_ServantNotActive[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f53),
  ACE_NTOHL (0x65727661),
  ACE_NTOHL (0x6e744e6f),
  ACE_NTOHL (0x74416374),
  ACE_NTOHL (0x6976653a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/POA/ServantNotActive:2.3
    17,
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x616e744e),
  ACE_NTOHL (0x6f744163),
  ACE_NTOHL (0x74697665),
  ACE_NTOHL (0x0),  // name = ServantNotActive
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_ServantNotActive (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_ServantNotActive),
    (char *) &_oc_PortableServer_POA_ServantNotActive,
    0,
    sizeof (PortableServer::POA::ServantNotActive)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_ServantNotActive =
  &_tc_TAO_tc_PortableServer_POA_ServantNotActive;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::WrongAdapter::WrongAdapter (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/WrongAdapter:2.3",
        "WrongAdapter"
      )
{
}

PortableServer::POA::WrongAdapter::~WrongAdapter (void)
{
}

PortableServer::POA::WrongAdapter::WrongAdapter (const ::PortableServer::POA::WrongAdapter &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::WrongAdapter&
PortableServer::POA::WrongAdapter::operator= (const ::PortableServer::POA::WrongAdapter &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::WrongAdapter::_tao_any_destructor (void *_tao_void_pointer)
{
  WrongAdapter *tmp = ACE_static_cast (WrongAdapter*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::WrongAdapter *
PortableServer::POA::WrongAdapter::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/WrongAdapter:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (WrongAdapter *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::WrongAdapter::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::WrongAdapter, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::WrongAdapter::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::WrongAdapter (*this),
      0
    );
  return result;
}

void PortableServer::POA::WrongAdapter::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::WrongAdapter::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::WrongAdapter::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::WrongAdapter::_type (void) const
{
  return ::PortableServer::POA::_tc_WrongAdapter;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_WrongAdapter[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  48,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f57),
  ACE_NTOHL (0x726f6e67),
  ACE_NTOHL (0x41646170),
  ACE_NTOHL (0x7465723a),
  ACE_NTOHL (0x322e3300),  // repository ID = IDL:omg.org/PortableServer/POA/WrongAdapter:2.3
    13,
  ACE_NTOHL (0x57726f6e),
  ACE_NTOHL (0x67416461),
  ACE_NTOHL (0x70746572),
  ACE_NTOHL (0x0),  // name = WrongAdapter
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_WrongAdapter (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_WrongAdapter),
    (char *) &_oc_PortableServer_POA_WrongAdapter,
    0,
    sizeof (PortableServer::POA::WrongAdapter)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_WrongAdapter =
  &_tc_TAO_tc_PortableServer_POA_WrongAdapter;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::POA::WrongPolicy::WrongPolicy (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/POA/WrongPolicy:2.3",
        "WrongPolicy"
      )
{
}

PortableServer::POA::WrongPolicy::~WrongPolicy (void)
{
}

PortableServer::POA::WrongPolicy::WrongPolicy (const ::PortableServer::POA::WrongPolicy &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::POA::WrongPolicy&
PortableServer::POA::WrongPolicy::operator= (const ::PortableServer::POA::WrongPolicy &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::WrongPolicy::_tao_any_destructor (void *_tao_void_pointer)
{
  WrongPolicy *tmp = ACE_static_cast (WrongPolicy*, _tao_void_pointer);
  delete tmp;
}

PortableServer::POA::WrongPolicy *
PortableServer::POA::WrongPolicy::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/WrongPolicy:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (WrongPolicy *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::POA::WrongPolicy::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::WrongPolicy, 0);
  return retval;
}

CORBA::Exception *
PortableServer::POA::WrongPolicy::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::POA::WrongPolicy (*this),
      0
    );
  return result;
}

void PortableServer::POA::WrongPolicy::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::POA::WrongPolicy::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::WrongPolicy::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::POA::WrongPolicy::_type (void) const
{
  return ::PortableServer::POA::_tc_WrongPolicy;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA_WrongPolicy[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f412f57),
  ACE_NTOHL (0x726f6e67),
  ACE_NTOHL (0x506f6c69),
  ACE_NTOHL (0x63793a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/POA/WrongPolicy:2.3
    12,
  ACE_NTOHL (0x57726f6e),
  ACE_NTOHL (0x67506f6c),
  ACE_NTOHL (0x69637900),  // name = WrongPolicy
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_WrongPolicy (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_POA_WrongPolicy),
    (char *) &_oc_PortableServer_POA_WrongPolicy,
    0,
    sizeof (PortableServer::POA::WrongPolicy)
  );

::CORBA::TypeCode_ptr PortableServer::POA::_tc_WrongPolicy =
  &_tc_TAO_tc_PortableServer_POA_WrongPolicy;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_POA[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f50),
  ACE_NTOHL (0x4f413a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/POA:2.3
    4,
  ACE_NTOHL (0x504f4100),  // name = POA
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_POA),
    (char *) &_oc_PortableServer_POA,
    0,
    sizeof (PortableServer::POA)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_POA,
    &_tc_TAO_tc_PortableServer_POA
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:61

int PortableServer::Current::_tao_class_id = 0;

PortableServer::Current_ptr
PortableServer::tao_Current_life::tao_duplicate (
    PortableServer::Current_ptr p
  )
{
  return PortableServer::Current::_duplicate (p);
}

void
PortableServer::tao_Current_life::tao_release (
    PortableServer::Current_ptr p
  )
{
  CORBA::release (p);
}

PortableServer::Current_ptr
PortableServer::tao_Current_life::tao_nil (
    void
  )
{
  return PortableServer::Current::_nil ();
}

CORBA::Boolean
PortableServer::tao_Current_life::tao_marshal (
    PortableServer::Current_ptr p,
    TAO_OutputCDR &cdr
  )
{
  return p->marshal (cdr);
}

PortableServer::Current_ptr
PortableServer::tao_Current_cast::tao_narrow (
    CORBA::Object *p
    ACE_ENV_ARG_DECL
  )
{
  return PortableServer::Current::_narrow (p ACE_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::tao_Current_cast::tao_upcast (
    void *src
  )
{
  PortableServer::Current **tmp =
    ACE_static_cast (PortableServer::Current **, src);
  return *tmp;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)
  template class
    TAO_Objref_Var_T<
        PortableServer::Current,
        PortableServer::tao_Current_life
      >;
  template class
    TAO_Objref_Out_T<
        PortableServer::Current,
        PortableServer::tao_Current_life
      >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate \
    TAO_Objref_Var_T< \
        PortableServer::Current, \
        PortableServer::tao_Current_life \
      >
# pragma instantiate \
    TAO_Objref_Out_T< \
        PortableServer::Current, \
        PortableServer::tao_Current_life \
      >
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/interface_cs.cpp:232

PortableServer::Current::Current (void)
{}

PortableServer::Current::~Current (void)
{}

void
PortableServer::Current::_tao_any_destructor (void *_tao_void_pointer)
{
  Current *tmp = ACE_static_cast (Current *, _tao_void_pointer);
  CORBA::release (tmp);
}

PortableServer::Current_ptr
PortableServer::Current::_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL
  )
{
  return Current::_unchecked_narrow (obj ACE_ENV_ARG_PARAMETER);
}

PortableServer::Current_ptr
PortableServer::Current::_unchecked_narrow (
    CORBA::Object_ptr obj
    ACE_ENV_ARG_DECL_NOT_USED
  )
{
  if (CORBA::is_nil (obj))
    {
      return Current::_nil ();
    }

  return
      ACE_reinterpret_cast (
          Current_ptr,
          obj->_tao_QueryInterface (
              ACE_reinterpret_cast (
                  ptr_arith_t,
                  &Current::_tao_class_id
                )
            )
        );
}

PortableServer::Current_ptr
PortableServer::Current::_duplicate (Current_ptr obj)
{
  if (! CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }

  return obj;
}

void *PortableServer::Current::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;

  if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &ACE_NESTED_CLASS (::PortableServer, Current)::_tao_class_id)
            )
    {
      retv = ACE_reinterpret_cast (void*, this);
    }
  else if (type == ACE_reinterpret_cast (
              ptr_arith_t,
              &::CORBA::Current::_tao_class_id)
            )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (
                CORBA::Current_ptr,
                this
              )
          );
    }
  else if (type == ACE_reinterpret_cast (
               ptr_arith_t,
               &CORBA::Object::_tao_class_id)
             )
    {
      retv =
        ACE_reinterpret_cast (
            void *,
            ACE_static_cast (CORBA::Object_ptr, this)
          );
    }

  if (retv != 0)
    {
      this->_add_ref ();
    }

  return retv;
}

const char* PortableServer::Current::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/Current:2.3";
}

CORBA::Boolean
PortableServer::Current::marshal (TAO_OutputCDR &)
{
  return 0;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/exception_cs.cpp:63

PortableServer::Current::NoContext::NoContext (void)
  : CORBA::UserException (
        "IDL:omg.org/PortableServer/Current/NoContext:2.3",
        "NoContext"
      )
{
}

PortableServer::Current::NoContext::~NoContext (void)
{
}

PortableServer::Current::NoContext::NoContext (const ::PortableServer::Current::NoContext &_tao_excp)
  : CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
}

PortableServer::Current::NoContext&
PortableServer::Current::NoContext::operator= (const ::PortableServer::Current::NoContext &_tao_excp)
{
  this->ACE_NESTED_CLASS (CORBA, UserException)::operator= (_tao_excp);
  return *this;
}

void PortableServer::Current::NoContext::_tao_any_destructor (void *_tao_void_pointer)
{
  NoContext *tmp = ACE_static_cast (NoContext*, _tao_void_pointer);
  delete tmp;
}

PortableServer::Current::NoContext *
PortableServer::Current::NoContext::_downcast (CORBA::Exception *_tao_excp)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/Current/NoContext:2.3", _tao_excp->_rep_id ()))
    {
      return ACE_dynamic_cast (NoContext *, _tao_excp);
    }
  else
    {
      return 0;
    }
}

CORBA::Exception *PortableServer::Current::NoContext::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::Current::NoContext, 0);
  return retval;
}

CORBA::Exception *
PortableServer::Current::NoContext::_tao_duplicate (void) const
{
  CORBA::Exception *result;
  ACE_NEW_RETURN (
      result,
      ::PortableServer::Current::NoContext (*this),
      0
    );
  return result;
}

void PortableServer::Current::NoContext::_raise (void)
{
  TAO_RAISE (*this);
}

void PortableServer::Current::NoContext::_tao_encode (
    TAO_OutputCDR &
    ACE_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::Current::NoContext::_tao_decode (
    TAO_InputCDR &
    ACE_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::Current::NoContext::_type (void) const
{
  return ::PortableServer::Current::_tc_NoContext;
}

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_Current_NoContext[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f43),
  ACE_NTOHL (0x75727265),
  ACE_NTOHL (0x6e742f4e),
  ACE_NTOHL (0x6f436f6e),
  ACE_NTOHL (0x74657874),
  ACE_NTOHL (0x3a322e33),
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/Current/NoContext:2.3
    10,
  ACE_NTOHL (0x4e6f436f),
  ACE_NTOHL (0x6e746578),
  ACE_NTOHL (0x74000000),  // name = NoContext
  0, // member count
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_Current_NoContext (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_Current_NoContext),
    (char *) &_oc_PortableServer_Current_NoContext,
    0,
    sizeof (PortableServer::Current::NoContext)
  );

::CORBA::TypeCode_ptr PortableServer::Current::_tc_NoContext =
  &_tc_TAO_tc_PortableServer_Current_NoContext;

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_typecode/typecode_defn.cpp:284

static const CORBA::Long _oc_PortableServer_Current[] =
{
    TAO_ENCAP_BYTE_ORDER, // byte order
  39,
  ACE_NTOHL (0x49444c3a),
  ACE_NTOHL (0x6f6d672e),
  ACE_NTOHL (0x6f72672f),
  ACE_NTOHL (0x506f7274),
  ACE_NTOHL (0x61626c65),
  ACE_NTOHL (0x53657276),
  ACE_NTOHL (0x65722f43),
  ACE_NTOHL (0x75727265),
  ACE_NTOHL (0x6e743a32),
  ACE_NTOHL (0x2e330000),  // repository ID = IDL:omg.org/PortableServer/Current:2.3
    8,
  ACE_NTOHL (0x43757272),
  ACE_NTOHL (0x656e7400),  // name = Current
  };

static CORBA::TypeCode _tc_TAO_tc_PortableServer_Current (
    CORBA::tk_objref,
    sizeof (_oc_PortableServer_Current),
    (char *) &_oc_PortableServer_Current,
    0,
    sizeof (PortableServer::Current)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (
    ::CORBA::TypeCode_ptr,
    _tc_Current,
    &_tc_TAO_tc_PortableServer_Current
  )
TAO_NAMESPACE_END

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const PortableServer::POAList &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableServer::POAList>::insert_copy (
      _tao_any,
      PortableServer::POAList::_tao_any_destructor,
      PortableServer::_tc_POAList,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::POAList *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableServer::POAList>::insert (
      _tao_any,
      PortableServer::POAList::_tao_any_destructor,
      PortableServer::_tc_POAList,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::POAList *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const PortableServer::POAList *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const PortableServer::POAList *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableServer::POAList>::extract (
        _tao_any,
        PortableServer::POAList::_tao_any_destructor,
        PortableServer::_tc_POAList,
        _tao_elem
      );
}

template<>
CORBA::Boolean
TAO::Any_Dual_Impl_T<PortableServer::POAList>::marshal_value (TAO_OutputCDR &)
{
  return 0;
}

template<>
CORBA::Boolean
TAO::Any_Dual_Impl_T<PortableServer::POAList>::demarshal_value (TAO_InputCDR &)
{
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<PortableServer::POAList>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<PortableServer::POAList>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<PortableServer::ObjectId>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<PortableServer::ObjectId>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if (TAO_HAS_MINIMUM_CORBA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const PortableServer::ForwardRequest &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableServer::ForwardRequest>::insert_copy (
      _tao_any,
      PortableServer::ForwardRequest::_tao_any_destructor,
      PortableServer::_tc_ForwardRequest,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ForwardRequest *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableServer::ForwardRequest>::insert (
      _tao_any,
      PortableServer::ForwardRequest::_tao_any_destructor,
      PortableServer::_tc_ForwardRequest,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ForwardRequest *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const PortableServer::ForwardRequest *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const PortableServer::ForwardRequest *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableServer::ForwardRequest>::extract (
        _tao_any,
        PortableServer::ForwardRequest::_tao_any_destructor,
        PortableServer::_tc_ForwardRequest,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<PortableServer::ForwardRequest>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<PortableServer::ForwardRequest \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /* TAO_HAS_MINIMUM_CORBA == 0 */

#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_exception/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const PortableServer::NotAGroupObject &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableServer::NotAGroupObject>::insert_copy (
      _tao_any,
      PortableServer::NotAGroupObject::_tao_any_destructor,
      PortableServer::_tc_NotAGroupObject,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::NotAGroupObject *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableServer::NotAGroupObject>::insert (
      _tao_any,
      PortableServer::NotAGroupObject::_tao_any_destructor,
      PortableServer::_tc_NotAGroupObject,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::NotAGroupObject *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const PortableServer::NotAGroupObject *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const PortableServer::NotAGroupObject *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableServer::NotAGroupObject>::extract (
        _tao_any,
        PortableServer::NotAGroupObject::_tao_any_destructor,
        PortableServer::_tc_NotAGroupObject,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<PortableServer::NotAGroupObject>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<PortableServer::NotAGroupObject \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/any_op_cs.cpp:54

// Copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    const PortableServer::IDs &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableServer::IDs>::insert_copy (
      _tao_any,
      PortableServer::IDs::_tao_any_destructor,
      PortableServer::_tc_IDs,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::IDs *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<PortableServer::IDs>::insert (
      _tao_any,
      PortableServer::IDs::_tao_any_destructor,
      PortableServer::_tc_IDs,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::IDs *&_tao_elem
  )
{
  return _tao_any >>= ACE_const_cast (
      const PortableServer::IDs *&,
      _tao_elem
    );
}

// Extraction to const pointer.
CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    const PortableServer::IDs *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<PortableServer::IDs>::extract (
        _tao_any,
        PortableServer::IDs::_tao_any_destructor,
        PortableServer::_tc_IDs,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Dual_Impl_T<PortableServer::IDs>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Dual_Impl_T<PortableServer::IDs>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ThreadPolicyValue _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<PortableServer::ThreadPolicyValue>::insert (
      _tao_any,
      PortableServer::_tc_ThreadPolicyValue,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ThreadPolicyValue &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<PortableServer::ThreadPolicyValue>::extract (
        _tao_any,
        PortableServer::_tc_ThreadPolicyValue,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<PortableServer::ThreadPolicyValue>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<PortableServer::ThreadPolicyValue \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ThreadPolicy_ptr _tao_elem
  )
{
  PortableServer::ThreadPolicy_ptr _tao_objptr =
    PortableServer::ThreadPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ThreadPolicy_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::ThreadPolicy>::insert (
      _tao_any,
      PortableServer::ThreadPolicy::_tao_any_destructor,
      PortableServer::_tc_ThreadPolicy,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ThreadPolicy_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::ThreadPolicy>::extract (
        _tao_any,
        PortableServer::ThreadPolicy::_tao_any_destructor,
        PortableServer::_tc_ThreadPolicy,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::ThreadPolicy,PortableServer::ThreadPolicy_var,PortableServer::tao_ThreadPolicy_life>;
  template class TAO::Any_Impl_T<PortableServer::ThreadPolicy>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::ThreadPolicy, PortableServer::ThreadPolicy_var,PortableServer::tao_ThreadPolicy_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::ThreadPolicy>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::LifespanPolicyValue _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<PortableServer::LifespanPolicyValue>::insert (
      _tao_any,
      PortableServer::_tc_LifespanPolicyValue,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::LifespanPolicyValue &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<PortableServer::LifespanPolicyValue>::extract (
        _tao_any,
        PortableServer::_tc_LifespanPolicyValue,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<PortableServer::LifespanPolicyValue>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<PortableServer::LifespanPolicyValue \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::LifespanPolicy_ptr _tao_elem
  )
{
  PortableServer::LifespanPolicy_ptr _tao_objptr =
    PortableServer::LifespanPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::LifespanPolicy_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::LifespanPolicy>::insert (
      _tao_any,
      PortableServer::LifespanPolicy::_tao_any_destructor,
      PortableServer::_tc_LifespanPolicy,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::LifespanPolicy_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::LifespanPolicy>::extract (
        _tao_any,
        PortableServer::LifespanPolicy::_tao_any_destructor,
        PortableServer::_tc_LifespanPolicy,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<PortableServer::LifespanPolicy>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<PortableServer::LifespanPolicy>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::IdUniquenessPolicyValue _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<PortableServer::IdUniquenessPolicyValue>::insert (
      _tao_any,
      PortableServer::_tc_IdUniquenessPolicyValue,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::IdUniquenessPolicyValue &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<PortableServer::IdUniquenessPolicyValue>::extract (
        _tao_any,
        PortableServer::_tc_IdUniquenessPolicyValue,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<PortableServer::IdUniquenessPolicyValue>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<PortableServer::IdUniquenessPolicyValue \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::IdUniquenessPolicy_ptr _tao_elem
  )
{
  PortableServer::IdUniquenessPolicy_ptr _tao_objptr =
    PortableServer::IdUniquenessPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::IdUniquenessPolicy_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::IdUniquenessPolicy>::insert (
      _tao_any,
      PortableServer::IdUniquenessPolicy::_tao_any_destructor,
      PortableServer::_tc_IdUniquenessPolicy,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::IdUniquenessPolicy_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::IdUniquenessPolicy>::extract (
        _tao_any,
        PortableServer::IdUniquenessPolicy::_tao_any_destructor,
        PortableServer::_tc_IdUniquenessPolicy,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::IdUniquenessPolicy,PortableServer::IdUniquenessPolicy_var,PortableServer::tao_IdUniquenessPolicy_life>;
  template class TAO::Any_Impl_T<PortableServer::IdUniquenessPolicy>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::IdUniquenessPolicy, PortableServer::IdUniquenessPolicy_var,>
# pragma instantiate TAO::Any_Impl_T<PortableServer::LifespanPolicy>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::IdAssignmentPolicyValue _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<PortableServer::IdAssignmentPolicyValue>::insert (
      _tao_any,
      PortableServer::_tc_IdAssignmentPolicyValue,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::IdAssignmentPolicyValue &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<PortableServer::IdAssignmentPolicyValue>::extract (
        _tao_any,
        PortableServer::_tc_IdAssignmentPolicyValue,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<PortableServer::IdAssignmentPolicyValue>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<PortableServer::IdAssignmentPolicyValue \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::IdAssignmentPolicy_ptr _tao_elem
  )
{
  PortableServer::IdAssignmentPolicy_ptr _tao_objptr =
    PortableServer::IdAssignmentPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::IdAssignmentPolicy_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::IdAssignmentPolicy>::insert (
      _tao_any,
      PortableServer::IdAssignmentPolicy::_tao_any_destructor,
      PortableServer::_tc_IdAssignmentPolicy,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::IdAssignmentPolicy_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::IdAssignmentPolicy>::extract (
        _tao_any,
        PortableServer::IdAssignmentPolicy::_tao_any_destructor,
        PortableServer::_tc_IdAssignmentPolicy,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
template class TAO_Object_Manager<PortableServer::IdAssignmentPolicy,PortableServer::IdAssignmentPolicy_var,PortableServer::tao_IdAssignmentPolicy_life>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate TAO_Object_Manager<PortableServer::IdAssignmentPolicy,PortableServer::IdAssignmentPolicy_var,PortableServer::tao_IdAssignmentPolicy_life>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
template class TAO::Any_Impl_T<PortableServer::IdAssignmentPolicy>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<PortableServer::LifespanPolicy>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */


#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ImplicitActivationPolicyValue _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<PortableServer::ImplicitActivationPolicyValue>::insert (
      _tao_any,
      PortableServer::_tc_ImplicitActivationPolicyValue,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ImplicitActivationPolicyValue &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<PortableServer::ImplicitActivationPolicyValue>::extract (
        _tao_any,
        PortableServer::_tc_ImplicitActivationPolicyValue,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<PortableServer::ImplicitActivationPolicyValue>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<PortableServer::ImplicitActivationPolicyValue \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ImplicitActivationPolicy_ptr _tao_elem
  )
{
  PortableServer::ImplicitActivationPolicy_ptr _tao_objptr =
    PortableServer::ImplicitActivationPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ImplicitActivationPolicy_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::ImplicitActivationPolicy>::insert (
      _tao_any,
      PortableServer::ImplicitActivationPolicy::_tao_any_destructor,
      PortableServer::_tc_ImplicitActivationPolicy,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ImplicitActivationPolicy_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::ImplicitActivationPolicy>::extract (
        _tao_any,
        PortableServer::ImplicitActivationPolicy::_tao_any_destructor,
        PortableServer::_tc_ImplicitActivationPolicy,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::ImplicitActivationPolicy,PortableServer::ImplicitActivationPolicy_var,PortableServer::tao_ImplicitActivationPolicy_life>;
  template class TAO::Any_Impl_T<PortableServer::ImplicitActivationPolicy>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::ImplicitActivationPolicy, PortableServer::ImplicitActivationPolicy_var,PortableServer::tao_ImplicitActivationPolicy_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::ImplicitActivationPolicy>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantRetentionPolicyValue _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<PortableServer::ServantRetentionPolicyValue>::insert (
      _tao_any,
      PortableServer::_tc_ServantRetentionPolicyValue,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ServantRetentionPolicyValue &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<PortableServer::ServantRetentionPolicyValue>::extract (
        _tao_any,
        PortableServer::_tc_ServantRetentionPolicyValue,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<PortableServer::ServantRetentionPolicyValue>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<PortableServer::ServantRetentionPolicyValue \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantRetentionPolicy_ptr _tao_elem
  )
{
  PortableServer::ServantRetentionPolicy_ptr _tao_objptr =
    PortableServer::ServantRetentionPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantRetentionPolicy_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::ServantRetentionPolicy>::insert (
      _tao_any,
      PortableServer::ServantRetentionPolicy::_tao_any_destructor,
      PortableServer::_tc_ServantRetentionPolicy,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ServantRetentionPolicy_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::ServantRetentionPolicy>::extract (
        _tao_any,
        PortableServer::ServantRetentionPolicy::_tao_any_destructor,
        PortableServer::_tc_ServantRetentionPolicy,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Impl_T<PortableServer::ServantRetentionPolicy>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Impl_T<PortableServer::ServantRetentionPolicy>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_enum/any_op_cs.cpp:52

void operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::RequestProcessingPolicyValue _tao_elem
  )
{
  TAO::Any_Basic_Impl_T<PortableServer::RequestProcessingPolicyValue>::insert (
      _tao_any,
      PortableServer::_tc_RequestProcessingPolicyValue,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::RequestProcessingPolicyValue &_tao_elem
  )
{
  return
    TAO::Any_Basic_Impl_T<PortableServer::RequestProcessingPolicyValue>::extract (
        _tao_any,
        PortableServer::_tc_RequestProcessingPolicyValue,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO::Any_Basic_Impl_T<PortableServer::RequestProcessingPolicyValue>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO::Any_Basic_Impl_T<PortableServer::RequestProcessingPolicyValue \>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::RequestProcessingPolicy_ptr _tao_elem
  )
{
  PortableServer::RequestProcessingPolicy_ptr _tao_objptr =
    PortableServer::RequestProcessingPolicy::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::RequestProcessingPolicy_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::RequestProcessingPolicy>::insert (
      _tao_any,
      PortableServer::RequestProcessingPolicy::_tao_any_destructor,
      PortableServer::_tc_RequestProcessingPolicy,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::RequestProcessingPolicy_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::RequestProcessingPolicy>::extract (
        _tao_any,
        PortableServer::RequestProcessingPolicy::_tao_any_destructor,
        PortableServer::_tc_RequestProcessingPolicy,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::RequestProcessingPolicy,PortableServer::RequestProcessingPolicy_var,PortableServer::tao_RequestProcessingPolicy_life>;
  template class TAO::Any_Impl_T<PortableServer::RequestProcessingPolicy>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::RequestProcessingPolicy, PortableServer::RequestProcessingPolicy_var,PortableServer::tao_RequestProcessingPolicy_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::RequestProcessingPolicy>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::POAManager_ptr _tao_elem
  )
{
  PortableServer::POAManager_ptr _tao_objptr =
    PortableServer::POAManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::POAManager_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::POAManager>::insert (
      _tao_any,
      PortableServer::POAManager::_tao_any_destructor,
      PortableServer::_tc_POAManager,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::POAManager_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::POAManager>::extract (
        _tao_any,
        PortableServer::POAManager::_tao_any_destructor,
        PortableServer::_tc_POAManager,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::POAManager,PortableServer::POAManager_var,PortableServer::tao_POAManager_life>;
  template class TAO::Any_Impl_T<PortableServer::POAManager>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::POAManager, PortableServer::POAManager_var>
# pragma instantiate TAO::Any_Impl_T<PortableServer::POAManager>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::AdapterActivator_ptr _tao_elem
  )
{
  PortableServer::AdapterActivator_ptr _tao_objptr =
    PortableServer::AdapterActivator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::AdapterActivator_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::AdapterActivator>::insert (
      _tao_any,
      PortableServer::AdapterActivator::_tao_any_destructor,
      PortableServer::_tc_AdapterActivator,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::AdapterActivator_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::AdapterActivator>::extract (
        _tao_any,
        PortableServer::AdapterActivator::_tao_any_destructor,
        PortableServer::_tc_AdapterActivator,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::AdapterActivator,PortableServer::AdapterActivator_var,PortableServer::tao_AdapterActivator_life>;
  template class TAO::Any_Impl_T<PortableServer::AdapterActivator>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::AdapterActivator, PortableServer::AdapterActivator_var,PortableServer::tao_AdapterActivator_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::AdapterActivator>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantManager_ptr _tao_elem
  )
{
  PortableServer::ServantManager_ptr _tao_objptr =
    PortableServer::ServantManager::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantManager_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::ServantManager>::insert (
      _tao_any,
      PortableServer::ServantManager::_tao_any_destructor,
      PortableServer::_tc_ServantManager,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ServantManager_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::ServantManager>::extract (
        _tao_any,
        PortableServer::ServantManager::_tao_any_destructor,
        PortableServer::_tc_ServantManager,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::ServantManager,PortableServer::ServantManager_var,PortableServer::tao_ServantManager_life>;
  template class TAO::Any_Impl_T<PortableServer::ServantManager>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::ServantManager, PortableServer::ServantManager_var,PortableServer::tao_ServantManager_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::ServantManager>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantActivator_ptr _tao_elem
  )
{
  PortableServer::ServantActivator_ptr _tao_objptr =
    PortableServer::ServantActivator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantActivator_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::ServantActivator>::insert (
      _tao_any,
      PortableServer::ServantActivator::_tao_any_destructor,
      PortableServer::_tc_ServantActivator,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ServantActivator_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::ServantActivator>::extract (
        _tao_any,
        PortableServer::ServantActivator::_tao_any_destructor,
        PortableServer::_tc_ServantActivator,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::ServantActivator,PortableServer::ServantActivator_var,PortableServer::tao_ServantActivator_life>;
  template class TAO::Any_Impl_T<PortableServer::ServantActivator>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::ServantActivator, PortableServer::ServantActivator_var, PortableServer::tao_ServantActivator_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::ServantActivator>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantLocator_ptr _tao_elem
  )
{
  PortableServer::ServantLocator_ptr _tao_objptr =
    PortableServer::ServantLocator::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::ServantLocator_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::ServantLocator>::insert (
      _tao_any,
      PortableServer::ServantLocator::_tao_any_destructor,
      PortableServer::_tc_ServantLocator,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::ServantLocator_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::ServantLocator>::extract (
        _tao_any,
        PortableServer::ServantLocator::_tao_any_destructor,
        PortableServer::_tc_ServantLocator,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<PortableServer::ServantLocator,PortableServer::ServantLocator_var,PortableServer::tao_ServantLocator_life>;
  template class TAO::Any_Impl_T<PortableServer::ServantLocator>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::ServantLocator, PortableServer::ServantLocator_var,PortableServer::tao_ServantLocator_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::ServantLocator>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::POA_ptr _tao_elem
  )
{
  PortableServer::POA_ptr _tao_objptr =
    PortableServer::POA::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::POA_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::POA>::insert (
      _tao_any,
      PortableServer::POA::_tao_any_destructor,
      PortableServer::_tc_POA,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::POA_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::POA>::extract (
        _tao_any,
        PortableServer::POA::_tao_any_destructor,
        PortableServer::_tc_POA,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
template class TAO_Object_Manager<PortableServer::POA,PortableServer::POA_var,PortableServer::tao_POA_life>;
template class TAO::Any_Impl_T<PortableServer::POA>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::POA, PortableServer::POA_var,PortableServer::tao_POA_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::POA>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_interface/any_op_cs.cpp:52

// Copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::Current_ptr _tao_elem
  )
{
  PortableServer::Current_ptr _tao_objptr =
    PortableServer::Current::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

// Non-copying insertion.
void
operator<<= (
    CORBA::Any &_tao_any,
    PortableServer::Current_ptr *_tao_elem
  )
{
  TAO::Any_Impl_T<PortableServer::Current>::insert (
      _tao_any,
      PortableServer::Current::_tao_any_destructor,
      PortableServer::_tc_Current,
      *_tao_elem
    );
}

CORBA::Boolean
operator>>= (
    const CORBA::Any &_tao_any,
    PortableServer::Current_ptr &_tao_elem
  )
{
  return
    TAO::Any_Impl_T<PortableServer::Current>::extract (
        _tao_any,
        PortableServer::Current::_tao_any_destructor,
        PortableServer::_tc_Current,
        _tao_elem
      );
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
template class TAO_Object_Manager<PortableServer::Current,PortableServer::Current_var, PortableServer::tao_Current_life>;
template class TAO::Any_Impl_T<PortableServer::Current>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
# pragma instantiate TAO_Object_Manager<PortableServer::Current, PortableServer::Current_var,PortableServer::tao_Current_life>
# pragma instantiate TAO::Any_Impl_T<PortableServer::Current>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:125
#if 0
CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableServer::ObjectId &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();

  if (strm << _tao_seq_len)
    {
      // Encode all elements.

#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      {
        TAO_Unbounded_Sequence<CORBA::Octet> *oseq =
          ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (PortableServer::ObjectId *)&_tao_sequence);
        if (oseq->mb ())
          return strm.write_octet_array_mb (oseq->mb ());
        else
          return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
      }

#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
      return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());

#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    }

  return 0;
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableServer::ObjectId &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;

  if (strm >> _tao_seq_len)
    {
      // Add a check to the length of the sequence
      // to make sure it does not exceed the length
      // of the stream. (See bug 58.)
      if (_tao_seq_len > strm.length ())
        {
          return 0;
        }

      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);

      // If length is 0 we return true.
      if (0 >= _tao_seq_len)
        {
          return 1;
        }

      // Retrieve all the elements.

#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      if (ACE_BIT_DISABLED (strm.start ()->flags (),
      ACE_Message_Block::DONT_DELETE))
      {
        TAO_ORB_Core* orb_core = strm.orb_core ();
        if (orb_core != 0 &&
        strm.orb_core ()->resource_factory ()->
        input_cdr_allocator_type_locked () == 1)
        {
          TAO_Unbounded_Sequence<CORBA::Octet> *oseq =
            ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
          oseq->replace (_tao_seq_len, strm.start ());
          oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
          strm.skip_bytes (_tao_seq_len);
          return 1;
        }
      }
      return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
      return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());

#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    }

  return 0;
}
#endif
#if (TAO_HAS_MINIMUM_POA == 0)

// TAO_IDL - Generated from
// W:\ACE_wrappers\TAO\TAO_IDL\be\be_visitor_sequence/cdr_op_cs.cpp:93

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableServer::IDs &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len = _tao_sequence.length ();

  if (strm << _tao_seq_len)
    {
      // Encode all elements.
      CORBA::Boolean _tao_marshal_flag = 1;

      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm << _tao_sequence[i]);
        }

      return _tao_marshal_flag;
    }

    return 0;
  }

    CORBA::Boolean operator>> (
      TAO_InputCDR &strm,
      PortableServer::IDs &_tao_sequence
    )
  {
    CORBA::ULong _tao_seq_len;

    if (strm >> _tao_seq_len)
      {
        // Add a check to the length of the sequence
        // to make sure it does not exceed the length
        // of the stream. (See bug 58.)
        if (_tao_seq_len > strm.length ())
          {
            return 0;
          }

        // Set the length of the sequence.
        _tao_sequence.length (_tao_seq_len);

        // If length is 0 we return true.
        if (0 >= _tao_seq_len)
          {
            return 1;
          }

        // Retrieve all the elements.
        }

      // Set the length of the sequence.
      _tao_sequence.length (_tao_seq_len);

      // If length is 0 we return true.
      if (0 >= _tao_seq_len)
        {
          return 1;
        }

      // Retrieve all the elements.
      CORBA::Boolean _tao_marshal_flag = 1;

      for (CORBA::ULong i = 0; i < _tao_seq_len && _tao_marshal_flag; ++i)
        {
          _tao_marshal_flag = (strm >> _tao_sequence[i]);
        }

      return _tao_marshal_flag;
    }

#endif /* TAO_HAS_MINIMUM_POA == 0 */
