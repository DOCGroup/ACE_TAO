// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "PortableServerC.h"
#include "POA.h"
#include "tao/ORB.h"
#include "tao/ORB_Core.h"

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "PortableServerC.i"
#endif /* !defined INLINE */


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_OBJECT_SEQUENCE_PORTABLESERVER_POALIST_CS_)
#define __TAO_UNBOUNDED_OBJECT_SEQUENCE_PORTABLESERVER_POALIST_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
PortableServer::_TAO_Unbounded_Object_Sequence_PortableServer_POAList::_allocate_buffer (CORBA::ULong length)
{
  PortableServer::POA **tmp = 0;
  tmp = _TAO_Unbounded_Object_Sequence_PortableServer_POAList::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    PortableServer::POA **old = ACE_reinterpret_cast (PortableServer::POA**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            tmp[i] = PortableServer::POA::_duplicate (old[i]);
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
PortableServer::_TAO_Unbounded_Object_Sequence_PortableServer_POAList::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  PortableServer::POA **tmp = ACE_reinterpret_cast (PortableServer::POA**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = PortableServer::POA::_nil ();
    }
  
  _TAO_Unbounded_Object_Sequence_PortableServer_POAList::freebuf (tmp);
  this->buffer_ = 0;
}

PortableServer::_TAO_Unbounded_Object_Sequence_PortableServer_POAList::~_TAO_Unbounded_Object_Sequence_PortableServer_POAList (void)
{
  this->_deallocate_buffer ();
}

void
PortableServer::_TAO_Unbounded_Object_Sequence_PortableServer_POAList::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  PortableServer::POA **tmp = ACE_reinterpret_cast (PortableServer::POA**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = PortableServer::POA::_nil ();
    }
}

void 
PortableServer::_TAO_Unbounded_Object_Sequence_PortableServer_POAList::_downcast (
    void* target,
    CORBA_Object *src
    TAO_ENV_ARG_DECL
  )
{
  PortableServer::POA **tmp = ACE_static_cast (PortableServer::POA**, target);
  *tmp = PortableServer::POA::_narrow (src TAO_ENV_ARG_PARAMETER);
  ACE_CHECK;
}

CORBA_Object*
PortableServer::_TAO_Unbounded_Object_Sequence_PortableServer_POAList::_upcast (void *src) const
{
  PortableServer::POA **tmp = ACE_static_cast (PortableServer::POA**, src);
  return *tmp;
}

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_PORTABLESERVER_POALIST_CS_)
#define _PORTABLESERVER_POALIST_CS_

// *************************************************************
// PortableServer::POAList
// *************************************************************

PortableServer::POAList::POAList (void)
{}
PortableServer::POAList::POAList (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_PortableServer_POAList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<PortableServer::POA,PortableServer::POA_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableServer::POAList::POAList (CORBA::ULong max, CORBA::ULong length, PortableServer::POA_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_PortableServer_POAList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<PortableServer::POA,PortableServer::POA_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableServer::POAList::POAList (const POAList &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Object_Sequence_PortableServer_POAList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Object_Sequence<PortableServer::POA,PortableServer::POA_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableServer::POAList::~POAList (void) // dtor
{}
void PortableServer::POAList::_tao_any_destructor (void *_tao_void_pointer)
{
  POAList *tmp = ACE_static_cast (POAList*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */


#if !defined (_PORTABLESERVER_OBJECTID_CS_)
#define _PORTABLESERVER_OBJECTID_CS_

// *************************************************************
// PortableServer::ObjectId
// *************************************************************

PortableServer::ObjectId::ObjectId (void)
{}
PortableServer::ObjectId::ObjectId (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableServer::ObjectId::ObjectId (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableServer::ObjectId::ObjectId (const ObjectId &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableServer::ObjectId::~ObjectId (void) // dtor
{}
void PortableServer::ObjectId::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectId *tmp = ACE_static_cast (ObjectId*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableServer_ObjectId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f4f), 
  ACE_NTOHL (0x626a6563), 
  ACE_NTOHL (0x7449643a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/ObjectId:1.0
  9,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744964), 
  ACE_NTOHL (0x0),  // name = ObjectId
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ObjectId (
    CORBA::tk_alias,
    sizeof (_oc_PortableServer_ObjectId),
    (char *) &_oc_PortableServer_ObjectId,
    0,
    sizeof (PortableServer::ObjectId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ObjectId, &_tc_TAO_tc_PortableServer_ObjectId)
TAO_NAMESPACE_END

#if (TAO_HAS_MINIMUM_CORBA == 0)

// Default constructor.
PortableServer::ForwardRequest::ForwardRequest (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/ForwardRequest:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::ForwardRequest::~ForwardRequest (void)
{
}

void PortableServer::ForwardRequest::_tao_any_destructor (void *_tao_void_pointer)
{
  ForwardRequest *tmp = ACE_static_cast (ForwardRequest*, _tao_void_pointer);
  delete tmp;
}

// Copy constructor.
PortableServer::ForwardRequest::ForwardRequest (const ::PortableServer::ForwardRequest &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  this->forward_reference = CORBA::Object::_duplicate (_tao_excp.forward_reference.in ());
}

// Assignment operator.
PortableServer::ForwardRequest&
PortableServer::ForwardRequest::operator= (const ::PortableServer::ForwardRequest &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->forward_reference = CORBA::Object::_duplicate (_tao_excp.forward_reference.in ());
  return *this;
}

// Narrow.
PortableServer::ForwardRequest *
PortableServer::ForwardRequest::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/ForwardRequest:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ForwardRequest *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::ForwardRequest::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::ForwardRequest::_tao_encode (
    TAO_OutputCDR &cdr
    TAO_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::ForwardRequest::_tao_decode (
    TAO_InputCDR &cdr
    TAO_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::ForwardRequest::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::ForwardRequest, 0);
  return retval;
}

PortableServer::ForwardRequest::ForwardRequest (
    const CORBA::Object_ptr  _tao_forward_reference
  )
  : CORBA_UserException ("IDL:omg.org/PortableServer/ForwardRequest:1.0")
{
  this->forward_reference = CORBA::Object::_duplicate (_tao_forward_reference);
}

static const CORBA::Long _oc_PortableServer_ForwardRequest[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f46), 
  ACE_NTOHL (0x6f727761), 
  ACE_NTOHL (0x72645265), 
  ACE_NTOHL (0x71756573), 
  ACE_NTOHL (0x743a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/ForwardRequest:1.0
  15,
  ACE_NTOHL (0x466f7277), 
  ACE_NTOHL (0x61726452), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x73740000),  // name = ForwardRequest
  1, // member count
  18,
  ACE_NTOHL (0x666f7277), 
  ACE_NTOHL (0x6172645f), 
  ACE_NTOHL (0x72656665), 
  ACE_NTOHL (0x72656e63), 
  ACE_NTOHL (0x65000000),  // name = forward_reference
  CORBA::tk_objref,
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f62), 
    ACE_NTOHL (0x6a656374), 
    ACE_NTOHL (0x3a312e30), 
    ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
    7,
    ACE_NTOHL (0x4f626a65), 
    ACE_NTOHL (0x63740000),  // name = Object

};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ForwardRequest (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_ForwardRequest),
    (char *) &_oc_PortableServer_ForwardRequest,
    0,
    sizeof (PortableServer::ForwardRequest)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ForwardRequest, &_tc_TAO_tc_PortableServer_ForwardRequest)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::ForwardRequest::_type (void) const
{
  return ::PortableServer::_tc_ForwardRequest;
}

// Default constructor.
PortableServer::NotAGroupObject::NotAGroupObject (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/NotAGroupObject:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::NotAGroupObject::~NotAGroupObject (void)
{
}

void PortableServer::NotAGroupObject::_tao_any_destructor (void *_tao_void_pointer)
{
  NotAGroupObject *tmp = ACE_static_cast (NotAGroupObject*, _tao_void_pointer);
  delete tmp;
}

// Copy constructor.
PortableServer::NotAGroupObject::NotAGroupObject (const ::PortableServer::NotAGroupObject &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::NotAGroupObject&
PortableServer::NotAGroupObject::operator= (const ::PortableServer::NotAGroupObject &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::NotAGroupObject *
PortableServer::NotAGroupObject::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/NotAGroupObject:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (NotAGroupObject *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::NotAGroupObject::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::NotAGroupObject::_tao_encode (
    TAO_OutputCDR &cdr
    TAO_ENV_ARG_DECL
  ) const
{
  if (cdr << *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::NotAGroupObject::_tao_decode (
    TAO_InputCDR &cdr
    TAO_ENV_ARG_DECL
  )
{
  if (cdr >> *this)
    {
      return;
    }
  
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::NotAGroupObject::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::NotAGroupObject, 0);
  return retval;
}

static const CORBA::Long _oc_PortableServer_NotAGroupObject[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f4e), 
  ACE_NTOHL (0x6f744147), 
  ACE_NTOHL (0x726f7570), 
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63743a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/NotAGroupObject:1.0
  16,
  ACE_NTOHL (0x4e6f7441), 
  ACE_NTOHL (0x47726f75), 
  ACE_NTOHL (0x704f626a), 
  ACE_NTOHL (0x65637400),  // name = NotAGroupObject
  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_NotAGroupObject (
    CORBA::tk_except,
    sizeof (_oc_PortableServer_NotAGroupObject),
    (char *) &_oc_PortableServer_NotAGroupObject,
    0,
    sizeof (PortableServer::NotAGroupObject)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_NotAGroupObject, &_tc_TAO_tc_PortableServer_NotAGroupObject)
TAO_NAMESPACE_END


// TAO extension - the virtual _type method.
CORBA::TypeCode_ptr PortableServer::NotAGroupObject::_type (void) const
{
  return ::PortableServer::_tc_NotAGroupObject;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_PORTABLESERVER_IDS_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_PORTABLESERVER_IDS_CS_

void
PortableServer::_TAO_Unbounded_Sequence_PortableServer_IDs::_allocate_buffer (CORBA::ULong length)
{
  PortableServer::ObjectId* tmp = 0;
  tmp = _TAO_Unbounded_Sequence_PortableServer_IDs::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    PortableServer::ObjectId *old = ACE_reinterpret_cast (PortableServer::ObjectId *,this->buffer_);
    
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      tmp[i] = old[i];
    
    if (this->release_)
      _TAO_Unbounded_Sequence_PortableServer_IDs::freebuf (old);
    
  }
  this->buffer_ = tmp;
}

void
PortableServer::_TAO_Unbounded_Sequence_PortableServer_IDs::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  
  PortableServer::ObjectId *tmp = ACE_reinterpret_cast (PortableServer::ObjectId *,this->buffer_);
  
  _TAO_Unbounded_Sequence_PortableServer_IDs::freebuf (tmp);
  this->buffer_ = 0;
} 

PortableServer::_TAO_Unbounded_Sequence_PortableServer_IDs::~_TAO_Unbounded_Sequence_PortableServer_IDs (void) // Dtor.
{
  this->_deallocate_buffer ();
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_PORTABLESERVER_IDS_CS_)
#define _PORTABLESERVER_IDS_CS_

// *************************************************************
// PortableServer::IDs
// *************************************************************

PortableServer::IDs::IDs (void)
{}
PortableServer::IDs::IDs (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_PortableServer_IDs
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<PortableServer::ObjectId>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableServer::IDs::IDs (CORBA::ULong max, CORBA::ULong length, PortableServer::ObjectId *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_PortableServer_IDs
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<PortableServer::ObjectId>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableServer::IDs::IDs (const IDs &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Sequence_PortableServer_IDs
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Sequence<PortableServer::ObjectId>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableServer::IDs::~IDs (void) // dtor
{}
void PortableServer::IDs::_tao_any_destructor (void *_tao_void_pointer)
{
  IDs *tmp = ACE_static_cast (IDs*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableServer_IDs[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f49), 
  ACE_NTOHL (0x44733a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/IDs:1.0
  4,
  ACE_NTOHL (0x49447300),  // name = IDs
  CORBA::tk_sequence, // typecode kind
  100, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x6f6d672e), 
      ACE_NTOHL (0x6f72672f), 
      ACE_NTOHL (0x506f7274), 
      ACE_NTOHL (0x61626c65), 
      ACE_NTOHL (0x53657276), 
      ACE_NTOHL (0x65722f4f), 
      ACE_NTOHL (0x626a6563), 
      ACE_NTOHL (0x7449643a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/ObjectId:1.0
      9,
      ACE_NTOHL (0x4f626a65), 
      ACE_NTOHL (0x63744964), 
      ACE_NTOHL (0x0),  // name = ObjectId
      CORBA::tk_sequence, // typecode kind
      12, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_octet,

        0U,


    0U,

};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_IDs (
    CORBA::tk_alias,
    sizeof (_oc_PortableServer_IDs),
    (char *) &_oc_PortableServer_IDs,
    0,
    sizeof (PortableServer::IDs)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_IDs, &_tc_TAO_tc_PortableServer_IDs)
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_CORBA == 0 */

TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, THREAD_POLICY_ID, 16U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, LIFESPAN_POLICY_ID, 17U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, ID_UNIQUENESS_POLICY_ID, 18U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, ID_ASSIGNMENT_POLICY_ID, 19U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, IMPLICIT_ACTIVATION_POLICY_ID, 20U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, SERVANT_RETENTION_POLICY_ID, 21U)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_PROCESSING_POLICY_ID, 22U)
TAO_NAMESPACE_END

#if (TAO_HAS_MINIMUM_POA == 0)

static const CORBA::Long _oc_PortableServer_ThreadPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f54), 
  ACE_NTOHL (0x68726561), 
  ACE_NTOHL (0x64506f6c), 
  ACE_NTOHL (0x69637956), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/ThreadPolicyValue:1.0
  18,
  ACE_NTOHL (0x54687265), 
  ACE_NTOHL (0x6164506f), 
  ACE_NTOHL (0x6c696379), 
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65000000),  // name = ThreadPolicyValue
  2, // member count
  15,
  ACE_NTOHL (0x4f52425f), 
  ACE_NTOHL (0x4354524c), 
  ACE_NTOHL (0x5f4d4f44), 
  ACE_NTOHL (0x454c0000),  // name = ORB_CTRL_MODEL
  20,
  ACE_NTOHL (0x53494e47), 
  ACE_NTOHL (0x4c455f54), 
  ACE_NTOHL (0x48524541), 
  ACE_NTOHL (0x445f4d4f), 
  ACE_NTOHL (0x44454c00),  // name = SINGLE_THREAD_MODEL
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ThreadPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_ThreadPolicyValue),
    (char *) &_oc_PortableServer_ThreadPolicyValue,
    0,
    sizeof (PortableServer::ThreadPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ThreadPolicyValue, &_tc_TAO_tc_PortableServer_ThreadPolicyValue)
TAO_NAMESPACE_END

int PortableServer::ThreadPolicy::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::ThreadPolicy_var
// *************************************************************

PortableServer::ThreadPolicy_var::ThreadPolicy_var (void) // default constructor
  : ptr_ (ThreadPolicy::_nil ())
{}

::PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::ThreadPolicy_var::ThreadPolicy_var (const ::PortableServer::ThreadPolicy_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ThreadPolicy::_duplicate (p.ptr ()))
{}

PortableServer::ThreadPolicy_var::~ThreadPolicy_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::ThreadPolicy_var &
PortableServer::ThreadPolicy_var::operator= (ThreadPolicy_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::ThreadPolicy_var &
PortableServer::ThreadPolicy_var::operator= (const ::PortableServer::ThreadPolicy_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::ThreadPolicy::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::ThreadPolicy_var::operator const ::PortableServer::ThreadPolicy_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::ThreadPolicy_var::operator ::PortableServer::ThreadPolicy_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::ThreadPolicy_ptr &
PortableServer::ThreadPolicy_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::ThreadPolicy_ptr &
PortableServer::ThreadPolicy_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ThreadPolicy::_nil ();
  return this->ptr_;
}

::PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::ThreadPolicy_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::ThreadPolicy::_nil ();
  return val;
}

::PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy_var::tao_duplicate (ThreadPolicy_ptr p)
{
  return ::PortableServer::ThreadPolicy::_duplicate (p);
}

void
PortableServer::ThreadPolicy_var::tao_release (ThreadPolicy_ptr p)
{
  CORBA::release (p);
}

::PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy_var::tao_nil (void)
{
  return ::PortableServer::ThreadPolicy::_nil ();
}

::PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::ThreadPolicy::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::ThreadPolicy_var::tao_upcast (void *src)
{
  ThreadPolicy **tmp =
    ACE_static_cast (ThreadPolicy **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::ThreadPolicy_out
// *************************************************************

PortableServer::ThreadPolicy_out::ThreadPolicy_out (ThreadPolicy_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::ThreadPolicy::_nil ();
}

PortableServer::ThreadPolicy_out::ThreadPolicy_out (ThreadPolicy_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ThreadPolicy::_nil ();
}

PortableServer::ThreadPolicy_out::ThreadPolicy_out (const ::PortableServer::ThreadPolicy_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ThreadPolicy_out &, p).ptr_)
{}

::PortableServer::ThreadPolicy_out &
PortableServer::ThreadPolicy_out::operator= (const ::PortableServer::ThreadPolicy_out &p)
{
  this->ptr_ = ACE_const_cast (ThreadPolicy_out&, p).ptr_;
  return *this;
}

PortableServer::ThreadPolicy_out &
PortableServer::ThreadPolicy_out::operator= (const ::PortableServer::ThreadPolicy_var &p)
{
  this->ptr_ = ::PortableServer::ThreadPolicy::_duplicate (p.ptr ());
  return *this;
}

PortableServer::ThreadPolicy_out &
PortableServer::ThreadPolicy_out::operator= (ThreadPolicy_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::ThreadPolicy_out::operator ::PortableServer::ThreadPolicy_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::ThreadPolicy_ptr &
PortableServer::ThreadPolicy_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::ThreadPolicy::ThreadPolicy (void)
{}
  // destructor
  PortableServer::ThreadPolicy::~ThreadPolicy (void)
  {}
  
  PortableServer::ThreadPolicy_ptr PortableServer::ThreadPolicy::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return ThreadPolicy::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::ThreadPolicy_ptr PortableServer::ThreadPolicy::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return ThreadPolicy::_nil ();
    return
        ACE_reinterpret_cast
          (
            ThreadPolicy_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ThreadPolicy::_tao_class_id
                    )
                )
          );
}

PortableServer::ThreadPolicy_ptr
PortableServer::ThreadPolicy::_duplicate (ThreadPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::ThreadPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, ThreadPolicy)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::ThreadPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ThreadPolicy:1.0";
}

#endif /* TAO_HAS_MINIMUM_POA == 0 */

static const CORBA::Long _oc_PortableServer_LifespanPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f4c), 
  ACE_NTOHL (0x69666573), 
  ACE_NTOHL (0x70616e50), 
  ACE_NTOHL (0x6f6c6963), 
  ACE_NTOHL (0x7956616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/LifespanPolicyValue:1.0
  20,
  ACE_NTOHL (0x4c696665), 
  ACE_NTOHL (0x7370616e), 
  ACE_NTOHL (0x506f6c69), 
  ACE_NTOHL (0x63795661), 
  ACE_NTOHL (0x6c756500),  // name = LifespanPolicyValue
  2, // member count
  10,
  ACE_NTOHL (0x5452414e), 
  ACE_NTOHL (0x5349454e), 
  ACE_NTOHL (0x54000000),  // name = TRANSIENT
  11,
  ACE_NTOHL (0x50455253), 
  ACE_NTOHL (0x49535445), 
  ACE_NTOHL (0x4e540000),  // name = PERSISTENT
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_LifespanPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_LifespanPolicyValue),
    (char *) &_oc_PortableServer_LifespanPolicyValue,
    0,
    sizeof (PortableServer::LifespanPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_LifespanPolicyValue, &_tc_TAO_tc_PortableServer_LifespanPolicyValue)
TAO_NAMESPACE_END

int PortableServer::LifespanPolicy::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::LifespanPolicy_var
// *************************************************************

PortableServer::LifespanPolicy_var::LifespanPolicy_var (void) // default constructor
  : ptr_ (LifespanPolicy::_nil ())
{}

::PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::LifespanPolicy_var::LifespanPolicy_var (const ::PortableServer::LifespanPolicy_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (LifespanPolicy::_duplicate (p.ptr ()))
{}

PortableServer::LifespanPolicy_var::~LifespanPolicy_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::LifespanPolicy_var &
PortableServer::LifespanPolicy_var::operator= (LifespanPolicy_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::LifespanPolicy_var &
PortableServer::LifespanPolicy_var::operator= (const ::PortableServer::LifespanPolicy_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::LifespanPolicy::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::LifespanPolicy_var::operator const ::PortableServer::LifespanPolicy_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::LifespanPolicy_var::operator ::PortableServer::LifespanPolicy_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::LifespanPolicy_ptr &
PortableServer::LifespanPolicy_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::LifespanPolicy_ptr &
PortableServer::LifespanPolicy_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::LifespanPolicy::_nil ();
  return this->ptr_;
}

::PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::LifespanPolicy_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::LifespanPolicy::_nil ();
  return val;
}

::PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy_var::tao_duplicate (LifespanPolicy_ptr p)
{
  return ::PortableServer::LifespanPolicy::_duplicate (p);
}

void
PortableServer::LifespanPolicy_var::tao_release (LifespanPolicy_ptr p)
{
  CORBA::release (p);
}

::PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy_var::tao_nil (void)
{
  return ::PortableServer::LifespanPolicy::_nil ();
}

::PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::LifespanPolicy::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::LifespanPolicy_var::tao_upcast (void *src)
{
  LifespanPolicy **tmp =
    ACE_static_cast (LifespanPolicy **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::LifespanPolicy_out
// *************************************************************

PortableServer::LifespanPolicy_out::LifespanPolicy_out (LifespanPolicy_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::LifespanPolicy::_nil ();
}

PortableServer::LifespanPolicy_out::LifespanPolicy_out (LifespanPolicy_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::LifespanPolicy::_nil ();
}

PortableServer::LifespanPolicy_out::LifespanPolicy_out (const ::PortableServer::LifespanPolicy_out &p) // copy constructor
  : ptr_ (ACE_const_cast (LifespanPolicy_out &, p).ptr_)
{}

::PortableServer::LifespanPolicy_out &
PortableServer::LifespanPolicy_out::operator= (const ::PortableServer::LifespanPolicy_out &p)
{
  this->ptr_ = ACE_const_cast (LifespanPolicy_out&, p).ptr_;
  return *this;
}

PortableServer::LifespanPolicy_out &
PortableServer::LifespanPolicy_out::operator= (const ::PortableServer::LifespanPolicy_var &p)
{
  this->ptr_ = ::PortableServer::LifespanPolicy::_duplicate (p.ptr ());
  return *this;
}

PortableServer::LifespanPolicy_out &
PortableServer::LifespanPolicy_out::operator= (LifespanPolicy_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::LifespanPolicy_out::operator ::PortableServer::LifespanPolicy_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::LifespanPolicy_ptr &
PortableServer::LifespanPolicy_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::LifespanPolicy::LifespanPolicy (void)
{}
  // destructor
  PortableServer::LifespanPolicy::~LifespanPolicy (void)
  {}
  
  PortableServer::LifespanPolicy_ptr PortableServer::LifespanPolicy::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return LifespanPolicy::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::LifespanPolicy_ptr PortableServer::LifespanPolicy::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return LifespanPolicy::_nil ();
    return
        ACE_reinterpret_cast
          (
            LifespanPolicy_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &LifespanPolicy::_tao_class_id
                    )
                )
          );
}

PortableServer::LifespanPolicy_ptr
PortableServer::LifespanPolicy::_duplicate (LifespanPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::LifespanPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, LifespanPolicy)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::LifespanPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/LifespanPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_IdUniquenessPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f49), 
  ACE_NTOHL (0x64556e69), 
  ACE_NTOHL (0x7175656e), 
  ACE_NTOHL (0x65737350), 
  ACE_NTOHL (0x6f6c6963), 
  ACE_NTOHL (0x7956616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/IdUniquenessPolicyValue:1.0
  24,
  ACE_NTOHL (0x4964556e), 
  ACE_NTOHL (0x69717565), 
  ACE_NTOHL (0x6e657373), 
  ACE_NTOHL (0x506f6c69), 
  ACE_NTOHL (0x63795661), 
  ACE_NTOHL (0x6c756500),  // name = IdUniquenessPolicyValue
  2, // member count
  10,
  ACE_NTOHL (0x554e4951), 
  ACE_NTOHL (0x55455f49), 
  ACE_NTOHL (0x44000000),  // name = UNIQUE_ID
  12,
  ACE_NTOHL (0x4d554c54), 
  ACE_NTOHL (0x49504c45), 
  ACE_NTOHL (0x5f494400),  // name = MULTIPLE_ID
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdUniquenessPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_IdUniquenessPolicyValue),
    (char *) &_oc_PortableServer_IdUniquenessPolicyValue,
    0,
    sizeof (PortableServer::IdUniquenessPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_IdUniquenessPolicyValue, &_tc_TAO_tc_PortableServer_IdUniquenessPolicyValue)
TAO_NAMESPACE_END

int PortableServer::IdUniquenessPolicy::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::IdUniquenessPolicy_var
// *************************************************************

PortableServer::IdUniquenessPolicy_var::IdUniquenessPolicy_var (void) // default constructor
  : ptr_ (IdUniquenessPolicy::_nil ())
{}

::PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::IdUniquenessPolicy_var::IdUniquenessPolicy_var (const ::PortableServer::IdUniquenessPolicy_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IdUniquenessPolicy::_duplicate (p.ptr ()))
{}

PortableServer::IdUniquenessPolicy_var::~IdUniquenessPolicy_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::IdUniquenessPolicy_var &
PortableServer::IdUniquenessPolicy_var::operator= (IdUniquenessPolicy_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::IdUniquenessPolicy_var &
PortableServer::IdUniquenessPolicy_var::operator= (const ::PortableServer::IdUniquenessPolicy_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::IdUniquenessPolicy::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::IdUniquenessPolicy_var::operator const ::PortableServer::IdUniquenessPolicy_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::IdUniquenessPolicy_var::operator ::PortableServer::IdUniquenessPolicy_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::IdUniquenessPolicy_ptr &
PortableServer::IdUniquenessPolicy_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::IdUniquenessPolicy_ptr &
PortableServer::IdUniquenessPolicy_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::IdUniquenessPolicy::_nil ();
  return this->ptr_;
}

::PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::IdUniquenessPolicy_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::IdUniquenessPolicy::_nil ();
  return val;
}

::PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy_var::tao_duplicate (IdUniquenessPolicy_ptr p)
{
  return ::PortableServer::IdUniquenessPolicy::_duplicate (p);
}

void
PortableServer::IdUniquenessPolicy_var::tao_release (IdUniquenessPolicy_ptr p)
{
  CORBA::release (p);
}

::PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy_var::tao_nil (void)
{
  return ::PortableServer::IdUniquenessPolicy::_nil ();
}

::PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::IdUniquenessPolicy::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::IdUniquenessPolicy_var::tao_upcast (void *src)
{
  IdUniquenessPolicy **tmp =
    ACE_static_cast (IdUniquenessPolicy **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::IdUniquenessPolicy_out
// *************************************************************

PortableServer::IdUniquenessPolicy_out::IdUniquenessPolicy_out (IdUniquenessPolicy_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::IdUniquenessPolicy::_nil ();
}

PortableServer::IdUniquenessPolicy_out::IdUniquenessPolicy_out (IdUniquenessPolicy_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::IdUniquenessPolicy::_nil ();
}

PortableServer::IdUniquenessPolicy_out::IdUniquenessPolicy_out (const ::PortableServer::IdUniquenessPolicy_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IdUniquenessPolicy_out &, p).ptr_)
{}

::PortableServer::IdUniquenessPolicy_out &
PortableServer::IdUniquenessPolicy_out::operator= (const ::PortableServer::IdUniquenessPolicy_out &p)
{
  this->ptr_ = ACE_const_cast (IdUniquenessPolicy_out&, p).ptr_;
  return *this;
}

PortableServer::IdUniquenessPolicy_out &
PortableServer::IdUniquenessPolicy_out::operator= (const ::PortableServer::IdUniquenessPolicy_var &p)
{
  this->ptr_ = ::PortableServer::IdUniquenessPolicy::_duplicate (p.ptr ());
  return *this;
}

PortableServer::IdUniquenessPolicy_out &
PortableServer::IdUniquenessPolicy_out::operator= (IdUniquenessPolicy_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::IdUniquenessPolicy_out::operator ::PortableServer::IdUniquenessPolicy_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::IdUniquenessPolicy_ptr &
PortableServer::IdUniquenessPolicy_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::IdUniquenessPolicy::IdUniquenessPolicy (void)
{}
  // destructor
  PortableServer::IdUniquenessPolicy::~IdUniquenessPolicy (void)
  {}
  
  PortableServer::IdUniquenessPolicy_ptr PortableServer::IdUniquenessPolicy::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return IdUniquenessPolicy::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::IdUniquenessPolicy_ptr PortableServer::IdUniquenessPolicy::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return IdUniquenessPolicy::_nil ();
    return
        ACE_reinterpret_cast
          (
            IdUniquenessPolicy_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IdUniquenessPolicy::_tao_class_id
                    )
                )
          );
}

PortableServer::IdUniquenessPolicy_ptr
PortableServer::IdUniquenessPolicy::_duplicate (IdUniquenessPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::IdUniquenessPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, IdUniquenessPolicy)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::IdUniquenessPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_IdAssignmentPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f49), 
  ACE_NTOHL (0x64417373), 
  ACE_NTOHL (0x69676e6d), 
  ACE_NTOHL (0x656e7450), 
  ACE_NTOHL (0x6f6c6963), 
  ACE_NTOHL (0x7956616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/IdAssignmentPolicyValue:1.0
  24,
  ACE_NTOHL (0x49644173), 
  ACE_NTOHL (0x7369676e), 
  ACE_NTOHL (0x6d656e74), 
  ACE_NTOHL (0x506f6c69), 
  ACE_NTOHL (0x63795661), 
  ACE_NTOHL (0x6c756500),  // name = IdAssignmentPolicyValue
  2, // member count
  8,
  ACE_NTOHL (0x55534552), 
  ACE_NTOHL (0x5f494400),  // name = USER_ID
  10,
  ACE_NTOHL (0x53595354), 
  ACE_NTOHL (0x454d5f49), 
  ACE_NTOHL (0x44000000),  // name = SYSTEM_ID
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdAssignmentPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_IdAssignmentPolicyValue),
    (char *) &_oc_PortableServer_IdAssignmentPolicyValue,
    0,
    sizeof (PortableServer::IdAssignmentPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_IdAssignmentPolicyValue, &_tc_TAO_tc_PortableServer_IdAssignmentPolicyValue)
TAO_NAMESPACE_END

int PortableServer::IdAssignmentPolicy::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::IdAssignmentPolicy_var
// *************************************************************

PortableServer::IdAssignmentPolicy_var::IdAssignmentPolicy_var (void) // default constructor
  : ptr_ (IdAssignmentPolicy::_nil ())
{}

::PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::IdAssignmentPolicy_var::IdAssignmentPolicy_var (const ::PortableServer::IdAssignmentPolicy_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (IdAssignmentPolicy::_duplicate (p.ptr ()))
{}

PortableServer::IdAssignmentPolicy_var::~IdAssignmentPolicy_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::IdAssignmentPolicy_var &
PortableServer::IdAssignmentPolicy_var::operator= (IdAssignmentPolicy_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::IdAssignmentPolicy_var &
PortableServer::IdAssignmentPolicy_var::operator= (const ::PortableServer::IdAssignmentPolicy_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::IdAssignmentPolicy::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::IdAssignmentPolicy_var::operator const ::PortableServer::IdAssignmentPolicy_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::IdAssignmentPolicy_var::operator ::PortableServer::IdAssignmentPolicy_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::IdAssignmentPolicy_ptr &
PortableServer::IdAssignmentPolicy_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::IdAssignmentPolicy_ptr &
PortableServer::IdAssignmentPolicy_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::IdAssignmentPolicy::_nil ();
  return this->ptr_;
}

::PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::IdAssignmentPolicy_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::IdAssignmentPolicy::_nil ();
  return val;
}

::PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy_var::tao_duplicate (IdAssignmentPolicy_ptr p)
{
  return ::PortableServer::IdAssignmentPolicy::_duplicate (p);
}

void
PortableServer::IdAssignmentPolicy_var::tao_release (IdAssignmentPolicy_ptr p)
{
  CORBA::release (p);
}

::PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy_var::tao_nil (void)
{
  return ::PortableServer::IdAssignmentPolicy::_nil ();
}

::PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::IdAssignmentPolicy::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::IdAssignmentPolicy_var::tao_upcast (void *src)
{
  IdAssignmentPolicy **tmp =
    ACE_static_cast (IdAssignmentPolicy **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::IdAssignmentPolicy_out
// *************************************************************

PortableServer::IdAssignmentPolicy_out::IdAssignmentPolicy_out (IdAssignmentPolicy_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::IdAssignmentPolicy::_nil ();
}

PortableServer::IdAssignmentPolicy_out::IdAssignmentPolicy_out (IdAssignmentPolicy_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::IdAssignmentPolicy::_nil ();
}

PortableServer::IdAssignmentPolicy_out::IdAssignmentPolicy_out (const ::PortableServer::IdAssignmentPolicy_out &p) // copy constructor
  : ptr_ (ACE_const_cast (IdAssignmentPolicy_out &, p).ptr_)
{}

::PortableServer::IdAssignmentPolicy_out &
PortableServer::IdAssignmentPolicy_out::operator= (const ::PortableServer::IdAssignmentPolicy_out &p)
{
  this->ptr_ = ACE_const_cast (IdAssignmentPolicy_out&, p).ptr_;
  return *this;
}

PortableServer::IdAssignmentPolicy_out &
PortableServer::IdAssignmentPolicy_out::operator= (const ::PortableServer::IdAssignmentPolicy_var &p)
{
  this->ptr_ = ::PortableServer::IdAssignmentPolicy::_duplicate (p.ptr ());
  return *this;
}

PortableServer::IdAssignmentPolicy_out &
PortableServer::IdAssignmentPolicy_out::operator= (IdAssignmentPolicy_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::IdAssignmentPolicy_out::operator ::PortableServer::IdAssignmentPolicy_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::IdAssignmentPolicy_ptr &
PortableServer::IdAssignmentPolicy_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::IdAssignmentPolicy::IdAssignmentPolicy (void)
{}
  // destructor
  PortableServer::IdAssignmentPolicy::~IdAssignmentPolicy (void)
  {}
  
  PortableServer::IdAssignmentPolicy_ptr PortableServer::IdAssignmentPolicy::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return IdAssignmentPolicy::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::IdAssignmentPolicy_ptr PortableServer::IdAssignmentPolicy::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return IdAssignmentPolicy::_nil ();
    return
        ACE_reinterpret_cast
          (
            IdAssignmentPolicy_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IdAssignmentPolicy::_tao_class_id
                    )
                )
          );
}

PortableServer::IdAssignmentPolicy_ptr
PortableServer::IdAssignmentPolicy::_duplicate (IdAssignmentPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::IdAssignmentPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, IdAssignmentPolicy)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::IdAssignmentPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0";
}

#if (TAO_HAS_MINIMUM_POA == 0)

static const CORBA::Long _oc_PortableServer_ImplicitActivationPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  61,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f49), 
  ACE_NTOHL (0x6d706c69), 
  ACE_NTOHL (0x63697441), 
  ACE_NTOHL (0x63746976), 
  ACE_NTOHL (0x6174696f), 
  ACE_NTOHL (0x6e506f6c), 
  ACE_NTOHL (0x69637956), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/ImplicitActivationPolicyValue:1.0
  30,
  ACE_NTOHL (0x496d706c), 
  ACE_NTOHL (0x69636974), 
  ACE_NTOHL (0x41637469), 
  ACE_NTOHL (0x76617469), 
  ACE_NTOHL (0x6f6e506f), 
  ACE_NTOHL (0x6c696379), 
  ACE_NTOHL (0x56616c75), 
  ACE_NTOHL (0x65000000),  // name = ImplicitActivationPolicyValue
  2, // member count
  20,
  ACE_NTOHL (0x494d504c), 
  ACE_NTOHL (0x49434954), 
  ACE_NTOHL (0x5f414354), 
  ACE_NTOHL (0x49564154), 
  ACE_NTOHL (0x494f4e00),  // name = IMPLICIT_ACTIVATION
  23,
  ACE_NTOHL (0x4e4f5f49), 
  ACE_NTOHL (0x4d504c49), 
  ACE_NTOHL (0x4349545f), 
  ACE_NTOHL (0x41435449), 
  ACE_NTOHL (0x56415449), 
  ACE_NTOHL (0x4f4e0000),  // name = NO_IMPLICIT_ACTIVATION
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ImplicitActivationPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_ImplicitActivationPolicyValue),
    (char *) &_oc_PortableServer_ImplicitActivationPolicyValue,
    0,
    sizeof (PortableServer::ImplicitActivationPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ImplicitActivationPolicyValue, &_tc_TAO_tc_PortableServer_ImplicitActivationPolicyValue)
TAO_NAMESPACE_END

int PortableServer::ImplicitActivationPolicy::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::ImplicitActivationPolicy_var
// *************************************************************

PortableServer::ImplicitActivationPolicy_var::ImplicitActivationPolicy_var (void) // default constructor
  : ptr_ (ImplicitActivationPolicy::_nil ())
{}

::PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::ImplicitActivationPolicy_var::ImplicitActivationPolicy_var (const ::PortableServer::ImplicitActivationPolicy_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ImplicitActivationPolicy::_duplicate (p.ptr ()))
{}

PortableServer::ImplicitActivationPolicy_var::~ImplicitActivationPolicy_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::ImplicitActivationPolicy_var &
PortableServer::ImplicitActivationPolicy_var::operator= (ImplicitActivationPolicy_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::ImplicitActivationPolicy_var &
PortableServer::ImplicitActivationPolicy_var::operator= (const ::PortableServer::ImplicitActivationPolicy_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::ImplicitActivationPolicy::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::ImplicitActivationPolicy_var::operator const ::PortableServer::ImplicitActivationPolicy_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::ImplicitActivationPolicy_var::operator ::PortableServer::ImplicitActivationPolicy_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::ImplicitActivationPolicy_ptr &
PortableServer::ImplicitActivationPolicy_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::ImplicitActivationPolicy_ptr &
PortableServer::ImplicitActivationPolicy_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ImplicitActivationPolicy::_nil ();
  return this->ptr_;
}

::PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::ImplicitActivationPolicy_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::ImplicitActivationPolicy::_nil ();
  return val;
}

::PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy_var::tao_duplicate (ImplicitActivationPolicy_ptr p)
{
  return ::PortableServer::ImplicitActivationPolicy::_duplicate (p);
}

void
PortableServer::ImplicitActivationPolicy_var::tao_release (ImplicitActivationPolicy_ptr p)
{
  CORBA::release (p);
}

::PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy_var::tao_nil (void)
{
  return ::PortableServer::ImplicitActivationPolicy::_nil ();
}

::PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::ImplicitActivationPolicy::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::ImplicitActivationPolicy_var::tao_upcast (void *src)
{
  ImplicitActivationPolicy **tmp =
    ACE_static_cast (ImplicitActivationPolicy **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::ImplicitActivationPolicy_out
// *************************************************************

PortableServer::ImplicitActivationPolicy_out::ImplicitActivationPolicy_out (ImplicitActivationPolicy_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::ImplicitActivationPolicy::_nil ();
}

PortableServer::ImplicitActivationPolicy_out::ImplicitActivationPolicy_out (ImplicitActivationPolicy_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ImplicitActivationPolicy::_nil ();
}

PortableServer::ImplicitActivationPolicy_out::ImplicitActivationPolicy_out (const ::PortableServer::ImplicitActivationPolicy_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ImplicitActivationPolicy_out &, p).ptr_)
{}

::PortableServer::ImplicitActivationPolicy_out &
PortableServer::ImplicitActivationPolicy_out::operator= (const ::PortableServer::ImplicitActivationPolicy_out &p)
{
  this->ptr_ = ACE_const_cast (ImplicitActivationPolicy_out&, p).ptr_;
  return *this;
}

PortableServer::ImplicitActivationPolicy_out &
PortableServer::ImplicitActivationPolicy_out::operator= (const ::PortableServer::ImplicitActivationPolicy_var &p)
{
  this->ptr_ = ::PortableServer::ImplicitActivationPolicy::_duplicate (p.ptr ());
  return *this;
}

PortableServer::ImplicitActivationPolicy_out &
PortableServer::ImplicitActivationPolicy_out::operator= (ImplicitActivationPolicy_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::ImplicitActivationPolicy_out::operator ::PortableServer::ImplicitActivationPolicy_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::ImplicitActivationPolicy_ptr &
PortableServer::ImplicitActivationPolicy_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::ImplicitActivationPolicy::ImplicitActivationPolicy (void)
{}
  // destructor
  PortableServer::ImplicitActivationPolicy::~ImplicitActivationPolicy (void)
  {}
  
  PortableServer::ImplicitActivationPolicy_ptr PortableServer::ImplicitActivationPolicy::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return ImplicitActivationPolicy::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::ImplicitActivationPolicy_ptr PortableServer::ImplicitActivationPolicy::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return ImplicitActivationPolicy::_nil ();
    return
        ACE_reinterpret_cast
          (
            ImplicitActivationPolicy_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ImplicitActivationPolicy::_tao_class_id
                    )
                )
          );
}

PortableServer::ImplicitActivationPolicy_ptr
PortableServer::ImplicitActivationPolicy::_duplicate (ImplicitActivationPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::ImplicitActivationPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, ImplicitActivationPolicy)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::ImplicitActivationPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_ServantRetentionPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  59,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f53), 
  ACE_NTOHL (0x65727661), 
  ACE_NTOHL (0x6e745265), 
  ACE_NTOHL (0x74656e74), 
  ACE_NTOHL (0x696f6e50), 
  ACE_NTOHL (0x6f6c6963), 
  ACE_NTOHL (0x7956616c), 
  ACE_NTOHL (0x75653a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/ServantRetentionPolicyValue:1.0
  28,
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x616e7452), 
  ACE_NTOHL (0x6574656e), 
  ACE_NTOHL (0x74696f6e), 
  ACE_NTOHL (0x506f6c69), 
  ACE_NTOHL (0x63795661), 
  ACE_NTOHL (0x6c756500),  // name = ServantRetentionPolicyValue
  2, // member count
  7,
  ACE_NTOHL (0x52455441), 
  ACE_NTOHL (0x494e0000),  // name = RETAIN
  11,
  ACE_NTOHL (0x4e4f4e5f), 
  ACE_NTOHL (0x52455441), 
  ACE_NTOHL (0x494e0000),  // name = NON_RETAIN
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantRetentionPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_ServantRetentionPolicyValue),
    (char *) &_oc_PortableServer_ServantRetentionPolicyValue,
    0,
    sizeof (PortableServer::ServantRetentionPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ServantRetentionPolicyValue, &_tc_TAO_tc_PortableServer_ServantRetentionPolicyValue)
TAO_NAMESPACE_END

int PortableServer::ServantRetentionPolicy::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::ServantRetentionPolicy_var
// *************************************************************

PortableServer::ServantRetentionPolicy_var::ServantRetentionPolicy_var (void) // default constructor
  : ptr_ (ServantRetentionPolicy::_nil ())
{}

::PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::ServantRetentionPolicy_var::ServantRetentionPolicy_var (const ::PortableServer::ServantRetentionPolicy_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ServantRetentionPolicy::_duplicate (p.ptr ()))
{}

PortableServer::ServantRetentionPolicy_var::~ServantRetentionPolicy_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::ServantRetentionPolicy_var &
PortableServer::ServantRetentionPolicy_var::operator= (ServantRetentionPolicy_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::ServantRetentionPolicy_var &
PortableServer::ServantRetentionPolicy_var::operator= (const ::PortableServer::ServantRetentionPolicy_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::ServantRetentionPolicy::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::ServantRetentionPolicy_var::operator const ::PortableServer::ServantRetentionPolicy_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::ServantRetentionPolicy_var::operator ::PortableServer::ServantRetentionPolicy_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::ServantRetentionPolicy_ptr &
PortableServer::ServantRetentionPolicy_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::ServantRetentionPolicy_ptr &
PortableServer::ServantRetentionPolicy_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ServantRetentionPolicy::_nil ();
  return this->ptr_;
}

::PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::ServantRetentionPolicy_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::ServantRetentionPolicy::_nil ();
  return val;
}

::PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy_var::tao_duplicate (ServantRetentionPolicy_ptr p)
{
  return ::PortableServer::ServantRetentionPolicy::_duplicate (p);
}

void
PortableServer::ServantRetentionPolicy_var::tao_release (ServantRetentionPolicy_ptr p)
{
  CORBA::release (p);
}

::PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy_var::tao_nil (void)
{
  return ::PortableServer::ServantRetentionPolicy::_nil ();
}

::PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::ServantRetentionPolicy::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::ServantRetentionPolicy_var::tao_upcast (void *src)
{
  ServantRetentionPolicy **tmp =
    ACE_static_cast (ServantRetentionPolicy **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::ServantRetentionPolicy_out
// *************************************************************

PortableServer::ServantRetentionPolicy_out::ServantRetentionPolicy_out (ServantRetentionPolicy_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::ServantRetentionPolicy::_nil ();
}

PortableServer::ServantRetentionPolicy_out::ServantRetentionPolicy_out (ServantRetentionPolicy_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ServantRetentionPolicy::_nil ();
}

PortableServer::ServantRetentionPolicy_out::ServantRetentionPolicy_out (const ::PortableServer::ServantRetentionPolicy_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ServantRetentionPolicy_out &, p).ptr_)
{}

::PortableServer::ServantRetentionPolicy_out &
PortableServer::ServantRetentionPolicy_out::operator= (const ::PortableServer::ServantRetentionPolicy_out &p)
{
  this->ptr_ = ACE_const_cast (ServantRetentionPolicy_out&, p).ptr_;
  return *this;
}

PortableServer::ServantRetentionPolicy_out &
PortableServer::ServantRetentionPolicy_out::operator= (const ::PortableServer::ServantRetentionPolicy_var &p)
{
  this->ptr_ = ::PortableServer::ServantRetentionPolicy::_duplicate (p.ptr ());
  return *this;
}

PortableServer::ServantRetentionPolicy_out &
PortableServer::ServantRetentionPolicy_out::operator= (ServantRetentionPolicy_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::ServantRetentionPolicy_out::operator ::PortableServer::ServantRetentionPolicy_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::ServantRetentionPolicy_ptr &
PortableServer::ServantRetentionPolicy_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::ServantRetentionPolicy::ServantRetentionPolicy (void)
{}
  // destructor
  PortableServer::ServantRetentionPolicy::~ServantRetentionPolicy (void)
  {}
  
  PortableServer::ServantRetentionPolicy_ptr PortableServer::ServantRetentionPolicy::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return ServantRetentionPolicy::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::ServantRetentionPolicy_ptr PortableServer::ServantRetentionPolicy::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return ServantRetentionPolicy::_nil ();
    return
        ACE_reinterpret_cast
          (
            ServantRetentionPolicy_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ServantRetentionPolicy::_tao_class_id
                    )
                )
          );
}

PortableServer::ServantRetentionPolicy_ptr
PortableServer::ServantRetentionPolicy::_duplicate (ServantRetentionPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::ServantRetentionPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, ServantRetentionPolicy)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::ServantRetentionPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_RequestProcessingPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  60,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x6f6d672e), 
  ACE_NTOHL (0x6f72672f), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65722f52), 
  ACE_NTOHL (0x65717565), 
  ACE_NTOHL (0x73745072), 
  ACE_NTOHL (0x6f636573), 
  ACE_NTOHL (0x73696e67), 
  ACE_NTOHL (0x506f6c69), 
  ACE_NTOHL (0x63795661), 
  ACE_NTOHL (0x6c75653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/RequestProcessingPolicyValue:1.0
  29,
  ACE_NTOHL (0x52657175), 
  ACE_NTOHL (0x65737450), 
  ACE_NTOHL (0x726f6365), 
  ACE_NTOHL (0x7373696e), 
  ACE_NTOHL (0x67506f6c), 
  ACE_NTOHL (0x69637956), 
  ACE_NTOHL (0x616c7565), 
  ACE_NTOHL (0x0),  // name = RequestProcessingPolicyValue
  3, // member count
  27,
  ACE_NTOHL (0x5553455f), 
  ACE_NTOHL (0x41435449), 
  ACE_NTOHL (0x56455f4f), 
  ACE_NTOHL (0x424a4543), 
  ACE_NTOHL (0x545f4d41), 
  ACE_NTOHL (0x505f4f4e), 
  ACE_NTOHL (0x4c590000),  // name = USE_ACTIVE_OBJECT_MAP_ONLY
  20,
  ACE_NTOHL (0x5553455f), 
  ACE_NTOHL (0x44454641), 
  ACE_NTOHL (0x554c545f), 
  ACE_NTOHL (0x53455256), 
  ACE_NTOHL (0x414e5400),  // name = USE_DEFAULT_SERVANT
  20,
  ACE_NTOHL (0x5553455f), 
  ACE_NTOHL (0x53455256), 
  ACE_NTOHL (0x414e545f), 
  ACE_NTOHL (0x4d414e41), 
  ACE_NTOHL (0x47455200),  // name = USE_SERVANT_MANAGER
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_RequestProcessingPolicyValue (
    CORBA::tk_enum,
    sizeof (_oc_PortableServer_RequestProcessingPolicyValue),
    (char *) &_oc_PortableServer_RequestProcessingPolicyValue,
    0,
    sizeof (PortableServer::RequestProcessingPolicyValue)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_RequestProcessingPolicyValue, &_tc_TAO_tc_PortableServer_RequestProcessingPolicyValue)
TAO_NAMESPACE_END

int PortableServer::RequestProcessingPolicy::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::RequestProcessingPolicy_var
// *************************************************************

PortableServer::RequestProcessingPolicy_var::RequestProcessingPolicy_var (void) // default constructor
  : ptr_ (RequestProcessingPolicy::_nil ())
{}

::PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::RequestProcessingPolicy_var::RequestProcessingPolicy_var (const ::PortableServer::RequestProcessingPolicy_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (RequestProcessingPolicy::_duplicate (p.ptr ()))
{}

PortableServer::RequestProcessingPolicy_var::~RequestProcessingPolicy_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::RequestProcessingPolicy_var &
PortableServer::RequestProcessingPolicy_var::operator= (RequestProcessingPolicy_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::RequestProcessingPolicy_var &
PortableServer::RequestProcessingPolicy_var::operator= (const ::PortableServer::RequestProcessingPolicy_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::RequestProcessingPolicy::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::RequestProcessingPolicy_var::operator const ::PortableServer::RequestProcessingPolicy_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::RequestProcessingPolicy_var::operator ::PortableServer::RequestProcessingPolicy_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::RequestProcessingPolicy_ptr &
PortableServer::RequestProcessingPolicy_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::RequestProcessingPolicy_ptr &
PortableServer::RequestProcessingPolicy_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::RequestProcessingPolicy::_nil ();
  return this->ptr_;
}

::PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::RequestProcessingPolicy_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::RequestProcessingPolicy::_nil ();
  return val;
}

::PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy_var::tao_duplicate (RequestProcessingPolicy_ptr p)
{
  return ::PortableServer::RequestProcessingPolicy::_duplicate (p);
}

void
PortableServer::RequestProcessingPolicy_var::tao_release (RequestProcessingPolicy_ptr p)
{
  CORBA::release (p);
}

::PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy_var::tao_nil (void)
{
  return ::PortableServer::RequestProcessingPolicy::_nil ();
}

::PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::RequestProcessingPolicy::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::RequestProcessingPolicy_var::tao_upcast (void *src)
{
  RequestProcessingPolicy **tmp =
    ACE_static_cast (RequestProcessingPolicy **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::RequestProcessingPolicy_out
// *************************************************************

PortableServer::RequestProcessingPolicy_out::RequestProcessingPolicy_out (RequestProcessingPolicy_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::RequestProcessingPolicy::_nil ();
}

PortableServer::RequestProcessingPolicy_out::RequestProcessingPolicy_out (RequestProcessingPolicy_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::RequestProcessingPolicy::_nil ();
}

PortableServer::RequestProcessingPolicy_out::RequestProcessingPolicy_out (const ::PortableServer::RequestProcessingPolicy_out &p) // copy constructor
  : ptr_ (ACE_const_cast (RequestProcessingPolicy_out &, p).ptr_)
{}

::PortableServer::RequestProcessingPolicy_out &
PortableServer::RequestProcessingPolicy_out::operator= (const ::PortableServer::RequestProcessingPolicy_out &p)
{
  this->ptr_ = ACE_const_cast (RequestProcessingPolicy_out&, p).ptr_;
  return *this;
}

PortableServer::RequestProcessingPolicy_out &
PortableServer::RequestProcessingPolicy_out::operator= (const ::PortableServer::RequestProcessingPolicy_var &p)
{
  this->ptr_ = ::PortableServer::RequestProcessingPolicy::_duplicate (p.ptr ());
  return *this;
}

PortableServer::RequestProcessingPolicy_out &
PortableServer::RequestProcessingPolicy_out::operator= (RequestProcessingPolicy_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::RequestProcessingPolicy_out::operator ::PortableServer::RequestProcessingPolicy_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::RequestProcessingPolicy_ptr &
PortableServer::RequestProcessingPolicy_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::RequestProcessingPolicy::RequestProcessingPolicy (void)
{}
  // destructor
  PortableServer::RequestProcessingPolicy::~RequestProcessingPolicy (void)
  {}
  
  PortableServer::RequestProcessingPolicy_ptr PortableServer::RequestProcessingPolicy::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return RequestProcessingPolicy::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::RequestProcessingPolicy_ptr PortableServer::RequestProcessingPolicy::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return RequestProcessingPolicy::_nil ();
    return
        ACE_reinterpret_cast
          (
            RequestProcessingPolicy_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &RequestProcessingPolicy::_tao_class_id
                    )
                )
          );
}

PortableServer::RequestProcessingPolicy_ptr
PortableServer::RequestProcessingPolicy::_duplicate (RequestProcessingPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::RequestProcessingPolicy::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, RequestProcessingPolicy)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Policy::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Policy_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::RequestProcessingPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0";
}

#endif /* TAO_HAS_MINIMUM_POA == 0 */

int PortableServer::POAManager::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::POAManager_var
// *************************************************************

PortableServer::POAManager_var::POAManager_var (void) // default constructor
  : ptr_ (POAManager::_nil ())
{}

::PortableServer::POAManager_ptr
PortableServer::POAManager_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::POAManager_var::POAManager_var (const ::PortableServer::POAManager_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (POAManager::_duplicate (p.ptr ()))
{}

PortableServer::POAManager_var::~POAManager_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::POAManager_var &
PortableServer::POAManager_var::operator= (POAManager_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::POAManager_var &
PortableServer::POAManager_var::operator= (const ::PortableServer::POAManager_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::POAManager::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::POAManager_var::operator const ::PortableServer::POAManager_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::POAManager_var::operator ::PortableServer::POAManager_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::POAManager_ptr
PortableServer::POAManager_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::POAManager_ptr
PortableServer::POAManager_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::POAManager_ptr &
PortableServer::POAManager_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::POAManager_ptr &
PortableServer::POAManager_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::POAManager::_nil ();
  return this->ptr_;
}

::PortableServer::POAManager_ptr
PortableServer::POAManager_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::POAManager_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::POAManager::_nil ();
  return val;
}

::PortableServer::POAManager_ptr
PortableServer::POAManager_var::tao_duplicate (POAManager_ptr p)
{
  return ::PortableServer::POAManager::_duplicate (p);
}

void
PortableServer::POAManager_var::tao_release (POAManager_ptr p)
{
  CORBA::release (p);
}

::PortableServer::POAManager_ptr
PortableServer::POAManager_var::tao_nil (void)
{
  return ::PortableServer::POAManager::_nil ();
}

::PortableServer::POAManager_ptr
PortableServer::POAManager_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::POAManager::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::POAManager_var::tao_upcast (void *src)
{
  POAManager **tmp =
    ACE_static_cast (POAManager **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::POAManager_out
// *************************************************************

PortableServer::POAManager_out::POAManager_out (POAManager_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::POAManager::_nil ();
}

PortableServer::POAManager_out::POAManager_out (POAManager_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::POAManager::_nil ();
}

PortableServer::POAManager_out::POAManager_out (const ::PortableServer::POAManager_out &p) // copy constructor
  : ptr_ (ACE_const_cast (POAManager_out &, p).ptr_)
{}

::PortableServer::POAManager_out &
PortableServer::POAManager_out::operator= (const ::PortableServer::POAManager_out &p)
{
  this->ptr_ = ACE_const_cast (POAManager_out&, p).ptr_;
  return *this;
}

PortableServer::POAManager_out &
PortableServer::POAManager_out::operator= (const ::PortableServer::POAManager_var &p)
{
  this->ptr_ = ::PortableServer::POAManager::_duplicate (p.ptr ());
  return *this;
}

PortableServer::POAManager_out &
PortableServer::POAManager_out::operator= (POAManager_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::POAManager_out::operator ::PortableServer::POAManager_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::POAManager_ptr &
PortableServer::POAManager_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::POAManager_ptr
PortableServer::POAManager_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::POAManager::POAManager (void)
{}
  // destructor
  PortableServer::POAManager::~POAManager (void)
  {}
  
  PortableServer::POAManager_ptr PortableServer::POAManager::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return POAManager::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::POAManager_ptr PortableServer::POAManager::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return POAManager::_nil ();
    return
        ACE_reinterpret_cast
          (
            POAManager_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &POAManager::_tao_class_id
                    )
                )
          );
}

PortableServer::POAManager_ptr
PortableServer::POAManager::_duplicate (POAManager_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::POAManager::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, POAManager)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::POAManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/POAManager:1.0";
}

// Default constructor.
PortableServer::POAManager::AdapterInactive::AdapterInactive (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POAManager/AdapterInactive:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POAManager::AdapterInactive::~AdapterInactive (void)
{
}

// Copy constructor.
PortableServer::POAManager::AdapterInactive::AdapterInactive (const ::PortableServer::POAManager::AdapterInactive &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POAManager::AdapterInactive&
PortableServer::POAManager::AdapterInactive::operator= (const ::PortableServer::POAManager::AdapterInactive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POAManager::AdapterInactive *
PortableServer::POAManager::AdapterInactive::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POAManager/AdapterInactive:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (AdapterInactive *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POAManager::AdapterInactive::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POAManager::AdapterInactive::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POAManager::AdapterInactive::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POAManager::AdapterInactive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POAManager::AdapterInactive, 0);
  return retval;
}

#if (TAO_HAS_MINIMUM_POA == 0)

int PortableServer::AdapterActivator::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::AdapterActivator_var
// *************************************************************

PortableServer::AdapterActivator_var::AdapterActivator_var (void) // default constructor
  : ptr_ (AdapterActivator::_nil ())
{}

::PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::AdapterActivator_var::AdapterActivator_var (const ::PortableServer::AdapterActivator_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (AdapterActivator::_duplicate (p.ptr ()))
{}

PortableServer::AdapterActivator_var::~AdapterActivator_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::AdapterActivator_var &
PortableServer::AdapterActivator_var::operator= (AdapterActivator_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::AdapterActivator_var &
PortableServer::AdapterActivator_var::operator= (const ::PortableServer::AdapterActivator_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::AdapterActivator::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::AdapterActivator_var::operator const ::PortableServer::AdapterActivator_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::AdapterActivator_var::operator ::PortableServer::AdapterActivator_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::AdapterActivator_ptr &
PortableServer::AdapterActivator_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::AdapterActivator_ptr &
PortableServer::AdapterActivator_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::AdapterActivator::_nil ();
  return this->ptr_;
}

::PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::AdapterActivator_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::AdapterActivator::_nil ();
  return val;
}

::PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator_var::tao_duplicate (AdapterActivator_ptr p)
{
  return ::PortableServer::AdapterActivator::_duplicate (p);
}

void
PortableServer::AdapterActivator_var::tao_release (AdapterActivator_ptr p)
{
  CORBA::release (p);
}

::PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator_var::tao_nil (void)
{
  return ::PortableServer::AdapterActivator::_nil ();
}

::PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::AdapterActivator::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::AdapterActivator_var::tao_upcast (void *src)
{
  AdapterActivator **tmp =
    ACE_static_cast (AdapterActivator **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::AdapterActivator_out
// *************************************************************

PortableServer::AdapterActivator_out::AdapterActivator_out (AdapterActivator_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::AdapterActivator::_nil ();
}

PortableServer::AdapterActivator_out::AdapterActivator_out (AdapterActivator_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::AdapterActivator::_nil ();
}

PortableServer::AdapterActivator_out::AdapterActivator_out (const ::PortableServer::AdapterActivator_out &p) // copy constructor
  : ptr_ (ACE_const_cast (AdapterActivator_out &, p).ptr_)
{}

::PortableServer::AdapterActivator_out &
PortableServer::AdapterActivator_out::operator= (const ::PortableServer::AdapterActivator_out &p)
{
  this->ptr_ = ACE_const_cast (AdapterActivator_out&, p).ptr_;
  return *this;
}

PortableServer::AdapterActivator_out &
PortableServer::AdapterActivator_out::operator= (const ::PortableServer::AdapterActivator_var &p)
{
  this->ptr_ = ::PortableServer::AdapterActivator::_duplicate (p.ptr ());
  return *this;
}

PortableServer::AdapterActivator_out &
PortableServer::AdapterActivator_out::operator= (AdapterActivator_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::AdapterActivator_out::operator ::PortableServer::AdapterActivator_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::AdapterActivator_ptr &
PortableServer::AdapterActivator_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::AdapterActivator::AdapterActivator (void)
{}
  // destructor
  PortableServer::AdapterActivator::~AdapterActivator (void)
  {}
  
  PortableServer::AdapterActivator_ptr PortableServer::AdapterActivator::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return AdapterActivator::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::AdapterActivator_ptr PortableServer::AdapterActivator::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return AdapterActivator::_nil ();
    return
        ACE_reinterpret_cast
          (
            AdapterActivator_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &AdapterActivator::_tao_class_id
                    )
                )
          );
}

PortableServer::AdapterActivator_ptr
PortableServer::AdapterActivator::_duplicate (AdapterActivator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::AdapterActivator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, AdapterActivator)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::AdapterActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/AdapterActivator:2.3";
}

int PortableServer::ServantManager::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::ServantManager_var
// *************************************************************

PortableServer::ServantManager_var::ServantManager_var (void) // default constructor
  : ptr_ (ServantManager::_nil ())
{}

::PortableServer::ServantManager_ptr
PortableServer::ServantManager_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::ServantManager_var::ServantManager_var (const ::PortableServer::ServantManager_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ServantManager::_duplicate (p.ptr ()))
{}

PortableServer::ServantManager_var::~ServantManager_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::ServantManager_var &
PortableServer::ServantManager_var::operator= (ServantManager_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::ServantManager_var &
PortableServer::ServantManager_var::operator= (const ::PortableServer::ServantManager_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::ServantManager::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::ServantManager_var::operator const ::PortableServer::ServantManager_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::ServantManager_var::operator ::PortableServer::ServantManager_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::ServantManager_ptr
PortableServer::ServantManager_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::ServantManager_ptr
PortableServer::ServantManager_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::ServantManager_ptr &
PortableServer::ServantManager_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::ServantManager_ptr &
PortableServer::ServantManager_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ServantManager::_nil ();
  return this->ptr_;
}

::PortableServer::ServantManager_ptr
PortableServer::ServantManager_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::ServantManager_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::ServantManager::_nil ();
  return val;
}

::PortableServer::ServantManager_ptr
PortableServer::ServantManager_var::tao_duplicate (ServantManager_ptr p)
{
  return ::PortableServer::ServantManager::_duplicate (p);
}

void
PortableServer::ServantManager_var::tao_release (ServantManager_ptr p)
{
  CORBA::release (p);
}

::PortableServer::ServantManager_ptr
PortableServer::ServantManager_var::tao_nil (void)
{
  return ::PortableServer::ServantManager::_nil ();
}

::PortableServer::ServantManager_ptr
PortableServer::ServantManager_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::ServantManager::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::ServantManager_var::tao_upcast (void *src)
{
  ServantManager **tmp =
    ACE_static_cast (ServantManager **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::ServantManager_out
// *************************************************************

PortableServer::ServantManager_out::ServantManager_out (ServantManager_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::ServantManager::_nil ();
}

PortableServer::ServantManager_out::ServantManager_out (ServantManager_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ServantManager::_nil ();
}

PortableServer::ServantManager_out::ServantManager_out (const ::PortableServer::ServantManager_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ServantManager_out &, p).ptr_)
{}

::PortableServer::ServantManager_out &
PortableServer::ServantManager_out::operator= (const ::PortableServer::ServantManager_out &p)
{
  this->ptr_ = ACE_const_cast (ServantManager_out&, p).ptr_;
  return *this;
}

PortableServer::ServantManager_out &
PortableServer::ServantManager_out::operator= (const ::PortableServer::ServantManager_var &p)
{
  this->ptr_ = ::PortableServer::ServantManager::_duplicate (p.ptr ());
  return *this;
}

PortableServer::ServantManager_out &
PortableServer::ServantManager_out::operator= (ServantManager_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::ServantManager_out::operator ::PortableServer::ServantManager_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::ServantManager_ptr &
PortableServer::ServantManager_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::ServantManager_ptr
PortableServer::ServantManager_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::ServantManager::ServantManager (void)
{}
  // destructor
  PortableServer::ServantManager::~ServantManager (void)
  {}
  
  PortableServer::ServantManager_ptr PortableServer::ServantManager::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return ServantManager::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::ServantManager_ptr PortableServer::ServantManager::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return ServantManager::_nil ();
    return
        ACE_reinterpret_cast
          (
            ServantManager_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ServantManager::_tao_class_id
                    )
                )
          );
}

PortableServer::ServantManager_ptr
PortableServer::ServantManager::_duplicate (ServantManager_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::ServantManager::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, ServantManager)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::ServantManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantManager:1.0";
}

int PortableServer::ServantActivator::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::ServantActivator_var
// *************************************************************

PortableServer::ServantActivator_var::ServantActivator_var (void) // default constructor
  : ptr_ (ServantActivator::_nil ())
{}

::PortableServer::ServantActivator_ptr
PortableServer::ServantActivator_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::ServantActivator_var::ServantActivator_var (const ::PortableServer::ServantActivator_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ServantActivator::_duplicate (p.ptr ()))
{}

PortableServer::ServantActivator_var::~ServantActivator_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::ServantActivator_var &
PortableServer::ServantActivator_var::operator= (ServantActivator_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::ServantActivator_var &
PortableServer::ServantActivator_var::operator= (const ::PortableServer::ServantActivator_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::ServantActivator::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::ServantActivator_var::operator const ::PortableServer::ServantActivator_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::ServantActivator_var::operator ::PortableServer::ServantActivator_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::ServantActivator_ptr
PortableServer::ServantActivator_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::ServantActivator_ptr
PortableServer::ServantActivator_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::ServantActivator_ptr &
PortableServer::ServantActivator_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::ServantActivator_ptr &
PortableServer::ServantActivator_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ServantActivator::_nil ();
  return this->ptr_;
}

::PortableServer::ServantActivator_ptr
PortableServer::ServantActivator_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::ServantActivator_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::ServantActivator::_nil ();
  return val;
}

::PortableServer::ServantActivator_ptr
PortableServer::ServantActivator_var::tao_duplicate (ServantActivator_ptr p)
{
  return ::PortableServer::ServantActivator::_duplicate (p);
}

void
PortableServer::ServantActivator_var::tao_release (ServantActivator_ptr p)
{
  CORBA::release (p);
}

::PortableServer::ServantActivator_ptr
PortableServer::ServantActivator_var::tao_nil (void)
{
  return ::PortableServer::ServantActivator::_nil ();
}

::PortableServer::ServantActivator_ptr
PortableServer::ServantActivator_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::ServantActivator::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::ServantActivator_var::tao_upcast (void *src)
{
  ServantActivator **tmp =
    ACE_static_cast (ServantActivator **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::ServantActivator_out
// *************************************************************

PortableServer::ServantActivator_out::ServantActivator_out (ServantActivator_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::ServantActivator::_nil ();
}

PortableServer::ServantActivator_out::ServantActivator_out (ServantActivator_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ServantActivator::_nil ();
}

PortableServer::ServantActivator_out::ServantActivator_out (const ::PortableServer::ServantActivator_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ServantActivator_out &, p).ptr_)
{}

::PortableServer::ServantActivator_out &
PortableServer::ServantActivator_out::operator= (const ::PortableServer::ServantActivator_out &p)
{
  this->ptr_ = ACE_const_cast (ServantActivator_out&, p).ptr_;
  return *this;
}

PortableServer::ServantActivator_out &
PortableServer::ServantActivator_out::operator= (const ::PortableServer::ServantActivator_var &p)
{
  this->ptr_ = ::PortableServer::ServantActivator::_duplicate (p.ptr ());
  return *this;
}

PortableServer::ServantActivator_out &
PortableServer::ServantActivator_out::operator= (ServantActivator_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::ServantActivator_out::operator ::PortableServer::ServantActivator_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::ServantActivator_ptr &
PortableServer::ServantActivator_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::ServantActivator_ptr
PortableServer::ServantActivator_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::ServantActivator::ServantActivator (void)
{}
  // destructor
  PortableServer::ServantActivator::~ServantActivator (void)
  {}
  
  PortableServer::ServantActivator_ptr PortableServer::ServantActivator::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return ServantActivator::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::ServantActivator_ptr PortableServer::ServantActivator::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return ServantActivator::_nil ();
    return
        ACE_reinterpret_cast
          (
            ServantActivator_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ServantActivator::_tao_class_id
                    )
                )
          );
}

PortableServer::ServantActivator_ptr
PortableServer::ServantActivator::_duplicate (ServantActivator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::ServantActivator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, ServantActivator)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, ServantManager)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            PortableServer::ServantManager_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::ServantActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantActivator:2.3";
}

int PortableServer::ServantLocator::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::ServantLocator_var
// *************************************************************

PortableServer::ServantLocator_var::ServantLocator_var (void) // default constructor
  : ptr_ (ServantLocator::_nil ())
{}

::PortableServer::ServantLocator_ptr
PortableServer::ServantLocator_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::ServantLocator_var::ServantLocator_var (const ::PortableServer::ServantLocator_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (ServantLocator::_duplicate (p.ptr ()))
{}

PortableServer::ServantLocator_var::~ServantLocator_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::ServantLocator_var &
PortableServer::ServantLocator_var::operator= (ServantLocator_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::ServantLocator_var &
PortableServer::ServantLocator_var::operator= (const ::PortableServer::ServantLocator_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::ServantLocator::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::ServantLocator_var::operator const ::PortableServer::ServantLocator_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::ServantLocator_var::operator ::PortableServer::ServantLocator_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::ServantLocator_ptr
PortableServer::ServantLocator_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::ServantLocator_ptr
PortableServer::ServantLocator_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::ServantLocator_ptr &
PortableServer::ServantLocator_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::ServantLocator_ptr &
PortableServer::ServantLocator_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ServantLocator::_nil ();
  return this->ptr_;
}

::PortableServer::ServantLocator_ptr
PortableServer::ServantLocator_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::ServantLocator_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::ServantLocator::_nil ();
  return val;
}

::PortableServer::ServantLocator_ptr
PortableServer::ServantLocator_var::tao_duplicate (ServantLocator_ptr p)
{
  return ::PortableServer::ServantLocator::_duplicate (p);
}

void
PortableServer::ServantLocator_var::tao_release (ServantLocator_ptr p)
{
  CORBA::release (p);
}

::PortableServer::ServantLocator_ptr
PortableServer::ServantLocator_var::tao_nil (void)
{
  return ::PortableServer::ServantLocator::_nil ();
}

::PortableServer::ServantLocator_ptr
PortableServer::ServantLocator_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::ServantLocator::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::ServantLocator_var::tao_upcast (void *src)
{
  ServantLocator **tmp =
    ACE_static_cast (ServantLocator **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::ServantLocator_out
// *************************************************************

PortableServer::ServantLocator_out::ServantLocator_out (ServantLocator_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::ServantLocator::_nil ();
}

PortableServer::ServantLocator_out::ServantLocator_out (ServantLocator_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::ServantLocator::_nil ();
}

PortableServer::ServantLocator_out::ServantLocator_out (const ::PortableServer::ServantLocator_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ServantLocator_out &, p).ptr_)
{}

::PortableServer::ServantLocator_out &
PortableServer::ServantLocator_out::operator= (const ::PortableServer::ServantLocator_out &p)
{
  this->ptr_ = ACE_const_cast (ServantLocator_out&, p).ptr_;
  return *this;
}

PortableServer::ServantLocator_out &
PortableServer::ServantLocator_out::operator= (const ::PortableServer::ServantLocator_var &p)
{
  this->ptr_ = ::PortableServer::ServantLocator::_duplicate (p.ptr ());
  return *this;
}

PortableServer::ServantLocator_out &
PortableServer::ServantLocator_out::operator= (ServantLocator_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::ServantLocator_out::operator ::PortableServer::ServantLocator_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::ServantLocator_ptr &
PortableServer::ServantLocator_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::ServantLocator_ptr
PortableServer::ServantLocator_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::ServantLocator::ServantLocator (void)
{}
  // destructor
  PortableServer::ServantLocator::~ServantLocator (void)
  {}
  
  PortableServer::ServantLocator_ptr PortableServer::ServantLocator::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return ServantLocator::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::ServantLocator_ptr PortableServer::ServantLocator::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return ServantLocator::_nil ();
    return
        ACE_reinterpret_cast
          (
            ServantLocator_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ServantLocator::_tao_class_id
                    )
                )
          );
}

PortableServer::ServantLocator_ptr
PortableServer::ServantLocator::_duplicate (ServantLocator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::ServantLocator::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, ServantLocator)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, ServantManager)::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            PortableServer::ServantManager_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::ServantLocator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantLocator:2.3";
}

#endif /* TAO_HAS_MINIMUM_POA == 0 */

int PortableServer::POA::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::POA_var
// *************************************************************

PortableServer::POA_var::POA_var (void) // default constructor
  : ptr_ (POA::_nil ())
{}

::PortableServer::POA_ptr
PortableServer::POA_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::POA_var::POA_var (const ::PortableServer::POA_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (POA::_duplicate (p.ptr ()))
{}

PortableServer::POA_var::~POA_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::POA_var &
PortableServer::POA_var::operator= (POA_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::POA_var &
PortableServer::POA_var::operator= (const ::PortableServer::POA_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::POA::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::POA_var::operator const ::PortableServer::POA_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::POA_var::operator ::PortableServer::POA_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::POA_ptr
PortableServer::POA_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::POA_ptr
PortableServer::POA_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::POA_ptr &
PortableServer::POA_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::POA_ptr &
PortableServer::POA_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::POA::_nil ();
  return this->ptr_;
}

::PortableServer::POA_ptr
PortableServer::POA_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::POA_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::POA::_nil ();
  return val;
}

::PortableServer::POA_ptr
PortableServer::POA_var::tao_duplicate (POA_ptr p)
{
  return ::PortableServer::POA::_duplicate (p);
}

void
PortableServer::POA_var::tao_release (POA_ptr p)
{
  CORBA::release (p);
}

::PortableServer::POA_ptr
PortableServer::POA_var::tao_nil (void)
{
  return ::PortableServer::POA::_nil ();
}

::PortableServer::POA_ptr
PortableServer::POA_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::POA::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::POA_var::tao_upcast (void *src)
{
  POA **tmp =
    ACE_static_cast (POA **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::POA_out
// *************************************************************

PortableServer::POA_out::POA_out (POA_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::POA::_nil ();
}

PortableServer::POA_out::POA_out (POA_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::POA::_nil ();
}

PortableServer::POA_out::POA_out (const ::PortableServer::POA_out &p) // copy constructor
  : ptr_ (ACE_const_cast (POA_out &, p).ptr_)
{}

::PortableServer::POA_out &
PortableServer::POA_out::operator= (const ::PortableServer::POA_out &p)
{
  this->ptr_ = ACE_const_cast (POA_out&, p).ptr_;
  return *this;
}

PortableServer::POA_out &
PortableServer::POA_out::operator= (const ::PortableServer::POA_var &p)
{
  this->ptr_ = ::PortableServer::POA::_duplicate (p.ptr ());
  return *this;
}

PortableServer::POA_out &
PortableServer::POA_out::operator= (POA_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::POA_out::operator ::PortableServer::POA_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::POA_ptr &
PortableServer::POA_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::POA_ptr
PortableServer::POA_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::POA::POA (void)
{}
  // destructor
  PortableServer::POA::~POA (void)
  {}
  
  PortableServer::POA_ptr PortableServer::POA::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return POA::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::POA_ptr PortableServer::POA::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return POA::_nil ();
    return
        ACE_reinterpret_cast
          (
            POA_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &POA::_tao_class_id
                    )
                )
          );
}

PortableServer::POA_ptr
PortableServer::POA::_duplicate (POA_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::POA::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, POA)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::POA::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/POA:2.3";
}

// Default constructor.
PortableServer::POA::AdapterAlreadyExists::AdapterAlreadyExists (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/AdapterAlreadyExists:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::AdapterAlreadyExists::~AdapterAlreadyExists (void)
{
}

// Copy constructor.
PortableServer::POA::AdapterAlreadyExists::AdapterAlreadyExists (const ::PortableServer::POA::AdapterAlreadyExists &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::AdapterAlreadyExists&
PortableServer::POA::AdapterAlreadyExists::operator= (const ::PortableServer::POA::AdapterAlreadyExists &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::AdapterAlreadyExists *
PortableServer::POA::AdapterAlreadyExists::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/AdapterAlreadyExists:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (AdapterAlreadyExists *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::AdapterAlreadyExists::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::AdapterAlreadyExists::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::AdapterAlreadyExists::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::AdapterAlreadyExists::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::AdapterAlreadyExists, 0);
  return retval;
}

// Default constructor.
PortableServer::POA::AdapterNonExistent::AdapterNonExistent (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/AdapterNonExistent:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::AdapterNonExistent::~AdapterNonExistent (void)
{
}

// Copy constructor.
PortableServer::POA::AdapterNonExistent::AdapterNonExistent (const ::PortableServer::POA::AdapterNonExistent &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::AdapterNonExistent&
PortableServer::POA::AdapterNonExistent::operator= (const ::PortableServer::POA::AdapterNonExistent &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::AdapterNonExistent *
PortableServer::POA::AdapterNonExistent::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/AdapterNonExistent:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (AdapterNonExistent *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::AdapterNonExistent::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::AdapterNonExistent::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::AdapterNonExistent::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::AdapterNonExistent::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::AdapterNonExistent, 0);
  return retval;
}

// Default constructor.
PortableServer::POA::InvalidPolicy::InvalidPolicy (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/InvalidPolicy:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::InvalidPolicy::~InvalidPolicy (void)
{
}

// Copy constructor.
PortableServer::POA::InvalidPolicy::InvalidPolicy (const ::PortableServer::POA::InvalidPolicy &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  this->index = _tao_excp.index;
}

// Assignment operator.
PortableServer::POA::InvalidPolicy&
PortableServer::POA::InvalidPolicy::operator= (const ::PortableServer::POA::InvalidPolicy &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->index = _tao_excp.index;
  return *this;
}

// Narrow.
PortableServer::POA::InvalidPolicy *
PortableServer::POA::InvalidPolicy::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/InvalidPolicy:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (InvalidPolicy *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::InvalidPolicy::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::InvalidPolicy::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::InvalidPolicy::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::InvalidPolicy::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::InvalidPolicy, 0);
  return retval;
}

PortableServer::POA::InvalidPolicy::InvalidPolicy (
    CORBA::UShort _tao_index
  )
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/InvalidPolicy:1.0")
{
  this->index = _tao_index;
}

#if (TAO_HAS_MINIMUM_POA == 0)

// Default constructor.
PortableServer::POA::NoServant::NoServant (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/NoServant:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::NoServant::~NoServant (void)
{
}

// Copy constructor.
PortableServer::POA::NoServant::NoServant (const ::PortableServer::POA::NoServant &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::NoServant&
PortableServer::POA::NoServant::operator= (const ::PortableServer::POA::NoServant &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::NoServant *
PortableServer::POA::NoServant::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/NoServant:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (NoServant *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::NoServant::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::NoServant::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::NoServant::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::NoServant::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::NoServant, 0);
  return retval;
}

#endif /* TAO_HAS_MINIMUM_POA == 0 */

// Default constructor.
PortableServer::POA::ObjectAlreadyActive::ObjectAlreadyActive (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/ObjectAlreadyActive:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::ObjectAlreadyActive::~ObjectAlreadyActive (void)
{
}

// Copy constructor.
PortableServer::POA::ObjectAlreadyActive::ObjectAlreadyActive (const ::PortableServer::POA::ObjectAlreadyActive &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::ObjectAlreadyActive&
PortableServer::POA::ObjectAlreadyActive::operator= (const ::PortableServer::POA::ObjectAlreadyActive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::ObjectAlreadyActive *
PortableServer::POA::ObjectAlreadyActive::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ObjectAlreadyActive:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ObjectAlreadyActive *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::ObjectAlreadyActive::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::ObjectAlreadyActive::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::ObjectAlreadyActive::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::ObjectAlreadyActive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::ObjectAlreadyActive, 0);
  return retval;
}

// Default constructor.
PortableServer::POA::ObjectNotActive::ObjectNotActive (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/ObjectNotActive:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::ObjectNotActive::~ObjectNotActive (void)
{
}

// Copy constructor.
PortableServer::POA::ObjectNotActive::ObjectNotActive (const ::PortableServer::POA::ObjectNotActive &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::ObjectNotActive&
PortableServer::POA::ObjectNotActive::operator= (const ::PortableServer::POA::ObjectNotActive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::ObjectNotActive *
PortableServer::POA::ObjectNotActive::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ObjectNotActive:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ObjectNotActive *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::ObjectNotActive::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::ObjectNotActive::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::ObjectNotActive::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::ObjectNotActive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::ObjectNotActive, 0);
  return retval;
}

// Default constructor.
PortableServer::POA::ServantAlreadyActive::ServantAlreadyActive (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/ServantAlreadyActive:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::ServantAlreadyActive::~ServantAlreadyActive (void)
{
}

// Copy constructor.
PortableServer::POA::ServantAlreadyActive::ServantAlreadyActive (const ::PortableServer::POA::ServantAlreadyActive &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::ServantAlreadyActive&
PortableServer::POA::ServantAlreadyActive::operator= (const ::PortableServer::POA::ServantAlreadyActive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::ServantAlreadyActive *
PortableServer::POA::ServantAlreadyActive::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ServantAlreadyActive:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ServantAlreadyActive *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::ServantAlreadyActive::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::ServantAlreadyActive::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::ServantAlreadyActive::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::ServantAlreadyActive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::ServantAlreadyActive, 0);
  return retval;
}

// Default constructor.
PortableServer::POA::ServantNotActive::ServantNotActive (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/ServantNotActive:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::ServantNotActive::~ServantNotActive (void)
{
}

// Copy constructor.
PortableServer::POA::ServantNotActive::ServantNotActive (const ::PortableServer::POA::ServantNotActive &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::ServantNotActive&
PortableServer::POA::ServantNotActive::operator= (const ::PortableServer::POA::ServantNotActive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::ServantNotActive *
PortableServer::POA::ServantNotActive::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ServantNotActive:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (ServantNotActive *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::ServantNotActive::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::ServantNotActive::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::ServantNotActive::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::ServantNotActive::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::ServantNotActive, 0);
  return retval;
}

// Default constructor.
PortableServer::POA::WrongAdapter::WrongAdapter (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/WrongAdapter:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::WrongAdapter::~WrongAdapter (void)
{
}

// Copy constructor.
PortableServer::POA::WrongAdapter::WrongAdapter (const ::PortableServer::POA::WrongAdapter &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::WrongAdapter&
PortableServer::POA::WrongAdapter::operator= (const ::PortableServer::POA::WrongAdapter &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::WrongAdapter *
PortableServer::POA::WrongAdapter::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/WrongAdapter:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (WrongAdapter *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::WrongAdapter::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::WrongAdapter::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::WrongAdapter::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::WrongAdapter::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::WrongAdapter, 0);
  return retval;
}

// Default constructor.
PortableServer::POA::WrongPolicy::WrongPolicy (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/POA/WrongPolicy:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::POA::WrongPolicy::~WrongPolicy (void)
{
}

// Copy constructor.
PortableServer::POA::WrongPolicy::WrongPolicy (const ::PortableServer::POA::WrongPolicy &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::POA::WrongPolicy&
PortableServer::POA::WrongPolicy::operator= (const ::PortableServer::POA::WrongPolicy &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::POA::WrongPolicy *
PortableServer::POA::WrongPolicy::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/WrongPolicy:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (WrongPolicy *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::POA::WrongPolicy::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::POA::WrongPolicy::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::POA::WrongPolicy::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::POA::WrongPolicy::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::POA::WrongPolicy, 0);
  return retval;
}

int PortableServer::Current::_tao_class_id = 0;

// *************************************************************
// Operations for class PortableServer::Current_var
// *************************************************************

PortableServer::Current_var::Current_var (void) // default constructor
  : ptr_ (Current::_nil ())
{}

::PortableServer::Current_ptr
PortableServer::Current_var::ptr (void) const
{
  return this->ptr_;
}

PortableServer::Current_var::Current_var (const ::PortableServer::Current_var &p) // copy constructor
  : TAO_Base_var (),
    ptr_ (Current::_duplicate (p.ptr ()))
{}

PortableServer::Current_var::~Current_var (void) // destructor
{
  CORBA::release (this->ptr_);
}

PortableServer::Current_var &
PortableServer::Current_var::operator= (Current_ptr p)
{
  CORBA::release (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableServer::Current_var &
PortableServer::Current_var::operator= (const ::PortableServer::Current_var &p)
{
  if (this != &p)
  {
    CORBA::release (this->ptr_);
    this->ptr_ = ::PortableServer::Current::_duplicate (p.ptr ());
  }
  return *this;
}

PortableServer::Current_var::operator const ::PortableServer::Current_ptr &() const // cast
{
  return this->ptr_;
}

PortableServer::Current_var::operator ::PortableServer::Current_ptr &() // cast 
{
  return this->ptr_;
}

::PortableServer::Current_ptr
PortableServer::Current_var::operator-> (void) const
{
  return this->ptr_;
}

::PortableServer::Current_ptr
PortableServer::Current_var::in (void) const
{
  return this->ptr_;
}

::PortableServer::Current_ptr &
PortableServer::Current_var::inout (void)
{
  return this->ptr_;
}

::PortableServer::Current_ptr &
PortableServer::Current_var::out (void)
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::Current::_nil ();
  return this->ptr_;
}

::PortableServer::Current_ptr
PortableServer::Current_var::_retn (void)
{
  // yield ownership of managed obj reference
  ::PortableServer::Current_ptr val = this->ptr_;
  this->ptr_ = ::PortableServer::Current::_nil ();
  return val;
}

::PortableServer::Current_ptr
PortableServer::Current_var::tao_duplicate (Current_ptr p)
{
  return ::PortableServer::Current::_duplicate (p);
}

void
PortableServer::Current_var::tao_release (Current_ptr p)
{
  CORBA::release (p);
}

::PortableServer::Current_ptr
PortableServer::Current_var::tao_nil (void)
{
  return ::PortableServer::Current::_nil ();
}

::PortableServer::Current_ptr
PortableServer::Current_var::tao_narrow (
    CORBA::Object *p
    TAO_ENV_ARG_DECL
  )
{
  return ::PortableServer::Current::_narrow (p TAO_ENV_ARG_PARAMETER);
}

CORBA::Object *
PortableServer::Current_var::tao_upcast (void *src)
{
  Current **tmp =
    ACE_static_cast (Current **, src);
  return *tmp;
}

// *************************************************************
// Operations for class PortableServer::Current_out
// *************************************************************

PortableServer::Current_out::Current_out (Current_ptr &p)
  : ptr_ (p)
{
  this->ptr_ = ::PortableServer::Current::_nil ();
}

PortableServer::Current_out::Current_out (Current_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::release (this->ptr_);
  this->ptr_ = ::PortableServer::Current::_nil ();
}

PortableServer::Current_out::Current_out (const ::PortableServer::Current_out &p) // copy constructor
  : ptr_ (ACE_const_cast (Current_out &, p).ptr_)
{}

::PortableServer::Current_out &
PortableServer::Current_out::operator= (const ::PortableServer::Current_out &p)
{
  this->ptr_ = ACE_const_cast (Current_out&, p).ptr_;
  return *this;
}

PortableServer::Current_out &
PortableServer::Current_out::operator= (const ::PortableServer::Current_var &p)
{
  this->ptr_ = ::PortableServer::Current::_duplicate (p.ptr ());
  return *this;
}

PortableServer::Current_out &
PortableServer::Current_out::operator= (Current_ptr p)
{
  this->ptr_ = p;
  return *this;
}

PortableServer::Current_out::operator ::PortableServer::Current_ptr &() // cast
{
  return this->ptr_;
}

::PortableServer::Current_ptr &
PortableServer::Current_out::ptr (void) // ptr
{
  return this->ptr_;
}

::PortableServer::Current_ptr
PortableServer::Current_out::operator-> (void)
{
  return this->ptr_;
}


// default constructor
PortableServer::Current::Current (void)
{}
  // destructor
  PortableServer::Current::~Current (void)
  {}
  
  PortableServer::Current_ptr PortableServer::Current::_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL
    )
  {
    return Current::_unchecked_narrow (obj TAO_ENV_ARG_PARAMETER);
  }
  
  PortableServer::Current_ptr PortableServer::Current::_unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_NOT_USED
    )
  {
    if (CORBA::is_nil (obj))
      return Current::_nil ();
    return
        ACE_reinterpret_cast
          (
            Current_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &Current::_tao_class_id
                    )
                )
          );
}

PortableServer::Current_ptr
PortableServer::Current::_duplicate (Current_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void *PortableServer::Current::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableServer, Current)::_tao_class_id))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Current::_tao_class_id))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Current_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_tao_class_id))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableServer::Current::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/Current:2.3";
}

// Default constructor.
PortableServer::Current::NoContext::NoContext (void)
  : CORBA_UserException ("IDL:omg.org/PortableServer/Current/NoContext:1.0")
{
}

// Destructor - all members are of self managing types.
PortableServer::Current::NoContext::~NoContext (void)
{
}

// Copy constructor.
PortableServer::Current::NoContext::NoContext (const ::PortableServer::Current::NoContext &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// Assignment operator.
PortableServer::Current::NoContext&
PortableServer::Current::NoContext::operator= (const ::PortableServer::Current::NoContext &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// Narrow.
PortableServer::Current::NoContext *
PortableServer::Current::NoContext::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/Current/NoContext:1.0", exc->_id ()))
    {
      return ACE_dynamic_cast (NoContext *, exc);
    }
  else
    {
      return 0;
    }
}

void PortableServer::Current::NoContext::_raise ()
{
  TAO_RAISE (*this);
}

void PortableServer::Current::NoContext::_tao_encode (
    TAO_OutputCDR &
    TAO_ENV_ARG_DECL
  ) const
{
  ACE_THROW (CORBA::MARSHAL ());
}

void PortableServer::Current::NoContext::_tao_decode (
    TAO_InputCDR &
    TAO_ENV_ARG_DECL
  )
{
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method.
CORBA::Exception *PortableServer::Current::NoContext::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableServer::Current::NoContext, 0);
  return retval;
}

char *
PortableServer::ObjectId_to_string (const PortableServer::ObjectId &id)
{
  return TAO_POA::ObjectId_to_string (id);
}

CORBA::WChar *
PortableServer::ObjectId_to_wstring (const PortableServer::ObjectId &id)
{
  return TAO_POA::ObjectId_to_wstring (id);
}

PortableServer::ObjectId *
PortableServer::string_to_ObjectId (const char *id)
{
  return TAO_POA::string_to_ObjectId (id);
}

PortableServer::ObjectId *
PortableServer::wstring_to_ObjectId (const CORBA::WChar *id)
{
  return TAO_POA::wstring_to_ObjectId (id);
}

void operator<<= (
    CORBA::Any &_tao_any,
    const PortableServer::ObjectId &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableServer::_tc_ObjectId,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::ObjectId *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_ObjectId,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableServer::ObjectId::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::ObjectId *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableServer::ObjectId*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableServer::ObjectId *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_ObjectId TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableServer::ObjectId*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableServer::ObjectId *tmp;
      ACE_NEW_RETURN (tmp, PortableServer::ObjectId, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableServer::_tc_ObjectId,
            1,
            ACE_static_cast (void *, tmp),
            PortableServer::ObjectId::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if (TAO_HAS_MINIMUM_CORBA == 0)

void operator<<= (CORBA::Any &_tao_any, const PortableServer::ForwardRequest &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_ForwardRequest,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::ForwardRequest *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_ForwardRequest,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableServer::ForwardRequest::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::ForwardRequest *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableServer::ForwardRequest*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableServer::ForwardRequest *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_ForwardRequest TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::ForwardRequest *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableServer::ForwardRequest *tmp;
      ACE_NEW_RETURN (tmp, PortableServer::ForwardRequest, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableServer/ForwardRequest:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableServer::_tc_ForwardRequest,
            1,
            tmp,
            PortableServer::ForwardRequest::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::NotAGroupObject &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_NotAGroupObject,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::NotAGroupObject *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_NotAGroupObject,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableServer::NotAGroupObject::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::NotAGroupObject *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableServer::NotAGroupObject*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableServer::NotAGroupObject *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_NotAGroupObject TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::NotAGroupObject *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableServer::NotAGroupObject *tmp;
      ACE_NEW_RETURN (tmp, PortableServer::NotAGroupObject, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:omg.org/PortableServer/NotAGroupObject:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableServer::_tc_NotAGroupObject,
            1,
            tmp,
            PortableServer::NotAGroupObject::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const PortableServer::IDs &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableServer::_tc_IDs,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::IDs *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_IDs,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableServer::IDs::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::IDs *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableServer::IDs*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableServer::IDs *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_IDs TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableServer::IDs*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableServer::IDs *tmp;
      ACE_NEW_RETURN (tmp, PortableServer::IDs, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableServer::_tc_IDs,
            1,
            ACE_static_cast (void *, tmp),
            PortableServer::IDs::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#endif /* TAO_HAS_MINIMUM_CORBA == 0 */

#if (TAO_HAS_MINIMUM_POA == 0)

void operator<<= (CORBA::Any &_tao_any, PortableServer::ThreadPolicyValue _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_ThreadPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::ThreadPolicyValue &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_ThreadPolicyValue TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::ThreadPolicy,PortableServer::ThreadPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::ThreadPolicy,PortableServer::ThreadPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /* TAO_HAS_MINIMUM_POA == 0 */

void operator<<= (CORBA::Any &_tao_any, PortableServer::LifespanPolicyValue _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_LifespanPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::LifespanPolicyValue &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_LifespanPolicyValue TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::LifespanPolicy,PortableServer::LifespanPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::LifespanPolicy,PortableServer::LifespanPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, PortableServer::IdUniquenessPolicyValue _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_IdUniquenessPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::IdUniquenessPolicyValue &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_IdUniquenessPolicyValue TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::IdUniquenessPolicy,PortableServer::IdUniquenessPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::IdUniquenessPolicy,PortableServer::IdUniquenessPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, PortableServer::IdAssignmentPolicyValue _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_IdAssignmentPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::IdAssignmentPolicyValue &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_IdAssignmentPolicyValue TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::IdAssignmentPolicy,PortableServer::IdAssignmentPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::IdAssignmentPolicy,PortableServer::IdAssignmentPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if (TAO_HAS_MINIMUM_POA == 0)

void operator<<= (CORBA::Any &_tao_any, PortableServer::ImplicitActivationPolicyValue _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_ImplicitActivationPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::ImplicitActivationPolicyValue &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_ImplicitActivationPolicyValue TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::ImplicitActivationPolicy,PortableServer::ImplicitActivationPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::ImplicitActivationPolicy,PortableServer::ImplicitActivationPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, PortableServer::ServantRetentionPolicyValue _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_ServantRetentionPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::ServantRetentionPolicyValue &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_ServantRetentionPolicyValue TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::ServantRetentionPolicy,PortableServer::ServantRetentionPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::ServantRetentionPolicy,PortableServer::ServantRetentionPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, PortableServer::RequestProcessingPolicyValue _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableServer::_tc_RequestProcessingPolicyValue,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::RequestProcessingPolicyValue &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableServer::_tc_RequestProcessingPolicyValue TAO_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::RequestProcessingPolicy,PortableServer::RequestProcessingPolicy_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::RequestProcessingPolicy,PortableServer::RequestProcessingPolicy_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /* TAO_HAS_MINIMUM_POA == 0 */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::POAManager,PortableServer::POAManager_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::POAManager,PortableServer::POAManager_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if (TAO_HAS_MINIMUM_POA == 0)

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::AdapterActivator,PortableServer::AdapterActivator_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::AdapterActivator,PortableServer::AdapterActivator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::ServantManager,PortableServer::ServantManager_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::ServantManager,PortableServer::ServantManager_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::ServantActivator,PortableServer::ServantActivator_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::ServantActivator,PortableServer::ServantActivator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::ServantLocator,PortableServer::ServantLocator_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::ServantLocator,PortableServer::ServantLocator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#endif /* TAO_HAS_MINIMUM_POA == 0 */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::POA,PortableServer::POA_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::POA,PortableServer::POA_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableServer::Current,PortableServer::Current_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableServer::Current,PortableServer::Current_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableServer::ObjectId &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    {
      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (PortableServer::ObjectId *)&_tao_sequence);
      if (oseq->mb ())
        return strm.write_octet_array_mb (oseq->mb ());
      else
        return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
    
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableServer::ObjectId &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    if (ACE_BIT_DISABLED (strm.start ()->flags (),
    ACE_Message_Block::DONT_DELETE))
    {
      TAO_ORB_Core* orb_core = strm.orb_core ();
      if (orb_core != 0 &&
      strm.orb_core ()->resource_factory ()->
      input_cdr_allocator_type_locked () == 1)
      {
        TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
          ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
        oseq->replace (_tao_seq_len, strm.start ());
        oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
        strm.skip_bytes (_tao_seq_len);
        return 1;
      }
    }
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableServer::IDs &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableServer::IDs &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 58.)
    if (_tao_seq_len > strm.length())
      return 0;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

