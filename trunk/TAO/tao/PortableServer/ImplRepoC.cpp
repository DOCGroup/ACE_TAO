/* -*- C++ -*- $Id$ */


// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "ImplRepoC.h"
#include "tao/Stub.h"
#include "tao/NVList.h"
#include "tao/ORB_Core.h"
#include "tao/Invocation.h"

#if !defined (__ACE_INLINE__)
#include "ImplRepoC.i"
#endif /* !defined INLINE */

void ImplementationRepository::ServerObject::_tao_any_destructor (void *x)
{
  ImplementationRepository::ServerObject *tmp = ACE_static_cast (ImplementationRepository::ServerObject*,x);
  CORBA::release (tmp);
}

ImplementationRepository::ServerObject_ptr ImplementationRepository::ServerObject::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ServerObject::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:ImplementationRepository/ServerObject:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ServerObject::_nil ());
  if (is_a == 0)
    return ServerObject::_nil ();
  return ServerObject::_unchecked_narrow (obj, ACE_TRY_ENV);
}

ImplementationRepository::ServerObject_ptr ImplementationRepository::ServerObject::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ServerObject::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  ServerObject_ptr default_proxy = ServerObject::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_ImplementationRepository_ServerObject_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_ImplementationRepository_ServerObject_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ServerObject (stub), ServerObject::_nil ());
  return TAO_ImplementationRepository_ServerObject_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

ImplementationRepository::ServerObject_ptr
ImplementationRepository::ServerObject::_duplicate (ServerObject_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void ImplementationRepository::ServerObject::ping (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "ping",
      4,
      0,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        break;
      }

}

void ImplementationRepository::ServerObject::shutdown (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "shutdown",
      8,
      0,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        ACE_CHECK;
        break;

      }

}

CORBA::Boolean ImplementationRepository::ServerObject::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:ImplementationRepository/ServerObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* ImplementationRepository::ServerObject::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/ServerObject:1.0";
}

ImplementationRepository::TAO_ImplementationRepository_ServerObject_Default_Proxy_Factory::TAO_ImplementationRepository_ServerObject_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_ImplementationRepository_ServerObject_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

ImplementationRepository::TAO_ImplementationRepository_ServerObject_Default_Proxy_Factory::~TAO_ImplementationRepository_ServerObject_Default_Proxy_Factory (void)
{
}

ImplementationRepository::ServerObject_ptr
ImplementationRepository::TAO_ImplementationRepository_ServerObject_Default_Proxy_Factory::create_proxy (
    ::ImplementationRepository::ServerObject_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

ImplementationRepository::TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter::TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

ImplementationRepository::TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter::~TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
ImplementationRepository::TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_ImplementationRepository_ServerObject_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
ImplementationRepository::TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

ImplementationRepository::ServerObject_ptr
ImplementationRepository::TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter::create_proxy (
    ::ImplementationRepository::ServerObject_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_ImplementationRepository_ServerObject_Default_Proxy_Factory (1),
         0);


  return this->proxy_factory_->create_proxy (proxy);
}

ImplementationRepository::TAO_ImplementationRepository_ServerObject_Smart_Proxy_Base::TAO_ImplementationRepository_ServerObject_Smart_Proxy_Base (::ImplementationRepository::ServerObject_ptr proxy)
: base_proxy_ (proxy)
{
}

ImplementationRepository::TAO_ImplementationRepository_ServerObject_Smart_Proxy_Base::~TAO_ImplementationRepository_ServerObject_Smart_Proxy_Base (void)
{
}

void ImplementationRepository::TAO_ImplementationRepository_ServerObject_Smart_Proxy_Base::ping  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->ping (
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_ServerObject_Smart_Proxy_Base::shutdown  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->shutdown (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class TAO_Singleton<ImplementationRepository::TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter, TAO_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate TAO_Singleton<ImplementationRepository::TAO_ImplementationRepository_ServerObject_Proxy_Factory_Adapter, TAO_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_ImplementationRepository_ServerObject[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f536572), ACE_NTOHL (0x7665724f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x743a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:ImplementationRepository/ServerObject:1.0
  13, ACE_NTOHL (0x53657276), ACE_NTOHL (0x65724f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = ServerObject
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_ServerObject (CORBA::tk_objref, sizeof (_oc_ImplementationRepository_ServerObject), (char *) &_oc_ImplementationRepository_ServerObject, 0, sizeof (ImplementationRepository::ServerObject));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServerObject, &_tc_TAO_tc_ImplementationRepository_ServerObject)
TAO_NAMESPACE_END
static const CORBA::Long _oc_ImplementationRepository_EnvironmentVariable[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  53, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x56617269), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentVariable:1.0
  20, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e7456), ACE_NTOHL (0x61726961), ACE_NTOHL (0x626c6500),  // name = EnvironmentVariable
  2, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_string,
  0U, // string length
  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_string,
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_EnvironmentVariable (CORBA::tk_struct, sizeof (_oc_ImplementationRepository_EnvironmentVariable), (char *) &_oc_ImplementationRepository_EnvironmentVariable, 0, sizeof (ImplementationRepository::EnvironmentVariable));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnvironmentVariable, &_tc_TAO_tc_ImplementationRepository_EnvironmentVariable)
TAO_NAMESPACE_END
void ImplementationRepository::EnvironmentVariable::_tao_any_destructor (void *x)
{
  ImplementationRepository::EnvironmentVariable *tmp = ACE_static_cast (ImplementationRepository::EnvironmentVariable*,x);
  delete tmp;
}

static const CORBA::Long _oc_ImplementationRepository_Address[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f416464), ACE_NTOHL (0x72657373), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/Address:1.0
  8, ACE_NTOHL (0x41646472), ACE_NTOHL (0x65737300),  // name = Address
  CORBA::tk_string,
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_Address (CORBA::tk_alias, sizeof (_oc_ImplementationRepository_Address), (char *) &_oc_ImplementationRepository_Address, 0, sizeof (ImplementationRepository::Address));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Address, &_tc_TAO_tc_ImplementationRepository_Address)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IMPLEMENTATIONREPOSITORY_ENVIRONMENTLIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IMPLEMENTATIONREPOSITORY_ENVIRONMENTLIST_CS_

  void
  ImplementationRepository::_TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList::_allocate_buffer (CORBA::ULong length)
  {
    ImplementationRepository::EnvironmentVariable* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList::allocbuf (length);

    if (this->buffer_ != 0)
    {
      ImplementationRepository::EnvironmentVariable *old = ACE_reinterpret_cast (ImplementationRepository::EnvironmentVariable *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  ImplementationRepository::_TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    ImplementationRepository::EnvironmentVariable *tmp = ACE_reinterpret_cast (ImplementationRepository::EnvironmentVariable *,this->buffer_);

    _TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList::freebuf (tmp);
    this->buffer_ = 0;
  }

  ImplementationRepository::_TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList::~_TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IMPLEMENTATIONREPOSITORY_ENVIRONMENTLIST_CS_)
#define _IMPLEMENTATIONREPOSITORY_ENVIRONMENTLIST_CS_

// *************************************************************
// ImplementationRepository::EnvironmentList
// *************************************************************

ImplementationRepository::EnvironmentList::EnvironmentList (void)
{}
ImplementationRepository::EnvironmentList::EnvironmentList (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<ImplementationRepository::EnvironmentVariable>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
ImplementationRepository::EnvironmentList::EnvironmentList (CORBA::ULong max, CORBA::ULong length, ImplementationRepository::EnvironmentVariable *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<ImplementationRepository::EnvironmentVariable>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
ImplementationRepository::EnvironmentList::EnvironmentList (const EnvironmentList &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_ImplementationRepository_EnvironmentList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<ImplementationRepository::EnvironmentVariable>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
ImplementationRepository::EnvironmentList::~EnvironmentList (void) // dtor
{}
void ImplementationRepository::EnvironmentList::_tao_any_destructor (void *x)
{
  ImplementationRepository::EnvironmentList *tmp = ACE_static_cast (ImplementationRepository::EnvironmentList*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_ImplementationRepository_EnvironmentList[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x4c697374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentList:1.0
  16, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e744c), ACE_NTOHL (0x69737400),  // name = EnvironmentList
  CORBA::tk_sequence, // typecode kind
  148, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    132, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      53, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x56617269), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentVariable:1.0
      20, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e7456), ACE_NTOHL (0x61726961), ACE_NTOHL (0x626c6500),  // name = EnvironmentVariable
      2, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_string,
      0U, // string length
      6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_string,
      0U, // string length

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_EnvironmentList (CORBA::tk_alias, sizeof (_oc_ImplementationRepository_EnvironmentList), (char *) &_oc_ImplementationRepository_EnvironmentList, 0, sizeof (ImplementationRepository::EnvironmentList));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnvironmentList, &_tc_TAO_tc_ImplementationRepository_EnvironmentList)
TAO_NAMESPACE_END
static const CORBA::Long _oc_ImplementationRepository_ActivationMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f416374), ACE_NTOHL (0x69766174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:ImplementationRepository/ActivationMode:1.0
  15, ACE_NTOHL (0x41637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e4d6f), ACE_NTOHL (0x64650000),  // name = ActivationMode
  4, // member count
  7, ACE_NTOHL (0x4e4f524d), ACE_NTOHL (0x414c0000),  // name = NORMAL
  7, ACE_NTOHL (0x4d414e55), ACE_NTOHL (0x414c0000),  // name = MANUAL
  11, ACE_NTOHL (0x5045525f), ACE_NTOHL (0x434c4945), ACE_NTOHL (0x4e540000),  // name = PER_CLIENT
  11, ACE_NTOHL (0x4155544f), ACE_NTOHL (0x5f535441), ACE_NTOHL (0x52540000),  // name = AUTO_START
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_ActivationMode (CORBA::tk_enum, sizeof (_oc_ImplementationRepository_ActivationMode), (char *) &_oc_ImplementationRepository_ActivationMode, 0, sizeof (ImplementationRepository::ActivationMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ActivationMode, &_tc_TAO_tc_ImplementationRepository_ActivationMode)
TAO_NAMESPACE_END
static const CORBA::Long _oc_ImplementationRepository_StartupOptions[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f537461), ACE_NTOHL (0x72747570), ACE_NTOHL (0x4f707469), ACE_NTOHL (0x6f6e733a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:ImplementationRepository/StartupOptions:1.0
  15, ACE_NTOHL (0x53746172), ACE_NTOHL (0x7475704f), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = StartupOptions
  4, // member count
  13, ACE_NTOHL (0x636f6d6d), ACE_NTOHL (0x616e645f), ACE_NTOHL (0x6c696e65), ACE_NTOHL (0x0),  // name = command_line
  CORBA::tk_string,
  0U, // string length
  12, ACE_NTOHL (0x656e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e7400),  // name = environment
  CORBA::tk_alias, // typecode kind for typedefs
  236, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x4c697374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentList:1.0
    16, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e744c), ACE_NTOHL (0x69737400),  // name = EnvironmentList
    CORBA::tk_sequence, // typecode kind
    148, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      132, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        53, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x56617269), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentVariable:1.0
        20, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e7456), ACE_NTOHL (0x61726961), ACE_NTOHL (0x626c6500),  // name = EnvironmentVariable
        2, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_string,
        0U, // string length
        6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
        CORBA::tk_string,
        0U, // string length

      0U,


  18, ACE_NTOHL (0x776f726b), ACE_NTOHL (0x696e675f), ACE_NTOHL (0x64697265), ACE_NTOHL (0x63746f72), ACE_NTOHL (0x79000000),  // name = working_directory
  CORBA::tk_string,
  0U, // string length
  11, ACE_NTOHL (0x61637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e0000),  // name = activation
  CORBA::tk_enum, // typecode kind
  136, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f416374), ACE_NTOHL (0x69766174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:ImplementationRepository/ActivationMode:1.0
    15, ACE_NTOHL (0x41637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e4d6f), ACE_NTOHL (0x64650000),  // name = ActivationMode
    4, // member count
    7, ACE_NTOHL (0x4e4f524d), ACE_NTOHL (0x414c0000),  // name = NORMAL
    7, ACE_NTOHL (0x4d414e55), ACE_NTOHL (0x414c0000),  // name = MANUAL
    11, ACE_NTOHL (0x5045525f), ACE_NTOHL (0x434c4945), ACE_NTOHL (0x4e540000),  // name = PER_CLIENT
    11, ACE_NTOHL (0x4155544f), ACE_NTOHL (0x5f535441), ACE_NTOHL (0x52540000),  // name = AUTO_START

};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_StartupOptions (CORBA::tk_struct, sizeof (_oc_ImplementationRepository_StartupOptions), (char *) &_oc_ImplementationRepository_StartupOptions, 0, sizeof (ImplementationRepository::StartupOptions));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StartupOptions, &_tc_TAO_tc_ImplementationRepository_StartupOptions)
TAO_NAMESPACE_END
void ImplementationRepository::StartupOptions::_tao_any_destructor (void *x)
{
  ImplementationRepository::StartupOptions *tmp = ACE_static_cast (ImplementationRepository::StartupOptions*,x);
  delete tmp;
}

static const CORBA::Long _oc_ImplementationRepository_ServerInformation[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f536572), ACE_NTOHL (0x76657249), ACE_NTOHL (0x6e666f72), ACE_NTOHL (0x6d617469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:ImplementationRepository/ServerInformation:1.0
  18, ACE_NTOHL (0x53657276), ACE_NTOHL (0x6572496e), ACE_NTOHL (0x666f726d), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e000000),  // name = ServerInformation
  4, // member count
  15, ACE_NTOHL (0x6c6f6769), ACE_NTOHL (0x63616c5f), ACE_NTOHL (0x73657276), ACE_NTOHL (0x65720000),  // name = logical_server
  CORBA::tk_string,
  0U, // string length
  7, ACE_NTOHL (0x73657276), ACE_NTOHL (0x65720000),  // name = server
  CORBA::tk_string,
  0U, // string length
  8, ACE_NTOHL (0x73746172), ACE_NTOHL (0x74757000),  // name = startup
  CORBA::tk_struct, // typecode kind
  560, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f537461), ACE_NTOHL (0x72747570), ACE_NTOHL (0x4f707469), ACE_NTOHL (0x6f6e733a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:ImplementationRepository/StartupOptions:1.0
    15, ACE_NTOHL (0x53746172), ACE_NTOHL (0x7475704f), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = StartupOptions
    4, // member count
    13, ACE_NTOHL (0x636f6d6d), ACE_NTOHL (0x616e645f), ACE_NTOHL (0x6c696e65), ACE_NTOHL (0x0),  // name = command_line
    CORBA::tk_string,
    0U, // string length
    12, ACE_NTOHL (0x656e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e7400),  // name = environment
    CORBA::tk_alias, // typecode kind for typedefs
    236, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x4c697374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentList:1.0
      16, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e744c), ACE_NTOHL (0x69737400),  // name = EnvironmentList
      CORBA::tk_sequence, // typecode kind
      148, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        CORBA::tk_struct, // typecode kind
        132, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          53, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x56617269), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentVariable:1.0
          20, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e7456), ACE_NTOHL (0x61726961), ACE_NTOHL (0x626c6500),  // name = EnvironmentVariable
          2, // member count
          5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
          CORBA::tk_string,
          0U, // string length
          6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
          CORBA::tk_string,
          0U, // string length

        0U,


    18, ACE_NTOHL (0x776f726b), ACE_NTOHL (0x696e675f), ACE_NTOHL (0x64697265), ACE_NTOHL (0x63746f72), ACE_NTOHL (0x79000000),  // name = working_directory
    CORBA::tk_string,
    0U, // string length
    11, ACE_NTOHL (0x61637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e0000),  // name = activation
    CORBA::tk_enum, // typecode kind
    136, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f416374), ACE_NTOHL (0x69766174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:ImplementationRepository/ActivationMode:1.0
      15, ACE_NTOHL (0x41637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e4d6f), ACE_NTOHL (0x64650000),  // name = ActivationMode
      4, // member count
      7, ACE_NTOHL (0x4e4f524d), ACE_NTOHL (0x414c0000),  // name = NORMAL
      7, ACE_NTOHL (0x4d414e55), ACE_NTOHL (0x414c0000),  // name = MANUAL
      11, ACE_NTOHL (0x5045525f), ACE_NTOHL (0x434c4945), ACE_NTOHL (0x4e540000),  // name = PER_CLIENT
      11, ACE_NTOHL (0x4155544f), ACE_NTOHL (0x5f535441), ACE_NTOHL (0x52540000),  // name = AUTO_START


  9, ACE_NTOHL (0x6c6f6361), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = location
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f416464), ACE_NTOHL (0x72657373), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/Address:1.0
    8, ACE_NTOHL (0x41646472), ACE_NTOHL (0x65737300),  // name = Address
    CORBA::tk_string,
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_ServerInformation (CORBA::tk_struct, sizeof (_oc_ImplementationRepository_ServerInformation), (char *) &_oc_ImplementationRepository_ServerInformation, 0, sizeof (ImplementationRepository::ServerInformation));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServerInformation, &_tc_TAO_tc_ImplementationRepository_ServerInformation)
TAO_NAMESPACE_END
void ImplementationRepository::ServerInformation::_tao_any_destructor (void *x)
{
  ImplementationRepository::ServerInformation *tmp = ACE_static_cast (ImplementationRepository::ServerInformation*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IMPLEMENTATIONREPOSITORY_SERVERINFORMATIONLIST_CS_)
#define __TAO_UNBOUNDED_SEQUENCE_IMPLEMENTATIONREPOSITORY_SERVERINFORMATIONLIST_CS_

  void
  ImplementationRepository::_TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList::_allocate_buffer (CORBA::ULong length)
  {
    ImplementationRepository::ServerInformation* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList::allocbuf (length);

    if (this->buffer_ != 0)
    {
      ImplementationRepository::ServerInformation *old = ACE_reinterpret_cast (ImplementationRepository::ServerInformation *,this->buffer_);

      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];

      if (this->release_)
        _TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList::freebuf (old);

    }
    this->buffer_ = tmp;
  }

  void
  ImplementationRepository::_TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;

    ImplementationRepository::ServerInformation *tmp = ACE_reinterpret_cast (ImplementationRepository::ServerInformation *,this->buffer_);

    _TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList::freebuf (tmp);
    this->buffer_ = 0;
  }

  ImplementationRepository::_TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList::~_TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IMPLEMENTATIONREPOSITORY_SERVERINFORMATIONLIST_CS_)
#define _IMPLEMENTATIONREPOSITORY_SERVERINFORMATIONLIST_CS_

// *************************************************************
// ImplementationRepository::ServerInformationList
// *************************************************************

ImplementationRepository::ServerInformationList::ServerInformationList (void)
{}
ImplementationRepository::ServerInformationList::ServerInformationList (CORBA::ULong max) // uses max size
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<ImplementationRepository::ServerInformation>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max)
{}
ImplementationRepository::ServerInformationList::ServerInformationList (CORBA::ULong max, CORBA::ULong length, ImplementationRepository::ServerInformation *buffer, CORBA::Boolean release)
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<ImplementationRepository::ServerInformation>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (max, length, buffer, release)
{}
ImplementationRepository::ServerInformationList::ServerInformationList (const ServerInformationList &seq) // copy ctor
  :
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_ImplementationRepository_ServerInformationList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<ImplementationRepository::ServerInformation>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
 (seq)
{}
ImplementationRepository::ServerInformationList::~ServerInformationList (void) // dtor
{}
void ImplementationRepository::ServerInformationList::_tao_any_destructor (void *x)
{
  ImplementationRepository::ServerInformationList *tmp = ACE_static_cast (ImplementationRepository::ServerInformationList*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_ImplementationRepository_ServerInformationList[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f536572), ACE_NTOHL (0x76657249), ACE_NTOHL (0x6e666f72), ACE_NTOHL (0x6d617469), ACE_NTOHL (0x6f6e4c69), ACE_NTOHL (0x73743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:ImplementationRepository/ServerInformationList:1.0
  22, ACE_NTOHL (0x53657276), ACE_NTOHL (0x6572496e), ACE_NTOHL (0x666f726d), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4c6973), ACE_NTOHL (0x74000000),  // name = ServerInformationList
  CORBA::tk_sequence, // typecode kind
  828, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    812, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      51, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f536572), ACE_NTOHL (0x76657249), ACE_NTOHL (0x6e666f72), ACE_NTOHL (0x6d617469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:ImplementationRepository/ServerInformation:1.0
      18, ACE_NTOHL (0x53657276), ACE_NTOHL (0x6572496e), ACE_NTOHL (0x666f726d), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e000000),  // name = ServerInformation
      4, // member count
      15, ACE_NTOHL (0x6c6f6769), ACE_NTOHL (0x63616c5f), ACE_NTOHL (0x73657276), ACE_NTOHL (0x65720000),  // name = logical_server
      CORBA::tk_string,
      0U, // string length
      7, ACE_NTOHL (0x73657276), ACE_NTOHL (0x65720000),  // name = server
      CORBA::tk_string,
      0U, // string length
      8, ACE_NTOHL (0x73746172), ACE_NTOHL (0x74757000),  // name = startup
      CORBA::tk_struct, // typecode kind
      560, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f537461), ACE_NTOHL (0x72747570), ACE_NTOHL (0x4f707469), ACE_NTOHL (0x6f6e733a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:ImplementationRepository/StartupOptions:1.0
        15, ACE_NTOHL (0x53746172), ACE_NTOHL (0x7475704f), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = StartupOptions
        4, // member count
        13, ACE_NTOHL (0x636f6d6d), ACE_NTOHL (0x616e645f), ACE_NTOHL (0x6c696e65), ACE_NTOHL (0x0),  // name = command_line
        CORBA::tk_string,
        0U, // string length
        12, ACE_NTOHL (0x656e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e7400),  // name = environment
        CORBA::tk_alias, // typecode kind for typedefs
        236, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x4c697374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentList:1.0
          16, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e744c), ACE_NTOHL (0x69737400),  // name = EnvironmentList
          CORBA::tk_sequence, // typecode kind
          148, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            132, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              53, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f456e76), ACE_NTOHL (0x69726f6e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x56617269), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/EnvironmentVariable:1.0
              20, ACE_NTOHL (0x456e7669), ACE_NTOHL (0x726f6e6d), ACE_NTOHL (0x656e7456), ACE_NTOHL (0x61726961), ACE_NTOHL (0x626c6500),  // name = EnvironmentVariable
              2, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_string,
              0U, // string length
              6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
              CORBA::tk_string,
              0U, // string length

            0U,


        18, ACE_NTOHL (0x776f726b), ACE_NTOHL (0x696e675f), ACE_NTOHL (0x64697265), ACE_NTOHL (0x63746f72), ACE_NTOHL (0x79000000),  // name = working_directory
        CORBA::tk_string,
        0U, // string length
        11, ACE_NTOHL (0x61637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e0000),  // name = activation
        CORBA::tk_enum, // typecode kind
        136, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f416374), ACE_NTOHL (0x69766174), ACE_NTOHL (0x696f6e4d), ACE_NTOHL (0x6f64653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:ImplementationRepository/ActivationMode:1.0
          15, ACE_NTOHL (0x41637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e4d6f), ACE_NTOHL (0x64650000),  // name = ActivationMode
          4, // member count
          7, ACE_NTOHL (0x4e4f524d), ACE_NTOHL (0x414c0000),  // name = NORMAL
          7, ACE_NTOHL (0x4d414e55), ACE_NTOHL (0x414c0000),  // name = MANUAL
          11, ACE_NTOHL (0x5045525f), ACE_NTOHL (0x434c4945), ACE_NTOHL (0x4e540000),  // name = PER_CLIENT
          11, ACE_NTOHL (0x4155544f), ACE_NTOHL (0x5f535441), ACE_NTOHL (0x52540000),  // name = AUTO_START


      9, ACE_NTOHL (0x6c6f6361), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = location
      CORBA::tk_alias, // typecode kind for typedefs
      72, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f416464), ACE_NTOHL (0x72657373), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/Address:1.0
        8, ACE_NTOHL (0x41646472), ACE_NTOHL (0x65737300),  // name = Address
        CORBA::tk_string,
        0U, // string length


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_ServerInformationList (CORBA::tk_alias, sizeof (_oc_ImplementationRepository_ServerInformationList), (char *) &_oc_ImplementationRepository_ServerInformationList, 0, sizeof (ImplementationRepository::ServerInformationList));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServerInformationList, &_tc_TAO_tc_ImplementationRepository_ServerInformationList)
TAO_NAMESPACE_END
void ImplementationRepository::Administration::_tao_any_destructor (void *x)
{
  ImplementationRepository::Administration *tmp = ACE_static_cast (ImplementationRepository::Administration*,x);
  CORBA::release (tmp);
}

ImplementationRepository::Administration_ptr ImplementationRepository::Administration::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Administration::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:ImplementationRepository/Administration:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (Administration::_nil ());
  if (is_a == 0)
    return Administration::_nil ();
  return Administration::_unchecked_narrow (obj, ACE_TRY_ENV);
}

ImplementationRepository::Administration_ptr ImplementationRepository::Administration::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Administration::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  Administration_ptr default_proxy = Administration::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_ImplementationRepository_Administration_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_ImplementationRepository_Administration_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, Administration (stub), Administration::_nil ());
  return TAO_ImplementationRepository_Administration_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

ImplementationRepository::Administration_ptr
ImplementationRepository::Administration::_duplicate (Administration_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

// default constructor
ImplementationRepository::Administration::AlreadyRegistered::AlreadyRegistered (void)
  : CORBA_UserException ("IDL:ImplementationRepository/Administration/AlreadyRegistered:1.0")
{
}

// destructor - all members are of self managing types
ImplementationRepository::Administration::AlreadyRegistered::~AlreadyRegistered (void)
{
}

void ImplementationRepository::Administration::AlreadyRegistered::_tao_any_destructor (void *x)
{
  ImplementationRepository::Administration::AlreadyRegistered *tmp = ACE_static_cast (ImplementationRepository::Administration::AlreadyRegistered*,x);
  delete tmp;
}

// copy constructor
ImplementationRepository::Administration::AlreadyRegistered::AlreadyRegistered (const ::ImplementationRepository::Administration::AlreadyRegistered &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  }

// assignment operator
ImplementationRepository::Administration::AlreadyRegistered&
ImplementationRepository::Administration::AlreadyRegistered::operator= (const ::ImplementationRepository::Administration::AlreadyRegistered &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
ImplementationRepository::Administration::AlreadyRegistered *
ImplementationRepository::Administration::AlreadyRegistered::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:ImplementationRepository/Administration/AlreadyRegistered:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (AlreadyRegistered *, exc);
  else
    return 0;
}


void ImplementationRepository::Administration::AlreadyRegistered::_raise ()
{
  TAO_RAISE(*this);
}


void ImplementationRepository::Administration::AlreadyRegistered::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void ImplementationRepository::Administration::AlreadyRegistered::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV)
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *ImplementationRepository::Administration::AlreadyRegistered::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::ImplementationRepository::Administration::AlreadyRegistered, 0);
  return retval;
}

static const CORBA::Long _oc_ImplementationRepository_Administration_AlreadyRegistered[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  66, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f41646d), ACE_NTOHL (0x696e6973), ACE_NTOHL (0x74726174), ACE_NTOHL (0x696f6e2f), ACE_NTOHL (0x416c7265), ACE_NTOHL (0x61647952), ACE_NTOHL (0x65676973), ACE_NTOHL (0x74657265), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:ImplementationRepository/Administration/AlreadyRegistered:1.0
  18, ACE_NTOHL (0x416c7265), ACE_NTOHL (0x61647952), ACE_NTOHL (0x65676973), ACE_NTOHL (0x74657265), ACE_NTOHL (0x64000000),  // name = AlreadyRegistered
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_Administration_AlreadyRegistered (CORBA::tk_except, sizeof (_oc_ImplementationRepository_Administration_AlreadyRegistered), (char *) &_oc_ImplementationRepository_Administration_AlreadyRegistered, 0, sizeof (ImplementationRepository::Administration::AlreadyRegistered));
CORBA::TypeCode_ptr ImplementationRepository::Administration::_tc_AlreadyRegistered = &_tc_TAO_tc_ImplementationRepository_Administration_AlreadyRegistered;

CORBA::TypeCode_ptr
ImplementationRepository::Administration::AlreadyRegistered::_type (void) const
{
  return _tc_AlreadyRegistered;
}

// default constructor
ImplementationRepository::Administration::CannotActivate::CannotActivate (void)
  : CORBA_UserException ("IDL:ImplementationRepository/Administration/CannotActivate:1.0")
{
}

// destructor - all members are of self managing types
ImplementationRepository::Administration::CannotActivate::~CannotActivate (void)
{
}

void ImplementationRepository::Administration::CannotActivate::_tao_any_destructor (void *x)
{
  ImplementationRepository::Administration::CannotActivate *tmp = ACE_static_cast (ImplementationRepository::Administration::CannotActivate*,x);
  delete tmp;
}

// copy constructor
ImplementationRepository::Administration::CannotActivate::CannotActivate (const ::ImplementationRepository::Administration::CannotActivate &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
    this->reason = CORBA::string_dup (_tao_excp.reason.in ());
}

// assignment operator
ImplementationRepository::Administration::CannotActivate&
ImplementationRepository::Administration::CannotActivate::operator= (const ::ImplementationRepository::Administration::CannotActivate &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  this->reason = CORBA::string_dup (_tao_excp.reason.in ());
  return *this;
}

// narrow
ImplementationRepository::Administration::CannotActivate *
ImplementationRepository::Administration::CannotActivate::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:ImplementationRepository/Administration/CannotActivate:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (CannotActivate *, exc);
  else
    return 0;
}


void ImplementationRepository::Administration::CannotActivate::_raise ()
{
  TAO_RAISE(*this);
}


void ImplementationRepository::Administration::CannotActivate::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void ImplementationRepository::Administration::CannotActivate::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV)
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *ImplementationRepository::Administration::CannotActivate::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::ImplementationRepository::Administration::CannotActivate, 0);
  return retval;
}

ImplementationRepository::Administration::CannotActivate::CannotActivate (
  const char * _tao_reason
)
  : CORBA_UserException (CORBA::string_dup ("IDL:ImplementationRepository/Administration/CannotActivate:1.0"))
{
    this->reason = CORBA::string_dup (_tao_reason);
}

static const CORBA::Long _oc_ImplementationRepository_Administration_CannotActivate[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  63, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f41646d), ACE_NTOHL (0x696e6973), ACE_NTOHL (0x74726174), ACE_NTOHL (0x696f6e2f), ACE_NTOHL (0x43616e6e), ACE_NTOHL (0x6f744163), ACE_NTOHL (0x74697661), ACE_NTOHL (0x74653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:ImplementationRepository/Administration/CannotActivate:1.0
  15, ACE_NTOHL (0x43616e6e), ACE_NTOHL (0x6f744163), ACE_NTOHL (0x74697661), ACE_NTOHL (0x74650000),  // name = CannotActivate
  1, // member count
  7, ACE_NTOHL (0x72656173), ACE_NTOHL (0x6f6e0000),  // name = reason
  CORBA::tk_string,
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_Administration_CannotActivate (CORBA::tk_except, sizeof (_oc_ImplementationRepository_Administration_CannotActivate), (char *) &_oc_ImplementationRepository_Administration_CannotActivate, 0, sizeof (ImplementationRepository::Administration::CannotActivate));
CORBA::TypeCode_ptr ImplementationRepository::Administration::_tc_CannotActivate = &_tc_TAO_tc_ImplementationRepository_Administration_CannotActivate;

CORBA::TypeCode_ptr
ImplementationRepository::Administration::CannotActivate::_type (void) const
{
  return _tc_CannotActivate;
}

// default constructor
ImplementationRepository::Administration::NotFound::NotFound (void)
  : CORBA_UserException ("IDL:ImplementationRepository/Administration/NotFound:1.0")
{
}

// destructor - all members are of self managing types
ImplementationRepository::Administration::NotFound::~NotFound (void)
{
}

void ImplementationRepository::Administration::NotFound::_tao_any_destructor (void *x)
{
  ImplementationRepository::Administration::NotFound *tmp = ACE_static_cast (ImplementationRepository::Administration::NotFound*,x);
  delete tmp;
}

// copy constructor
ImplementationRepository::Administration::NotFound::NotFound (const ::ImplementationRepository::Administration::NotFound &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
  }

// assignment operator
ImplementationRepository::Administration::NotFound&
ImplementationRepository::Administration::NotFound::operator= (const ::ImplementationRepository::Administration::NotFound &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
ImplementationRepository::Administration::NotFound *
ImplementationRepository::Administration::NotFound::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:ImplementationRepository/Administration/NotFound:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (NotFound *, exc);
  else
    return 0;
}


void ImplementationRepository::Administration::NotFound::_raise ()
{
  TAO_RAISE(*this);
}


void ImplementationRepository::Administration::NotFound::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void ImplementationRepository::Administration::NotFound::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV)
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *ImplementationRepository::Administration::NotFound::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::ImplementationRepository::Administration::NotFound, 0);
  return retval;
}

static const CORBA::Long _oc_ImplementationRepository_Administration_NotFound[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  57, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f41646d), ACE_NTOHL (0x696e6973), ACE_NTOHL (0x74726174), ACE_NTOHL (0x696f6e2f), ACE_NTOHL (0x4e6f7446), ACE_NTOHL (0x6f756e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:ImplementationRepository/Administration/NotFound:1.0
  9, ACE_NTOHL (0x4e6f7446), ACE_NTOHL (0x6f756e64), ACE_NTOHL (0x0),  // name = NotFound
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_Administration_NotFound (CORBA::tk_except, sizeof (_oc_ImplementationRepository_Administration_NotFound), (char *) &_oc_ImplementationRepository_Administration_NotFound, 0, sizeof (ImplementationRepository::Administration::NotFound));
CORBA::TypeCode_ptr ImplementationRepository::Administration::_tc_NotFound = &_tc_TAO_tc_ImplementationRepository_Administration_NotFound;

CORBA::TypeCode_ptr
ImplementationRepository::Administration::NotFound::_type (void) const
{
  return _tc_NotFound;
}

void ImplementationRepository::Administration::activate_server (
    const char * server,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound,
    ImplementationRepository::Administration::CannotActivate
  ))
{

  static TAO_Exception_Data _tao_ImplementationRepository_Administration_activate_server_exceptiondata [] =
  {
    {ImplementationRepository::Administration::_tc_NotFound, ImplementationRepository::Administration::NotFound::_alloc},
    {ImplementationRepository::Administration::_tc_CannotActivate, ImplementationRepository::Administration::CannotActivate::_alloc}
  };




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "activate_server",
      15,
      1,
      istub->orb_core ()
    );
      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << server)
          ))
          ACE_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (_tao_ImplementationRepository_Administration_activate_server_exceptiondata, 2, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        break;
      }

}

void ImplementationRepository::Administration::register_server (
    const char * server,
    const ImplementationRepository::StartupOptions & options,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::AlreadyRegistered
  ))
{

  static TAO_Exception_Data _tao_ImplementationRepository_Administration_register_server_exceptiondata [] =
  {
    {ImplementationRepository::Administration::_tc_AlreadyRegistered, ImplementationRepository::Administration::AlreadyRegistered::_alloc}
  };




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "register_server",
      15,
      1,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << server) &&
              (_tao_out << options)
          ))
          ACE_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (_tao_ImplementationRepository_Administration_register_server_exceptiondata, 1, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        break;
      }

}

void ImplementationRepository::Administration::reregister_server (
    const char * server,
    const ImplementationRepository::StartupOptions & options,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "reregister_server",
      17,
      1,
      istub->orb_core ()
    );
      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << server) &&
              (_tao_out << options)
          ))
          ACE_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        break;
      }

}

void ImplementationRepository::Administration::remove_server (
    const char * server,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{

  static TAO_Exception_Data _tao_ImplementationRepository_Administration_remove_server_exceptiondata [] =
  {
    {ImplementationRepository::Administration::_tc_NotFound, ImplementationRepository::Administration::NotFound::_alloc}
  };




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "remove_server",
      13,
      1,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << server)
          ))
          ACE_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (_tao_ImplementationRepository_Administration_remove_server_exceptiondata, 1, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        break;
      }
}

void ImplementationRepository::Administration::shutdown_server (
    const char * server,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{

  static TAO_Exception_Data _tao_ImplementationRepository_Administration_shutdown_server_exceptiondata [] =
  {
    {ImplementationRepository::Administration::_tc_NotFound, ImplementationRepository::Administration::NotFound::_alloc}
  };




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "shutdown_server",
      15,
      1,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << server)
          ))
          ACE_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (_tao_ImplementationRepository_Administration_shutdown_server_exceptiondata, 1, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }

        break;

      }
}

char * ImplementationRepository::Administration::server_is_running (
    const char * server,
    const char * addr,
    ImplementationRepository::ServerObject_ptr server_object,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{

  static TAO_Exception_Data _tao_ImplementationRepository_Administration_server_is_running_exceptiondata [] =
  {
    {ImplementationRepository::Administration::_tc_NotFound, ImplementationRepository::Administration::NotFound::_alloc}
  };

  CORBA::String_var _tao_safe_retval;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "server_is_running",
      17,
      1,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);

        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK_RETURN (0);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << server) &&
              (_tao_out << addr) &&
              (_tao_out << server_object)
          ))
          ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

        int _invoke_status =
          _tao_call.invoke (_tao_ImplementationRepository_Administration_server_is_running_exceptiondata, 1, ACE_TRY_ENV);
                ACE_CHECK_RETURN (0);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> _tao_safe_retval.inout ())
          ))
          ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

        break;

      }
  return _tao_safe_retval._retn ();
}

void ImplementationRepository::Administration::server_is_shutting_down (
    const char * server,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{

  static TAO_Exception_Data _tao_ImplementationRepository_Administration_server_is_shutting_down_exceptiondata [] =
  {
    {ImplementationRepository::Administration::_tc_NotFound, ImplementationRepository::Administration::NotFound::_alloc}
  };

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "server_is_shutting_down",
      23,
      1,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << server)
          ))
          ACE_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (_tao_ImplementationRepository_Administration_server_is_shutting_down_exceptiondata, 1, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }

        break;

      }

}

void ImplementationRepository::Administration::find (
    const char * server,
    ImplementationRepository::ServerInformation_out info,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{

  static TAO_Exception_Data _tao_ImplementationRepository_Administration_find_exceptiondata [] =
  {
    {ImplementationRepository::Administration::_tc_NotFound, ImplementationRepository::Administration::NotFound::_alloc}
  };




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  ACE_NEW (info.ptr (), ImplementationRepository::ServerInformation);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "find",
      4,
      1,
      istub->orb_core ()
    );


      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << server)
          ))
          ACE_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (_tao_ImplementationRepository_Administration_find_exceptiondata, 1, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> *info.ptr ())
          ))
          ACE_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        break;

      }

}

void ImplementationRepository::Administration::list (
    CORBA::ULong how_many,
    ImplementationRepository::ServerInformationList_out server_list,
    ImplementationRepository::ServerInformationIterator_out server_iterator,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  ACE_NEW (server_list.ptr (), ImplementationRepository::ServerInformationList);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "list",
      4,
      1,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << how_many)
          ))
          ACE_THROW (CORBA::MARSHAL ());
        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
                            (_tao_in >> *server_list.ptr ()) &&
              (_tao_in >> server_iterator.ptr ())
          ))
          ACE_THROW (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        break;

      }

}

CORBA::Boolean ImplementationRepository::Administration::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:ImplementationRepository/Administration:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* ImplementationRepository::Administration::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/Administration:1.0";
}

ImplementationRepository::TAO_ImplementationRepository_Administration_Default_Proxy_Factory::TAO_ImplementationRepository_Administration_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_ImplementationRepository_Administration_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

ImplementationRepository::TAO_ImplementationRepository_Administration_Default_Proxy_Factory::~TAO_ImplementationRepository_Administration_Default_Proxy_Factory (void)
{
}

ImplementationRepository::Administration_ptr
ImplementationRepository::TAO_ImplementationRepository_Administration_Default_Proxy_Factory::create_proxy (
    ::ImplementationRepository::Administration_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

ImplementationRepository::TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter::TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

ImplementationRepository::TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter::~TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
ImplementationRepository::TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_ImplementationRepository_Administration_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
ImplementationRepository::TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

ImplementationRepository::Administration_ptr
ImplementationRepository::TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter::create_proxy (
    ::ImplementationRepository::Administration_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_ImplementationRepository_Administration_Default_Proxy_Factory (1),
         0);


  return this->proxy_factory_->create_proxy (proxy);
}

ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::TAO_ImplementationRepository_Administration_Smart_Proxy_Base (::ImplementationRepository::Administration_ptr proxy)
: base_proxy_ (proxy)
{
}

ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::~TAO_ImplementationRepository_Administration_Smart_Proxy_Base (void)
{
}

void ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::activate_server  (
    const char * server,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound,
    ImplementationRepository::Administration::CannotActivate
  ))
{
  this->base_proxy_->activate_server (
      server,
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::register_server  (
    const char * server,
    const ImplementationRepository::StartupOptions & options,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::AlreadyRegistered
  ))
{
  this->base_proxy_->register_server (
      server,
      options,
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::reregister_server  (
    const char * server,
    const ImplementationRepository::StartupOptions & options,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->reregister_server (
      server,
      options,
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::remove_server  (
    const char * server,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{
  this->base_proxy_->remove_server (
      server,
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::shutdown_server  (
    const char * server,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{
  this->base_proxy_->shutdown_server (
      server,
      ACE_TRY_ENV
    );

}

char * ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::server_is_running  (
    const char * server,
    const char * addr,
    ImplementationRepository::ServerObject_ptr server_object,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{
  return this->base_proxy_->server_is_running (
      server,
      addr,
      server_object,
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::server_is_shutting_down  (
    const char * server,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{
  this->base_proxy_->server_is_shutting_down (
      server,
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::find  (
    const char * server,
    ImplementationRepository::ServerInformation_out info,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ImplementationRepository::Administration::NotFound
  ))
{
  this->base_proxy_->find (
      server,
      info,
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_Administration_Smart_Proxy_Base::list  (
    CORBA::ULong how_many,
    ImplementationRepository::ServerInformationList_out server_list,
    ImplementationRepository::ServerInformationIterator_out server_iterator,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->list (
      how_many,
      server_list,
      server_iterator,
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class TAO_Singleton<ImplementationRepository::TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter, TAO_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate TAO_Singleton<ImplementationRepository::TAO_ImplementationRepository_Administration_Proxy_Factory_Adapter, TAO_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_ImplementationRepository_Administration[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f41646d), ACE_NTOHL (0x696e6973), ACE_NTOHL (0x74726174), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:ImplementationRepository/Administration:1.0
  15, ACE_NTOHL (0x41646d69), ACE_NTOHL (0x6e697374), ACE_NTOHL (0x72617469), ACE_NTOHL (0x6f6e0000),  // name = Administration
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_Administration (CORBA::tk_objref, sizeof (_oc_ImplementationRepository_Administration), (char *) &_oc_ImplementationRepository_Administration, 0, sizeof (ImplementationRepository::Administration));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Administration, &_tc_TAO_tc_ImplementationRepository_Administration)
TAO_NAMESPACE_END
void ImplementationRepository::ServerInformationIterator::_tao_any_destructor (void *x)
{
  ImplementationRepository::ServerInformationIterator *tmp = ACE_static_cast (ImplementationRepository::ServerInformationIterator*,x);
  CORBA::release (tmp);
}

ImplementationRepository::ServerInformationIterator_ptr ImplementationRepository::ServerInformationIterator::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ServerInformationIterator::_nil ();
  CORBA::Boolean is_a = obj->_is_a ("IDL:ImplementationRepository/ServerInformationIterator:1.0", ACE_TRY_ENV);
  ACE_CHECK_RETURN (ServerInformationIterator::_nil ());
  if (is_a == 0)
    return ServerInformationIterator::_nil ();
  return ServerInformationIterator::_unchecked_narrow (obj, ACE_TRY_ENV);
}

ImplementationRepository::ServerInformationIterator_ptr ImplementationRepository::ServerInformationIterator::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ServerInformationIterator::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  ServerInformationIterator_ptr default_proxy = ServerInformationIterator::_nil ();
  if (obj->_is_collocated () && _TAO_collocation_ImplementationRepository_ServerInformationIterator_Stub_Factory_function_pointer != 0)
    {
      default_proxy = _TAO_collocation_ImplementationRepository_ServerInformationIterator_Stub_Factory_function_pointer (obj);
    }
  if (CORBA::is_nil (default_proxy))
    ACE_NEW_RETURN (default_proxy, ServerInformationIterator (stub), ServerInformationIterator::_nil ());
  return TAO_ImplementationRepository_ServerInformationIterator_PROXY_FACTORY_ADAPTER::instance ()->create_proxy (default_proxy);
}

ImplementationRepository::ServerInformationIterator_ptr
ImplementationRepository::ServerInformationIterator::_duplicate (ServerInformationIterator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean ImplementationRepository::ServerInformationIterator::next_n (
    CORBA::ULong how_many,
    ImplementationRepository::ServerInformationList_out server_list,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{

  CORBA::Boolean _tao_retval = 0;


  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);


  ACE_NEW_RETURN (server_list.ptr (), ImplementationRepository::ServerInformationList, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "next_n",
      6,
      1,
      istub->orb_core ()
    );
      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);

        ACE_CHECK_RETURN  (_tao_retval);
        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK_RETURN  (_tao_retval);

        TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
        if (!(
              (_tao_out << how_many)
          ))
          ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                ACE_CHECK_RETURN  (_tao_retval);

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        }
        TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
        if (!(
              (_tao_in >> CORBA::Any::to_boolean (_tao_retval)) &&
                            (_tao_in >> *server_list.ptr ())
          ))
          ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

        break;

      }
  return _tao_retval;
}

void ImplementationRepository::ServerInformationIterator::destroy (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{




  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "destroy",
      7,
      0,
      istub->orb_core ()
    );

      for (;;)
      {
        _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK;

        CORBA::Short flag = TAO_TWOWAY_RESPONSE_FLAG;
        // Tremporary hack until GIOP 1.2 is implemented.

        _tao_call.prepare_header (ACE_static_cast (CORBA::Octet, flag), ACE_TRY_ENV);
        ACE_CHECK;

        int _invoke_status =
          _tao_call.invoke (0, 0, ACE_TRY_ENV);
                ACE_CHECK;

        if (_invoke_status == TAO_INVOKE_RESTART)
          continue;
        if (_invoke_status != TAO_INVOKE_OK)
        {
          ACE_THROW (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
        }

        break;

      }

}

CORBA::Boolean ImplementationRepository::ServerInformationIterator::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:ImplementationRepository/ServerInformationIterator:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

const char* ImplementationRepository::ServerInformationIterator::_interface_repository_id (void) const
{
  return "IDL:ImplementationRepository/ServerInformationIterator:1.0";
}

ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Default_Proxy_Factory::TAO_ImplementationRepository_ServerInformationIterator_Default_Proxy_Factory (int register_proxy_factory)
{
  if (register_proxy_factory)
    {
      TAO_ImplementationRepository_ServerInformationIterator_PROXY_FACTORY_ADAPTER::instance ()->register_proxy_factory (this);
    }
}

ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Default_Proxy_Factory::~TAO_ImplementationRepository_ServerInformationIterator_Default_Proxy_Factory (void)
{
}

ImplementationRepository::ServerInformationIterator_ptr
ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Default_Proxy_Factory::create_proxy (
    ::ImplementationRepository::ServerInformationIterator_ptr proxy,
    CORBA::Environment &
  )
{
  return proxy;
}

ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter::TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter (void)
   : proxy_factory_ (0),
     delete_proxy_factory_ (0)
{
}

ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter::~TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter (void)
{
  // Making sure the factory which the adapter has is destroyed with it.
  if (this->proxy_factory_ != 0)
    delete this->proxy_factory_;
}

int
ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter::register_proxy_factory (
  TAO_ImplementationRepository_ServerInformationIterator_Default_Proxy_Factory *df,
     CORBA::Environment &ACE_TRY_ENV
      )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  // Remove any existing <proxy_factory_> and replace with the new one.
  this->unregister_proxy_factory (ACE_TRY_ENV);
  this->proxy_factory_ = df;
  this->delete_proxy_factory_ = 0;
return 0;
}

int
ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter::unregister_proxy_factory (
  CORBA::Environment &
    )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  if (this->delete_proxy_factory_ == 0 && this->proxy_factory_ != 0)
    {
      // Its necessary to set <delete_proxy_factory_> to 1 to make sure that it
      // doesnt get into an infinite loop in <unregister_proxy_factory> as it is
      // invoked in the destructor of the class too.
      this->delete_proxy_factory_ = 1;
      delete this->proxy_factory_;
      this->proxy_factory_ = 0;
    }
return 0;
}

ImplementationRepository::ServerInformationIterator_ptr
ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter::create_proxy (
    ::ImplementationRepository::ServerInformationIterator_ptr proxy,
    CORBA::Environment &
  )
{
  ACE_MT (ACE_GUARD_RETURN (TAO_SYNCH_RECURSIVE_MUTEX, ace_mon,
    this->lock_, 0));
  // Verify that an <proxy_factory_> is available else make one.
  if (this->proxy_factory_ == 0)
    ACE_NEW_RETURN (this->proxy_factory_,
        TAO_ImplementationRepository_ServerInformationIterator_Default_Proxy_Factory (1),
         0);


  return this->proxy_factory_->create_proxy (proxy);
}

ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Smart_Proxy_Base::TAO_ImplementationRepository_ServerInformationIterator_Smart_Proxy_Base (::ImplementationRepository::ServerInformationIterator_ptr proxy)
: base_proxy_ (proxy)
{
}

ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Smart_Proxy_Base::~TAO_ImplementationRepository_ServerInformationIterator_Smart_Proxy_Base (void)
{
}

CORBA::Boolean ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Smart_Proxy_Base::next_n  (
    CORBA::ULong how_many,
    ImplementationRepository::ServerInformationList_out server_list,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->base_proxy_->next_n (
      how_many,
      server_list,
      ACE_TRY_ENV
    );

}

void ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Smart_Proxy_Base::destroy  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->base_proxy_->destroy (
      ACE_TRY_ENV
    );

}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION) || \
  defined (ACE_HAS_GNU_REPO)
template class TAO_Singleton<ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter, TAO_SYNCH_RECURSIVE_MUTEX >;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#pragma instantiate TAO_Singleton<ImplementationRepository::TAO_ImplementationRepository_ServerInformationIterator_Proxy_Factory_Adapter, TAO_SYNCH_RECURSIVE_MUTEX>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

static const CORBA::Long _oc_ImplementationRepository_ServerInformationIterator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  59, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x496d706c), ACE_NTOHL (0x656d656e), ACE_NTOHL (0x74617469), ACE_NTOHL (0x6f6e5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x2f536572), ACE_NTOHL (0x76657249), ACE_NTOHL (0x6e666f72), ACE_NTOHL (0x6d617469), ACE_NTOHL (0x6f6e4974), ACE_NTOHL (0x65726174), ACE_NTOHL (0x6f723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:ImplementationRepository/ServerInformationIterator:1.0
  26, ACE_NTOHL (0x53657276), ACE_NTOHL (0x6572496e), ACE_NTOHL (0x666f726d), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e497465), ACE_NTOHL (0x7261746f), ACE_NTOHL (0x72000000),  // name = ServerInformationIterator
};
static CORBA::TypeCode _tc_TAO_tc_ImplementationRepository_ServerInformationIterator (CORBA::tk_objref, sizeof (_oc_ImplementationRepository_ServerInformationIterator), (char *) &_oc_ImplementationRepository_ServerInformationIterator, 0, sizeof (ImplementationRepository::ServerInformationIterator));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (ImplementationRepository)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServerInformationIterator, &_tc_TAO_tc_ImplementationRepository_ServerInformationIterator)
TAO_NAMESPACE_END
ImplementationRepository::ServerObject_ptr (*_TAO_collocation_ImplementationRepository_ServerObject_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::ServerObject_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        ImplementationRepository::_tc_ServerObject,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        ImplementationRepository::ServerObject::_duplicate (_tao_elem),
        ImplementationRepository::ServerObject::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::ServerObject_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = ImplementationRepository::ServerObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_ServerObject, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          ImplementationRepository::_tc_ServerObject,
          1,
          _tao_elem,
          ImplementationRepository::ServerObject::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = ImplementationRepository::ServerObject::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = ImplementationRepository::ServerObject::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<ImplementationRepository::ServerObject,ImplementationRepository::ServerObject_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<ImplementationRepository::ServerObject,ImplementationRepository::ServerObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const ImplementationRepository::EnvironmentVariable &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_EnvironmentVariable,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::EnvironmentVariable *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_EnvironmentVariable,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      ImplementationRepository::EnvironmentVariable::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::EnvironmentVariable *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast (const ImplementationRepository::EnvironmentVariable *&, _tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const ImplementationRepository::EnvironmentVariable *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_EnvironmentVariable, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const ImplementationRepository::EnvironmentVariable*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      ImplementationRepository::EnvironmentVariable *tmp;
      ACE_NEW_RETURN (tmp, ImplementationRepository::EnvironmentVariable, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            ImplementationRepository::_tc_EnvironmentVariable,
            1,
            ACE_static_cast (void *, tmp),
            ImplementationRepository::EnvironmentVariable::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const ImplementationRepository::EnvironmentList &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        ImplementationRepository::_tc_EnvironmentList,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::EnvironmentList *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_EnvironmentList,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      ImplementationRepository::EnvironmentList::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::EnvironmentList *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const ImplementationRepository::EnvironmentList*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const ImplementationRepository::EnvironmentList *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_EnvironmentList, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const ImplementationRepository::EnvironmentList*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      ImplementationRepository::EnvironmentList *tmp;
      ACE_NEW_RETURN (tmp, ImplementationRepository::EnvironmentList, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            ImplementationRepository::_tc_EnvironmentList,
            1,
            ACE_static_cast (void *, tmp),
            ImplementationRepository::EnvironmentList::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::ActivationMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_ActivationMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::ActivationMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_ActivationMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const ImplementationRepository::StartupOptions &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_StartupOptions,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::StartupOptions *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_StartupOptions,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      ImplementationRepository::StartupOptions::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::StartupOptions *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast (const ImplementationRepository::StartupOptions *&, _tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const ImplementationRepository::StartupOptions *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_StartupOptions, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const ImplementationRepository::StartupOptions*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      ImplementationRepository::StartupOptions *tmp;
      ACE_NEW_RETURN (tmp, ImplementationRepository::StartupOptions, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            ImplementationRepository::_tc_StartupOptions,
            1,
            ACE_static_cast (void *, tmp),
            ImplementationRepository::StartupOptions::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const ImplementationRepository::ServerInformation &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_ServerInformation,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::ServerInformation *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_ServerInformation,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      ImplementationRepository::ServerInformation::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::ServerInformation *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast (const ImplementationRepository::ServerInformation *&, _tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const ImplementationRepository::ServerInformation *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_ServerInformation, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const ImplementationRepository::ServerInformation*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      ImplementationRepository::ServerInformation *tmp;
      ACE_NEW_RETURN (tmp, ImplementationRepository::ServerInformation, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            ImplementationRepository::_tc_ServerInformation,
            1,
            ACE_static_cast (void *, tmp),
            ImplementationRepository::ServerInformation::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const ImplementationRepository::ServerInformationList &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        ImplementationRepository::_tc_ServerInformationList,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::ServerInformationList *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::_tc_ServerInformationList,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      ImplementationRepository::ServerInformationList::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::ServerInformationList *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast (
      const ImplementationRepository::ServerInformationList *&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const ImplementationRepository::ServerInformationList *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_ServerInformationList, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const ImplementationRepository::ServerInformationList*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      ImplementationRepository::ServerInformationList *tmp;
      ACE_NEW_RETURN (tmp, ImplementationRepository::ServerInformationList, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            ImplementationRepository::_tc_ServerInformationList,
            1,
            ACE_static_cast (void *, tmp),
            ImplementationRepository::ServerInformationList::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

ImplementationRepository::Administration_ptr (*_TAO_collocation_ImplementationRepository_Administration_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::Administration_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        ImplementationRepository::_tc_Administration,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        ImplementationRepository::Administration::_duplicate (_tao_elem),
        ImplementationRepository::Administration::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::Administration_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = ImplementationRepository::Administration::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_Administration, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          ImplementationRepository::_tc_Administration,
          1,
          _tao_elem,
          ImplementationRepository::Administration::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = ImplementationRepository::Administration::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = ImplementationRepository::Administration::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<ImplementationRepository::Administration,ImplementationRepository::Administration_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<ImplementationRepository::Administration,ImplementationRepository::Administration_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const ImplementationRepository::Administration::AlreadyRegistered &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::Administration::_tc_AlreadyRegistered,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::Administration::AlreadyRegistered *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::Administration::_tc_AlreadyRegistered,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      ImplementationRepository::Administration::AlreadyRegistered::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::Administration::AlreadyRegistered *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast (
      const ImplementationRepository::Administration::AlreadyRegistered *&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const ImplementationRepository::Administration::AlreadyRegistered *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::Administration::_tc_AlreadyRegistered, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (ImplementationRepository::Administration::AlreadyRegistered *)_tao_any.value ();
      return 1;
    }
    else
    {
      ImplementationRepository::Administration::AlreadyRegistered *tmp;
      ACE_NEW_RETURN (tmp, ImplementationRepository::Administration::AlreadyRegistered, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            ImplementationRepository::Administration::_tc_AlreadyRegistered,
            1,
            tmp,
            ImplementationRepository::Administration::AlreadyRegistered::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const ImplementationRepository::Administration::CannotActivate &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::Administration::_tc_CannotActivate,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::Administration::CannotActivate *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::Administration::_tc_CannotActivate,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      ImplementationRepository::Administration::CannotActivate::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::Administration::CannotActivate *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast (
      const ImplementationRepository::Administration::CannotActivate *&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const ImplementationRepository::Administration::CannotActivate *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::Administration::_tc_CannotActivate, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (ImplementationRepository::Administration::CannotActivate *)_tao_any.value ();
      return 1;
    }
    else
    {
      ImplementationRepository::Administration::CannotActivate *tmp;
      ACE_NEW_RETURN (tmp, ImplementationRepository::Administration::CannotActivate, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            ImplementationRepository::Administration::_tc_CannotActivate,
            1,
            tmp,
            ImplementationRepository::Administration::CannotActivate::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const ImplementationRepository::Administration::NotFound &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::Administration::_tc_NotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::Administration::NotFound *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      ImplementationRepository::Administration::_tc_NotFound,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      ImplementationRepository::Administration::NotFound::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::Administration::NotFound *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast (
      const ImplementationRepository::Administration::NotFound *&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const ImplementationRepository::Administration::NotFound *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::Administration::_tc_NotFound, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (ImplementationRepository::Administration::NotFound *)_tao_any.value ();
      return 1;
    }
    else
    {
      ImplementationRepository::Administration::NotFound *tmp;
      ACE_NEW_RETURN (tmp, ImplementationRepository::Administration::NotFound, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            ImplementationRepository::Administration::_tc_NotFound,
            1,
            tmp,
            ImplementationRepository::Administration::NotFound::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

ImplementationRepository::ServerInformationIterator_ptr (*_TAO_collocation_ImplementationRepository_ServerInformationIterator_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, ImplementationRepository::ServerInformationIterator_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        ImplementationRepository::_tc_ServerInformationIterator,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        ImplementationRepository::ServerInformationIterator::_duplicate (_tao_elem),
        ImplementationRepository::ServerInformationIterator::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, ImplementationRepository::ServerInformationIterator_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = ImplementationRepository::ServerInformationIterator::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (ImplementationRepository::_tc_ServerInformationIterator, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          ImplementationRepository::_tc_ServerInformationIterator,
          1,
          _tao_elem,
          ImplementationRepository::ServerInformationIterator::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = ImplementationRepository::ServerInformationIterator::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = ImplementationRepository::ServerInformationIterator::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
  template class TAO_Object_Manager<ImplementationRepository::ServerInformationIterator,ImplementationRepository::ServerInformationIterator_var>;
#elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
#  pragma instantiate TAO_Object_Manager<ImplementationRepository::ServerInformationIterator,ImplementationRepository::ServerInformationIterator_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::EnvironmentList &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::EnvironmentList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const ImplementationRepository::ServerInformationList &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    ImplementationRepository::ServerInformationList &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len)
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}
