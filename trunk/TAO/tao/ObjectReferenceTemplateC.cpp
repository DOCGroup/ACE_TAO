// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "ObjectReferenceTemplateC.h"

#include "tao/Stub.h"
#include "tao/Invocation.h"
#include "tao/PortableInterceptor.h"
#include "tao/ValueFactory.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#include "tao/ClientRequestInfo_i.h"
#include "tao/ClientInterceptorAdapter.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus -w-sig
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "ObjectReferenceTemplateC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_PortableInterceptor_ServerId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65724964), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/ServerId:1.0
  9,
  ACE_NTOHL (0x53657276), 
  ACE_NTOHL (0x65724964), 
  ACE_NTOHL (0x0),  // name = ServerId
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ServerId (
    CORBA::tk_alias,
    sizeof (_oc_PortableInterceptor_ServerId),
    (char *) &_oc_PortableInterceptor_ServerId,
    0,
    sizeof (PortableInterceptor::ServerId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ServerId, &_tc_TAO_tc_PortableInterceptor_ServerId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableInterceptor_ORBId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x4f524249), 
  ACE_NTOHL (0x643a312e), 
  ACE_NTOHL (0x30000000),  // repository ID = IDL:PortableInterceptor/ORBId:1.0
  6,
  ACE_NTOHL (0x4f524249), 
  ACE_NTOHL (0x64000000),  // name = ORBId
  CORBA::tk_string, 
  0U, // string length
};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ORBId (
    CORBA::tk_alias,
    sizeof (_oc_PortableInterceptor_ORBId),
    (char *) &_oc_PortableInterceptor_ORBId,
    0,
    sizeof (PortableInterceptor::ORBId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ORBId, &_tc_TAO_tc_PortableInterceptor_ORBId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableInterceptor_AdapterName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x41646170), 
  ACE_NTOHL (0x7465724e), 
  ACE_NTOHL (0x616d653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/AdapterName:1.0
  12,
  ACE_NTOHL (0x41646170), 
  ACE_NTOHL (0x7465724e), 
  ACE_NTOHL (0x616d6500),  // name = AdapterName
  CORBA::tk_alias, // typecode kind for typedefs
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f5374), 
    ACE_NTOHL (0x72696e67), 
    ACE_NTOHL (0x5365713a), 
    ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/CORBA/StringSeq:1.0
    10,
    ACE_NTOHL (0x53747269), 
    ACE_NTOHL (0x6e675365), 
    ACE_NTOHL (0x71000000),  // name = StringSeq
    CORBA::tk_sequence, // typecode kind
    16, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_string, 
      0U, // string length
      0U,


};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_AdapterName (
    CORBA::tk_alias,
    sizeof (_oc_PortableInterceptor_AdapterName),
    (char *) &_oc_PortableInterceptor_AdapterName,
    0,
    sizeof (PortableInterceptor::AdapterName)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_AdapterName, &_tc_TAO_tc_PortableInterceptor_AdapterName)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableInterceptor_ObjectId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744964), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/ObjectId:1.0
  9,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63744964), 
  ACE_NTOHL (0x0),  // name = ObjectId
  CORBA::tk_alias, // typecode kind for typedefs
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31,
    ACE_NTOHL (0x49444c3a), 
    ACE_NTOHL (0x6f6d672e), 
    ACE_NTOHL (0x6f72672f), 
    ACE_NTOHL (0x434f5242), 
    ACE_NTOHL (0x412f4f63), 
    ACE_NTOHL (0x74657453), 
    ACE_NTOHL (0x65713a31), 
    ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/OctetSeq:1.0
    9,
    ACE_NTOHL (0x4f637465), 
    ACE_NTOHL (0x74536571), 
    ACE_NTOHL (0x0),  // name = OctetSeq
    CORBA::tk_sequence, // typecode kind
    12, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_octet,

      0U,


};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ObjectId (
    CORBA::tk_alias,
    sizeof (_oc_PortableInterceptor_ObjectId),
    (char *) &_oc_PortableInterceptor_ObjectId,
    0,
    sizeof (PortableInterceptor::ObjectId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ObjectId, &_tc_TAO_tc_PortableInterceptor_ObjectId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableInterceptor_ObjectReferenceFactory[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63745265), 
  ACE_NTOHL (0x66657265), 
  ACE_NTOHL (0x6e636546), 
  ACE_NTOHL (0x6163746f), 
  ACE_NTOHL (0x72793a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:PortableInterceptor/ObjectReferenceFactory:1.0
  23,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63745265), 
  ACE_NTOHL (0x66657265), 
  ACE_NTOHL (0x6e636546), 
  ACE_NTOHL (0x6163746f), 
  ACE_NTOHL (0x72790000),  // name = ObjectReferenceFactory
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  0, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ObjectReferenceFactory (
    CORBA::tk_value,
    sizeof (_oc_PortableInterceptor_ObjectReferenceFactory),
    (char *) &_oc_PortableInterceptor_ObjectReferenceFactory,
    0,
    sizeof (PortableInterceptor::ObjectReferenceFactory)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ObjectReferenceFactory, &_tc_TAO_tc_PortableInterceptor_ObjectReferenceFactory)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class PortableInterceptor::ObjectReferenceFactory_var
// *************************************************************

PortableInterceptor::ObjectReferenceFactory_var::ObjectReferenceFactory_var (void) // default constructor
  : ptr_ (0)
{}

PortableInterceptor::ObjectReferenceFactory_var::ObjectReferenceFactory_var (ObjectReferenceFactory* p)
  : ptr_ (p)
{}

PortableInterceptor::ObjectReferenceFactory_var::ObjectReferenceFactory_var (const ObjectReferenceFactory* p)
  : ptr_ (ACE_const_cast(ObjectReferenceFactory*, p))
{}

PortableInterceptor::ObjectReferenceFactory* 
PortableInterceptor::ObjectReferenceFactory_var::ptr (void) const
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory_var::ObjectReferenceFactory_var (const ObjectReferenceFactory_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

PortableInterceptor::ObjectReferenceFactory_var::~ObjectReferenceFactory_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

PortableInterceptor::ObjectReferenceFactory_var &
PortableInterceptor::ObjectReferenceFactory_var::operator= (ObjectReferenceFactory* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableInterceptor::ObjectReferenceFactory_var &
PortableInterceptor::ObjectReferenceFactory_var::operator= (const ObjectReferenceFactory_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ObjectReferenceFactory* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

PortableInterceptor::ObjectReferenceFactory_var::operator const PortableInterceptor::ObjectReferenceFactory* () const // cast
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory_var::operator PortableInterceptor::ObjectReferenceFactory* () // cast 
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory* 
PortableInterceptor::ObjectReferenceFactory_var::operator-> (void) const
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory*
PortableInterceptor::ObjectReferenceFactory_var::in (void) const
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory* &
PortableInterceptor::ObjectReferenceFactory_var::inout (void)
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory* &
PortableInterceptor::ObjectReferenceFactory_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory* 
PortableInterceptor::ObjectReferenceFactory_var::_retn (void)
{
  // yield ownership of managed obj reference
  ObjectReferenceFactory* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class PortableInterceptor::ObjectReferenceFactory_out
// *************************************************************

PortableInterceptor::ObjectReferenceFactory_out::ObjectReferenceFactory_out (ObjectReferenceFactory* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

PortableInterceptor::ObjectReferenceFactory_out::ObjectReferenceFactory_out (ObjectReferenceFactory_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

PortableInterceptor::ObjectReferenceFactory_out::ObjectReferenceFactory_out (const ObjectReferenceFactory_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ObjectReferenceFactory_out&,p).ptr_)
{}

PortableInterceptor::ObjectReferenceFactory_out &
PortableInterceptor::ObjectReferenceFactory_out::operator= (const ObjectReferenceFactory_out &p)
{
  this->ptr_ = ACE_const_cast (ObjectReferenceFactory_out&,p).ptr_;
  return *this;
}

PortableInterceptor::ObjectReferenceFactory_out &
PortableInterceptor::ObjectReferenceFactory_out::operator= (const ObjectReferenceFactory_var &p)
{
  ObjectReferenceFactory* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

PortableInterceptor::ObjectReferenceFactory_out &
PortableInterceptor::ObjectReferenceFactory_out::operator= (ObjectReferenceFactory* p)
{
  this->ptr_ = p;
  return *this;
}

PortableInterceptor::ObjectReferenceFactory_out::operator PortableInterceptor::ObjectReferenceFactory* &() // cast
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory* &
PortableInterceptor::ObjectReferenceFactory_out::ptr (void) // ptr
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory* 
PortableInterceptor::ObjectReferenceFactory_out::operator-> (void)
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceFactory* PortableInterceptor::ObjectReferenceFactory::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (ObjectReferenceFactory* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* PortableInterceptor::ObjectReferenceFactory::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* PortableInterceptor::ObjectReferenceFactory::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  return rval;
}

void
PortableInterceptor::ObjectReferenceFactory::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectReferenceFactory *tmp = ACE_static_cast (ObjectReferenceFactory*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean PortableInterceptor::ObjectReferenceFactory::_tao_unmarshal (TAO_InputCDR &strm, ObjectReferenceFactory *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          ObjectReferenceFactory::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "PortableInterceptor::ObjectReferenceFactory::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "PortableInterceptor::ObjectReferenceFactory::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ObjectReferenceFactory::_downcast (base);
  // %! unmarshal_post
  return 1;
}

static const CORBA::Long _oc_PortableInterceptor_ObjectReferenceTemplate[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63745265), 
  ACE_NTOHL (0x66657265), 
  ACE_NTOHL (0x6e636554), 
  ACE_NTOHL (0x656d706c), 
  ACE_NTOHL (0x6174653a), 
  ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/ObjectReferenceTemplate:1.0
  24,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63745265), 
  ACE_NTOHL (0x66657265), 
  ACE_NTOHL (0x6e636554), 
  ACE_NTOHL (0x656d706c), 
  ACE_NTOHL (0x61746500),  // name = ObjectReferenceTemplate
  2, // value modifier
  CORBA::tk_null, // no stateful base valuetype

  3, // member count
};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ObjectReferenceTemplate (
    CORBA::tk_value,
    sizeof (_oc_PortableInterceptor_ObjectReferenceTemplate),
    (char *) &_oc_PortableInterceptor_ObjectReferenceTemplate,
    0,
    sizeof (PortableInterceptor::ObjectReferenceTemplate)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ObjectReferenceTemplate, &_tc_TAO_tc_PortableInterceptor_ObjectReferenceTemplate)
TAO_NAMESPACE_END

// *************************************************************
// Operations for class PortableInterceptor::ObjectReferenceTemplate_var
// *************************************************************

PortableInterceptor::ObjectReferenceTemplate_var::ObjectReferenceTemplate_var (void) // default constructor
  : ptr_ (0)
{}

PortableInterceptor::ObjectReferenceTemplate_var::ObjectReferenceTemplate_var (ObjectReferenceTemplate* p)
  : ptr_ (p)
{}

PortableInterceptor::ObjectReferenceTemplate_var::ObjectReferenceTemplate_var (const ObjectReferenceTemplate* p)
  : ptr_ (ACE_const_cast(ObjectReferenceTemplate*, p))
{}

PortableInterceptor::ObjectReferenceTemplate* 
PortableInterceptor::ObjectReferenceTemplate_var::ptr (void) const
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate_var::ObjectReferenceTemplate_var (const ObjectReferenceTemplate_var &p) // copy constructor
{
  CORBA::add_ref (p.ptr ());
  this->ptr_ = p.ptr ();
}

PortableInterceptor::ObjectReferenceTemplate_var::~ObjectReferenceTemplate_var (void) // destructor
{
  CORBA::remove_ref (this->ptr_);
}

PortableInterceptor::ObjectReferenceTemplate_var &
PortableInterceptor::ObjectReferenceTemplate_var::operator= (ObjectReferenceTemplate* p)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = p;
  return *this;
}

PortableInterceptor::ObjectReferenceTemplate_var &
PortableInterceptor::ObjectReferenceTemplate_var::operator= (const ObjectReferenceTemplate_var &p)
{
  if (this != &p)
  {
    CORBA::remove_ref (this->ptr_);
    ObjectReferenceTemplate* tmp = p.ptr ();
    CORBA::add_ref (tmp);
    this->ptr_ = tmp;
  }
  return *this;
}

PortableInterceptor::ObjectReferenceTemplate_var::operator const PortableInterceptor::ObjectReferenceTemplate* () const // cast
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate_var::operator PortableInterceptor::ObjectReferenceTemplate* () // cast 
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate* 
PortableInterceptor::ObjectReferenceTemplate_var::operator-> (void) const
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate*
PortableInterceptor::ObjectReferenceTemplate_var::in (void) const
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate* &
PortableInterceptor::ObjectReferenceTemplate_var::inout (void)
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate* &
PortableInterceptor::ObjectReferenceTemplate_var::out (void)
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate* 
PortableInterceptor::ObjectReferenceTemplate_var::_retn (void)
{
  // yield ownership of managed obj reference
  ObjectReferenceTemplate* tmp = this->ptr_;
  this->ptr_ = 0;
  return tmp;
}

// *************************************************************
// Operations for class PortableInterceptor::ObjectReferenceTemplate_out
// *************************************************************

PortableInterceptor::ObjectReferenceTemplate_out::ObjectReferenceTemplate_out (ObjectReferenceTemplate* &p)
  : ptr_ (p)
{
  this->ptr_ = 0;
}

PortableInterceptor::ObjectReferenceTemplate_out::ObjectReferenceTemplate_out (ObjectReferenceTemplate_var &p) // constructor from _var
  : ptr_ (p.out ())
{
  CORBA::remove_ref (this->ptr_);
  this->ptr_ = 0;
}

PortableInterceptor::ObjectReferenceTemplate_out::ObjectReferenceTemplate_out (const ObjectReferenceTemplate_out &p) // copy constructor
  : ptr_ (ACE_const_cast (ObjectReferenceTemplate_out&,p).ptr_)
{}

PortableInterceptor::ObjectReferenceTemplate_out &
PortableInterceptor::ObjectReferenceTemplate_out::operator= (const ObjectReferenceTemplate_out &p)
{
  this->ptr_ = ACE_const_cast (ObjectReferenceTemplate_out&,p).ptr_;
  return *this;
}

PortableInterceptor::ObjectReferenceTemplate_out &
PortableInterceptor::ObjectReferenceTemplate_out::operator= (const ObjectReferenceTemplate_var &p)
{
  ObjectReferenceTemplate* tmp = p.ptr ();
  CORBA::add_ref (tmp);
  this->ptr_ = tmp;
  return *this;
}

PortableInterceptor::ObjectReferenceTemplate_out &
PortableInterceptor::ObjectReferenceTemplate_out::operator= (ObjectReferenceTemplate* p)
{
  this->ptr_ = p;
  return *this;
}

PortableInterceptor::ObjectReferenceTemplate_out::operator PortableInterceptor::ObjectReferenceTemplate* &() // cast
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate* &
PortableInterceptor::ObjectReferenceTemplate_out::ptr (void) // ptr
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate* 
PortableInterceptor::ObjectReferenceTemplate_out::operator-> (void)
{
  return this->ptr_;
}

PortableInterceptor::ObjectReferenceTemplate* PortableInterceptor::ObjectReferenceTemplate::_downcast (CORBA::ValueBase* v)
{
  if (v == 0) return 0;
  return (ObjectReferenceTemplate* ) v->_tao_obv_narrow ((ptr_arith_t) &_downcast);
}

const char* PortableInterceptor::ObjectReferenceTemplate::_tao_obv_repository_id () const
{
  return this->_tao_obv_static_repository_id ();
}

void* PortableInterceptor::ObjectReferenceTemplate::_tao_obv_narrow (ptr_arith_t type_id)
{
  if (type_id == (ptr_arith_t) &_downcast)
    return this;
  void *rval = 0;
  if (rval == 0)
    rval = ACE_NESTED_CLASS (PortableInterceptor,ObjectReferenceFactory)::_tao_obv_narrow (type_id);
  return rval;
}

void
PortableInterceptor::ObjectReferenceTemplate::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectReferenceTemplate *tmp = ACE_static_cast (ObjectReferenceTemplate*, _tao_void_pointer);
  delete tmp;
}

CORBA::Boolean PortableInterceptor::ObjectReferenceTemplate::_tao_unmarshal (TAO_InputCDR &strm, ObjectReferenceTemplate *&new_object)
{
  CORBA::Boolean retval = 1;
  CORBA::ValueBase *base;   // %! should be a _var
  CORBA::ValueFactory_ptr factory;   // %! should be a _var
  if (!CORBA::ValueBase::_tao_unmarshal_pre (strm, factory, base,
          ObjectReferenceTemplate::_tao_obv_static_repository_id ()) )
    {
      return 0;
    }
  if (factory != 0)
    {
      base = factory->create_for_unmarshal ();
      factory->_remove_ref ();
      if (base == 0)  return 0;  // %! except.?
      //%! ACE_DEBUG ((LM_DEBUG, "PortableInterceptor::ObjectReferenceTemplate::_tao_unmarshal %s\n", base->_tao_obv_repository_id () ));
      retval = base->_tao_unmarshal_v (strm);
      //%! ACE_DEBUG ((LM_DEBUG, "PortableInterceptor::ObjectReferenceTemplate::_tao_unmarshal retval unmarshal_v is %d\n", retval));
      if (!retval) return 0;
    }
  // Now base must be null or point to the unmarshaled object.
  // Align the pointer to the right subobject.
  new_object = ObjectReferenceTemplate::_downcast (base);
  // %! unmarshal_post
  return 1;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_VALUETYPE_SEQUENCE_PORTABLEINTERCEPTOR_OBJECTREFERENCETEMPLATESEQ_CS_)
#define __TAO_UNBOUNDED_VALUETYPE_SEQUENCE_PORTABLEINTERCEPTOR_OBJECTREFERENCETEMPLATESEQ_CS_

// The Base_Sequence functions, please see tao/Sequence.h
void
PortableInterceptor::_TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq::_allocate_buffer (CORBA::ULong length)
{
  PortableInterceptor::ObjectReferenceTemplate **tmp = 0;
  tmp = _TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq::allocbuf (length);
  
  if (this->buffer_ != 0)
  {
    PortableInterceptor::ObjectReferenceTemplate **old = ACE_reinterpret_cast (PortableInterceptor::ObjectReferenceTemplate**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
      {
        if (!this->release_)
          {
            if (old[i] != 0)
              old[i]->_add_ref ();
            tmp[i] = old[i];
          }
        else
          {
            tmp[i] = old[i];
          }
      }
    
    if (this->release_)
      {
        delete[] old;
      }
  }
  this->buffer_ = tmp;
}

void
PortableInterceptor::_TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq::_deallocate_buffer (void)
{
  if (this->buffer_ == 0 || this->release_ == 0)
    return;
  PortableInterceptor::ObjectReferenceTemplate **tmp = ACE_reinterpret_cast (PortableInterceptor::ObjectReferenceTemplate**, this->buffer_);
  
  for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
  
  _TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq::freebuf (tmp);
  this->buffer_ = 0;
}

PortableInterceptor::_TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq::~_TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq (void)
{
  this->_deallocate_buffer ();
}

void
PortableInterceptor::_TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
{
  PortableInterceptor::ObjectReferenceTemplate **tmp = ACE_reinterpret_cast (PortableInterceptor::ObjectReferenceTemplate**, this->buffer_);
  
  for (CORBA::ULong i = nl; i < ol; ++i)
    {
      if (tmp[i] != 0)
        tmp[i]->_remove_ref ();
      tmp[i] = 0;
    }
}


#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

#if !defined (_PORTABLEINTERCEPTOR_OBJECTREFERENCETEMPLATESEQ_CS_)
#define _PORTABLEINTERCEPTOR_OBJECTREFERENCETEMPLATESEQ_CS_

// *************************************************************
// PortableInterceptor::ObjectReferenceTemplateSeq
// *************************************************************

PortableInterceptor::ObjectReferenceTemplateSeq::ObjectReferenceTemplateSeq (void)
{}
PortableInterceptor::ObjectReferenceTemplateSeq::ObjectReferenceTemplateSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<PortableInterceptor::ObjectReferenceTemplate,PortableInterceptor::ObjectReferenceTemplate_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableInterceptor::ObjectReferenceTemplateSeq::ObjectReferenceTemplateSeq (CORBA::ULong max, CORBA::ULong length, PortableInterceptor::ObjectReferenceTemplate_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<PortableInterceptor::ObjectReferenceTemplate,PortableInterceptor::ObjectReferenceTemplate_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableInterceptor::ObjectReferenceTemplateSeq::ObjectReferenceTemplateSeq (const ObjectReferenceTemplateSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
_TAO_Unbounded_Valuetype_Sequence_PortableInterceptor_ObjectReferenceTemplateSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
TAO_Unbounded_Valuetype_Sequence<PortableInterceptor::ObjectReferenceTemplate,PortableInterceptor::ObjectReferenceTemplate_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableInterceptor::ObjectReferenceTemplateSeq::~ObjectReferenceTemplateSeq (void) // dtor
{}
void PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor (void *_tao_void_pointer)
{
  ObjectReferenceTemplateSeq *tmp = ACE_static_cast (ObjectReferenceTemplateSeq*, _tao_void_pointer);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableInterceptor_ObjectReferenceTemplateSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63745265), 
  ACE_NTOHL (0x66657265), 
  ACE_NTOHL (0x6e636554), 
  ACE_NTOHL (0x656d706c), 
  ACE_NTOHL (0x61746553), 
  ACE_NTOHL (0x65713a31), 
  ACE_NTOHL (0x2e300000),  // repository ID = IDL:PortableInterceptor/ObjectReferenceTemplateSeq:1.0
  27,
  ACE_NTOHL (0x4f626a65), 
  ACE_NTOHL (0x63745265), 
  ACE_NTOHL (0x66657265), 
  ACE_NTOHL (0x6e636554), 
  ACE_NTOHL (0x656d706c), 
  ACE_NTOHL (0x61746553), 
  ACE_NTOHL (0x65710000),  // name = ObjectReferenceTemplateSeq
  CORBA::tk_sequence, // typecode kind
  116, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_value, // typecode kind
    448, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      52,
      ACE_NTOHL (0x49444c3a), 
      ACE_NTOHL (0x506f7274), 
      ACE_NTOHL (0x61626c65), 
      ACE_NTOHL (0x496e7465), 
      ACE_NTOHL (0x72636570), 
      ACE_NTOHL (0x746f722f), 
      ACE_NTOHL (0x4f626a65), 
      ACE_NTOHL (0x63745265), 
      ACE_NTOHL (0x66657265), 
      ACE_NTOHL (0x6e636554), 
      ACE_NTOHL (0x656d706c), 
      ACE_NTOHL (0x6174653a), 
      ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/ObjectReferenceTemplate:1.0
      24,
      ACE_NTOHL (0x4f626a65), 
      ACE_NTOHL (0x63745265), 
      ACE_NTOHL (0x66657265), 
      ACE_NTOHL (0x6e636554), 
      ACE_NTOHL (0x656d706c), 
      ACE_NTOHL (0x61746500),  // name = ObjectReferenceTemplate
      2, // value modifier
      CORBA::tk_null, // no stateful base valuetype

      3, // member count

    0U,

};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ObjectReferenceTemplateSeq (
    CORBA::tk_alias,
    sizeof (_oc_PortableInterceptor_ObjectReferenceTemplateSeq),
    (char *) &_oc_PortableInterceptor_ObjectReferenceTemplateSeq,
    0,
    sizeof (PortableInterceptor::ObjectReferenceTemplateSeq)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_ObjectReferenceTemplateSeq, &_tc_TAO_tc_PortableInterceptor_ObjectReferenceTemplateSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableInterceptor_AdapterManagerId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x41646170), 
  ACE_NTOHL (0x7465724d), 
  ACE_NTOHL (0x616e6167), 
  ACE_NTOHL (0x65724964), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/AdapterManagerId:1.0
  17,
  ACE_NTOHL (0x41646170), 
  ACE_NTOHL (0x7465724d), 
  ACE_NTOHL (0x616e6167), 
  ACE_NTOHL (0x65724964), 
  ACE_NTOHL (0x0),  // name = AdapterManagerId
  CORBA::tk_long,

};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_AdapterManagerId (
    CORBA::tk_alias,
    sizeof (_oc_PortableInterceptor_AdapterManagerId),
    (char *) &_oc_PortableInterceptor_AdapterManagerId,
    0,
    sizeof (PortableInterceptor::AdapterManagerId)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_AdapterManagerId, &_tc_TAO_tc_PortableInterceptor_AdapterManagerId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableInterceptor_AdapterState[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41,
  ACE_NTOHL (0x49444c3a), 
  ACE_NTOHL (0x506f7274), 
  ACE_NTOHL (0x61626c65), 
  ACE_NTOHL (0x496e7465), 
  ACE_NTOHL (0x72636570), 
  ACE_NTOHL (0x746f722f), 
  ACE_NTOHL (0x41646170), 
  ACE_NTOHL (0x74657253), 
  ACE_NTOHL (0x74617465), 
  ACE_NTOHL (0x3a312e30), 
  ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/AdapterState:1.0
  13,
  ACE_NTOHL (0x41646170), 
  ACE_NTOHL (0x74657253), 
  ACE_NTOHL (0x74617465), 
  ACE_NTOHL (0x0),  // name = AdapterState
  CORBA::tk_short,

};

static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_AdapterState (
    CORBA::tk_alias,
    sizeof (_oc_PortableInterceptor_AdapterState),
    (char *) &_oc_PortableInterceptor_AdapterState,
    0,
    sizeof (PortableInterceptor::AdapterState)
  );

TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (::CORBA::TypeCode_ptr, _tc_AdapterState, &_tc_TAO_tc_PortableInterceptor_AdapterState)
TAO_NAMESPACE_END

TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, HOLDING, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, ACTIVE, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, DISCARDING, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, INACTIVE, 3)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, NON_EXISTENT, 4)
TAO_NAMESPACE_END
TAO_Export void
operator<<= (CORBA::Any &any, PortableInterceptor::ObjectReferenceFactory *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        PortableInterceptor::_tc_ObjectReferenceFactory, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

TAO_Export void
operator<<= (CORBA::Any &any, PortableInterceptor::ObjectReferenceFactory **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        PortableInterceptor::_tc_ObjectReferenceFactory, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        PortableInterceptor::ObjectReferenceFactory::_tao_any_destructor);
  }
}

TAO_Export CORBA::Boolean
operator>>= (const CORBA::Any &any, PortableInterceptor::ObjectReferenceFactory *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableInterceptor::_tc_ObjectReferenceFactory ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const PortableInterceptor::ObjectReferenceFactory *const_holder = ACE_static_cast (
          const PortableInterceptor::ObjectReferenceFactory*,
          any.value ());
      value = ACE_const_cast (
          PortableInterceptor::ObjectReferenceFactory*,
          const_holder);
      return 1;
    }
    else
    {
      PortableInterceptor::ObjectReferenceFactory *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            PortableInterceptor::_tc_ObjectReferenceFactory,
            1,
            ACE_static_cast (void *, tmp),
            PortableInterceptor::ObjectReferenceFactory::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<PortableInterceptor::ObjectReferenceFactory, PortableInterceptor::ObjectReferenceFactory_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<PortableInterceptor::ObjectReferenceFactory, PortableInterceptor::ObjectReferenceFactory_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

TAO_Export void
operator<<= (CORBA::Any &any, PortableInterceptor::ObjectReferenceTemplate *value) // copying
{
  TAO_OutputCDR stream;
  if (stream << value)
  {
    any._tao_replace (
        PortableInterceptor::_tc_ObjectReferenceTemplate, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ());
  }
}

TAO_Export void
operator<<= (CORBA::Any &any, PortableInterceptor::ObjectReferenceTemplate **value) // non-copying
{
  TAO_OutputCDR stream;
  if (stream << *value)
  {
    any._tao_replace (
        PortableInterceptor::_tc_ObjectReferenceTemplate, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        *value,
        PortableInterceptor::ObjectReferenceTemplate::_tao_any_destructor);
  }
}

TAO_Export CORBA::Boolean
operator>>= (const CORBA::Any &any, PortableInterceptor::ObjectReferenceTemplate *&value)
{
  ACE_TRY_NEW_ENV
  {
    value = 0;
    CORBA::TypeCode_var type = any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableInterceptor::_tc_ObjectReferenceTemplate ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
    {
      return 0; // not equivalent
    }
    if (any.any_owns_data ())
    {
      const PortableInterceptor::ObjectReferenceTemplate *const_holder = ACE_static_cast (
          const PortableInterceptor::ObjectReferenceTemplate*,
          any.value ());
      value = ACE_const_cast (
          PortableInterceptor::ObjectReferenceTemplate*,
          const_holder);
      return 1;
    }
    else
    {
      PortableInterceptor::ObjectReferenceTemplate *tmp;
      TAO_InputCDR stream (
          any._tao_get_cdr (),
          any._tao_byte_order ());
      if (stream >> tmp)
      {
        ((CORBA::Any *)&any)->_tao_replace (
            PortableInterceptor::_tc_ObjectReferenceTemplate,
            1,
            ACE_static_cast (void *, tmp),
            PortableInterceptor::ObjectReferenceTemplate::_tao_any_destructor);
        value = tmp;
        return 1;
      }
      
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Valuetype_Manager<PortableInterceptor::ObjectReferenceTemplate, PortableInterceptor::ObjectReferenceTemplate_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Valuetype_Manager<PortableInterceptor::ObjectReferenceTemplate, PortableInterceptor::ObjectReferenceTemplate_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (
    CORBA::Any &_tao_any,
    const PortableInterceptor::ObjectReferenceTemplateSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ObjectReferenceTemplateSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ObjectReferenceTemplateSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableInterceptor::ObjectReferenceTemplateSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableInterceptor::ObjectReferenceTemplateSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    
    CORBA::Boolean result = type->equivalent (PortableInterceptor::_tc_ObjectReferenceTemplateSeq ACE_ENV_ARG_PARAMETER);
    ACE_TRY_CHECK;
    
    if (!result)
      return 0; // not equivalent
    
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableInterceptor::ObjectReferenceTemplateSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableInterceptor::ObjectReferenceTemplateSeq *tmp;
      ACE_NEW_RETURN (tmp, PortableInterceptor::ObjectReferenceTemplateSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableInterceptor::_tc_ObjectReferenceTemplateSeq,
            1,
            ACE_static_cast (void *, tmp),
            PortableInterceptor::ObjectReferenceTemplateSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

//@@ Boris: begin experimental
void
CORBA::add_ref (PortableInterceptor::ObjectReferenceFactory * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (PortableInterceptor::ObjectReferenceFactory * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const PortableInterceptor::ObjectReferenceFactory *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (PortableInterceptor::ObjectReferenceFactory*, _tao_valuetype),
    (ptr_arith_t) &PortableInterceptor::ObjectReferenceFactory::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, PortableInterceptor::ObjectReferenceFactory *&_tao_valuetype)
{
  return PortableInterceptor::ObjectReferenceFactory::_tao_unmarshal (strm, _tao_valuetype);
}

//@@ Boris: begin experimental
void
CORBA::add_ref (PortableInterceptor::ObjectReferenceTemplate * vt)
{
  if (vt != 0)
  {
    vt->_add_ref ();
  }
}

void
CORBA::remove_ref (PortableInterceptor::ObjectReferenceTemplate * vt)
{
  if (vt != 0)
  {
    vt->_remove_ref ();
  }
}

//@@ Boris: end experimental
CORBA::Boolean
operator<< (TAO_OutputCDR &strm, const PortableInterceptor::ObjectReferenceTemplate *_tao_valuetype)
{
  return CORBA_ValueBase::_tao_marshal (strm,
    ACE_const_cast (PortableInterceptor::ObjectReferenceTemplate*, _tao_valuetype),
    (ptr_arith_t) &PortableInterceptor::ObjectReferenceTemplate::_downcast);
}

CORBA::Boolean
operator>> (TAO_InputCDR &strm, PortableInterceptor::ObjectReferenceTemplate *&_tao_valuetype)
{
  return PortableInterceptor::ObjectReferenceTemplate::_tao_unmarshal (strm, _tao_valuetype);
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::ObjectReferenceTemplateSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::ObjectReferenceTemplateSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // Add a check to the length of the sequence
    // to make sure it does not exceed the length
    // of the stream. (See bug 58.)
    if (_tao_seq_len > strm.length())
      return 0;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

