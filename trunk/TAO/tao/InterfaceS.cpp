/* -*- C++ -*- */
// $Id$

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/InterfaceS.h"

ACE_RCSID(tao, InterfaceS, "$Id$")

#if (TAO_HAS_INTERFACE_REPOSITORY == 1)

#if !defined (__ACE_INLINE__)
#include "tao/InterfaceS.i"
#endif /* !defined INLINE */

class TAO_CORBA_IRObject_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:52 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IRObject_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IRObject_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15,  0,
     15, 15,  0, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15,  1, 15, 15, 15, 15,  0, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,
#else
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15,  0, 15,  0, 15, 15,
      0, 15, 15, 15, 15, 15, 15, 15, 15, 15,
     15, 15, 15, 15, 15, 15,  1, 15, 15, 15,
     15,  0, 15, 15, 15, 15, 15, 15,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IRObject_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 4,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 14,
      HASH_VALUE_RANGE = 10,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::IRObject::_is_a_skel},
      {"",0},
      {"destroy", 	&POA_CORBA::IRObject::destroy_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_get_def_kind", 	&POA_CORBA::IRObject::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA::IRObject::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:05:52 */
static TAO_CORBA_IRObject_Perfect_Hash_OpTable tao_CORBA_IRObject_optable;

CORBA::IRObject_ptr _TAO_collocation_POA_CORBA_IRObject_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::IRObject_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_IRObject (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_IRObject_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_IRObject_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_IRObject_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_IRObject_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_IRObject_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_IRObject_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::IRObject::IRObject (void)
{
  this->optable_ = &tao_CORBA_IRObject_optable;
}

// copy ctor
POA_CORBA::IRObject::IRObject (const IRObject& rhs)
  :   TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::IRObject::~IRObject (void)
{
}

void POA_CORBA::IRObject::_get_def_kind_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *)_tao_object_reference;

  CORBA::DefinitionKind _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_def_kind",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->def_kind (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_def_kind",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_def_kind",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::IRObject::destroy_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *)_tao_object_reference;

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "destroy",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->destroy (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "destroy",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "destroy",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::IRObject::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::IRObject::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::IRObject *_tao_impl = (POA_CORBA::IRObject *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::IRObject::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::IRObject::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::IRObject::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

CORBA::IRObject*
POA_CORBA::IRObject::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::IRObject_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_IRObject (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::IRObject::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_IRObject::_tao_thru_poa_collocated_IRObject (
  TAO_Stub *stub
)
  :  CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_IRObject::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_IRObject::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::DefinitionKind POA_CORBA::_tao_thru_poa_collocated_IRObject::def_kind  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::DefinitionKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "def_kind",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->def_kind (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_IRObject::destroy  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "destroy",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::IRObject_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IRObject:1.0"
        )
    )->destroy (
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_Contained_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:52 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Contained_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Contained_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Contained_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 15,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::Contained::move_skel},
      {"_is_a",  &POA_CORBA::Contained::_is_a_skel},
      {"_get_id", 	&POA_CORBA::Contained::_get_id_skel},
      {"_set_id", 	&POA_CORBA::Contained::_set_id_skel},
      {"describe", 	&POA_CORBA::Contained::describe_skel},
      {"_get_name", 	&POA_CORBA::Contained::_get_name_skel},
      {"_set_name", 	&POA_CORBA::Contained::_set_name_skel},
      {"_get_version", 	&POA_CORBA::Contained::_get_version_skel},
      {"_set_version", 	&POA_CORBA::Contained::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::Contained::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::Contained::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::Contained::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::Contained::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA::Contained::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::Contained::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -2,   4,   5,  -1, -43,   8, -43, -11,  -2, -38,  13, 
       -1,  14,  -1,  15,  16,  -1,  -1,  -1,  -1,  17,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  18, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:52 */
static TAO_CORBA_Contained_Perfect_Hash_OpTable tao_CORBA_Contained_optable;

CORBA::Contained_ptr _TAO_collocation_POA_CORBA_Contained_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::Contained_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_Contained (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_Contained_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_Contained_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_Contained_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_Contained_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_Contained_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_Contained_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::Contained::Contained (void)
{
  this->optable_ = &tao_CORBA_Contained_optable;
}

// copy ctor
POA_CORBA::Contained::Contained (const Contained& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::Contained::~Contained (void)
{
}

void POA_CORBA::Contained::_get_id_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_id",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->id (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_id",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_id",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Contained::_set_id_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::String_var id;
  if (!(
    (_tao_in >> id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_id",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->id (
        id.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_id",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_id",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::Contained::_get_name_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_name",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->name (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_name",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_name",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Contained::_set_name_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::String_var name;
  if (!(
    (_tao_in >> name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_name",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->name (
        name.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_name",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_name",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::Contained::_get_version_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_version",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->version (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_version",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_version",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Contained::_set_version_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::String_var version;
  if (!(
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_version",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->version (
        version.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_version",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_version",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::Contained::_get_defined_in_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::Container_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_defined_in",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->defined_in (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_defined_in",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_defined_in",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Contained::_get_absolute_name_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::String_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_absolute_name",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->absolute_name (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_absolute_name",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_absolute_name",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Contained::_get_containing_repository_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::Repository_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_containing_repository",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->containing_repository (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_containing_repository",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_containing_repository",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Contained::describe_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::Contained::Description_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->describe (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Contained::move_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *)_tao_object_reference;

  CORBA::Container_var new_container;
  CORBA::String_var new_name;
  CORBA::String_var new_version;
  if (!(
    (_tao_in >> new_container.out ()) &&
    (_tao_in >> new_name.out ()) &&
    (_tao_in >> new_version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "move",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->move (
        new_container.in (),
        new_name.in (),
        new_version.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "move",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "move",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::Contained::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::Contained::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Contained *_tao_impl = (POA_CORBA::Contained *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::Contained::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::Contained::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::Contained::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Contained:1.0";
}

CORBA::Contained*
POA_CORBA::Contained::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::Contained_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_Contained (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::Contained::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_Contained::_tao_thru_poa_collocated_Contained (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_Contained::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_Contained::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


char * POA_CORBA::_tao_thru_poa_collocated_Contained::id  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "id",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->id (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_Contained::id  (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "id",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->id (
      id,
      ACE_TRY_ENV
    );
  return;
}

char * POA_CORBA::_tao_thru_poa_collocated_Contained::name  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "name",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->name (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_Contained::name  (
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "name",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->name (
      name,
      ACE_TRY_ENV
    );
  return;
}

char * POA_CORBA::_tao_thru_poa_collocated_Contained::version  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "version",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->version (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_Contained::version  (
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "version",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->version (
      version,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Container_ptr POA_CORBA::_tao_thru_poa_collocated_Contained::defined_in  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Container_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "defined_in",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->defined_in (
      ACE_TRY_ENV
    );

}

char * POA_CORBA::_tao_thru_poa_collocated_Contained::absolute_name  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::String_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "absolute_name",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->absolute_name (
      ACE_TRY_ENV
    );

}

CORBA::Repository_ptr POA_CORBA::_tao_thru_poa_collocated_Contained::containing_repository  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Repository_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "containing_repository",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->containing_repository (
      ACE_TRY_ENV
    );

}

CORBA::Contained::Description * POA_CORBA::_tao_thru_poa_collocated_Contained::describe  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Contained::Description_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "describe",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->describe (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_Contained::move  (
    CORBA::Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "move",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::Contained_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Contained:1.0"
        )
    )->move (
      new_container,
      new_name,
      new_version,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_Container_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:52 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Container_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Container_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 15,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39,  0,
     39,  0,  0,  0, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39,  0, 20,  5,
     39,  0, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 10, 10, 39, 39, 39, 10,  0, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39,
#else
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
     39, 39, 39, 39, 39, 15, 39,  0, 39,  0,
      0,  0, 39, 39, 39, 39, 39, 39,  0, 20,
      5, 39,  0, 39, 39, 10, 10, 39, 39, 39,
     10,  0, 39, 39, 39, 39, 39, 39,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Container_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 17,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 38,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup", 	&POA_CORBA::Container::lookup_skel},
      {"destroy", 	&POA_CORBA::Container::destroy_skel},
      {"",0},{"",0},{"",0},
      {"lookup_name", 	&POA_CORBA::Container::lookup_name_skel},
      {"create_value", 	&POA_CORBA::Container::create_value_skel},
      {"create_module", 	&POA_CORBA::Container::create_module_skel},
      {"",0},{"",0},
      {"create_interface", 	&POA_CORBA::Container::create_interface_skel},
      {"create_union", 	&POA_CORBA::Container::create_union_skel},
      {"contents", 	&POA_CORBA::Container::contents_skel},
      {"",0},
      {"_is_a",  &POA_CORBA::Container::_is_a_skel},
      {"create_exception", 	&POA_CORBA::Container::create_exception_skel},
      {"create_alias", 	&POA_CORBA::Container::create_alias_skel},
      {"create_struct", 	&POA_CORBA::Container::create_struct_skel},
      {"",0},
      {"create_constant", 	&POA_CORBA::Container::create_constant_skel},
      {"create_value_box", 	&POA_CORBA::Container::create_value_box_skel},
      {"describe_contents", 	&POA_CORBA::Container::describe_contents_skel},
      {"_get_def_kind", 	&POA_CORBA::Container::_get_def_kind_skel},
      {"",0},{"",0},
      {"create_enum", 	&POA_CORBA::Container::create_enum_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_CORBA::Container::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:05:52 */
static TAO_CORBA_Container_Perfect_Hash_OpTable tao_CORBA_Container_optable;

CORBA::Container_ptr _TAO_collocation_POA_CORBA_Container_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::Container_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_Container (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_Container_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_Container_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_Container_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_Container_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_Container_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_Container_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::Container::Container (void)
{
  this->optable_ = &tao_CORBA_Container_optable;
}

// copy ctor
POA_CORBA::Container::Container (const Container& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::Container::~Container (void)
{
}

void POA_CORBA::Container::lookup_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::Contained_var _tao_retval;
  CORBA::String_var search_name;
  if (!(
    (_tao_in >> search_name.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->lookup (
        search_name.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::contents_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::ContainedSeq_var _tao_retval;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "contents",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->contents (
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "contents",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "contents",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::lookup_name_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::ContainedSeq_var _tao_retval;
  CORBA::String_var search_name;
  CORBA::Long levels_to_search;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  if (!(
    (_tao_in >> search_name.out ()) &&
    (_tao_in >> levels_to_search) &&
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup_name",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->lookup_name (
        search_name.in (),
        levels_to_search,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup_name",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup_name",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::describe_contents_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::Container::DescriptionSeq_var _tao_retval;
  CORBA::DefinitionKind limit_type;
  CORBA::Boolean exclude_inherited;
  CORBA::Long max_returned_objs;
  if (!(
    (_tao_in >> limit_type) &&
    (_tao_in >> CORBA::Any::to_boolean (exclude_inherited)) &&
    (_tao_in >> max_returned_objs)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_contents",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->describe_contents (
        limit_type,
        exclude_inherited,
        max_returned_objs,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_contents",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_contents",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_module_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::ModuleDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_module",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_module (
        id.in (),
        name.in (),
        version.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_module",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_module",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_constant_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::ConstantDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var type;
  CORBA::Any value;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_constant",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_constant (
        id.in (),
        name.in (),
        version.in (),
        type.in (),
        value,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_constant",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_constant",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_struct_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::StructDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_struct",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_struct (
        id.in (),
        name.in (),
        version.in (),
        members,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_struct",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_struct",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_union_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::UnionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var discriminator_type;
  CORBA::UnionMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> discriminator_type.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_union",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_union (
        id.in (),
        name.in (),
        version.in (),
        discriminator_type.in (),
        members,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_union",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_union",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_enum_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::EnumDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::EnumMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_enum",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_enum (
        id.in (),
        name.in (),
        version.in (),
        members,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_enum",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_enum",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_alias_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::AliasDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var original_type;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_alias",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_alias (
        id.in (),
        name.in (),
        version.in (),
        original_type.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_alias",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_alias",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_interface_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::InterfaceDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_interface",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_interface (
        id.in (),
        name.in (),
        version.in (),
        base_interfaces,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_interface",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_interface",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::ValueDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::Boolean is_custom;
  CORBA::Boolean is_abstract;
  CORBA::ValueDef_var base_value;
  CORBA::Boolean is_truncatable;
  CORBA::ValueDefSeq abstract_base_values;
  CORBA::InterfaceDef_var supported_interface;
  CORBA::InitializerSeq initializers;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_custom)) &&
    (_tao_in >> CORBA::Any::to_boolean (is_abstract)) &&
    (_tao_in >> base_value.out ()) &&
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable)) &&
    (_tao_in >> abstract_base_values) &&
    (_tao_in >> supported_interface.out ()) &&
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_value (
        id.in (),
        name.in (),
        version.in (),
        is_custom,
        is_abstract,
        base_value.in (),
        is_truncatable,
        abstract_base_values,
        supported_interface.in (),
        initializers,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_value_box_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::ValueBoxDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var original_type_def;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value_box",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_value_box (
        id.in (),
        name.in (),
        version.in (),
        original_type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value_box",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value_box",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::create_exception_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *)_tao_object_reference;

  CORBA::ExceptionDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::StructMemberSeq members;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_exception",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_exception (
        id.in (),
        name.in (),
        version.in (),
        members,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_exception",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_exception",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Container::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::Container::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Container *_tao_impl = (POA_CORBA::Container *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::Container::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::Container::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::Container::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Container:1.0";
}

CORBA::Container*
POA_CORBA::Container::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::Container_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_Container (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::Container::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_Container::_tao_thru_poa_collocated_Container (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_Container::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_Container::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::Contained_ptr POA_CORBA::_tao_thru_poa_collocated_Container::lookup  (
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "lookup",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->lookup (
      search_name,
      ACE_TRY_ENV
    );

}

CORBA::ContainedSeq * POA_CORBA::_tao_thru_poa_collocated_Container::contents  (
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "contents",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->contents (
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

}

CORBA::ContainedSeq * POA_CORBA::_tao_thru_poa_collocated_Container::lookup_name  (
    const char * search_name,
    CORBA::Long levels_to_search,
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ContainedSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "lookup_name",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->lookup_name (
      search_name,
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );

}

CORBA::Container::DescriptionSeq * POA_CORBA::_tao_thru_poa_collocated_Container::describe_contents  (
    CORBA::DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Container::DescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "describe_contents",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->describe_contents (
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );

}

CORBA::ModuleDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_module  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ModuleDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_module",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_module (
      id,
      name,
      version,
      ACE_TRY_ENV
    );

}

CORBA::ConstantDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_constant  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ConstantDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_constant",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_constant (
      id,
      name,
      version,
      type,
      value,
      ACE_TRY_ENV
    );

}

CORBA::StructDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_struct  (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::StructDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_struct",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_struct (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}

CORBA::UnionDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_union  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr discriminator_type,
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::UnionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_union",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_union (
      id,
      name,
      version,
      discriminator_type,
      members,
      ACE_TRY_ENV
    );

}

CORBA::EnumDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_enum  (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::EnumDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_enum",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_enum (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}

CORBA::AliasDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_alias  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AliasDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_alias",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_alias (
      id,
      name,
      version,
      original_type,
      ACE_TRY_ENV
    );

}

CORBA::InterfaceDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_interface  (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_interface",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_interface (
      id,
      name,
      version,
      base_interfaces,
      ACE_TRY_ENV
    );

}

CORBA::ValueDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_value  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    CORBA::ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const CORBA::ValueDefSeq & abstract_base_values,
    CORBA::InterfaceDef_ptr supported_interface,
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_value",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_value (
      id,
      name,
      version,
      is_custom,
      is_abstract,
      base_value,
      is_truncatable,
      abstract_base_values,
      supported_interface,
      initializers,
      ACE_TRY_ENV
    );

}

CORBA::ValueBoxDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_value_box  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueBoxDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_value_box",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_value_box (
      id,
      name,
      version,
      original_type_def,
      ACE_TRY_ENV
    );

}

CORBA::ExceptionDef_ptr POA_CORBA::_tao_thru_poa_collocated_Container::create_exception  (
    const char * id,
    const char * name,
    const char * version,
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExceptionDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_exception",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Container_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Container:1.0"
        )
    )->create_exception (
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );

}



class TAO_CORBA_IDLType_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_IDLType_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_IDLType_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_IDLType_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 5,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::IDLType::_is_a_skel},
      {"",0},
      {"destroy", 	&POA_CORBA::IDLType::destroy_skel},
      {"",0},
      {"_get_type", 	&POA_CORBA::IDLType::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind", 	&POA_CORBA::IDLType::_get_def_kind_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"_non_existent",  &POA_CORBA::IDLType::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_IDLType_Perfect_Hash_OpTable tao_CORBA_IDLType_optable;

CORBA::IDLType_ptr _TAO_collocation_POA_CORBA_IDLType_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::IDLType_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_IDLType (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_IDLType_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_IDLType_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_IDLType_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_IDLType_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_IDLType_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_IDLType_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::IDLType::IDLType (void)
{
  this->optable_ = &tao_CORBA_IDLType_optable;
}

// copy ctor
POA_CORBA::IDLType::IDLType (const IDLType& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::IDLType::~IDLType (void)
{
}

void POA_CORBA::IDLType::_get_type_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::IDLType *_tao_impl = (POA_CORBA::IDLType *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->type (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::IDLType::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::IDLType *_tao_impl = (POA_CORBA::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::IDLType::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::IDLType *_tao_impl = (POA_CORBA::IDLType *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::IDLType::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::IDLType::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::IDLType::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IDLType:1.0";
}

CORBA::IDLType*
POA_CORBA::IDLType::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::IDLType_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_IDLType (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::IDLType::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_IDLType::_tao_thru_poa_collocated_IDLType (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_IDLType::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IDLType:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_IDLType::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IDLType:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_IDLType::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::IDLType_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/IDLType:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}



class TAO_CORBA_Repository_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_Repository_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_Repository_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 25,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 10,
     66,  0, 23, 10, 66,  5, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66,  0,  0, 15,
     66,  0, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 25,  0, 66, 66, 66,  0,  0, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66,
#else
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 66, 66, 66, 66, 66,
     66, 66, 66, 66, 66, 25, 66, 10, 66,  0,
     23, 10, 66,  5, 66, 66, 66, 66,  0,  0,
     15, 66,  0, 66, 66, 25,  0, 66, 66, 66,
      0,  0, 66, 66, 66, 66, 66, 66,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_Repository_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 25,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 17,
      MIN_HASH_VALUE = 6,
      MAX_HASH_VALUE = 65,
      HASH_VALUE_RANGE = 60,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"lookup", 	&POA_CORBA::Repository::lookup_skel},
      {"",0},{"",0},{"",0},{"",0},
      {"create_enum", 	&POA_CORBA::Repository::create_enum_skel},
      {"create_array", 	&POA_CORBA::Repository::create_array_skel},
      {"create_struct", 	&POA_CORBA::Repository::create_struct_skel},
      {"",0},
      {"create_constant", 	&POA_CORBA::Repository::create_constant_skel},
      {"create_value_box", 	&POA_CORBA::Repository::create_value_box_skel},
      {"",0},
      {"create_string", 	&POA_CORBA::Repository::create_string_skel},
      {"create_wstring", 	&POA_CORBA::Repository::create_wstring_skel},
      {"",0},
      {"lookup_name", 	&POA_CORBA::Repository::lookup_name_skel},
      {"create_value", 	&POA_CORBA::Repository::create_value_skel},
      {"create_module", 	&POA_CORBA::Repository::create_module_skel},
      {"",0},
      {"create_sequence", 	&POA_CORBA::Repository::create_sequence_skel},
      {"create_interface", 	&POA_CORBA::Repository::create_interface_skel},
      {"create_union", 	&POA_CORBA::Repository::create_union_skel},
      {"get_primitive", 	&POA_CORBA::Repository::get_primitive_skel},
      {"",0},
      {"destroy", 	&POA_CORBA::Repository::destroy_skel},
      {"create_exception", 	&POA_CORBA::Repository::create_exception_skel},
      {"lookup_id", 	&POA_CORBA::Repository::lookup_id_skel},
      {"contents", 	&POA_CORBA::Repository::contents_skel},
      {"",0},
      {"create_fixed", 	&POA_CORBA::Repository::create_fixed_skel},
      {"",0},
      {"create_alias", 	&POA_CORBA::Repository::create_alias_skel},
      {"_non_existent",  &POA_CORBA::Repository::_non_existent_skel},
      {"",0},
      {"_is_a",  &POA_CORBA::Repository::_is_a_skel},
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},{"",0},
      {"",0},{"",0},
      {"_get_def_kind", 	&POA_CORBA::Repository::_get_def_kind_skel},
      {"",0},{"",0},{"",0},
      {"describe_contents", 	&POA_CORBA::Repository::describe_contents_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_Repository_Perfect_Hash_OpTable tao_CORBA_Repository_optable;

CORBA::Repository_ptr _TAO_collocation_POA_CORBA_Repository_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::Repository_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_Repository (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_Repository_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_Repository_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_Repository_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_Repository_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_Repository_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_Repository_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::Repository::Repository (void)
{
  this->optable_ = &tao_CORBA_Repository_optable;
}

// copy ctor
POA_CORBA::Repository::Repository (const Repository& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::Repository::~Repository (void)
{
}

void POA_CORBA::Repository::lookup_id_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *)_tao_object_reference;

  CORBA::Contained_var _tao_retval;
  CORBA::String_var search_id;
  if (!(
    (_tao_in >> search_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup_id",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->lookup_id (
        search_id.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup_id",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "lookup_id",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Repository::get_primitive_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *)_tao_object_reference;

  CORBA::PrimitiveDef_var _tao_retval;
  CORBA::PrimitiveKind kind;
  if (!(
    (_tao_in >> kind)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "get_primitive",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->get_primitive (
        kind,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "get_primitive",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "get_primitive",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Repository::create_string_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *)_tao_object_reference;

  CORBA::StringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_string",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_string (
        bound,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_string",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_string",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Repository::create_wstring_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *)_tao_object_reference;

  CORBA::WstringDef_var _tao_retval;
  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_wstring",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_wstring (
        bound,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_wstring",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_wstring",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Repository::create_sequence_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *)_tao_object_reference;

  CORBA::SequenceDef_var _tao_retval;
  CORBA::ULong bound;
  CORBA::IDLType_var element_type;
  if (!(
    (_tao_in >> bound) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_sequence",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_sequence (
        bound,
        element_type.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_sequence",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_sequence",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Repository::create_array_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *)_tao_object_reference;

  CORBA::ArrayDef_var _tao_retval;
  CORBA::ULong length;
  CORBA::IDLType_var element_type;
  if (!(
    (_tao_in >> length) &&
    (_tao_in >> element_type.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_array",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_array (
        length,
        element_type.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_array",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_array",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Repository::create_fixed_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *)_tao_object_reference;

  CORBA::FixedDef_var _tao_retval;
  CORBA::UShort digits;
  CORBA::Short scale;
  if (!(
    (_tao_in >> digits) &&
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_fixed",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_fixed (
        digits,
        scale,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_fixed",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_fixed",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::Repository::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::Repository::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::Repository *_tao_impl = (POA_CORBA::Repository *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::Repository::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::Repository::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Repository:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Repository_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::Repository::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/Repository:1.0";
}

CORBA::Repository*
POA_CORBA::Repository::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::Repository_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_Repository (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::Repository::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_Repository::_tao_thru_poa_collocated_Repository (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_Repository::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_Repository::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::Contained_ptr POA_CORBA::_tao_thru_poa_collocated_Repository::lookup_id  (
    const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Contained_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "lookup_id",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->lookup_id (
      search_id,
      ACE_TRY_ENV
    );

}

CORBA::PrimitiveDef_ptr POA_CORBA::_tao_thru_poa_collocated_Repository::get_primitive  (
    CORBA::PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::PrimitiveDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "get_primitive",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->get_primitive (
      kind,
      ACE_TRY_ENV
    );

}

CORBA::StringDef_ptr POA_CORBA::_tao_thru_poa_collocated_Repository::create_string  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::StringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_string",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_string (
      bound,
      ACE_TRY_ENV
    );

}

CORBA::WstringDef_ptr POA_CORBA::_tao_thru_poa_collocated_Repository::create_wstring  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::WstringDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_wstring",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_wstring (
      bound,
      ACE_TRY_ENV
    );

}

CORBA::SequenceDef_ptr POA_CORBA::_tao_thru_poa_collocated_Repository::create_sequence  (
    CORBA::ULong bound,
    CORBA::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::SequenceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_sequence",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_sequence (
      bound,
      element_type,
      ACE_TRY_ENV
    );

}

CORBA::ArrayDef_ptr POA_CORBA::_tao_thru_poa_collocated_Repository::create_array  (
    CORBA::ULong length,
    CORBA::IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ArrayDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_array",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_array (
      length,
      element_type,
      ACE_TRY_ENV
    );

}

CORBA::FixedDef_ptr POA_CORBA::_tao_thru_poa_collocated_Repository::create_fixed  (
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::FixedDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_fixed",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::Repository_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/Repository:1.0"
        )
    )->create_fixed (
      digits,
      scale,
      ACE_TRY_ENV
    );

}



class TAO_CORBA_ModuleDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ModuleDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61,  0,
     61, 20,  3,  0, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 10, 15,  5,
     61, 10, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 15, 25, 61, 61, 61, 15,  5, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61,
#else
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61, 61, 61, 61, 61, 61,
     61, 61, 61, 61, 61,  0, 61,  0, 61, 20,
      3,  0, 61, 61, 61, 61, 61, 61, 10, 15,
      5, 61, 10, 61, 61, 15, 25, 61, 61, 61,
     15,  5, 61, 61, 61, 61, 61, 61,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ModuleDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 29,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 60,
      HASH_VALUE_RANGE = 56,
      DUPLICATES = 4
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::ModuleDef::_is_a_skel},
      {"_get_name", 	&POA_CORBA::ModuleDef::_get_name_skel},
      {"_set_name", 	&POA_CORBA::ModuleDef::_set_name_skel},
      {"_get_id", 	&POA_CORBA::ModuleDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::ModuleDef::_set_id_skel},
      {"describe", 	&POA_CORBA::ModuleDef::describe_skel},
      {"destroy", 	&POA_CORBA::ModuleDef::destroy_skel},
      {"_get_def_kind", 	&POA_CORBA::ModuleDef::_get_def_kind_skel},
      {"_get_version", 	&POA_CORBA::ModuleDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::ModuleDef::_set_version_skel},
      {"_get_absolute_name", 	&POA_CORBA::ModuleDef::_get_absolute_name_skel},
      {"move", 	&POA_CORBA::ModuleDef::move_skel},
      {"_get_defined_in", 	&POA_CORBA::ModuleDef::_get_defined_in_skel},
      {"lookup_name", 	&POA_CORBA::ModuleDef::lookup_name_skel},
      {"lookup", 	&POA_CORBA::ModuleDef::lookup_skel},
      {"_get_containing_repository", 	&POA_CORBA::ModuleDef::_get_containing_repository_skel},
      {"create_value", 	&POA_CORBA::ModuleDef::create_value_skel},
      {"create_module", 	&POA_CORBA::ModuleDef::create_module_skel},
      {"describe_contents", 	&POA_CORBA::ModuleDef::describe_contents_skel},
      {"create_interface", 	&POA_CORBA::ModuleDef::create_interface_skel},
      {"create_union", 	&POA_CORBA::ModuleDef::create_union_skel},
      {"_non_existent",  &POA_CORBA::ModuleDef::_non_existent_skel},
      {"create_exception", 	&POA_CORBA::ModuleDef::create_exception_skel},
      {"contents", 	&POA_CORBA::ModuleDef::contents_skel},
      {"create_enum", 	&POA_CORBA::ModuleDef::create_enum_skel},
      {"create_alias", 	&POA_CORBA::ModuleDef::create_alias_skel},
      {"create_value_box", 	&POA_CORBA::ModuleDef::create_value_box_skel},
      {"create_struct", 	&POA_CORBA::ModuleDef::create_struct_skel},
      {"create_constant", 	&POA_CORBA::ModuleDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -2,   5,  -1,  -8,  -2, -66, -63,  10,  -1, -13, 
       -2,  11,  12, -64,  15,  16,  17,  18,  -1,  -1,  -1,  -1,  19,  -1, 
       -1,  -1,  -1,  20,  21,  22,  -1,  23,  24,  25,  26,  -1,  -1,  27, 
       -1,  28,  -1,  -1,  29,  30,  -1,  -1,  -1,  31,  -1,  -1,  -1,  -1, 
       -1,  -1,  32,  -1,  33, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_ModuleDef_Perfect_Hash_OpTable tao_CORBA_ModuleDef_optable;

CORBA::ModuleDef_ptr _TAO_collocation_POA_CORBA_ModuleDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::ModuleDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_ModuleDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_ModuleDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_ModuleDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_ModuleDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_ModuleDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_ModuleDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_ModuleDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::ModuleDef::ModuleDef (void)
{
  this->optable_ = &tao_CORBA_ModuleDef_optable;
}

// copy ctor
POA_CORBA::ModuleDef::ModuleDef (const ModuleDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ModuleDef::~ModuleDef (void)
{
}

void POA_CORBA::ModuleDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ModuleDef *_tao_impl = (POA_CORBA::ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ModuleDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ModuleDef *_tao_impl = (POA_CORBA::ModuleDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ModuleDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ModuleDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ModuleDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ModuleDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ModuleDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ModuleDef:1.0";
}

CORBA::ModuleDef*
POA_CORBA::ModuleDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::ModuleDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_ModuleDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::ModuleDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_ModuleDef::_tao_thru_poa_collocated_ModuleDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ModuleDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ModuleDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ModuleDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ModuleDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ModuleDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ModuleDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_CORBA_ConstantDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ConstantDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ConstantDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::ConstantDef::move_skel},
      {"_is_a",  &POA_CORBA::ConstantDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::ConstantDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::ConstantDef::_set_id_skel},
      {"describe", 	&POA_CORBA::ConstantDef::describe_skel},
      {"_get_type", 	&POA_CORBA::ConstantDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::ConstantDef::_set_name_skel},
      {"_get_name", 	&POA_CORBA::ConstantDef::_get_name_skel},
      {"_get_value", 	&POA_CORBA::ConstantDef::_get_value_skel},
      {"_set_value", 	&POA_CORBA::ConstantDef::_set_value_skel},
      {"_get_version", 	&POA_CORBA::ConstantDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::ConstantDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::ConstantDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::ConstantDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::ConstantDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::ConstantDef::_get_absolute_name_skel},
      {"_get_type_def", 	&POA_CORBA::ConstantDef::_get_type_def_skel},
      {"_set_type_def", 	&POA_CORBA::ConstantDef::_set_type_def_skel},
      {"_non_existent",  &POA_CORBA::ConstantDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::ConstantDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46, -46,  -1, -46,  16, 
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1, 
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_ConstantDef_Perfect_Hash_OpTable tao_CORBA_ConstantDef_optable;

CORBA::ConstantDef_ptr _TAO_collocation_POA_CORBA_ConstantDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::ConstantDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_ConstantDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_ConstantDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_ConstantDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_ConstantDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_ConstantDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_ConstantDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_ConstantDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::ConstantDef::ConstantDef (void)
{
  this->optable_ = &tao_CORBA_ConstantDef_optable;
}

// copy ctor
POA_CORBA::ConstantDef::ConstantDef (const ConstantDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ConstantDef::~ConstantDef (void)
{
}

void POA_CORBA::ConstantDef::_get_type_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ConstantDef *_tao_impl = (POA_CORBA::ConstantDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->type (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ConstantDef::_get_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ConstantDef *_tao_impl = (POA_CORBA::ConstantDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->type_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ConstantDef::_set_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ConstantDef *_tao_impl = (POA_CORBA::ConstantDef *)_tao_object_reference;

  CORBA::IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->type_def (
        type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ConstantDef::_get_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ConstantDef *_tao_impl = (POA_CORBA::ConstantDef *)_tao_object_reference;

  CORBA::Any_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->value (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ConstantDef::_set_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ConstantDef *_tao_impl = (POA_CORBA::ConstantDef *)_tao_object_reference;

  CORBA::Any value;
  if (!(
    (_tao_in >> value)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->value (
        value,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ConstantDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ConstantDef *_tao_impl = (POA_CORBA::ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ConstantDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ConstantDef *_tao_impl = (POA_CORBA::ConstantDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ConstantDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ConstantDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ConstantDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ConstantDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ConstantDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ConstantDef:1.0";
}

CORBA::ConstantDef*
POA_CORBA::ConstantDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::ConstantDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_ConstantDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::ConstantDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_ConstantDef::_tao_thru_poa_collocated_ConstantDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ConstantDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ConstantDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_ConstantDef::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}

CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_ConstantDef::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->type_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ConstantDef::type_def  (
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->type_def (
      type_def,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Any * POA_CORBA::_tao_thru_poa_collocated_ConstantDef::value  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Any_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "value",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->value (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ConstantDef::value  (
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "value",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ConstantDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ConstantDef:1.0"
        )
    )->value (
      value,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_TypedefDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_TypedefDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_TypedefDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 16,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 5
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::TypedefDef::move_skel},
      {"_is_a",  &POA_CORBA::TypedefDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::TypedefDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::TypedefDef::_set_id_skel},
      {"describe", 	&POA_CORBA::TypedefDef::describe_skel},
      {"_get_name", 	&POA_CORBA::TypedefDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::TypedefDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::TypedefDef::_set_name_skel},
      {"_get_version", 	&POA_CORBA::TypedefDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::TypedefDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::TypedefDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::TypedefDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::TypedefDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::TypedefDef::_get_absolute_name_skel},
      {"_non_existent",  &POA_CORBA::TypedefDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::TypedefDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14, 
       -1,  15,  -1,  16,  17,  -1,  -1,  -1,  -1,  18,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  19, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_TypedefDef_Perfect_Hash_OpTable tao_CORBA_TypedefDef_optable;

CORBA::TypedefDef_ptr _TAO_collocation_POA_CORBA_TypedefDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::TypedefDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_TypedefDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_TypedefDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_TypedefDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_TypedefDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_TypedefDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_TypedefDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_TypedefDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::TypedefDef::TypedefDef (void)
{
  this->optable_ = &tao_CORBA_TypedefDef_optable;
}

// copy ctor
POA_CORBA::TypedefDef::TypedefDef (const TypedefDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::TypedefDef::~TypedefDef (void)
{
}

void POA_CORBA::TypedefDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::TypedefDef *_tao_impl = (POA_CORBA::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::TypedefDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::TypedefDef *_tao_impl = (POA_CORBA::TypedefDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::TypedefDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::TypedefDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::TypedefDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/TypedefDef:1.0";
}

CORBA::TypedefDef*
POA_CORBA::TypedefDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::TypedefDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_TypedefDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::TypedefDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_TypedefDef::_tao_thru_poa_collocated_TypedefDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_TypedefDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::TypedefDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_TypedefDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::TypedefDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/TypedefDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}




class TAO_CORBA_StructDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_StructDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StructDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58,  0,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58,  0,
     58, 20,  3,  0, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 10, 10, 10,
     58, 10, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 25, 15, 58, 58, 58, 15,  5, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58,
#else
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
     58, 58, 58, 58, 58,  0, 58,  0, 58, 20,
      3,  0, 58, 58, 58, 58, 58, 58, 10, 10,
     10, 58, 10, 58, 58, 25, 15, 58, 58, 58,
     15,  5, 58, 58, 58, 58, 58, 58,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_StructDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 32,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 57,
      HASH_VALUE_RANGE = 53,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::StructDef::_is_a_skel},
      {"_get_name", 	&POA_CORBA::StructDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::StructDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::StructDef::_set_name_skel},
      {"_get_id", 	&POA_CORBA::StructDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::StructDef::_set_id_skel},
      {"describe", 	&POA_CORBA::StructDef::describe_skel},
      {"move", 	&POA_CORBA::StructDef::move_skel},
      {"destroy", 	&POA_CORBA::StructDef::destroy_skel},
      {"_get_def_kind", 	&POA_CORBA::StructDef::_get_def_kind_skel},
      {"_get_absolute_name", 	&POA_CORBA::StructDef::_get_absolute_name_skel},
      {"lookup_name", 	&POA_CORBA::StructDef::lookup_name_skel},
      {"_get_version", 	&POA_CORBA::StructDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::StructDef::_set_version_skel},
      {"_get_defined_in", 	&POA_CORBA::StructDef::_get_defined_in_skel},
      {"lookup", 	&POA_CORBA::StructDef::lookup_skel},
      {"_non_existent",  &POA_CORBA::StructDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::StructDef::_get_containing_repository_skel},
      {"create_value", 	&POA_CORBA::StructDef::create_value_skel},
      {"create_module", 	&POA_CORBA::StructDef::create_module_skel},
      {"create_interface", 	&POA_CORBA::StructDef::create_interface_skel},
      {"_get_members", 	&POA_CORBA::StructDef::_get_members_skel},
      {"_set_members", 	&POA_CORBA::StructDef::_set_members_skel},
      {"create_enum", 	&POA_CORBA::StructDef::create_enum_skel},
      {"create_union", 	&POA_CORBA::StructDef::create_union_skel},
      {"describe_contents", 	&POA_CORBA::StructDef::describe_contents_skel},
      {"create_exception", 	&POA_CORBA::StructDef::create_exception_skel},
      {"create_struct", 	&POA_CORBA::StructDef::create_struct_skel},
      {"create_constant", 	&POA_CORBA::StructDef::create_constant_skel},
      {"create_value_box", 	&POA_CORBA::StructDef::create_value_box_skel},
      {"contents", 	&POA_CORBA::StructDef::contents_skel},
      {"create_alias", 	&POA_CORBA::StructDef::create_alias_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -3,   5,  -1,  -9,  -2, -63, -60,  11,  -1,  -1, 
       12,  13,  14,  -1,  15, -17,  -2,  16, -60,  -1,  -1,  19,  20,  -1, 
       21,  -1,  -1,  22,  23,  24, -26,  -2,  25, -60,  -1,  -1,  -1,  28, 
       29,  -1,  -1,  30,  31,  -1,  32,  -1,  33,  34,  -1,  35,  -1,  -1, 
       -1,  36, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_StructDef_Perfect_Hash_OpTable tao_CORBA_StructDef_optable;

CORBA::StructDef_ptr _TAO_collocation_POA_CORBA_StructDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::StructDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_StructDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_StructDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_StructDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_StructDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_StructDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_StructDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_StructDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::StructDef::StructDef (void)
{
  this->optable_ = &tao_CORBA_StructDef_optable;
}

// copy ctor
POA_CORBA::StructDef::StructDef (const StructDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::StructDef::~StructDef (void)
{
}

void POA_CORBA::StructDef::_get_members_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::StructDef *_tao_impl = (POA_CORBA::StructDef *)_tao_object_reference;

  CORBA::StructMemberSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->members (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::StructDef::_set_members_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::StructDef *_tao_impl = (POA_CORBA::StructDef *)_tao_object_reference;

  CORBA::StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
        members,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::StructDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::StructDef *_tao_impl = (POA_CORBA::StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::StructDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::StructDef *_tao_impl = (POA_CORBA::StructDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::StructDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::StructDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/StructDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::StructDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::StructDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StructDef:1.0";
}

CORBA::StructDef*
POA_CORBA::StructDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::StructDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_StructDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::StructDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_StructDef::_tao_thru_poa_collocated_StructDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_StructDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StructDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_StructDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StructDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::StructMemberSeq * POA_CORBA::_tao_thru_poa_collocated_StructDef::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StructDef:1.0"
        )
    )->members (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_StructDef::members  (
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::StructDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StructDef:1.0"
        )
    )->members (
      members,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_UnionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_UnionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68,  0,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68,  0,
     68,  8, 20,  0, 10, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68,  0,  0, 10,
     68,  0, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 30, 30, 68, 68, 68,  5,  5, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68,
#else
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
     68, 68, 68, 68, 68,  0, 68,  0, 68,  8,
     20,  0, 10, 68, 68, 68, 68, 68,  0,  0,
     10, 68,  0, 68, 68, 30, 30, 68, 68, 68,
      5,  5, 68, 68, 68, 68, 68, 68,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_UnionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 35,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 27,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 67,
      HASH_VALUE_RANGE = 64,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::UnionDef::move_skel},
      {"_is_a",  &POA_CORBA::UnionDef::_is_a_skel},
      {"lookup", 	&POA_CORBA::UnionDef::lookup_skel},
      {"_get_name", 	&POA_CORBA::UnionDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::UnionDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::UnionDef::_set_name_skel},
      {"lookup_name", 	&POA_CORBA::UnionDef::lookup_name_skel},
      {"_get_absolute_name", 	&POA_CORBA::UnionDef::_get_absolute_name_skel},
      {"create_enum", 	&POA_CORBA::UnionDef::create_enum_skel},
      {"create_value", 	&POA_CORBA::UnionDef::create_value_skel},
      {"create_module", 	&POA_CORBA::UnionDef::create_module_skel},
      {"_get_version", 	&POA_CORBA::UnionDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::UnionDef::_set_version_skel},
      {"_get_discriminator_type", 	&POA_CORBA::UnionDef::_get_discriminator_type_skel},
      {"create_interface", 	&POA_CORBA::UnionDef::create_interface_skel},
      {"_get_defined_in", 	&POA_CORBA::UnionDef::_get_defined_in_skel},
      {"_get_id", 	&POA_CORBA::UnionDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::UnionDef::_set_id_skel},
      {"describe", 	&POA_CORBA::UnionDef::describe_skel},
      {"create_value_box", 	&POA_CORBA::UnionDef::create_value_box_skel},
      {"create_union", 	&POA_CORBA::UnionDef::create_union_skel},
      {"_get_containing_repository", 	&POA_CORBA::UnionDef::_get_containing_repository_skel},
      {"destroy", 	&POA_CORBA::UnionDef::destroy_skel},
      {"_get_def_kind", 	&POA_CORBA::UnionDef::_get_def_kind_skel},
      {"create_exception", 	&POA_CORBA::UnionDef::create_exception_skel},
      {"_get_discriminator_type_def", 	&POA_CORBA::UnionDef::_get_discriminator_type_def_skel},
      {"_set_discriminator_type_def", 	&POA_CORBA::UnionDef::_set_discriminator_type_def_skel},
      {"_get_members", 	&POA_CORBA::UnionDef::_get_members_skel},
      {"_set_members", 	&POA_CORBA::UnionDef::_set_members_skel},
      {"_non_existent",  &POA_CORBA::UnionDef::_non_existent_skel},
      {"contents", 	&POA_CORBA::UnionDef::contents_skel},
      {"create_alias", 	&POA_CORBA::UnionDef::create_alias_skel},
      {"create_struct", 	&POA_CORBA::UnionDef::create_struct_skel},
      {"create_constant", 	&POA_CORBA::UnionDef::create_constant_skel},
      {"describe_contents", 	&POA_CORBA::UnionDef::describe_contents_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -69,  -1,  10,  -1,  -1, 
      -15,  -2, -20,  -2,  11,  12,  13,  14, -75,  17,  18,  19,  -1, -78, 
       22,  23,  24,  25,  26,  27,  28, -29,  -2, -69,  -1,  -1, -31,  -2, 
      -69,  33,  -1,  -1,  34,  -1,  -1,  -1,  35,  36,  -1,  37,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  38, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_UnionDef_Perfect_Hash_OpTable tao_CORBA_UnionDef_optable;

CORBA::UnionDef_ptr _TAO_collocation_POA_CORBA_UnionDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::UnionDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_UnionDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_UnionDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_UnionDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_UnionDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_UnionDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_UnionDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_UnionDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::UnionDef::UnionDef (void)
{
  this->optable_ = &tao_CORBA_UnionDef_optable;
}

// copy ctor
POA_CORBA::UnionDef::UnionDef (const UnionDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::UnionDef::~UnionDef (void)
{
}

void POA_CORBA::UnionDef::_get_discriminator_type_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::UnionDef *_tao_impl = (POA_CORBA::UnionDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_discriminator_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->discriminator_type (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_discriminator_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_discriminator_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::UnionDef::_get_discriminator_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::UnionDef *_tao_impl = (POA_CORBA::UnionDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_discriminator_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->discriminator_type_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_discriminator_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_discriminator_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::UnionDef::_set_discriminator_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::UnionDef *_tao_impl = (POA_CORBA::UnionDef *)_tao_object_reference;

  CORBA::IDLType_var discriminator_type_def;
  if (!(
    (_tao_in >> discriminator_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_discriminator_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->discriminator_type_def (
        discriminator_type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_discriminator_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_discriminator_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::UnionDef::_get_members_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::UnionDef *_tao_impl = (POA_CORBA::UnionDef *)_tao_object_reference;

  CORBA::UnionMemberSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->members (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::UnionDef::_set_members_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::UnionDef *_tao_impl = (POA_CORBA::UnionDef *)_tao_object_reference;

  CORBA::UnionMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
        members,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::UnionDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::UnionDef *_tao_impl = (POA_CORBA::UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::UnionDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::UnionDef *_tao_impl = (POA_CORBA::UnionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::UnionDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::UnionDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/UnionDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::UnionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::UnionDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/UnionDef:1.0";
}

CORBA::UnionDef*
POA_CORBA::UnionDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::UnionDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_UnionDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::UnionDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_UnionDef::_tao_thru_poa_collocated_UnionDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_UnionDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_UnionDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_UnionDef::discriminator_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "discriminator_type",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->discriminator_type (
      ACE_TRY_ENV
    );

}

CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_UnionDef::discriminator_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "discriminator_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->discriminator_type_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_UnionDef::discriminator_type_def  (
    CORBA::IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "discriminator_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->discriminator_type_def (
      discriminator_type_def,
      ACE_TRY_ENV
    );
  return;
}

CORBA::UnionMemberSeq * POA_CORBA::_tao_thru_poa_collocated_UnionDef::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::UnionMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->members (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_UnionDef::members  (
    const CORBA::UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::UnionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/UnionDef:1.0"
        )
    )->members (
      members,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_EnumDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_EnumDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 10, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 37, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 10, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_EnumDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::EnumDef::move_skel},
      {"_is_a",  &POA_CORBA::EnumDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::EnumDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::EnumDef::_set_id_skel},
      {"describe", 	&POA_CORBA::EnumDef::describe_skel},
      {"_get_name", 	&POA_CORBA::EnumDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::EnumDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::EnumDef::_set_name_skel},
      {"_get_version", 	&POA_CORBA::EnumDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::EnumDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::EnumDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::EnumDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::EnumDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::EnumDef::_get_absolute_name_skel},
      {"_get_members", 	&POA_CORBA::EnumDef::_get_members_skel},
      {"_set_members", 	&POA_CORBA::EnumDef::_set_members_skel},
      {"_non_existent",  &POA_CORBA::EnumDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::EnumDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14, 
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_EnumDef_Perfect_Hash_OpTable tao_CORBA_EnumDef_optable;

CORBA::EnumDef_ptr _TAO_collocation_POA_CORBA_EnumDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::EnumDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_EnumDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_EnumDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_EnumDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_EnumDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_EnumDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_EnumDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_EnumDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::EnumDef::EnumDef (void)
{
  this->optable_ = &tao_CORBA_EnumDef_optable;
}

// copy ctor
POA_CORBA::EnumDef::EnumDef (const EnumDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::EnumDef::~EnumDef (void)
{
}

void POA_CORBA::EnumDef::_get_members_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::EnumDef *_tao_impl = (POA_CORBA::EnumDef *)_tao_object_reference;

  CORBA::EnumMemberSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->members (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::EnumDef::_set_members_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::EnumDef *_tao_impl = (POA_CORBA::EnumDef *)_tao_object_reference;

  CORBA::EnumMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
        members,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::EnumDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::EnumDef *_tao_impl = (POA_CORBA::EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::EnumDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::EnumDef *_tao_impl = (POA_CORBA::EnumDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::EnumDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::EnumDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/EnumDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::EnumDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::EnumDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/EnumDef:1.0";
}

CORBA::EnumDef*
POA_CORBA::EnumDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::EnumDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_EnumDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::EnumDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_EnumDef::_tao_thru_poa_collocated_EnumDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_EnumDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/EnumDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_EnumDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/EnumDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::EnumMemberSeq * POA_CORBA::_tao_thru_poa_collocated_EnumDef::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::EnumMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/EnumDef:1.0"
        )
    )->members (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_EnumDef::members  (
    const CORBA::EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::EnumDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/EnumDef:1.0"
        )
    )->members (
      members,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_AliasDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_AliasDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0,  0, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 10, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0,  0, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 10, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_AliasDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 18,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::AliasDef::move_skel},
      {"_is_a",  &POA_CORBA::AliasDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::AliasDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::AliasDef::_set_id_skel},
      {"describe", 	&POA_CORBA::AliasDef::describe_skel},
      {"_get_name", 	&POA_CORBA::AliasDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::AliasDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::AliasDef::_set_name_skel},
      {"_get_version", 	&POA_CORBA::AliasDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::AliasDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::AliasDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::AliasDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::AliasDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::AliasDef::_get_absolute_name_skel},
      {"_get_original_type_def", 	&POA_CORBA::AliasDef::_get_original_type_def_skel},
      {"_set_original_type_def", 	&POA_CORBA::AliasDef::_set_original_type_def_skel},
      {"_non_existent",  &POA_CORBA::AliasDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::AliasDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -3,   4,   5,  -1, -43,   8, -43, -12,  -2, -38,  14, 
       -1,  15,  -1,  16,  17,  -1, -18,  -2, -38,  20,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  21, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_AliasDef_Perfect_Hash_OpTable tao_CORBA_AliasDef_optable;

CORBA::AliasDef_ptr _TAO_collocation_POA_CORBA_AliasDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::AliasDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_AliasDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_AliasDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_AliasDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_AliasDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_AliasDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_AliasDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_AliasDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::AliasDef::AliasDef (void)
{
  this->optable_ = &tao_CORBA_AliasDef_optable;
}

// copy ctor
POA_CORBA::AliasDef::AliasDef (const AliasDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,TypedefDef) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::AliasDef::~AliasDef (void)
{
}

void POA_CORBA::AliasDef::_get_original_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::AliasDef *_tao_impl = (POA_CORBA::AliasDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_original_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->original_type_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_original_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_original_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::AliasDef::_set_original_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::AliasDef *_tao_impl = (POA_CORBA::AliasDef *)_tao_object_reference;

  CORBA::IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_original_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->original_type_def (
        original_type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_original_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_original_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::AliasDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::AliasDef *_tao_impl = (POA_CORBA::AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::AliasDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::AliasDef *_tao_impl = (POA_CORBA::AliasDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::AliasDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::AliasDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/AliasDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::AliasDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/TypedefDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::TypedefDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::AliasDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AliasDef:1.0";
}

CORBA::AliasDef*
POA_CORBA::AliasDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::AliasDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_AliasDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::AliasDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_AliasDef::_tao_thru_poa_collocated_AliasDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_TypedefDef) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_AliasDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AliasDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_AliasDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AliasDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_AliasDef::original_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "original_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AliasDef:1.0"
        )
    )->original_type_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_AliasDef::original_type_def  (
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "original_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::AliasDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AliasDef:1.0"
        )
    )->original_type_def (
      original_type_def,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  5, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  5, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 0
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::PrimitiveDef::_is_a_skel},
      {"",0},
      {"destroy", 	&POA_CORBA::PrimitiveDef::destroy_skel},
      {"",0},
      {"_get_kind", 	&POA_CORBA::PrimitiveDef::_get_kind_skel},
      {"",0},{"",0},{"",0},
      {"_get_def_kind", 	&POA_CORBA::PrimitiveDef::_get_def_kind_skel},
      {"_get_type", 	&POA_CORBA::PrimitiveDef::_get_type_skel},
      {"",0},{"",0},{"",0},
      {"_non_existent",  &POA_CORBA::PrimitiveDef::_non_existent_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname_;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_PrimitiveDef_Perfect_Hash_OpTable tao_CORBA_PrimitiveDef_optable;

CORBA::PrimitiveDef_ptr _TAO_collocation_POA_CORBA_PrimitiveDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::PrimitiveDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_PrimitiveDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_PrimitiveDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_PrimitiveDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_PrimitiveDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_PrimitiveDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_PrimitiveDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_PrimitiveDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::PrimitiveDef::PrimitiveDef (void)
{
  this->optable_ = &tao_CORBA_PrimitiveDef_optable;
}

// copy ctor
POA_CORBA::PrimitiveDef::PrimitiveDef (const PrimitiveDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::PrimitiveDef::~PrimitiveDef (void)
{
}

void POA_CORBA::PrimitiveDef::_get_kind_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::PrimitiveDef *_tao_impl = (POA_CORBA::PrimitiveDef *)_tao_object_reference;

  CORBA::PrimitiveKind _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_kind",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->kind (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_kind",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_kind",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::PrimitiveDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::PrimitiveDef *_tao_impl = (POA_CORBA::PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::PrimitiveDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::PrimitiveDef *_tao_impl = (POA_CORBA::PrimitiveDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::PrimitiveDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::PrimitiveDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/PrimitiveDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::PrimitiveDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::PrimitiveDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/PrimitiveDef:1.0";
}

CORBA::PrimitiveDef*
POA_CORBA::PrimitiveDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::PrimitiveDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_PrimitiveDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::PrimitiveDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_PrimitiveDef::_tao_thru_poa_collocated_PrimitiveDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_PrimitiveDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/PrimitiveDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_PrimitiveDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/PrimitiveDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::PrimitiveKind POA_CORBA::_tao_thru_poa_collocated_PrimitiveDef::kind  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::PrimitiveKind _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "kind",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::PrimitiveDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/PrimitiveDef:1.0"
        )
    )->kind (
      ACE_TRY_ENV
    );

}



class TAO_CORBA_StringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_StringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_StringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_StringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::StringDef::_is_a_skel},
      {"destroy", 	&POA_CORBA::StringDef::destroy_skel},
      {"_get_type", 	&POA_CORBA::StringDef::_get_type_skel},
      {"_get_bound", 	&POA_CORBA::StringDef::_get_bound_skel},
      {"_set_bound", 	&POA_CORBA::StringDef::_set_bound_skel},
      {"_get_def_kind", 	&POA_CORBA::StringDef::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA::StringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -25,  -1,  -1,  10, 
       -1,  -1,  -1,  -1,  11, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_StringDef_Perfect_Hash_OpTable tao_CORBA_StringDef_optable;

CORBA::StringDef_ptr _TAO_collocation_POA_CORBA_StringDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::StringDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_StringDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_StringDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_StringDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_StringDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_StringDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_StringDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_StringDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::StringDef::StringDef (void)
{
  this->optable_ = &tao_CORBA_StringDef_optable;
}

// copy ctor
POA_CORBA::StringDef::StringDef (const StringDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::StringDef::~StringDef (void)
{
}

void POA_CORBA::StringDef::_get_bound_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::StringDef *_tao_impl = (POA_CORBA::StringDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->bound (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::StringDef::_set_bound_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::StringDef *_tao_impl = (POA_CORBA::StringDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
        bound,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::StringDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::StringDef *_tao_impl = (POA_CORBA::StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::StringDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::StringDef *_tao_impl = (POA_CORBA::StringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::StringDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::StringDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/StringDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::StringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::StringDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/StringDef:1.0";
}

CORBA::StringDef*
POA_CORBA::StringDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::StringDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_StringDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::StringDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_StringDef::_tao_thru_poa_collocated_StringDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_StringDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StringDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_StringDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StringDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::ULong POA_CORBA::_tao_thru_poa_collocated_StringDef::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StringDef:1.0"
        )
    )->bound (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_StringDef::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::StringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/StringDef:1.0"
        )
    )->bound (
      bound,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_WstringDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_WstringDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_WstringDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::WstringDef::_is_a_skel},
      {"destroy", 	&POA_CORBA::WstringDef::destroy_skel},
      {"_get_type", 	&POA_CORBA::WstringDef::_get_type_skel},
      {"_get_bound", 	&POA_CORBA::WstringDef::_get_bound_skel},
      {"_set_bound", 	&POA_CORBA::WstringDef::_set_bound_skel},
      {"_get_def_kind", 	&POA_CORBA::WstringDef::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA::WstringDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -25,  -1,  -1,  10, 
       -1,  -1,  -1,  -1,  11, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_WstringDef_Perfect_Hash_OpTable tao_CORBA_WstringDef_optable;

CORBA::WstringDef_ptr _TAO_collocation_POA_CORBA_WstringDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::WstringDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_WstringDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_WstringDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_WstringDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_WstringDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_WstringDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_WstringDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_WstringDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::WstringDef::WstringDef (void)
{
  this->optable_ = &tao_CORBA_WstringDef_optable;
}

// copy ctor
POA_CORBA::WstringDef::WstringDef (const WstringDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::WstringDef::~WstringDef (void)
{
}

void POA_CORBA::WstringDef::_get_bound_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::WstringDef *_tao_impl = (POA_CORBA::WstringDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->bound (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::WstringDef::_set_bound_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::WstringDef *_tao_impl = (POA_CORBA::WstringDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
        bound,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::WstringDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::WstringDef *_tao_impl = (POA_CORBA::WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::WstringDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::WstringDef *_tao_impl = (POA_CORBA::WstringDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::WstringDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::WstringDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/WstringDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::WstringDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::WstringDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/WstringDef:1.0";
}

CORBA::WstringDef*
POA_CORBA::WstringDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::WstringDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_WstringDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::WstringDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_WstringDef::_tao_thru_poa_collocated_WstringDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_WstringDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/WstringDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_WstringDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/WstringDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::ULong POA_CORBA::_tao_thru_poa_collocated_WstringDef::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/WstringDef:1.0"
        )
    )->bound (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_WstringDef::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::WstringDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/WstringDef:1.0"
        )
    )->bound (
      bound,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_FixedDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_FixedDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_FixedDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19,  0,
     19, 19,  0,  0, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19,  0,  5, 19, 19, 19, 19,  0, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19,
#else
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0, 19,  0, 19, 19,
      0,  0, 19, 19, 19, 19, 19, 19, 19, 19,
     19, 19, 19, 19, 19,  0,  5, 19, 19, 19,
     19,  0, 19, 19, 19, 19, 19, 19,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_FixedDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 9,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 13,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 18,
      HASH_VALUE_RANGE = 14,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::FixedDef::_is_a_skel},
      {"destroy", 	&POA_CORBA::FixedDef::destroy_skel},
      {"_get_type", 	&POA_CORBA::FixedDef::_get_type_skel},
      {"_get_scale", 	&POA_CORBA::FixedDef::_get_scale_skel},
      {"_set_scale", 	&POA_CORBA::FixedDef::_set_scale_skel},
      {"_get_digits", 	&POA_CORBA::FixedDef::_get_digits_skel},
      {"_set_digits", 	&POA_CORBA::FixedDef::_set_digits_skel},
      {"_get_def_kind", 	&POA_CORBA::FixedDef::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA::FixedDef::_non_existent_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -8,  -2, -10,  -2,   5,  -1,   6,  -1,   7, -27, -26,  -1,  12, 
       -1,  -1,  -1,  -1,  13, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_FixedDef_Perfect_Hash_OpTable tao_CORBA_FixedDef_optable;

CORBA::FixedDef_ptr _TAO_collocation_POA_CORBA_FixedDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::FixedDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_FixedDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_FixedDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_FixedDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_FixedDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_FixedDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_FixedDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_FixedDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::FixedDef::FixedDef (void)
{
  this->optable_ = &tao_CORBA_FixedDef_optable;
}

// copy ctor
POA_CORBA::FixedDef::FixedDef (const FixedDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::FixedDef::~FixedDef (void)
{
}

void POA_CORBA::FixedDef::_get_digits_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *)_tao_object_reference;

  CORBA::UShort _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_digits",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->digits (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_digits",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_digits",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::FixedDef::_set_digits_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *)_tao_object_reference;

  CORBA::UShort digits;
  if (!(
    (_tao_in >> digits)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_digits",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->digits (
        digits,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_digits",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_digits",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::FixedDef::_get_scale_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *)_tao_object_reference;

  CORBA::Short _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_scale",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->scale (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_scale",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_scale",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::FixedDef::_set_scale_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *)_tao_object_reference;

  CORBA::Short scale;
  if (!(
    (_tao_in >> scale)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_scale",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->scale (
        scale,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_scale",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_scale",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::FixedDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::FixedDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::FixedDef *_tao_impl = (POA_CORBA::FixedDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::FixedDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::FixedDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/FixedDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::FixedDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::FixedDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/FixedDef:1.0";
}

CORBA::FixedDef*
POA_CORBA::FixedDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::FixedDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_FixedDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::FixedDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_FixedDef::_tao_thru_poa_collocated_FixedDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_FixedDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_FixedDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::UShort POA_CORBA::_tao_thru_poa_collocated_FixedDef::digits  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::UShort _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "digits",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->digits (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_FixedDef::digits  (
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "digits",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->digits (
      digits,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Short POA_CORBA::_tao_thru_poa_collocated_FixedDef::scale  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Short _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "scale",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->scale (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_FixedDef::scale  (
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "scale",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::FixedDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/FixedDef:1.0"
        )
    )->scale (
      scale,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_SequenceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_SequenceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_SequenceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::SequenceDef::_is_a_skel},
      {"destroy", 	&POA_CORBA::SequenceDef::destroy_skel},
      {"_get_type", 	&POA_CORBA::SequenceDef::_get_type_skel},
      {"_get_bound", 	&POA_CORBA::SequenceDef::_get_bound_skel},
      {"_set_bound", 	&POA_CORBA::SequenceDef::_set_bound_skel},
      {"_get_def_kind", 	&POA_CORBA::SequenceDef::_get_def_kind_skel},
      {"_get_element_type", 	&POA_CORBA::SequenceDef::_get_element_type_skel},
      {"_non_existent",  &POA_CORBA::SequenceDef::_non_existent_skel},
      {"_get_element_type_def", 	&POA_CORBA::SequenceDef::_get_element_type_def_skel},
      {"_set_element_type_def", 	&POA_CORBA::SequenceDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7, -28,  -1,  -1,  10, 
       -1,  -1,  -1,  11,  12, -13,  -2, -23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_SequenceDef_Perfect_Hash_OpTable tao_CORBA_SequenceDef_optable;

CORBA::SequenceDef_ptr _TAO_collocation_POA_CORBA_SequenceDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::SequenceDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_SequenceDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_SequenceDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_SequenceDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_SequenceDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_SequenceDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_SequenceDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_SequenceDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::SequenceDef::SequenceDef (void)
{
  this->optable_ = &tao_CORBA_SequenceDef_optable;
}

// copy ctor
POA_CORBA::SequenceDef::SequenceDef (const SequenceDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::SequenceDef::~SequenceDef (void)
{
}

void POA_CORBA::SequenceDef::_get_bound_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::SequenceDef *_tao_impl = (POA_CORBA::SequenceDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->bound (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::SequenceDef::_set_bound_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::SequenceDef *_tao_impl = (POA_CORBA::SequenceDef *)_tao_object_reference;

  CORBA::ULong bound;
  if (!(
    (_tao_in >> bound)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->bound (
        bound,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_bound",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::SequenceDef::_get_element_type_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::SequenceDef *_tao_impl = (POA_CORBA::SequenceDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->element_type (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::SequenceDef::_get_element_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::SequenceDef *_tao_impl = (POA_CORBA::SequenceDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->element_type_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::SequenceDef::_set_element_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::SequenceDef *_tao_impl = (POA_CORBA::SequenceDef *)_tao_object_reference;

  CORBA::IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_element_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->element_type_def (
        element_type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_element_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_element_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::SequenceDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::SequenceDef *_tao_impl = (POA_CORBA::SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::SequenceDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::SequenceDef *_tao_impl = (POA_CORBA::SequenceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::SequenceDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::SequenceDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/SequenceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::SequenceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::SequenceDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/SequenceDef:1.0";
}

CORBA::SequenceDef*
POA_CORBA::SequenceDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::SequenceDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_SequenceDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::SequenceDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_SequenceDef::_tao_thru_poa_collocated_SequenceDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_SequenceDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_SequenceDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::ULong POA_CORBA::_tao_thru_poa_collocated_SequenceDef::bound  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->bound (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_SequenceDef::bound  (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "bound",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->bound (
      bound,
      ACE_TRY_ENV
    );
  return;
}

CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_SequenceDef::element_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->element_type (
      ACE_TRY_ENV
    );

}

CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_SequenceDef::element_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->element_type_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_SequenceDef::element_type_def  (
    CORBA::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::SequenceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/SequenceDef:1.0"
        )
    )->element_type_def (
      element_type_def,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_ArrayDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:53 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ArrayDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22,  0,
     22, 22,  0,  0,  0, 22,  0, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22,  5, 22, 22, 22, 22,  0, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,
#else
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22,  0, 22,  0, 22, 22,
      0,  0,  0, 22,  0, 22, 22, 22, 22, 22,
     22, 22, 22, 22, 22, 22,  5, 22, 22, 22,
     22,  0, 22, 22, 22, 22, 22, 22,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ArrayDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 10,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 21,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 21,
      HASH_VALUE_RANGE = 17,
      DUPLICATES = 3
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::ArrayDef::_is_a_skel},
      {"destroy", 	&POA_CORBA::ArrayDef::destroy_skel},
      {"_get_type", 	&POA_CORBA::ArrayDef::_get_type_skel},
      {"_get_length", 	&POA_CORBA::ArrayDef::_get_length_skel},
      {"_set_length", 	&POA_CORBA::ArrayDef::_set_length_skel},
      {"_get_def_kind", 	&POA_CORBA::ArrayDef::_get_def_kind_skel},
      {"_get_element_type", 	&POA_CORBA::ArrayDef::_get_element_type_skel},
      {"_non_existent",  &POA_CORBA::ArrayDef::_non_existent_skel},
      {"_get_element_type_def", 	&POA_CORBA::ArrayDef::_get_element_type_def_skel},
      {"_set_element_type_def", 	&POA_CORBA::ArrayDef::_set_element_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -8,  -2,   5,  -1,   6,  -1,   7,  -1, -29,  -1,  10, 
       -1,  -1,  -1,  11,  12, -13,  -2, -23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:53 */
static TAO_CORBA_ArrayDef_Perfect_Hash_OpTable tao_CORBA_ArrayDef_optable;

CORBA::ArrayDef_ptr _TAO_collocation_POA_CORBA_ArrayDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::ArrayDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_ArrayDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_ArrayDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_ArrayDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_ArrayDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_ArrayDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_ArrayDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_ArrayDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::ArrayDef::ArrayDef (void)
{
  this->optable_ = &tao_CORBA_ArrayDef_optable;
}

// copy ctor
POA_CORBA::ArrayDef::ArrayDef (const ArrayDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ArrayDef::~ArrayDef (void)
{
}

void POA_CORBA::ArrayDef::_get_length_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ArrayDef *_tao_impl = (POA_CORBA::ArrayDef *)_tao_object_reference;

  CORBA::ULong _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_length",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->length (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_length",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_length",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ArrayDef::_set_length_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ArrayDef *_tao_impl = (POA_CORBA::ArrayDef *)_tao_object_reference;

  CORBA::ULong length;
  if (!(
    (_tao_in >> length)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_length",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->length (
        length,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_length",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_length",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ArrayDef::_get_element_type_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ArrayDef *_tao_impl = (POA_CORBA::ArrayDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->element_type (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ArrayDef::_get_element_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ArrayDef *_tao_impl = (POA_CORBA::ArrayDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->element_type_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_element_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ArrayDef::_set_element_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ArrayDef *_tao_impl = (POA_CORBA::ArrayDef *)_tao_object_reference;

  CORBA::IDLType_var element_type_def;
  if (!(
    (_tao_in >> element_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_element_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->element_type_def (
        element_type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_element_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_element_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ArrayDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ArrayDef *_tao_impl = (POA_CORBA::ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ArrayDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ArrayDef *_tao_impl = (POA_CORBA::ArrayDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ArrayDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ArrayDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ArrayDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ArrayDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ArrayDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ArrayDef:1.0";
}

CORBA::ArrayDef*
POA_CORBA::ArrayDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::ArrayDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_ArrayDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::ArrayDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_ArrayDef::_tao_thru_poa_collocated_ArrayDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ArrayDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ArrayDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::ULong POA_CORBA::_tao_thru_poa_collocated_ArrayDef::length  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "length",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->length (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ArrayDef::length  (
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "length",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->length (
      length,
      ACE_TRY_ENV
    );
  return;
}

CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_ArrayDef::element_type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->element_type (
      ACE_TRY_ENV
    );

}

CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_ArrayDef::element_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->element_type_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ArrayDef::element_type_def  (
    CORBA::IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "element_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ArrayDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ArrayDef:1.0"
        )
    )->element_type_def (
      element_type_def,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:54 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52,  0,
     52, 20,  3,  0, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 10, 15,  5,
     52, 10, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 15, 15, 52, 52, 52, 15,  5, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52,
#else
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52, 52, 52, 52, 52, 52,
     52, 52, 52, 52, 52,  0, 52,  0, 52, 20,
      3,  0, 52, 52, 52, 52, 52, 52, 10, 15,
      5, 52, 10, 52, 52, 15, 15, 52, 52, 52,
     15,  5, 52, 52, 52, 52, 52, 52,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 32,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 51,
      HASH_VALUE_RANGE = 47,
      DUPLICATES = 6
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::ExceptionDef::_is_a_skel},
      {"_get_type", 	&POA_CORBA::ExceptionDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::ExceptionDef::_set_name_skel},
      {"_get_name", 	&POA_CORBA::ExceptionDef::_get_name_skel},
      {"_get_id", 	&POA_CORBA::ExceptionDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::ExceptionDef::_set_id_skel},
      {"describe", 	&POA_CORBA::ExceptionDef::describe_skel},
      {"destroy", 	&POA_CORBA::ExceptionDef::destroy_skel},
      {"_get_def_kind", 	&POA_CORBA::ExceptionDef::_get_def_kind_skel},
      {"_get_version", 	&POA_CORBA::ExceptionDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::ExceptionDef::_set_version_skel},
      {"_get_absolute_name", 	&POA_CORBA::ExceptionDef::_get_absolute_name_skel},
      {"move", 	&POA_CORBA::ExceptionDef::move_skel},
      {"_get_defined_in", 	&POA_CORBA::ExceptionDef::_get_defined_in_skel},
      {"lookup_name", 	&POA_CORBA::ExceptionDef::lookup_name_skel},
      {"lookup", 	&POA_CORBA::ExceptionDef::lookup_skel},
      {"_get_members", 	&POA_CORBA::ExceptionDef::_get_members_skel},
      {"_set_members", 	&POA_CORBA::ExceptionDef::_set_members_skel},
      {"_non_existent",  &POA_CORBA::ExceptionDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::ExceptionDef::_get_containing_repository_skel},
      {"create_value", 	&POA_CORBA::ExceptionDef::create_value_skel},
      {"create_module", 	&POA_CORBA::ExceptionDef::create_module_skel},
      {"describe_contents", 	&POA_CORBA::ExceptionDef::describe_contents_skel},
      {"create_interface", 	&POA_CORBA::ExceptionDef::create_interface_skel},
      {"create_union", 	&POA_CORBA::ExceptionDef::create_union_skel},
      {"create_exception", 	&POA_CORBA::ExceptionDef::create_exception_skel},
      {"contents", 	&POA_CORBA::ExceptionDef::contents_skel},
      {"create_enum", 	&POA_CORBA::ExceptionDef::create_enum_skel},
      {"create_alias", 	&POA_CORBA::ExceptionDef::create_alias_skel},
      {"create_struct", 	&POA_CORBA::ExceptionDef::create_struct_skel},
      {"create_constant", 	&POA_CORBA::ExceptionDef::create_constant_skel},
      {"create_value_box", 	&POA_CORBA::ExceptionDef::create_value_box_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -6,  -3,   5,  -1,  -9,  -2, -57, -54,  11,  -1, -14, 
       -2,  12,  13, -55,  16,  17,  18,  19,  -1,  -1, -21,  -2,  20, -54, 
       23,  -1,  -1,  24,  25,  26,  -1,  27,  28,  29,  -1,  -1,  -1,  30, 
       -1,  31,  -1,  -1,  32,  33,  34,  -1,  35,  36, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:54 */
static TAO_CORBA_ExceptionDef_Perfect_Hash_OpTable tao_CORBA_ExceptionDef_optable;

CORBA::ExceptionDef_ptr _TAO_collocation_POA_CORBA_ExceptionDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::ExceptionDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_ExceptionDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_ExceptionDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_ExceptionDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_ExceptionDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_ExceptionDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_ExceptionDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_ExceptionDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::ExceptionDef::ExceptionDef (void)
{
  this->optable_ = &tao_CORBA_ExceptionDef_optable;
}

// copy ctor
POA_CORBA::ExceptionDef::ExceptionDef (const ExceptionDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ExceptionDef::~ExceptionDef (void)
{
}

void POA_CORBA::ExceptionDef::_get_type_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ExceptionDef *_tao_impl = (POA_CORBA::ExceptionDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->type (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ExceptionDef::_get_members_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ExceptionDef *_tao_impl = (POA_CORBA::ExceptionDef *)_tao_object_reference;

  CORBA::StructMemberSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->members (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ExceptionDef::_set_members_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ExceptionDef *_tao_impl = (POA_CORBA::ExceptionDef *)_tao_object_reference;

  CORBA::StructMemberSeq members;
  if (!(
    (_tao_in >> members)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->members (
        members,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_members",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ExceptionDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ExceptionDef *_tao_impl = (POA_CORBA::ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ExceptionDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ExceptionDef *_tao_impl = (POA_CORBA::ExceptionDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ExceptionDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ExceptionDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ExceptionDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ExceptionDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ExceptionDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ExceptionDef:1.0";
}

CORBA::ExceptionDef*
POA_CORBA::ExceptionDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::ExceptionDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_ExceptionDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::ExceptionDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_ExceptionDef::_tao_thru_poa_collocated_ExceptionDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ExceptionDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ExceptionDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_ExceptionDef::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}

CORBA::StructMemberSeq * POA_CORBA::_tao_thru_poa_collocated_ExceptionDef::members  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::StructMemberSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        )
    )->members (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ExceptionDef::members  (
    const CORBA::StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "members",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ExceptionDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ExceptionDef:1.0"
        )
    )->members (
      members,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_AttributeDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:54 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_AttributeDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37, 37, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_AttributeDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 8
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::AttributeDef::move_skel},
      {"_is_a",  &POA_CORBA::AttributeDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::AttributeDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::AttributeDef::_set_id_skel},
      {"describe", 	&POA_CORBA::AttributeDef::describe_skel},
      {"_get_type", 	&POA_CORBA::AttributeDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::AttributeDef::_set_name_skel},
      {"_get_name", 	&POA_CORBA::AttributeDef::_get_name_skel},
      {"_set_mode", 	&POA_CORBA::AttributeDef::_set_mode_skel},
      {"_get_mode", 	&POA_CORBA::AttributeDef::_get_mode_skel},
      {"_get_version", 	&POA_CORBA::AttributeDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::AttributeDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::AttributeDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::AttributeDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::AttributeDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::AttributeDef::_get_absolute_name_skel},
      {"_get_type_def", 	&POA_CORBA::AttributeDef::_get_type_def_skel},
      {"_set_type_def", 	&POA_CORBA::AttributeDef::_set_type_def_skel},
      {"_non_existent",  &POA_CORBA::AttributeDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::AttributeDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
       -6,  -2,  -9,  -5,   4,   5,  -1, -43,   8, -43, -14,  -2, -38,  16, 
       -1,  17,  -1,  18,  19,  -1,  -1, -20,  -2, -38,  -1,  -1,  -1,  -1, 
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:54 */
static TAO_CORBA_AttributeDef_Perfect_Hash_OpTable tao_CORBA_AttributeDef_optable;

CORBA::AttributeDef_ptr _TAO_collocation_POA_CORBA_AttributeDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::AttributeDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_AttributeDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_AttributeDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_AttributeDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_AttributeDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_AttributeDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_AttributeDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_AttributeDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::AttributeDef::AttributeDef (void)
{
  this->optable_ = &tao_CORBA_AttributeDef_optable;
}

// copy ctor
POA_CORBA::AttributeDef::AttributeDef (const AttributeDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::AttributeDef::~AttributeDef (void)
{
}

void POA_CORBA::AttributeDef::_get_type_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::AttributeDef *_tao_impl = (POA_CORBA::AttributeDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->type (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::AttributeDef::_get_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::AttributeDef *_tao_impl = (POA_CORBA::AttributeDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->type_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::AttributeDef::_set_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::AttributeDef *_tao_impl = (POA_CORBA::AttributeDef *)_tao_object_reference;

  CORBA::IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->type_def (
        type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::AttributeDef::_get_mode_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::AttributeDef *_tao_impl = (POA_CORBA::AttributeDef *)_tao_object_reference;

  CORBA::AttributeMode _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_mode",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->mode (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_mode",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_mode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::AttributeDef::_set_mode_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::AttributeDef *_tao_impl = (POA_CORBA::AttributeDef *)_tao_object_reference;

  CORBA::AttributeMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_mode",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->mode (
        mode,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_mode",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_mode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::AttributeDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::AttributeDef *_tao_impl = (POA_CORBA::AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::AttributeDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::AttributeDef *_tao_impl = (POA_CORBA::AttributeDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::AttributeDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::AttributeDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/AttributeDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::AttributeDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::AttributeDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/AttributeDef:1.0";
}

CORBA::AttributeDef*
POA_CORBA::AttributeDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::AttributeDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_AttributeDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::AttributeDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_AttributeDef::_tao_thru_poa_collocated_AttributeDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_AttributeDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_AttributeDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_AttributeDef::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}

CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_AttributeDef::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->type_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_AttributeDef::type_def  (
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->type_def (
      type_def,
      ACE_TRY_ENV
    );
  return;
}

CORBA::AttributeMode POA_CORBA::_tao_thru_poa_collocated_AttributeDef::mode  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AttributeMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "mode",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->mode (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_AttributeDef::mode  (
    CORBA::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "mode",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::AttributeDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/AttributeDef:1.0"
        )
    )->mode (
      mode,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_OperationDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:54 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_OperationDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 15,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  5,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 20, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
     15,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      5, 37, 37, 37, 37,  0, 20, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_OperationDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 26,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 10
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::OperationDef::move_skel},
      {"_is_a",  &POA_CORBA::OperationDef::_is_a_skel},
      {"_get_mode", 	&POA_CORBA::OperationDef::_get_mode_skel},
      {"_set_name", 	&POA_CORBA::OperationDef::_set_name_skel},
      {"_get_name", 	&POA_CORBA::OperationDef::_get_name_skel},
      {"_set_mode", 	&POA_CORBA::OperationDef::_set_mode_skel},
      {"_get_params", 	&POA_CORBA::OperationDef::_get_params_skel},
      {"_set_params", 	&POA_CORBA::OperationDef::_set_params_skel},
      {"_get_contexts", 	&POA_CORBA::OperationDef::_get_contexts_skel},
      {"_set_contexts", 	&POA_CORBA::OperationDef::_set_contexts_skel},
      {"_get_exceptions", 	&POA_CORBA::OperationDef::_get_exceptions_skel},
      {"_set_exceptions", 	&POA_CORBA::OperationDef::_set_exceptions_skel},
      {"_get_version", 	&POA_CORBA::OperationDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::OperationDef::_set_version_skel},
      {"_get_absolute_name", 	&POA_CORBA::OperationDef::_get_absolute_name_skel},
      {"_get_defined_in", 	&POA_CORBA::OperationDef::_get_defined_in_skel},
      {"_get_id", 	&POA_CORBA::OperationDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::OperationDef::_set_id_skel},
      {"describe", 	&POA_CORBA::OperationDef::describe_skel},
      {"_get_result_def", 	&POA_CORBA::OperationDef::_get_result_def_skel},
      {"_set_result_def", 	&POA_CORBA::OperationDef::_set_result_def_skel},
      {"_get_def_kind", 	&POA_CORBA::OperationDef::_get_def_kind_skel},
      {"_get_result", 	&POA_CORBA::OperationDef::_get_result_skel},
      {"destroy", 	&POA_CORBA::OperationDef::destroy_skel},
      {"_non_existent",  &POA_CORBA::OperationDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::OperationDef::_get_containing_repository_skel},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
            {
              const class TAO_operation_db_entry   *resword; 

              switch (key)
                {
                case   4:
                  resword = &wordlist[4]; break;
                case   5:
                  resword = &wordlist[5]; break;
                case   9:
                  resword = &wordlist[6];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[7];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[8];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[9];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  11:
                  resword = &wordlist[10];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[11];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  13:
                  resword = &wordlist[12];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[13];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  15:
                  resword = &wordlist[14];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[15];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  17:
                  resword = &wordlist[16];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[17];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  18:
                  resword = &wordlist[18]; break;
                case  20:
                  resword = &wordlist[19]; break;
                case  22:
                  resword = &wordlist[20];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[21];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  23:
                  resword = &wordlist[22]; break;
                case  25:
                  resword = &wordlist[23];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  resword = &wordlist[24];
                  if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1)) return resword;
                  return 0;
                case  28:
                  resword = &wordlist[25]; break;
                case  31:
                  resword = &wordlist[26]; break;
                case  32:
                  resword = &wordlist[27]; break;
                case  33:
                  resword = &wordlist[28]; break;
                case  36:
                  resword = &wordlist[29]; break;
                default: return 0;
                }
              if (*str == *resword->opname_ && !strncmp (str + 1, resword->opname_ + 1, len - 1))
                return resword;
              return 0;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:54 */
static TAO_CORBA_OperationDef_Perfect_Hash_OpTable tao_CORBA_OperationDef_optable;

CORBA::OperationDef_ptr _TAO_collocation_POA_CORBA_OperationDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::OperationDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_OperationDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_OperationDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_OperationDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_OperationDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_OperationDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_OperationDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_OperationDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::OperationDef::OperationDef (void)
{
  this->optable_ = &tao_CORBA_OperationDef_optable;
}

// copy ctor
POA_CORBA::OperationDef::OperationDef (const OperationDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::OperationDef::~OperationDef (void)
{
}

void POA_CORBA::OperationDef::_get_result_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_result",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->result (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_result",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_result",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::OperationDef::_get_result_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_result_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->result_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_result_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_result_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::OperationDef::_set_result_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::IDLType_var result_def;
  if (!(
    (_tao_in >> result_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_result_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->result_def (
        result_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_result_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_result_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::OperationDef::_get_params_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::ParDescriptionSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_params",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->params (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_params",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_params",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::OperationDef::_set_params_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::ParDescriptionSeq params;
  if (!(
    (_tao_in >> params)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_params",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->params (
        params,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_params",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_params",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::OperationDef::_get_mode_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::OperationMode _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_mode",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->mode (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_mode",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_mode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::OperationDef::_set_mode_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::OperationMode mode;
  if (!(
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_mode",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->mode (
        mode,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_mode",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_mode",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::OperationDef::_get_contexts_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::ContextIdSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_contexts",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->contexts (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_contexts",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_contexts",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::OperationDef::_set_contexts_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::ContextIdSeq contexts;
  if (!(
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_contexts",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->contexts (
        contexts,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_contexts",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_contexts",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::OperationDef::_get_exceptions_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::ExceptionDefSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_exceptions",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->exceptions (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_exceptions",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_exceptions",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::OperationDef::_set_exceptions_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *)_tao_object_reference;

  CORBA::ExceptionDefSeq exceptions;
  if (!(
    (_tao_in >> exceptions)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_exceptions",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->exceptions (
        exceptions,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_exceptions",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_exceptions",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::OperationDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::OperationDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::OperationDef *_tao_impl = (POA_CORBA::OperationDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::OperationDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::OperationDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/OperationDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::OperationDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::OperationDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/OperationDef:1.0";
}

CORBA::OperationDef*
POA_CORBA::OperationDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::OperationDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_OperationDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::OperationDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_OperationDef::_tao_thru_poa_collocated_OperationDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_OperationDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_OperationDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_OperationDef::result  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "result",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->result (
      ACE_TRY_ENV
    );

}

CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_OperationDef::result_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "result_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->result_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_OperationDef::result_def  (
    CORBA::IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "result_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->result_def (
      result_def,
      ACE_TRY_ENV
    );
  return;
}

CORBA::ParDescriptionSeq * POA_CORBA::_tao_thru_poa_collocated_OperationDef::params  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ParDescriptionSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "params",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->params (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_OperationDef::params  (
    const CORBA::ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "params",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->params (
      params,
      ACE_TRY_ENV
    );
  return;
}

CORBA::OperationMode POA_CORBA::_tao_thru_poa_collocated_OperationDef::mode  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::OperationMode _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "mode",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->mode (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_OperationDef::mode  (
    CORBA::OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "mode",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->mode (
      mode,
      ACE_TRY_ENV
    );
  return;
}

CORBA::ContextIdSeq * POA_CORBA::_tao_thru_poa_collocated_OperationDef::contexts  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ContextIdSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "contexts",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->contexts (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_OperationDef::contexts  (
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "contexts",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->contexts (
      contexts,
      ACE_TRY_ENV
    );
  return;
}

CORBA::ExceptionDefSeq * POA_CORBA::_tao_thru_poa_collocated_OperationDef::exceptions  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ExceptionDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "exceptions",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->exceptions (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_OperationDef::exceptions  (
    const CORBA::ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "exceptions",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::OperationDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/OperationDef:1.0"
        )
    )->exceptions (
      exceptions,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:54 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71,  0,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71,  0,
     71, 25, 15,  0, 71, 71, 71, 10, 71, 71,
     71, 71, 71, 71, 71, 71, 71,  0,  0,  5,
     71,  0, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 15, 30, 71, 71, 71, 10,  5, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71,
#else
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
     71, 71, 71, 71, 71,  0, 71,  0, 71, 25,
     15,  0, 71, 71, 71, 10, 71, 71,  0,  0,
      5, 71,  0, 71, 71, 15, 30, 71, 71, 71,
     10,  5, 71, 71, 71, 71, 71, 71,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 36,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 70,
      HASH_VALUE_RANGE = 67,
      DUPLICATES = 8
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::InterfaceDef::move_skel},
      {"_is_a",  &POA_CORBA::InterfaceDef::_is_a_skel},
      {"lookup", 	&POA_CORBA::InterfaceDef::lookup_skel},
      {"_get_name", 	&POA_CORBA::InterfaceDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::InterfaceDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::InterfaceDef::_set_name_skel},
      {"lookup_name", 	&POA_CORBA::InterfaceDef::lookup_name_skel},
      {"is_a", 	&POA_CORBA::InterfaceDef::is_a_skel},
      {"_get_version", 	&POA_CORBA::InterfaceDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::InterfaceDef::_set_version_skel},
      {"_get_absolute_name", 	&POA_CORBA::InterfaceDef::_get_absolute_name_skel},
      {"_get_defined_in", 	&POA_CORBA::InterfaceDef::_get_defined_in_skel},
      {"_get_id", 	&POA_CORBA::InterfaceDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::InterfaceDef::_set_id_skel},
      {"describe", 	&POA_CORBA::InterfaceDef::describe_skel},
      {"destroy", 	&POA_CORBA::InterfaceDef::destroy_skel},
      {"_get_def_kind", 	&POA_CORBA::InterfaceDef::_get_def_kind_skel},
      {"_get_containing_repository", 	&POA_CORBA::InterfaceDef::_get_containing_repository_skel},
      {"describe_interface", 	&POA_CORBA::InterfaceDef::describe_interface_skel},
      {"_get_base_interfaces", 	&POA_CORBA::InterfaceDef::_get_base_interfaces_skel},
      {"_set_base_interfaces", 	&POA_CORBA::InterfaceDef::_set_base_interfaces_skel},
      {"create_enum", 	&POA_CORBA::InterfaceDef::create_enum_skel},
      {"create_value", 	&POA_CORBA::InterfaceDef::create_value_skel},
      {"create_module", 	&POA_CORBA::InterfaceDef::create_module_skel},
      {"create_attribute", 	&POA_CORBA::InterfaceDef::create_attribute_skel},
      {"create_interface", 	&POA_CORBA::InterfaceDef::create_interface_skel},
      {"create_union", 	&POA_CORBA::InterfaceDef::create_union_skel},
      {"_non_existent",  &POA_CORBA::InterfaceDef::_non_existent_skel},
      {"create_operation", 	&POA_CORBA::InterfaceDef::create_operation_skel},
      {"create_exception", 	&POA_CORBA::InterfaceDef::create_exception_skel},
      {"describe_contents", 	&POA_CORBA::InterfaceDef::describe_contents_skel},
      {"contents", 	&POA_CORBA::InterfaceDef::contents_skel},
      {"create_value_box", 	&POA_CORBA::InterfaceDef::create_value_box_skel},
      {"create_alias", 	&POA_CORBA::InterfaceDef::create_alias_skel},
      {"create_struct", 	&POA_CORBA::InterfaceDef::create_struct_skel},
      {"create_constant", 	&POA_CORBA::InterfaceDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,   4,   5,   6,  -7,  -3, -72,  -1,  10, -12,  -2, 
       11, -16,  -2, -75,  14,  -1,  15,  -1, -77,  18,  -1,  -1,  -1,  19, 
       20, -23,  -2,  21,  -1,  22,  -1, -76,  25,  26,  27, -28,  -2, -72, 
       30,  31, -32,  -2, -72,  34,  35,  -1,  -1,  36,  37,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  38,  -1, 
       39, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:54 */
static TAO_CORBA_InterfaceDef_Perfect_Hash_OpTable tao_CORBA_InterfaceDef_optable;

CORBA::InterfaceDef_ptr _TAO_collocation_POA_CORBA_InterfaceDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::InterfaceDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_InterfaceDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_InterfaceDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_InterfaceDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_InterfaceDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_InterfaceDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_InterfaceDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_InterfaceDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::InterfaceDef::InterfaceDef (void)
{
  this->optable_ = &tao_CORBA_InterfaceDef_optable;
}

// copy ctor
POA_CORBA::InterfaceDef::InterfaceDef (const InterfaceDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::InterfaceDef::~InterfaceDef (void)
{
}

void POA_CORBA::InterfaceDef::_get_base_interfaces_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::InterfaceDef *_tao_impl = (POA_CORBA::InterfaceDef *)_tao_object_reference;

  CORBA::InterfaceDefSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_base_interfaces",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->base_interfaces (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_base_interfaces",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_base_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::InterfaceDef::_set_base_interfaces_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::InterfaceDef *_tao_impl = (POA_CORBA::InterfaceDef *)_tao_object_reference;

  CORBA::InterfaceDefSeq base_interfaces;
  if (!(
    (_tao_in >> base_interfaces)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_base_interfaces",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->base_interfaces (
        base_interfaces,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_base_interfaces",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_base_interfaces",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::InterfaceDef::is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::InterfaceDef *_tao_impl = (POA_CORBA::InterfaceDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var interface_id;
  if (!(
    (_tao_in >> interface_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "is_a",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->is_a (
        interface_id.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "is_a",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "is_a",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::InterfaceDef::describe_interface_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::InterfaceDef *_tao_impl = (POA_CORBA::InterfaceDef *)_tao_object_reference;

  CORBA::InterfaceDef::FullInterfaceDescription_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_interface",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->describe_interface (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_interface",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_interface",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::InterfaceDef::create_attribute_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::InterfaceDef *_tao_impl = (POA_CORBA::InterfaceDef *)_tao_object_reference;

  CORBA::AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var type;
  CORBA::AttributeMode mode;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_attribute",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_attribute (
        id.in (),
        name.in (),
        version.in (),
        type.in (),
        mode,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_attribute",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_attribute",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::InterfaceDef::create_operation_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::InterfaceDef *_tao_impl = (POA_CORBA::InterfaceDef *)_tao_object_reference;

  CORBA::OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var result;
  CORBA::OperationMode mode;
  CORBA::ParDescriptionSeq params;
  CORBA::ExceptionDefSeq exceptions;
  CORBA::ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_operation",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_operation (
        id.in (),
        name.in (),
        version.in (),
        result.in (),
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_operation",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_operation",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::InterfaceDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::InterfaceDef *_tao_impl = (POA_CORBA::InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::InterfaceDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::InterfaceDef *_tao_impl = (POA_CORBA::InterfaceDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::InterfaceDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::InterfaceDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/InterfaceDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::InterfaceDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::InterfaceDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/InterfaceDef:1.0";
}

CORBA::InterfaceDef*
POA_CORBA::InterfaceDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::InterfaceDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_InterfaceDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::InterfaceDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::_tao_thru_poa_collocated_InterfaceDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::InterfaceDefSeq * POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::base_interfaces  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_interfaces",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->base_interfaces (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::base_interfaces  (
    const CORBA::InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_interfaces",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->base_interfaces (
      base_interfaces,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::is_a  (
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->is_a (
      interface_id,
      ACE_TRY_ENV
    );

}

CORBA::InterfaceDef::FullInterfaceDescription * POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::describe_interface  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDef::FullInterfaceDescription_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "describe_interface",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->describe_interface (
      ACE_TRY_ENV
    );

}

CORBA::AttributeDef_ptr POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::create_attribute  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_attribute",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->create_attribute (
      id,
      name,
      version,
      type,
      mode,
      ACE_TRY_ENV
    );

}

CORBA::OperationDef_ptr POA_CORBA::_tao_thru_poa_collocated_InterfaceDef::create_operation  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_operation",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::InterfaceDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/InterfaceDef:1.0"
        )
    )->create_operation (
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

}



class TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:54 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37,  0,
     37, 37,  0,  0, 10, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37,  0,  0,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37,  0, 15, 37, 37, 37, 37, 10, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37,
#else
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37, 37, 37, 37, 37, 37,
     37, 37, 37, 37, 37,  0, 37,  0, 37, 37,
      0,  0, 10, 37, 37, 37, 37, 37, 37,  0,
      0, 37, 37, 37, 37,  0, 15, 37, 37, 37,
     37, 10, 37, 37, 37, 37, 37, 37,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 20,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 36,
      HASH_VALUE_RANGE = 33,
      DUPLICATES = 7
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::ValueMemberDef::move_skel},
      {"_is_a",  &POA_CORBA::ValueMemberDef::_is_a_skel},
      {"_get_id", 	&POA_CORBA::ValueMemberDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::ValueMemberDef::_set_id_skel},
      {"describe", 	&POA_CORBA::ValueMemberDef::describe_skel},
      {"_get_type", 	&POA_CORBA::ValueMemberDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::ValueMemberDef::_set_name_skel},
      {"_get_name", 	&POA_CORBA::ValueMemberDef::_get_name_skel},
      {"_get_access", 	&POA_CORBA::ValueMemberDef::_get_access_skel},
      {"_set_access", 	&POA_CORBA::ValueMemberDef::_set_access_skel},
      {"_get_version", 	&POA_CORBA::ValueMemberDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::ValueMemberDef::_set_version_skel},
      {"_get_def_kind", 	&POA_CORBA::ValueMemberDef::_get_def_kind_skel},
      {"_get_defined_in", 	&POA_CORBA::ValueMemberDef::_get_defined_in_skel},
      {"destroy", 	&POA_CORBA::ValueMemberDef::destroy_skel},
      {"_get_absolute_name", 	&POA_CORBA::ValueMemberDef::_get_absolute_name_skel},
      {"_get_type_def", 	&POA_CORBA::ValueMemberDef::_get_type_def_skel},
      {"_set_type_def", 	&POA_CORBA::ValueMemberDef::_set_type_def_skel},
      {"_non_existent",  &POA_CORBA::ValueMemberDef::_non_existent_skel},
      {"_get_containing_repository", 	&POA_CORBA::ValueMemberDef::_get_containing_repository_skel},
    };

  static const signed char lookup[] =
    {
      -12,  -2, -14,  -2,   4,   5,  -1,  53,   8,  46,  -1, -47, -46,  16, 
       -1,  17,  -1,  18,  19,  -9,  -3, -20,  -2, -38,  -6,  -2,  -1,  -1, 
       22,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  23, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:54 */
static TAO_CORBA_ValueMemberDef_Perfect_Hash_OpTable tao_CORBA_ValueMemberDef_optable;

CORBA::ValueMemberDef_ptr _TAO_collocation_POA_CORBA_ValueMemberDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::ValueMemberDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_ValueMemberDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_ValueMemberDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_ValueMemberDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_ValueMemberDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_ValueMemberDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_ValueMemberDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::ValueMemberDef::ValueMemberDef (void)
{
  this->optable_ = &tao_CORBA_ValueMemberDef_optable;
}

// copy ctor
POA_CORBA::ValueMemberDef::ValueMemberDef (const ValueMemberDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ValueMemberDef::~ValueMemberDef (void)
{
}

void POA_CORBA::ValueMemberDef::_get_type_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;

  CORBA::TypeCode_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->type (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueMemberDef::_get_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->type_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueMemberDef::_set_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;

  CORBA::IDLType_var type_def;
  if (!(
    (_tao_in >> type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->type_def (
        type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueMemberDef::_get_access_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;

  CORBA::Visibility _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_access",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->access (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_access",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_access",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval)
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueMemberDef::_set_access_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *)_tao_object_reference;

  CORBA::Visibility access;
  if (!(
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_access",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->access (
        access,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_access",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_access",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueMemberDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ValueMemberDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueMemberDef *_tao_impl = (POA_CORBA::ValueMemberDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ValueMemberDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ValueMemberDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ValueMemberDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ValueMemberDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ValueMemberDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueMemberDef:1.0";
}

CORBA::ValueMemberDef*
POA_CORBA::ValueMemberDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::ValueMemberDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::ValueMemberDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef::_tao_thru_poa_collocated_ValueMemberDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::TypeCode_ptr POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef::type  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->type (
      ACE_TRY_ENV
    );

}

CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef::type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->type_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef::type_def  (
    CORBA::IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->type_def (
      type_def,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Visibility POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef::access  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Visibility _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "access",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->access (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueMemberDef::access  (
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "access",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueMemberDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueMemberDef:1.0"
        )
    )->access (
      access,
      ACE_TRY_ENV
    );
  return;
}



class TAO_CORBA_ValueDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:54 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ValueDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ValueDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86,  0,
     86, 50, 35,  0, 86, 86, 86, 25, 86, 86,
     86, 86, 86, 86, 86, 86, 86,  0,  0, 15,
     86,  0, 86,  0, 86, 86, 86, 86, 86, 86,
     86, 86, 20, 20, 86, 86, 86,  5,  5, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86,
#else
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86, 86, 86, 86, 86, 86,
     86, 86, 86, 86, 86,  0, 86,  0, 86, 50,
     35,  0, 86, 86, 86, 25, 86, 86,  0,  0,
     15, 86,  0, 86,  0, 20, 20, 86, 86, 86,
      5,  5, 86, 86, 86, 86, 86, 86,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ValueDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 49,
      MIN_WORD_LENGTH = 4,
      MAX_WORD_LENGTH = 26,
      MIN_HASH_VALUE = 4,
      MAX_HASH_VALUE = 85,
      HASH_VALUE_RANGE = 82,
      DUPLICATES = 14
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},
      {"move", 	&POA_CORBA::ValueDef::move_skel},
      {"_is_a",  &POA_CORBA::ValueDef::_is_a_skel},
      {"lookup", 	&POA_CORBA::ValueDef::lookup_skel},
      {"_get_name", 	&POA_CORBA::ValueDef::_get_name_skel},
      {"_get_type", 	&POA_CORBA::ValueDef::_get_type_skel},
      {"_set_name", 	&POA_CORBA::ValueDef::_set_name_skel},
      {"lookup_name", 	&POA_CORBA::ValueDef::lookup_name_skel},
      {"_get_is_custom", 	&POA_CORBA::ValueDef::_get_is_custom_skel},
      {"_set_is_custom", 	&POA_CORBA::ValueDef::_set_is_custom_skel},
      {"_get_base_value", 	&POA_CORBA::ValueDef::_get_base_value_skel},
      {"_set_base_value", 	&POA_CORBA::ValueDef::_set_base_value_skel},
      {"_get_absolute_name", 	&POA_CORBA::ValueDef::_get_absolute_name_skel},
      {"_get_is_truncatable", 	&POA_CORBA::ValueDef::_get_is_truncatable_skel},
      {"_set_is_truncatable", 	&POA_CORBA::ValueDef::_set_is_truncatable_skel},
      {"_get_supported_interface", 	&POA_CORBA::ValueDef::_get_supported_interface_skel},
      {"_set_supported_interface", 	&POA_CORBA::ValueDef::_set_supported_interface_skel},
      {"_get_version", 	&POA_CORBA::ValueDef::_get_version_skel},
      {"_set_version", 	&POA_CORBA::ValueDef::_set_version_skel},
      {"is_a", 	&POA_CORBA::ValueDef::is_a_skel},
      {"_get_defined_in", 	&POA_CORBA::ValueDef::_get_defined_in_skel},
      {"_get_containing_repository", 	&POA_CORBA::ValueDef::_get_containing_repository_skel},
      {"_non_existent",  &POA_CORBA::ValueDef::_non_existent_skel},
      {"_get_is_abstract", 	&POA_CORBA::ValueDef::_get_is_abstract_skel},
      {"_set_is_abstract", 	&POA_CORBA::ValueDef::_set_is_abstract_skel},
      {"_get_initializers", 	&POA_CORBA::ValueDef::_get_initializers_skel},
      {"_set_initializers", 	&POA_CORBA::ValueDef::_set_initializers_skel},
      {"_get_id", 	&POA_CORBA::ValueDef::_get_id_skel},
      {"_set_id", 	&POA_CORBA::ValueDef::_set_id_skel},
      {"describe", 	&POA_CORBA::ValueDef::describe_skel},
      {"_get_abstract_base_values", 	&POA_CORBA::ValueDef::_get_abstract_base_values_skel},
      {"_set_abstract_base_values", 	&POA_CORBA::ValueDef::_set_abstract_base_values_skel},
      {"destroy", 	&POA_CORBA::ValueDef::destroy_skel},
      {"_get_def_kind", 	&POA_CORBA::ValueDef::_get_def_kind_skel},
      {"describe_value", 	&POA_CORBA::ValueDef::describe_value_skel},
      {"create_enum", 	&POA_CORBA::ValueDef::create_enum_skel},
      {"create_value", 	&POA_CORBA::ValueDef::create_value_skel},
      {"create_module", 	&POA_CORBA::ValueDef::create_module_skel},
      {"create_attribute", 	&POA_CORBA::ValueDef::create_attribute_skel},
      {"create_interface", 	&POA_CORBA::ValueDef::create_interface_skel},
      {"create_value_member", 	&POA_CORBA::ValueDef::create_value_member_skel},
      {"create_value_box", 	&POA_CORBA::ValueDef::create_value_box_skel},
      {"describe_contents", 	&POA_CORBA::ValueDef::describe_contents_skel},
      {"create_union", 	&POA_CORBA::ValueDef::create_union_skel},
      {"contents", 	&POA_CORBA::ValueDef::contents_skel},
      {"create_operation", 	&POA_CORBA::ValueDef::create_operation_skel},
      {"create_exception", 	&POA_CORBA::ValueDef::create_exception_skel},
      {"create_alias", 	&POA_CORBA::ValueDef::create_alias_skel},
      {"create_struct", 	&POA_CORBA::ValueDef::create_struct_skel},
      {"create_constant", 	&POA_CORBA::ValueDef::create_constant_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -7,  -3,   4,   5,   6, -11,  -2, -92,  -1,  10, -13,  -2, 
      -92, -88, -16,  -2,  15, -88, -18,  -2, -20,  -2, -89, -26,  -2, -90, 
       -1,  22,  23,  24,  -1,  25, -28,  -2, -96, -88, -30,  -2, -33,  -2, 
      -89,  32,  -1, -90,  -1,  35,  36,  37,  -1,  -1,  -1,  -1,  -1,  -1, 
       -1,  -1,  -1,  -1,  -1,  38,  39,  40, -41,  -2, -87,  -1,  -1,  43, 
       -1,  44,  45,  -1,  -1,  -1,  -1,  46,  47, -48,  -2, -87,  50,  51, 
       -1,  52, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:54 */
static TAO_CORBA_ValueDef_Perfect_Hash_OpTable tao_CORBA_ValueDef_optable;

CORBA::ValueDef_ptr _TAO_collocation_POA_CORBA_ValueDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::ValueDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_ValueDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_ValueDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_ValueDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_ValueDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_ValueDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_ValueDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_ValueDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::ValueDef::ValueDef (void)
{
  this->optable_ = &tao_CORBA_ValueDef_optable;
}

// copy ctor
POA_CORBA::ValueDef::ValueDef (const ValueDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,Container) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,Contained) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ValueDef::~ValueDef (void)
{
}

void POA_CORBA::ValueDef::_get_supported_interface_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::InterfaceDef_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_supported_interface",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->supported_interface (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_supported_interface",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_supported_interface",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::_set_supported_interface_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::InterfaceDef_var supported_interface;
  if (!(
    (_tao_in >> supported_interface.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_supported_interface",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->supported_interface (
        supported_interface.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_supported_interface",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_supported_interface",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueDef::_get_initializers_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::InitializerSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_initializers",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->initializers (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_initializers",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_initializers",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::_set_initializers_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::InitializerSeq initializers;
  if (!(
    (_tao_in >> initializers)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_initializers",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->initializers (
        initializers,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_initializers",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_initializers",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueDef::_get_base_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::ValueDef_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_base_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->base_value (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_base_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_base_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::_set_base_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::ValueDef_var base_value;
  if (!(
    (_tao_in >> base_value.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_base_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->base_value (
        base_value.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_base_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_base_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueDef::_get_abstract_base_values_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::ValueDefSeq_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_abstract_base_values",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->abstract_base_values (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_abstract_base_values",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_abstract_base_values",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::_set_abstract_base_values_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::ValueDefSeq abstract_base_values;
  if (!(
    (_tao_in >> abstract_base_values)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_abstract_base_values",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->abstract_base_values (
        abstract_base_values,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_abstract_base_values",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_abstract_base_values",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueDef::_get_is_abstract_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_abstract",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->is_abstract (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_abstract",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_abstract",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::_set_is_abstract_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_abstract;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_abstract))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_abstract",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->is_abstract (
        is_abstract,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_abstract",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_abstract",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueDef::_get_is_custom_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_custom",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->is_custom (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_custom",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_custom",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::_set_is_custom_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_custom;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_custom))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_custom",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->is_custom (
        is_custom,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_custom",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_custom",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueDef::_get_is_truncatable_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_truncatable",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->is_truncatable (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_truncatable",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_is_truncatable",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::_set_is_truncatable_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::Boolean is_truncatable;
  if (!(
    (_tao_in >> CORBA::Any::to_boolean (is_truncatable))
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_truncatable",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->is_truncatable (
        is_truncatable,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_truncatable",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_is_truncatable",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueDef::is_a_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value_id;
  if (!(
    (_tao_in >> value_id.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "is_a",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->is_a (
        value_id.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "is_a",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "is_a",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << CORBA::Any::from_boolean (_tao_retval))
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::describe_value_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::ValueDef::FullValueDescription_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->describe_value (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_value",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "describe_value",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::create_value_member_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::ValueMemberDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var type;
  CORBA::Visibility access;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> access)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value_member",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_value_member (
        id.in (),
        name.in (),
        version.in (),
        type.in (),
        access,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value_member",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_value_member",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::create_attribute_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::AttributeDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var type;
  CORBA::AttributeMode mode;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> type.out ()) &&
    (_tao_in >> mode)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_attribute",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_attribute (
        id.in (),
        name.in (),
        version.in (),
        type.in (),
        mode,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_attribute",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_attribute",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::create_operation_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *)_tao_object_reference;

  CORBA::OperationDef_var _tao_retval;
  CORBA::String_var id;
  CORBA::String_var name;
  CORBA::String_var version;
  CORBA::IDLType_var result;
  CORBA::OperationMode mode;
  CORBA::ParDescriptionSeq params;
  CORBA::ExceptionDefSeq exceptions;
  CORBA::ContextIdSeq contexts;
  if (!(
    (_tao_in >> id.out ()) &&
    (_tao_in >> name.out ()) &&
    (_tao_in >> version.out ()) &&
    (_tao_in >> result.out ()) &&
    (_tao_in >> mode) &&
    (_tao_in >> params) &&
    (_tao_in >> exceptions) &&
    (_tao_in >> contexts)
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_operation",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->create_operation (
        id.in (),
        name.in (),
        version.in (),
        result.in (),
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_operation",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "create_operation",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ValueDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueDef *_tao_impl = (POA_CORBA::ValueDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ValueDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ValueDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ValueDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ValueDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Container:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Container_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Contained:1.0") == 0)
    return ACE_static_cast (POA_CORBA::Contained_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ValueDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueDef:1.0";
}

CORBA::ValueDef*
POA_CORBA::ValueDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::ValueDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_ValueDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::ValueDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_ValueDef::_tao_thru_poa_collocated_ValueDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Container) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_Contained) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::InterfaceDef_ptr POA_CORBA::_tao_thru_poa_collocated_ValueDef::supported_interface  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InterfaceDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "supported_interface",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->supported_interface (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueDef::supported_interface  (
    CORBA::InterfaceDef_ptr supported_interface,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "supported_interface",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->supported_interface (
      supported_interface,
      ACE_TRY_ENV
    );
  return;
}

CORBA::InitializerSeq * POA_CORBA::_tao_thru_poa_collocated_ValueDef::initializers  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::InitializerSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "initializers",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->initializers (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueDef::initializers  (
    const CORBA::InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "initializers",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->initializers (
      initializers,
      ACE_TRY_ENV
    );
  return;
}

CORBA::ValueDef_ptr POA_CORBA::_tao_thru_poa_collocated_ValueDef::base_value  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_value",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->base_value (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueDef::base_value  (
    CORBA::ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "base_value",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->base_value (
      base_value,
      ACE_TRY_ENV
    );
  return;
}

CORBA::ValueDefSeq * POA_CORBA::_tao_thru_poa_collocated_ValueDef::abstract_base_values  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDefSeq_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "abstract_base_values",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->abstract_base_values (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueDef::abstract_base_values  (
    const CORBA::ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "abstract_base_values",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->abstract_base_values (
      abstract_base_values,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueDef::is_abstract  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_abstract",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_abstract (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueDef::is_abstract  (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_abstract",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_abstract (
      is_abstract,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueDef::is_custom  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_custom",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_custom (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueDef::is_custom  (
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_custom",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_custom (
      is_custom,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueDef::is_truncatable  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_truncatable",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_truncatable (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueDef::is_truncatable  (
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_truncatable",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_truncatable (
      is_truncatable,
      ACE_TRY_ENV
    );
  return;
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueDef::is_a  (
    const char * value_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Boolean _tao_retval = 0;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN  (_tao_retval);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->is_a (
      value_id,
      ACE_TRY_ENV
    );

}

CORBA::ValueDef::FullValueDescription * POA_CORBA::_tao_thru_poa_collocated_ValueDef::describe_value  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueDef::FullValueDescription_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "describe_value",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->describe_value (
      ACE_TRY_ENV
    );

}

CORBA::ValueMemberDef_ptr POA_CORBA::_tao_thru_poa_collocated_ValueDef::create_value_member  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ValueMemberDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_value_member",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->create_value_member (
      id,
      name,
      version,
      type,
      access,
      ACE_TRY_ENV
    );

}

CORBA::AttributeDef_ptr POA_CORBA::_tao_thru_poa_collocated_ValueDef::create_attribute  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr type,
    CORBA::AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::AttributeDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_attribute",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->create_attribute (
      id,
      name,
      version,
      type,
      mode,
      ACE_TRY_ENV
    );

}

CORBA::OperationDef_ptr POA_CORBA::_tao_thru_poa_collocated_ValueDef::create_operation  (
    const char * id,
    const char * name,
    const char * version,
    CORBA::IDLType_ptr result,
    CORBA::OperationMode mode,
    const CORBA::ParDescriptionSeq & params,
    const CORBA::ExceptionDefSeq & exceptions,
    const CORBA::ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::OperationDef_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "create_operation",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueDef:1.0"
        )
    )->create_operation (
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );

}



class TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);
public:
 const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};
/* starting time is 22:05:54 */
/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: gperf -m -M -J -c -C -D -E -T -f 0 -F 0 -a -o -t -p -K opname_ -L C++ -Z TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23,  0,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23,  0,
     23, 23,  0,  0,  0, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23,  5, 23, 23, 23, 23,  0, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,
#else
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23,  0, 23,  0, 23, 23,
      0,  0,  0, 23, 23, 23, 23, 23, 23, 23,
     23, 23, 23, 23, 23, 23,  5, 23, 23, 23,
     23,  0, 23, 23, 23, 23, 23, 23,
#endif /* ACE_MVS */
    };
  return len + asso_values[str[len - 1]] + asso_values[str[0]];
}

const class TAO_operation_db_entry *
TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 22,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 22,
      HASH_VALUE_RANGE = 18,
      DUPLICATES = 2
    };

  static const class TAO_operation_db_entry  wordlist[] =
    {
      {"",0},{"",0},{"",0},{"",0},{"",0},
      {"_is_a",  &POA_CORBA::ValueBoxDef::_is_a_skel},
      {"destroy", 	&POA_CORBA::ValueBoxDef::destroy_skel},
      {"_get_type", 	&POA_CORBA::ValueBoxDef::_get_type_skel},
      {"_get_def_kind", 	&POA_CORBA::ValueBoxDef::_get_def_kind_skel},
      {"_non_existent",  &POA_CORBA::ValueBoxDef::_non_existent_skel},
      {"_get_original_type_def", 	&POA_CORBA::ValueBoxDef::_get_original_type_def_skel},
      {"_set_original_type_def", 	&POA_CORBA::ValueBoxDef::_set_original_type_def_skel},
    };

  static const signed char lookup[] =
    {
       -1,  -1,  -1,  -1,  -1,   5,  -1,   6,  -1,   7,  -1,  -1,  -1,   8, 
       -1,  -1,  -1,  -1,   9,  -1, -10,  -2, -24, 
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          int slot = lookup[key];

          if (slot >= 0 && slot < MAX_HASH_VALUE)
            {
              const char *s = wordlist[slot].opname_;

              if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
                return &wordlist[slot];
            }
          else if (slot < 0 && slot >= -MAX_HASH_VALUE)
            return 0;
          else
            {
              unsigned int offset = key + slot + (slot > 0 ? -MAX_HASH_VALUE : MAX_HASH_VALUE);
              const class TAO_operation_db_entry  *base = &wordlist[-lookup[offset]];
              const class TAO_operation_db_entry  *ptr = base + -lookup[offset + 1];

              while (--ptr >= base)
                if (*str == *ptr->opname_ && !strncmp (str + 1, ptr->opname_ + 1, len - 1))
                  return ptr;
            }
        }
    }
  return 0;
}
/* ending time is 22:05:54 */
static TAO_CORBA_ValueBoxDef_Perfect_Hash_OpTable tao_CORBA_ValueBoxDef_optable;

CORBA::ValueBoxDef_ptr _TAO_collocation_POA_CORBA_ValueBoxDef_Stub_Factory (
    CORBA::Object_ptr obj
  )
{
  TAO_Stub *stub = obj->_stubobj ();
  
  switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
    {
    case TAO_ORB_Core::THRU_POA:
      {
      CORBA::ValueBoxDef_ptr retval = 0;
      ACE_NEW_RETURN (
          retval,
          POA_CORBA::_tao_thru_poa_collocated_ValueBoxDef (stub),
          0
        );
      return retval;
      }
    case TAO_ORB_Core::DIRECT:
      break;
    default:
      break;
    }
  return 0;
}

int _TAO_collocation_POA_CORBA_ValueBoxDef_Stub_Factory_Initializer (long dummy)
{
  ACE_UNUSED_ARG (dummy);
  
  _TAO_collocation_CORBA_ValueBoxDef_Stub_Factory_function_pointer = 
    _TAO_collocation_POA_CORBA_ValueBoxDef_Stub_Factory;
  
  return 0;
}

static int _TAO_collocation_POA_CORBA_ValueBoxDef_Stub_Factory_Initializer_Scarecrow = 
  _TAO_collocation_POA_CORBA_ValueBoxDef_Stub_Factory_Initializer (ACE_reinterpret_cast (long, _TAO_collocation_POA_CORBA_ValueBoxDef_Stub_Factory_Initializer));

// skeleton constructor
POA_CORBA::ValueBoxDef::ValueBoxDef (void)
{
  this->optable_ = &tao_CORBA_ValueBoxDef_optable;
}

// copy ctor
POA_CORBA::ValueBoxDef::ValueBoxDef (const ValueBoxDef& rhs)
  :   ACE_NESTED_CLASS (POA_CORBA,IDLType) (rhs),
    ACE_NESTED_CLASS (POA_CORBA,IRObject) (rhs),
    TAO_ServantBase (rhs)
{}

// skeleton destructor
POA_CORBA::ValueBoxDef::~ValueBoxDef (void)
{
}

void POA_CORBA::ValueBoxDef::_get_original_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  POA_CORBA::ValueBoxDef *_tao_impl = (POA_CORBA::ValueBoxDef *)_tao_object_reference;

  CORBA::IDLType_var _tao_retval;
#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_original_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_retval = _tao_impl->original_type_def (
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_original_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_get_original_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!(
    (_tao_out << _tao_retval.in ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

}

void POA_CORBA::ValueBoxDef::_set_original_type_def_skel (
    CORBA::ServerRequest &_tao_server_request,
    void *_tao_object_reference, 
    void * /* context */, 
    CORBA::Environment &ACE_TRY_ENV
)
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueBoxDef *_tao_impl = (POA_CORBA::ValueBoxDef *)_tao_object_reference;

  CORBA::IDLType_var original_type_def;
  if (!(
    (_tao_in >> original_type_def.out ())
  ))
    ACE_THROW (CORBA::MARSHAL () );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ServerRequestInterceptor_Adapter
    _tao_vfr (_tao_server_request.orb ()->_get_server_interceptor (ACE_TRY_ENV));
  ACE_CHECK;
  PortableInterceptor::Cookies _tao_cookies;
  CORBA::NVList_var _tao_interceptor_args;
  CORBA::Object_var _tao_objref;
  if (_tao_vfr.valid ())
    {
      _tao_server_request.orb ()->create_list (0, _tao_interceptor_args.inout (), ACE_TRY_ENV);
      ACE_CHECK;

      _tao_objref = _tao_server_request.objref (ACE_TRY_ENV);
      ACE_CHECK;
    }

  ACE_TRY
    {
      _tao_vfr.preinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_original_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

      _tao_impl->original_type_def (
        original_type_def.in (),
        ACE_TRY_ENV
      );

      TAO_INTERCEPTOR_CHECK;

#if (TAO_HAS_INTERCEPTORS == 1)
      _tao_vfr.postinvoke (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_original_type_def",
          _tao_server_request.service_info (),
          _tao_interceptor_args.inout (),
          _tao_cookies,
          ACE_TRY_ENV
        );
      TAO_INTERCEPTOR_CHECK;
    }
  ACE_CATCHANY
    {
      _tao_vfr.exception_occurred (
          _tao_server_request.request_id (),
          1,
          _tao_objref.in (),
          "_set_original_type_def",
          _tao_cookies,
          ACE_TRY_ENV
        );
      ACE_RETHROW;
    }
  ACE_ENDTRY;
  ACE_CHECK;
#endif /* TAO_HAS_INTERCEPTORS */

  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  }

void POA_CORBA::ValueBoxDef::_is_a_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  TAO_InputCDR &_tao_in = _tao_server_request.incoming ();
  POA_CORBA::ValueBoxDef *_tao_impl = (POA_CORBA::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = 0;
  CORBA::String_var value;
  if (!((_tao_in >> value.out ())))
    ACE_THROW (CORBA::MARSHAL ());
  
  _tao_retval = _tao_impl->_is_a (value.in (), ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

void POA_CORBA::ValueBoxDef::_non_existent_skel (
    CORBA::ServerRequest &_tao_server_request, 
    void * _tao_object_reference,
    void * /* context */,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  POA_CORBA::ValueBoxDef *_tao_impl = (POA_CORBA::ValueBoxDef *) _tao_object_reference;
  CORBA::Boolean _tao_retval = _tao_impl->_non_existent (ACE_TRY_ENV);
  ACE_CHECK;
  
  _tao_server_request.init_reply (ACE_TRY_ENV);
  ACE_CHECK;
  TAO_OutputCDR &_tao_out = _tao_server_request.outgoing ();
  if (!((_tao_out << CORBA::Any::from_boolean (_tao_retval))))
    ACE_THROW (CORBA::MARSHAL ());
}

CORBA::Boolean POA_CORBA::ValueBoxDef::_is_a (
    const char* value,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (ACE_TRY_ENV))))
      return 1;
    else
      return 0;
}

void* POA_CORBA::ValueBoxDef::_downcast (
    const char* logical_type_id
  )
{
if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/ValueBoxDef:1.0") == 0)
    return ACE_static_cast (POA_CORBA::ValueBoxDef_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IDLType:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IDLType_ptr, this);
  if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/IRObject:1.0") == 0)
    return ACE_static_cast (POA_CORBA::IRObject_ptr, this);
    if (ACE_OS::strcmp (logical_type_id, "IDL:omg.org/CORBA/Object:1.0") == 0)
    return ACE_static_cast(PortableServer::Servant, this);
  return 0;
}

void POA_CORBA::ValueBoxDef::_dispatch (CORBA::ServerRequest &req, void *context, CORBA::Environment &ACE_TRY_ENV)
{
  TAO_Skeleton skel; // pointer to skeleton for operation
  const char *opname = req.operation (); // retrieve operation name
  // find the skeleton corresponding to this opname
  if (this->_find (opname, skel, req.operation_length ()) == -1)
  {
    ACE_ERROR ((LM_ERROR, "Bad operation <%s>\n", opname));
    ACE_THROW (CORBA_BAD_OPERATION ());
  }
  else
    skel (req, this, context, ACE_TRY_ENV);
}

const char* POA_CORBA::ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/ValueBoxDef:1.0";
}

CORBA::ValueBoxDef*
POA_CORBA::ValueBoxDef::_this (CORBA_Environment &ACE_TRY_ENV)
{
  TAO_Stub *stub = this->_create_stub (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  if (stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ())
    switch (stub->servant_orb_var ()->orb_core ()->get_collocation_strategy ())
      {
      case TAO_ORB_Core::THRU_POA:
        {
          ::CORBA::ValueBoxDef_ptr retval = 0;
          ACE_NEW_RETURN (
              retval,
              POA_CORBA::_tao_thru_poa_collocated_ValueBoxDef (stub),
              0
            );
          return retval;
        }
      case TAO_ORB_Core::DIRECT:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      default:
        ACE_THROW_RETURN (CORBA::BAD_PARAM (), 0);
      }
  else
    {
      // stub->_incr_refcnt ();
      CORBA::Object_ptr tmp = CORBA::Object::_nil ();
      ACE_NEW_RETURN (tmp, CORBA::Object (stub), 0);
      CORBA::Object_var obj = tmp;
      return ::CORBA::ValueBoxDef::_unchecked_narrow (obj.in ());
    }
}

POA_CORBA::_tao_thru_poa_collocated_ValueBoxDef::_tao_thru_poa_collocated_ValueBoxDef (
  TAO_Stub *stub
)
  :  ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IDLType) (stub),
    ACE_NESTED_CLASS (POA_CORBA,_tao_thru_poa_collocated_IRObject) (stub),
    CORBA_Object (stub, 0, 1)
{
}

CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueBoxDef::_is_a(
    const CORBA::Char *logical_type_id,
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_is_a",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueBoxDef:1.0"
        )
    )->_is_a (logical_type_id, ACE_TRY_ENV);
}


CORBA::Boolean POA_CORBA::_tao_thru_poa_collocated_ValueBoxDef::_non_existent(
    CORBA_Environment &ACE_TRY_ENV
  )

{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "_non_existent",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueBoxDef:1.0"
        )
    )->_non_existent (ACE_TRY_ENV);
}


CORBA::IDLType_ptr POA_CORBA::_tao_thru_poa_collocated_ValueBoxDef::original_type_def  (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::IDLType_var _tao_retval;
  ACE_UNUSED_ARG (_tao_retval);
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "original_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK_RETURN (0);
  return ACE_reinterpret_cast (
      POA_CORBA::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueBoxDef:1.0"
        )
    )->original_type_def (
      ACE_TRY_ENV
    );

}

void POA_CORBA::_tao_thru_poa_collocated_ValueBoxDef::original_type_def  (
    CORBA::IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Object_Adapter::Servant_Upcall servant_upcall (
      *this->_stubobj ()->servant_orb_var ()->orb_core ()->object_adapter ()
    );
  servant_upcall.prepare_for_upcall (
      this->_object_key (),
      "original_type_def",
      ACE_TRY_ENV
    );
  ACE_CHECK;
  ACE_reinterpret_cast (
      POA_CORBA::ValueBoxDef_ptr,
      servant_upcall.servant ()->_downcast (
          "IDL:omg.org/CORBA/ValueBoxDef:1.0"
        )
    )->original_type_def (
      original_type_def,
      ACE_TRY_ENV
    );
  return;
}

#endif /* TAO_HAS_INTERFACE_REPOSITORY == 1 */


