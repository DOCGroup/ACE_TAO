/* -*- C++ -*- $Id$ */

// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO and the TAO IDL Compiler have been developed by the Center for
// Distributed Object Computing at Washington University, St. Louis.
//
// Information about TAO is available at:
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

#include "tao/PortableInterceptorC.h"
#if (TAO_HAS_INTERCEPTORS == 1)
//Added
#include "tao/corba.h"

#if !defined (__ACE_INLINE__)
#include "tao/PortableInterceptorC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_PortableInterceptor_RepositoryId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/RepositoryId:1.0
  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_RepositoryId (CORBA::tk_alias, sizeof (_oc_PortableInterceptor_RepositoryId), (char *) &_oc_PortableInterceptor_RepositoryId, 0, sizeof (PortableInterceptor::RepositoryId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryId, &_tc_TAO_tc_PortableInterceptor_RepositoryId)
TAO_NAMESPACE_END

#if !defined (_PORTABLEINTERCEPTOR_OCTETSEQ_CS_)
#define _PORTABLEINTERCEPTOR_OCTETSEQ_CS_

// *************************************************************
// PortableInterceptor::OctetSeq
// *************************************************************

PortableInterceptor::OctetSeq::OctetSeq (void)
{}
PortableInterceptor::OctetSeq::OctetSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableInterceptor::OctetSeq::OctetSeq (CORBA::ULong max, CORBA::ULong length, CORBA::Octet *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableInterceptor::OctetSeq::OctetSeq (const OctetSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableInterceptor::OctetSeq::~OctetSeq (void) // dtor
{}
void PortableInterceptor::OctetSeq::_tao_any_destructor (void *x)
{
  OctetSeq *tmp = ACE_static_cast (OctetSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableInterceptor_OctetSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x4f637465), ACE_NTOHL (0x74536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/OctetSeq:1.0
  9, ACE_NTOHL (0x4f637465), ACE_NTOHL (0x74536571), ACE_NTOHL (0x0),  // name = OctetSeq
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_OctetSeq (CORBA::tk_alias, sizeof (_oc_PortableInterceptor_OctetSeq), (char *) &_oc_PortableInterceptor_OctetSeq, 0, sizeof (PortableInterceptor::OctetSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OctetSeq, &_tc_TAO_tc_PortableInterceptor_OctetSeq)
TAO_NAMESPACE_END

#if !defined (_PORTABLEINTERCEPTOR_STRINGSEQ_CS_)
#define _PORTABLEINTERCEPTOR_STRINGSEQ_CS_

// *************************************************************
// PortableInterceptor::StringSeq
// *************************************************************

PortableInterceptor::StringSeq::StringSeq (void)
{}
PortableInterceptor::StringSeq::StringSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
PortableInterceptor::StringSeq::StringSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
PortableInterceptor::StringSeq::StringSeq (const StringSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
PortableInterceptor::StringSeq::~StringSeq (void) // dtor
{}
void PortableInterceptor::StringSeq::_tao_any_destructor (void *x)
{
  StringSeq *tmp = ACE_static_cast (StringSeq*,x);
  delete tmp;
}


#endif /* end #if !defined */

static const CORBA::Long _oc_PortableInterceptor_StringSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x53747269), ACE_NTOHL (0x6e675365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:PortableInterceptor/StringSeq:1.0
  10, ACE_NTOHL (0x53747269), ACE_NTOHL (0x6e675365), ACE_NTOHL (0x71000000),  // name = StringSeq
  CORBA::tk_sequence, // typecode kind
  16, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_string, 
    0U, // string length
    0U,

};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_StringSeq (CORBA::tk_alias, sizeof (_oc_PortableInterceptor_StringSeq), (char *) &_oc_PortableInterceptor_StringSeq, 0, sizeof (PortableInterceptor::StringSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StringSeq, &_tc_TAO_tc_PortableInterceptor_StringSeq)
TAO_NAMESPACE_END

// default constructor
PortableInterceptor::Interceptor::Interceptor (void)
{}

// destructor
PortableInterceptor::Interceptor::~Interceptor (void)
{}

void PortableInterceptor::Interceptor::_tao_any_destructor (void *x)
{
  Interceptor *tmp = ACE_static_cast (Interceptor*,x);
  CORBA::release (tmp);
}

PortableInterceptor::Interceptor_ptr PortableInterceptor::Interceptor::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Interceptor::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/Interceptor:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (Interceptor::_nil ());
      if (is_a == 0)
        return Interceptor::_nil ();
    }
  return Interceptor::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableInterceptor::Interceptor_ptr PortableInterceptor::Interceptor::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Interceptor::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Interceptor_ptr default_proxy = Interceptor::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_Interceptor_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_PortableInterceptor_Interceptor_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::Interceptor (stub), Interceptor::_nil ());
     
      return default_proxy;
      
    }
  else 
    return
      ACE_reinterpret_cast
        (
          Interceptor_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Interceptor::_narrow
                  )
              )
        );
}

PortableInterceptor::Interceptor_ptr
PortableInterceptor::Interceptor::_duplicate (Interceptor_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

char * PortableInterceptor::Interceptor::name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_name",
      9,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Boolean PortableInterceptor::Interceptor::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/Interceptor:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::Interceptor::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, Interceptor)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::Interceptor::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/Interceptor:1.0";
}


static const CORBA::Long _oc_PortableInterceptor_Interceptor[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/Interceptor:1.0
  12, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f7200),  // name = Interceptor
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_Interceptor (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_Interceptor), (char *) &_oc_PortableInterceptor_Interceptor, 0, sizeof (PortableInterceptor::Interceptor));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Interceptor, &_tc_TAO_tc_PortableInterceptor_Interceptor)
TAO_NAMESPACE_END
// default constructor
PortableInterceptor::ForwardRequest::ForwardRequest (void)
  : CORBA_UserException ("IDL:PortableInterceptor/ForwardRequest:1.0")
{
}

// destructor - all members are of self managing types
PortableInterceptor::ForwardRequest::~ForwardRequest (void)
{
}

void PortableInterceptor::ForwardRequest::_tao_any_destructor (void *x)
{
  ForwardRequest *tmp = ACE_static_cast (ForwardRequest*,x);
  delete tmp;
}

// copy constructor
PortableInterceptor::ForwardRequest::ForwardRequest (const ::PortableInterceptor::ForwardRequest &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
    this->forward = CORBA::Object::_duplicate (_tao_excp.forward.in ());
  this->permanent = _tao_excp.permanent;
}

// assignment operator
PortableInterceptor::ForwardRequest&
PortableInterceptor::ForwardRequest::operator= (const ::PortableInterceptor::ForwardRequest &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  this->forward = CORBA::Object::_duplicate (_tao_excp.forward.in ());
  this->permanent = _tao_excp.permanent;
  return *this;
}

// narrow
PortableInterceptor::ForwardRequest *
PortableInterceptor::ForwardRequest::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableInterceptor/ForwardRequest:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (ForwardRequest *, exc);
  else
    return 0;
}


void PortableInterceptor::ForwardRequest::_raise ()
{
  TAO_RAISE(*this);
}


void PortableInterceptor::ForwardRequest::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void PortableInterceptor::ForwardRequest::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *PortableInterceptor::ForwardRequest::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableInterceptor::ForwardRequest, 0);
  return retval;
}

PortableInterceptor::ForwardRequest::ForwardRequest (
  const CORBA::Object_ptr  _tao_forward,
  CORBA::Boolean _tao_permanent
)
  : CORBA_UserException  (CORBA::string_dup ("IDL:PortableInterceptor/ForwardRequest:1.0"))
{
    this->forward = CORBA::Object::_duplicate (_tao_forward);
  this->permanent = _tao_permanent;
}

static const CORBA::Long _oc_PortableInterceptor_ForwardRequest[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x466f7277), ACE_NTOHL (0x61726452), ACE_NTOHL (0x65717565), ACE_NTOHL (0x73743a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:PortableInterceptor/ForwardRequest:1.0
  15, ACE_NTOHL (0x466f7277), ACE_NTOHL (0x61726452), ACE_NTOHL (0x65717565), ACE_NTOHL (0x73740000),  // name = ForwardRequest
  2, // member count
  8, ACE_NTOHL (0x666f7277), ACE_NTOHL (0x61726400),  // name = forward
  CORBA::tk_objref,
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
    7, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63740000),  // name = Object

  10, ACE_NTOHL (0x7065726d), ACE_NTOHL (0x616e656e), ACE_NTOHL (0x74000000),  // name = permanent
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ForwardRequest (CORBA::tk_except, sizeof (_oc_PortableInterceptor_ForwardRequest), (char *) &_oc_PortableInterceptor_ForwardRequest, 0, sizeof (PortableInterceptor::ForwardRequest));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ForwardRequest, &_tc_TAO_tc_PortableInterceptor_ForwardRequest)
TAO_NAMESPACE_END

// TAO extension - the virtual _type method
CORBA::TypeCode_ptr PortableInterceptor::ForwardRequest::_type (void) const
{
  return ::PortableInterceptor::_tc_ForwardRequest;
}

static const CORBA::Long _oc_PortableInterceptor_ReplyStatus[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x5265706c), ACE_NTOHL (0x79537461), ACE_NTOHL (0x7475733a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/ReplyStatus:1.0
  12, ACE_NTOHL (0x5265706c), ACE_NTOHL (0x79537461), ACE_NTOHL (0x74757300),  // name = ReplyStatus
  CORBA::tk_short,

};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ReplyStatus (CORBA::tk_alias, sizeof (_oc_PortableInterceptor_ReplyStatus), (char *) &_oc_PortableInterceptor_ReplyStatus, 0, sizeof (PortableInterceptor::ReplyStatus));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ReplyStatus, &_tc_TAO_tc_PortableInterceptor_ReplyStatus)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SUCCESSFUL, 0)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, SYSTEM_EXCEPTION, 1)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, USER_EXCEPTION, 2)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, LOCATION_FORWARD, 3)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, LOCATION_FORWARD_PERMANENT, 4)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::Short)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (const CORBA::Short, TRANSPORT_RETRY, 5)
TAO_NAMESPACE_END
static const CORBA::Long _oc_PortableInterceptor_SlotId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x536c6f74), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:PortableInterceptor/SlotId:1.0
  7, ACE_NTOHL (0x536c6f74), ACE_NTOHL (0x49640000),  // name = SlotId
  CORBA::tk_ulong,

};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_SlotId (CORBA::tk_alias, sizeof (_oc_PortableInterceptor_SlotId), (char *) &_oc_PortableInterceptor_SlotId, 0, sizeof (PortableInterceptor::SlotId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SlotId, &_tc_TAO_tc_PortableInterceptor_SlotId)
TAO_NAMESPACE_END
// default constructor
PortableInterceptor::InvalidSlot::InvalidSlot (void)
  : CORBA_UserException ("IDL:PortableInterceptor/InvalidSlot:1.0")
{
}

// destructor - all members are of self managing types
PortableInterceptor::InvalidSlot::~InvalidSlot (void)
{
}

void PortableInterceptor::InvalidSlot::_tao_any_destructor (void *x)
{
  InvalidSlot *tmp = ACE_static_cast (InvalidSlot*,x);
  delete tmp;
}

// copy constructor
PortableInterceptor::InvalidSlot::InvalidSlot (const ::PortableInterceptor::InvalidSlot &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// assignment operator
PortableInterceptor::InvalidSlot&
PortableInterceptor::InvalidSlot::operator= (const ::PortableInterceptor::InvalidSlot &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
PortableInterceptor::InvalidSlot *
PortableInterceptor::InvalidSlot::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableInterceptor/InvalidSlot:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (InvalidSlot *, exc);
  else
    return 0;
}


void PortableInterceptor::InvalidSlot::_raise ()
{
  TAO_RAISE(*this);
}


void PortableInterceptor::InvalidSlot::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void PortableInterceptor::InvalidSlot::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *PortableInterceptor::InvalidSlot::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableInterceptor::InvalidSlot, 0);
  return retval;
}

static const CORBA::Long _oc_PortableInterceptor_InvalidSlot[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x496e7661), ACE_NTOHL (0x6c696453), ACE_NTOHL (0x6c6f743a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/InvalidSlot:1.0
  12, ACE_NTOHL (0x496e7661), ACE_NTOHL (0x6c696453), ACE_NTOHL (0x6c6f7400),  // name = InvalidSlot
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_InvalidSlot (CORBA::tk_except, sizeof (_oc_PortableInterceptor_InvalidSlot), (char *) &_oc_PortableInterceptor_InvalidSlot, 0, sizeof (PortableInterceptor::InvalidSlot));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InvalidSlot, &_tc_TAO_tc_PortableInterceptor_InvalidSlot)
TAO_NAMESPACE_END

// TAO extension - the virtual _type method
CORBA::TypeCode_ptr PortableInterceptor::InvalidSlot::_type (void) const
{
  return ::PortableInterceptor::_tc_InvalidSlot;
}


// default constructor
PortableInterceptor::Current::Current (void)
{}

// destructor
PortableInterceptor::Current::~Current (void)
{}

void PortableInterceptor::Current::_tao_any_destructor (void *x)
{
  Current *tmp = ACE_static_cast (Current*,x);
  CORBA::release (tmp);
}

PortableInterceptor::Current_ptr PortableInterceptor::Current::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return Current::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/Current:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (Current::_nil ());
      if (is_a == 0)
        return Current::_nil ();
    }
  return Current::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableInterceptor::Current_ptr PortableInterceptor::Current::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return Current::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      Current_ptr default_proxy = Current::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_Current_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_PortableInterceptor_Current_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::Current (stub), Current::_nil ());
        return default_proxy;

    }
  else 
    return
      ACE_reinterpret_cast
        (
          Current_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &Current::_narrow
                  )
              )
        );
}

PortableInterceptor::Current_ptr
PortableInterceptor::Current::_duplicate (Current_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Any * PortableInterceptor::Current::get_slot (
    PortableInterceptor::SlotId id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::InvalidSlot
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_Current_get_slot_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_InvalidSlot, PortableInterceptor::InvalidSlot::_alloc}
  };

  CORBA::Any *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  CORBA::Any_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_slot",
      8,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_Current_get_slot_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

void PortableInterceptor::Current::set_slot (
    PortableInterceptor::SlotId id,
    const CORBA::Any & data,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::InvalidSlot
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_Current_set_slot_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_InvalidSlot, PortableInterceptor::InvalidSlot::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_slot",
      8,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id) &&
            (_tao_out << data)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_Current_set_slot_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::Current::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/Current:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Current:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::Current::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, Current)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &::CORBA::Current::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA::Current_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::Current::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/Current:1.0";
}


  static const CORBA::Long _oc_PortableInterceptor_Current[] =
  {
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x43757272), ACE_NTOHL (0x656e743a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/Current:1.0
    8, ACE_NTOHL (0x43757272), ACE_NTOHL (0x656e7400),  // name = Current
};
  static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_Current (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_Current), (char *) &_oc_PortableInterceptor_Current, 0, sizeof (PortableInterceptor::Current));
  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (PortableInterceptor)
  TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Current, &_tc_TAO_tc_PortableInterceptor_Current)
  TAO_NAMESPACE_END
    
  // default constructor
  PortableInterceptor::RequestInfo::RequestInfo (void)
  {}
  
  // destructor
  PortableInterceptor::RequestInfo::~RequestInfo (void)
  {}
  
  void PortableInterceptor::RequestInfo::_tao_any_destructor (void *x)
  {
    RequestInfo *tmp = ACE_static_cast (RequestInfo*,x);
    CORBA::release (tmp);
  }

  PortableInterceptor::RequestInfo_ptr PortableInterceptor::RequestInfo::_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV
    )
  {
    if (CORBA::is_nil (obj))
      return RequestInfo::_nil ();
    if (! obj->_is_local ())
      {
        CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/RequestInfo:1.0", ACE_TRY_ENV);
        ACE_CHECK_RETURN (RequestInfo::_nil ());
        if (is_a == 0)
          return RequestInfo::_nil ();
      }
    return RequestInfo::_unchecked_narrow (obj, ACE_TRY_ENV);
  }
  
  PortableInterceptor::RequestInfo_ptr PortableInterceptor::RequestInfo::_unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &
    )
  {
    if (CORBA::is_nil (obj))
      return RequestInfo::_nil ();
    if (! obj->_is_local ())
      {
        TAO_Stub* stub = obj->_stubobj ();
        if (stub)
          stub->_incr_refcnt ();
        RequestInfo_ptr default_proxy = RequestInfo::_nil ();

        if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_RequestInfo_Stub_Factory_function_pointer != 0)
          {
            default_proxy = _TAO_collocation_PortableInterceptor_RequestInfo_Stub_Factory_function_pointer (obj);
          }
        if (CORBA::is_nil (default_proxy))
          ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::RequestInfo (stub), RequestInfo::_nil ());
          return default_proxy;

      }
    else 
      return
        ACE_reinterpret_cast
          (
            RequestInfo_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &RequestInfo::_narrow
                    )
                )
          );
}

PortableInterceptor::RequestInfo_ptr
PortableInterceptor::RequestInfo::_duplicate (RequestInfo_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::ULong PortableInterceptor::RequestInfo::request_id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_request_id",
      15,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN  (_tao_retval);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN  (_tao_retval);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN  (_tao_retval);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_retval)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    break;
    
  }
return _tao_retval;
}

char * PortableInterceptor::RequestInfo::operation (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_operation",
      14,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

Dynamic::ParameterList * PortableInterceptor::RequestInfo::arguments (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  Dynamic::ParameterList *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, Dynamic::ParameterList, _tao_retval);
  Dynamic::ParameterList_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_arguments",
      14,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

Dynamic::ExceptionList * PortableInterceptor::RequestInfo::exceptions (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  Dynamic::ExceptionList *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, Dynamic::ExceptionList, _tao_retval);
  Dynamic::ExceptionList_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_exceptions",
      15,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

Dynamic::ContextList * PortableInterceptor::RequestInfo::contexts (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  Dynamic::ContextList *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, Dynamic::ContextList, _tao_retval);
  Dynamic::ContextList_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_contexts",
      13,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

Dynamic::RequestContext * PortableInterceptor::RequestInfo::operation_context (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  Dynamic::RequestContext *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, Dynamic::RequestContext, _tao_retval);
  Dynamic::RequestContext_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_operation_context",
      22,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Any * PortableInterceptor::RequestInfo::result (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Any *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  CORBA::Any_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result",
      11,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Boolean PortableInterceptor::RequestInfo::response_expected (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_response_expected",
      22,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN  (_tao_retval);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN  (_tao_retval);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN  (_tao_retval);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    break;
    
  }
return _tao_retval;
}

Messaging::SyncScope PortableInterceptor::RequestInfo::sync_scope (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  Messaging::SyncScope _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_sync_scope",
      15,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN  (_tao_retval);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN  (_tao_retval);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN  (_tao_retval);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_retval)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    break;
    
  }
return _tao_retval;
}

PortableInterceptor::ReplyStatus PortableInterceptor::RequestInfo::reply_status (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  PortableInterceptor::ReplyStatus _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_reply_status",
      17,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN  (_tao_retval);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN  (_tao_retval);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN  (_tao_retval);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_retval)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    break;
    
  }
return _tao_retval;
}

CORBA::Object_ptr PortableInterceptor::RequestInfo::forward_reference (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Object_ptr _tao_retval = CORBA::Object::_nil ();
  CORBA::Object_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_forward_reference",
      22,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Any * PortableInterceptor::RequestInfo::get_slot (
    PortableInterceptor::SlotId id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::InvalidSlot
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_RequestInfo_get_slot_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_InvalidSlot, PortableInterceptor::InvalidSlot::_alloc}
  };

  CORBA::Any *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  CORBA::Any_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_slot",
      8,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);
      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_RequestInfo_get_slot_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

IOP::ServiceContext * PortableInterceptor::RequestInfo::get_request_service_context (
    IOP::ServiceId id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IOP::ServiceContext *_tao_retval = 0;
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IOP::ServiceContext, _tao_retval);
  IOP::ServiceContext_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_request_service_context",
      27,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

IOP::ServiceContext * PortableInterceptor::RequestInfo::get_reply_service_context (
    IOP::ServiceId id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IOP::ServiceContext *_tao_retval = 0;
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IOP::ServiceContext, _tao_retval);
  IOP::ServiceContext_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_reply_service_context",
      25,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Boolean PortableInterceptor::RequestInfo::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/RequestInfo:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::RequestInfo::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, RequestInfo)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::RequestInfo::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/RequestInfo:1.0";
}


static const CORBA::Long _oc_PortableInterceptor_RequestInfo[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737449), ACE_NTOHL (0x6e666f3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/RequestInfo:1.0
  12, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737449), ACE_NTOHL (0x6e666f00),  // name = RequestInfo
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_RequestInfo (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_RequestInfo), (char *) &_oc_PortableInterceptor_RequestInfo, 0, sizeof (PortableInterceptor::RequestInfo));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestInfo, &_tc_TAO_tc_PortableInterceptor_RequestInfo)
TAO_NAMESPACE_END

// default constructor
PortableInterceptor::ClientRequestInfo::ClientRequestInfo (void)
{}

// destructor
PortableInterceptor::ClientRequestInfo::~ClientRequestInfo (void)
{}

void PortableInterceptor::ClientRequestInfo::_tao_any_destructor (void *x)
{
  ClientRequestInfo *tmp = ACE_static_cast (ClientRequestInfo*,x);
  CORBA::release (tmp);
}

PortableInterceptor::ClientRequestInfo_ptr PortableInterceptor::ClientRequestInfo::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ClientRequestInfo::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/ClientRequestInfo:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (ClientRequestInfo::_nil ());
      if (is_a == 0)
        return ClientRequestInfo::_nil ();
    }
  return ClientRequestInfo::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableInterceptor::ClientRequestInfo_ptr PortableInterceptor::ClientRequestInfo::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ClientRequestInfo::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ClientRequestInfo_ptr default_proxy = ClientRequestInfo::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_ClientRequestInfo_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_PortableInterceptor_ClientRequestInfo_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::ClientRequestInfo (stub), ClientRequestInfo::_nil ());
        return default_proxy;

    }
  else 
    return
      ACE_reinterpret_cast
        (
          ClientRequestInfo_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ClientRequestInfo::_narrow
                  )
              )
        );
}

PortableInterceptor::ClientRequestInfo_ptr
PortableInterceptor::ClientRequestInfo::_duplicate (ClientRequestInfo_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Object_ptr PortableInterceptor::ClientRequestInfo::target (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Object_ptr _tao_retval = CORBA::Object::_nil ();
  CORBA::Object_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_target",
      11,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Object_ptr PortableInterceptor::ClientRequestInfo::effective_target (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Object_ptr _tao_retval = CORBA::Object::_nil ();
  CORBA::Object_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_effective_target",
      21,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

IOP::TaggedProfile * PortableInterceptor::ClientRequestInfo::effective_profile (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IOP::TaggedProfile *_tao_retval = 0;
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IOP::TaggedProfile, _tao_retval);
  IOP::TaggedProfile_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_effective_profile",
      22,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Any * PortableInterceptor::ClientRequestInfo::received_exception (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Any *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  CORBA::Any_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_received_exception",
      23,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

char * PortableInterceptor::ClientRequestInfo::received_exception_id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_received_exception_id",
      26,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

IOP::TaggedComponent * PortableInterceptor::ClientRequestInfo::get_effective_component (
    IOP::ComponentId id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IOP::TaggedComponent *_tao_retval = 0;
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IOP::TaggedComponent, _tao_retval);
  IOP::TaggedComponent_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_effective_component",
      23,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Policy_ptr PortableInterceptor::ClientRequestInfo::get_request_policy (
    CORBA::PolicyType type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Policy_ptr _tao_retval = CORBA::Policy::_nil ();
  CORBA::Policy_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_request_policy",
      18,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << type)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

void PortableInterceptor::ClientRequestInfo::add_request_service_context (
    const IOP::ServiceContext & service_context,
    CORBA::Boolean replace,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "add_request_service_context",
      27,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << service_context) &&
            (_tao_out << CORBA::Any::from_boolean (replace))
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::ClientRequestInfo::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/ClientRequestInfo:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/RequestInfo:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::ClientRequestInfo::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, ClientRequestInfo)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, RequestInfo)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            PortableInterceptor::RequestInfo_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::ClientRequestInfo::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/ClientRequestInfo:1.0";
}


  static const CORBA::Long _oc_PortableInterceptor_ClientRequestInfo[] =
  {
    TAO_ENCAP_BYTE_ORDER, // byte order
    46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x436c6965), ACE_NTOHL (0x6e745265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74496e66), ACE_NTOHL (0x6f3a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:PortableInterceptor/ClientRequestInfo:1.0
    18, ACE_NTOHL (0x436c6965), ACE_NTOHL (0x6e745265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74496e66), ACE_NTOHL (0x6f000000),  // name = ClientRequestInfo
};
  static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ClientRequestInfo (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_ClientRequestInfo), (char *) &_oc_PortableInterceptor_ClientRequestInfo, 0, sizeof (PortableInterceptor::ClientRequestInfo));
  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (PortableInterceptor)
  TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ClientRequestInfo, &_tc_TAO_tc_PortableInterceptor_ClientRequestInfo)
  TAO_NAMESPACE_END
    
  // default constructor
  PortableInterceptor::ServerRequestInfo::ServerRequestInfo (void)
  {}
  
  // destructor
  PortableInterceptor::ServerRequestInfo::~ServerRequestInfo (void)
  {}
  
  void PortableInterceptor::ServerRequestInfo::_tao_any_destructor (void *x)
  {
    ServerRequestInfo *tmp = ACE_static_cast (ServerRequestInfo*,x);
    CORBA::release (tmp);
  }

  PortableInterceptor::ServerRequestInfo_ptr PortableInterceptor::ServerRequestInfo::_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV
    )
  {
    if (CORBA::is_nil (obj))
      return ServerRequestInfo::_nil ();
    if (! obj->_is_local ())
      {
        CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/ServerRequestInfo:1.0", ACE_TRY_ENV);
        ACE_CHECK_RETURN (ServerRequestInfo::_nil ());
        if (is_a == 0)
          return ServerRequestInfo::_nil ();
      }
    return ServerRequestInfo::_unchecked_narrow (obj, ACE_TRY_ENV);
  }
  
  PortableInterceptor::ServerRequestInfo_ptr PortableInterceptor::ServerRequestInfo::_unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &
    )
  {
    if (CORBA::is_nil (obj))
      return ServerRequestInfo::_nil ();
    if (! obj->_is_local ())
      {
        TAO_Stub* stub = obj->_stubobj ();
        if (stub)
          stub->_incr_refcnt ();
        ServerRequestInfo_ptr default_proxy = ServerRequestInfo::_nil ();

        if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_ServerRequestInfo_Stub_Factory_function_pointer != 0)
          {
            default_proxy = _TAO_collocation_PortableInterceptor_ServerRequestInfo_Stub_Factory_function_pointer (obj);
          }
        if (CORBA::is_nil (default_proxy))
          ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::ServerRequestInfo (stub), ServerRequestInfo::_nil ());
          return default_proxy;

      }
    else 
      return
        ACE_reinterpret_cast
          (
            ServerRequestInfo_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ServerRequestInfo::_narrow
                    )
                )
          );
}

PortableInterceptor::ServerRequestInfo_ptr
PortableInterceptor::ServerRequestInfo::_duplicate (ServerRequestInfo_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Any * PortableInterceptor::ServerRequestInfo::sending_exception (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Any *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  CORBA::Any_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_sending_exception",
      22,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

PortableInterceptor::OctetSeq * PortableInterceptor::ServerRequestInfo::object_id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  PortableInterceptor::OctetSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, PortableInterceptor::OctetSeq, _tao_retval);
  PortableInterceptor::OctetSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_object_id",
      14,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

PortableInterceptor::OctetSeq * PortableInterceptor::ServerRequestInfo::adapter_id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  PortableInterceptor::OctetSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, PortableInterceptor::OctetSeq, _tao_retval);
  PortableInterceptor::OctetSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_adapter_id",
      15,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

char * PortableInterceptor::ServerRequestInfo::target_most_derived_interface (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_target_most_derived_interface",
      34,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Policy_ptr PortableInterceptor::ServerRequestInfo::get_server_policy (
    CORBA::PolicyType type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Policy_ptr _tao_retval = CORBA::Policy::_nil ();
  CORBA::Policy_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_server_policy",
      17,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << type)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

void PortableInterceptor::ServerRequestInfo::set_slot (
    PortableInterceptor::SlotId id,
    const CORBA::Any & data,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::InvalidSlot
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ServerRequestInfo_set_slot_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_InvalidSlot, PortableInterceptor::InvalidSlot::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "set_slot",
      8,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id) &&
            (_tao_out << data)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ServerRequestInfo_set_slot_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::ServerRequestInfo::target_is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "target_is_a",
      11,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN  (_tao_retval);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN  (_tao_retval);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), _tao_retval);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN  (_tao_retval);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    break;
    
  }
return _tao_retval;
}

void PortableInterceptor::ServerRequestInfo::add_reply_service_context (
    const IOP::ServiceContext & service_context,
    CORBA::Boolean replace,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "add_reply_service_context",
      25,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << service_context) &&
            (_tao_out << CORBA::Any::from_boolean (replace))
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::ServerRequestInfo::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/ServerRequestInfo:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/RequestInfo:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::ServerRequestInfo::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, ServerRequestInfo)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, RequestInfo)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            PortableInterceptor::RequestInfo_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::ServerRequestInfo::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/ServerRequestInfo:1.0";
}


  static const CORBA::Long _oc_PortableInterceptor_ServerRequestInfo[] =
  {
    TAO_ENCAP_BYTE_ORDER, // byte order
    46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65725265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74496e66), ACE_NTOHL (0x6f3a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:PortableInterceptor/ServerRequestInfo:1.0
    18, ACE_NTOHL (0x53657276), ACE_NTOHL (0x65725265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74496e66), ACE_NTOHL (0x6f000000),  // name = ServerRequestInfo
};
  static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ServerRequestInfo (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_ServerRequestInfo), (char *) &_oc_PortableInterceptor_ServerRequestInfo, 0, sizeof (PortableInterceptor::ServerRequestInfo));
  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (PortableInterceptor)
  TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServerRequestInfo, &_tc_TAO_tc_PortableInterceptor_ServerRequestInfo)
  TAO_NAMESPACE_END
    
  // default constructor
  PortableInterceptor::ClientRequestInterceptor::ClientRequestInterceptor (void)
  {}
  
  // destructor
  PortableInterceptor::ClientRequestInterceptor::~ClientRequestInterceptor (void)
  {}
  
  void PortableInterceptor::ClientRequestInterceptor::_tao_any_destructor (void *x)
  {
    ClientRequestInterceptor *tmp = ACE_static_cast (ClientRequestInterceptor*,x);
    CORBA::release (tmp);
  }

  PortableInterceptor::ClientRequestInterceptor_ptr PortableInterceptor::ClientRequestInterceptor::_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV
    )
  {
    if (CORBA::is_nil (obj))
      return ClientRequestInterceptor::_nil ();
    if (! obj->_is_local ())
      {
        CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/ClientRequestInterceptor:1.0", ACE_TRY_ENV);
        ACE_CHECK_RETURN (ClientRequestInterceptor::_nil ());
        if (is_a == 0)
          return ClientRequestInterceptor::_nil ();
      }
    return ClientRequestInterceptor::_unchecked_narrow (obj, ACE_TRY_ENV);
  }
  
  PortableInterceptor::ClientRequestInterceptor_ptr PortableInterceptor::ClientRequestInterceptor::_unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &
    )
  {
    if (CORBA::is_nil (obj))
      return ClientRequestInterceptor::_nil ();
    if (! obj->_is_local ())
      {
        TAO_Stub* stub = obj->_stubobj ();
        if (stub)
          stub->_incr_refcnt ();
        ClientRequestInterceptor_ptr default_proxy = ClientRequestInterceptor::_nil ();

        if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_ClientRequestInterceptor_Stub_Factory_function_pointer != 0)
          {
            default_proxy = _TAO_collocation_PortableInterceptor_ClientRequestInterceptor_Stub_Factory_function_pointer (obj);
          }
        if (CORBA::is_nil (default_proxy))
          ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::ClientRequestInterceptor (stub), ClientRequestInterceptor::_nil ());
          return default_proxy;

      }
    else 
      return
        ACE_reinterpret_cast
          (
            ClientRequestInterceptor_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ClientRequestInterceptor::_narrow
                    )
                )
          );
}

PortableInterceptor::ClientRequestInterceptor_ptr
PortableInterceptor::ClientRequestInterceptor::_duplicate (ClientRequestInterceptor_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void PortableInterceptor::ClientRequestInterceptor::send_request (
    PortableInterceptor::ClientRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ForwardRequest
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ClientRequestInterceptor_send_request_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_ForwardRequest, PortableInterceptor::ForwardRequest::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "send_request",
      12,
      istub->orb_core ()
    );

    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ClientRequestInterceptor_send_request_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ClientRequestInterceptor::send_poll (
    PortableInterceptor::ClientRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "send_poll",
      9,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ClientRequestInterceptor::receive_reply (
    PortableInterceptor::ClientRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "receive_reply",
      13,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ClientRequestInterceptor::receive_exception (
    PortableInterceptor::ClientRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ForwardRequest
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ClientRequestInterceptor_receive_exception_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_ForwardRequest, PortableInterceptor::ForwardRequest::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "receive_exception",
      17,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ClientRequestInterceptor_receive_exception_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ClientRequestInterceptor::receive_other (
    PortableInterceptor::ClientRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ForwardRequest
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ClientRequestInterceptor_receive_other_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_ForwardRequest, PortableInterceptor::ForwardRequest::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "receive_other",
      13,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ClientRequestInterceptor_receive_other_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::ClientRequestInterceptor::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/ClientRequestInterceptor:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/Interceptor:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::ClientRequestInterceptor::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, ClientRequestInterceptor)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, Interceptor)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            PortableInterceptor::Interceptor_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::ClientRequestInterceptor::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/ClientRequestInterceptor:1.0";
}


static const CORBA::Long _oc_PortableInterceptor_ClientRequestInterceptor[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  53, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x436c6965), ACE_NTOHL (0x6e745265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74496e74), ACE_NTOHL (0x65726365), ACE_NTOHL (0x70746f72), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/ClientRequestInterceptor:1.0
  25, ACE_NTOHL (0x436c6965), ACE_NTOHL (0x6e745265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74496e74), ACE_NTOHL (0x65726365), ACE_NTOHL (0x70746f72), ACE_NTOHL (0x0),  // name = ClientRequestInterceptor
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ClientRequestInterceptor (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_ClientRequestInterceptor), (char *) &_oc_PortableInterceptor_ClientRequestInterceptor, 0, sizeof (PortableInterceptor::ClientRequestInterceptor));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ClientRequestInterceptor, &_tc_TAO_tc_PortableInterceptor_ClientRequestInterceptor)
TAO_NAMESPACE_END

// default constructor
PortableInterceptor::ServerRequestInterceptor::ServerRequestInterceptor (void)
{}

// destructor
PortableInterceptor::ServerRequestInterceptor::~ServerRequestInterceptor (void)
{}

void PortableInterceptor::ServerRequestInterceptor::_tao_any_destructor (void *x)
{
  ServerRequestInterceptor *tmp = ACE_static_cast (ServerRequestInterceptor*,x);
  CORBA::release (tmp);
}

PortableInterceptor::ServerRequestInterceptor_ptr PortableInterceptor::ServerRequestInterceptor::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ServerRequestInterceptor::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/ServerRequestInterceptor:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (ServerRequestInterceptor::_nil ());
      if (is_a == 0)
        return ServerRequestInterceptor::_nil ();
    }
  return ServerRequestInterceptor::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableInterceptor::ServerRequestInterceptor_ptr PortableInterceptor::ServerRequestInterceptor::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ServerRequestInterceptor::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ServerRequestInterceptor_ptr default_proxy = ServerRequestInterceptor::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_ServerRequestInterceptor_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_PortableInterceptor_ServerRequestInterceptor_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::ServerRequestInterceptor (stub), ServerRequestInterceptor::_nil ());
        return default_proxy;

    }
  else 
    return
      ACE_reinterpret_cast
        (
          ServerRequestInterceptor_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ServerRequestInterceptor::_narrow
                  )
              )
        );
}

PortableInterceptor::ServerRequestInterceptor_ptr
PortableInterceptor::ServerRequestInterceptor::_duplicate (ServerRequestInterceptor_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void PortableInterceptor::ServerRequestInterceptor::receive_request_service_contexts (
    PortableInterceptor::ServerRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ForwardRequest
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ServerRequestInterceptor_receive_request_service_contexts_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_ForwardRequest, PortableInterceptor::ForwardRequest::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "receive_request_service_contexts",
      32,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ServerRequestInterceptor_receive_request_service_contexts_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ServerRequestInterceptor::receive_request (
    PortableInterceptor::ServerRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ForwardRequest
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ServerRequestInterceptor_receive_request_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_ForwardRequest, PortableInterceptor::ForwardRequest::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "receive_request",
      15,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ServerRequestInterceptor_receive_request_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ServerRequestInterceptor::send_reply (
    PortableInterceptor::ServerRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "send_reply",
      10,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ServerRequestInterceptor::send_exception (
    PortableInterceptor::ServerRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ForwardRequest
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ServerRequestInterceptor_send_exception_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_ForwardRequest, PortableInterceptor::ForwardRequest::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "send_exception",
      14,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ServerRequestInterceptor_send_exception_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ServerRequestInterceptor::send_other (
    PortableInterceptor::ServerRequestInfo_ptr ri,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ForwardRequest
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ServerRequestInterceptor_send_other_exceptiondata [] = 
  {
    {PortableInterceptor::_tc_ForwardRequest, PortableInterceptor::ForwardRequest::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "send_other",
      10,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << ri)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ServerRequestInterceptor_send_other_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::ServerRequestInterceptor::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/ServerRequestInterceptor:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/Interceptor:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::ServerRequestInterceptor::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, ServerRequestInterceptor)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, Interceptor)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            PortableInterceptor::Interceptor_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::ServerRequestInterceptor::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/ServerRequestInterceptor:1.0";
}


static const CORBA::Long _oc_PortableInterceptor_ServerRequestInterceptor[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  53, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65725265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74496e74), ACE_NTOHL (0x65726365), ACE_NTOHL (0x70746f72), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/ServerRequestInterceptor:1.0
  25, ACE_NTOHL (0x53657276), ACE_NTOHL (0x65725265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x74496e74), ACE_NTOHL (0x65726365), ACE_NTOHL (0x70746f72), ACE_NTOHL (0x0),  // name = ServerRequestInterceptor
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ServerRequestInterceptor (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_ServerRequestInterceptor), (char *) &_oc_PortableInterceptor_ServerRequestInterceptor, 0, sizeof (PortableInterceptor::ServerRequestInterceptor));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServerRequestInterceptor, &_tc_TAO_tc_PortableInterceptor_ServerRequestInterceptor)
TAO_NAMESPACE_END

// default constructor
PortableInterceptor::IORInfo::IORInfo (void)
{}

// destructor
PortableInterceptor::IORInfo::~IORInfo (void)
{}

void PortableInterceptor::IORInfo::_tao_any_destructor (void *x)
{
  IORInfo *tmp = ACE_static_cast (IORInfo*,x);
  CORBA::release (tmp);
}

PortableInterceptor::IORInfo_ptr PortableInterceptor::IORInfo::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IORInfo::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/IORInfo:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IORInfo::_nil ());
      if (is_a == 0)
        return IORInfo::_nil ();
    }
  return IORInfo::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableInterceptor::IORInfo_ptr PortableInterceptor::IORInfo::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IORInfo::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IORInfo_ptr default_proxy = IORInfo::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_IORInfo_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_PortableInterceptor_IORInfo_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::IORInfo (stub), IORInfo::_nil ());
        return default_proxy;

    }
  else 
    return
      ACE_reinterpret_cast
        (
          IORInfo_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &IORInfo::_narrow
                  )
              )
        );
}

PortableInterceptor::IORInfo_ptr
PortableInterceptor::IORInfo::_duplicate (IORInfo_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Policy_ptr PortableInterceptor::IORInfo::get_effective_policy (
    CORBA::PolicyType type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Policy_ptr _tao_retval = CORBA::Policy::_nil ();
  CORBA::Policy_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_effective_policy",
      20,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << type)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

void PortableInterceptor::IORInfo::add_ior_component (
    const IOP::TaggedComponent & component,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "add_ior_component",
      17,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << component)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::IORInfo::add_ior_component_to_profile (
    const IOP::TaggedComponent & component,
    IOP::ProfileId profile_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "add_ior_component_to_profile",
      28,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << component) &&
            (_tao_out << profile_id)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::IORInfo::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/IORInfo:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::IORInfo::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, IORInfo)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::IORInfo::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/IORInfo:1.0";
}


  static const CORBA::Long _oc_PortableInterceptor_IORInfo[] =
  {
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x494f5249), ACE_NTOHL (0x6e666f3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/IORInfo:1.0
    8, ACE_NTOHL (0x494f5249), ACE_NTOHL (0x6e666f00),  // name = IORInfo
};
  static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_IORInfo (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_IORInfo), (char *) &_oc_PortableInterceptor_IORInfo, 0, sizeof (PortableInterceptor::IORInfo));
  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (PortableInterceptor)
  TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IORInfo, &_tc_TAO_tc_PortableInterceptor_IORInfo)
  TAO_NAMESPACE_END
    
  // default constructor
  PortableInterceptor::IORInterceptor::IORInterceptor (void)
  {}
  
  // destructor
  PortableInterceptor::IORInterceptor::~IORInterceptor (void)
  {}
  
  void PortableInterceptor::IORInterceptor::_tao_any_destructor (void *x)
  {
    IORInterceptor *tmp = ACE_static_cast (IORInterceptor*,x);
    CORBA::release (tmp);
  }

  PortableInterceptor::IORInterceptor_ptr PortableInterceptor::IORInterceptor::_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV
    )
  {
    if (CORBA::is_nil (obj))
      return IORInterceptor::_nil ();
    if (! obj->_is_local ())
      {
        CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/IORInterceptor:1.0", ACE_TRY_ENV);
        ACE_CHECK_RETURN (IORInterceptor::_nil ());
        if (is_a == 0)
          return IORInterceptor::_nil ();
      }
    return IORInterceptor::_unchecked_narrow (obj, ACE_TRY_ENV);
  }
  
  PortableInterceptor::IORInterceptor_ptr PortableInterceptor::IORInterceptor::_unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &
    )
  {
    if (CORBA::is_nil (obj))
      return IORInterceptor::_nil ();
    if (! obj->_is_local ())
      {
        TAO_Stub* stub = obj->_stubobj ();
        if (stub)
          stub->_incr_refcnt ();
        IORInterceptor_ptr default_proxy = IORInterceptor::_nil ();

        if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_IORInterceptor_Stub_Factory_function_pointer != 0)
          {
            default_proxy = _TAO_collocation_PortableInterceptor_IORInterceptor_Stub_Factory_function_pointer (obj);
          }
        if (CORBA::is_nil (default_proxy))
          ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::IORInterceptor (stub), IORInterceptor::_nil ());
          return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IORInterceptor_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IORInterceptor::_narrow
                    )
                )
          );
}

PortableInterceptor::IORInterceptor_ptr
PortableInterceptor::IORInterceptor::_duplicate (IORInterceptor_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void PortableInterceptor::IORInterceptor::establish_components (
    PortableInterceptor::IORInfo_ptr info,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "establish_components",
      20,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << info)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::IORInterceptor::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/IORInterceptor:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/Interceptor:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::IORInterceptor::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, IORInterceptor)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, Interceptor)::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            PortableInterceptor::Interceptor_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::IORInterceptor::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/IORInterceptor:1.0";
}


static const CORBA::Long _oc_PortableInterceptor_IORInterceptor[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x494f5249), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x63657074), ACE_NTOHL (0x6f723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:PortableInterceptor/IORInterceptor:1.0
  15, ACE_NTOHL (0x494f5249), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x63657074), ACE_NTOHL (0x6f720000),  // name = IORInterceptor
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_IORInterceptor (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_IORInterceptor), (char *) &_oc_PortableInterceptor_IORInterceptor, 0, sizeof (PortableInterceptor::IORInterceptor));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IORInterceptor, &_tc_TAO_tc_PortableInterceptor_IORInterceptor)
TAO_NAMESPACE_END

// default constructor
PortableInterceptor::PolicyFactory::PolicyFactory (void)
{}

// destructor
PortableInterceptor::PolicyFactory::~PolicyFactory (void)
{}

void PortableInterceptor::PolicyFactory::_tao_any_destructor (void *x)
{
  PolicyFactory *tmp = ACE_static_cast (PolicyFactory*,x);
  CORBA::release (tmp);
}

PortableInterceptor::PolicyFactory_ptr PortableInterceptor::PolicyFactory::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return PolicyFactory::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/PolicyFactory:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (PolicyFactory::_nil ());
      if (is_a == 0)
        return PolicyFactory::_nil ();
    }
  return PolicyFactory::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableInterceptor::PolicyFactory_ptr PortableInterceptor::PolicyFactory::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return PolicyFactory::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      PolicyFactory_ptr default_proxy = PolicyFactory::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_PolicyFactory_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_PortableInterceptor_PolicyFactory_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::PolicyFactory (stub), PolicyFactory::_nil ());
        return default_proxy;

    }
  else 
    return
      ACE_reinterpret_cast
        (
          PolicyFactory_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &PolicyFactory::_narrow
                  )
              )
        );
}

PortableInterceptor::PolicyFactory_ptr
PortableInterceptor::PolicyFactory::_duplicate (PolicyFactory_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Policy_ptr PortableInterceptor::PolicyFactory::create_policy (
    CORBA::PolicyType type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    CORBA::PolicyError
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_PolicyFactory_create_policy_exceptiondata [] = 
  {
    {CORBA::_tc_PolicyError, CORBA::PolicyError::_alloc}
  };

  CORBA::Policy_ptr _tao_retval = CORBA::Policy::_nil ();
  CORBA::Policy_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_policy",
      13,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << type) &&
            (_tao_out << value)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (), 0);

      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_PolicyFactory_create_policy_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

CORBA::Boolean PortableInterceptor::PolicyFactory::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/PolicyFactory:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::PolicyFactory::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, PolicyFactory)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::PolicyFactory::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/PolicyFactory:1.0";
}


static const CORBA::Long _oc_PortableInterceptor_PolicyFactory[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63794661), ACE_NTOHL (0x63746f72), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:PortableInterceptor/PolicyFactory:1.0
  14, ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63794661), ACE_NTOHL (0x63746f72), ACE_NTOHL (0x79000000),  // name = PolicyFactory
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_PolicyFactory (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_PolicyFactory), (char *) &_oc_PortableInterceptor_PolicyFactory, 0, sizeof (PortableInterceptor::PolicyFactory));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PolicyFactory, &_tc_TAO_tc_PortableInterceptor_PolicyFactory)
TAO_NAMESPACE_END

// default constructor
PortableInterceptor::ORBInitInfo::ORBInitInfo (void)
{}

// destructor
PortableInterceptor::ORBInitInfo::~ORBInitInfo (void)
{}

void PortableInterceptor::ORBInitInfo::_tao_any_destructor (void *x)
{
  ORBInitInfo *tmp = ACE_static_cast (ORBInitInfo*,x);
  CORBA::release (tmp);
}

PortableInterceptor::ORBInitInfo_ptr PortableInterceptor::ORBInitInfo::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return ORBInitInfo::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/ORBInitInfo:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (ORBInitInfo::_nil ());
      if (is_a == 0)
        return ORBInitInfo::_nil ();
    }
  return ORBInitInfo::_unchecked_narrow (obj, ACE_TRY_ENV);
}

PortableInterceptor::ORBInitInfo_ptr PortableInterceptor::ORBInitInfo::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return ORBInitInfo::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      ORBInitInfo_ptr default_proxy = ORBInitInfo::_nil ();

      if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_ORBInitInfo_Stub_Factory_function_pointer != 0)
        {
          default_proxy = _TAO_collocation_PortableInterceptor_ORBInitInfo_Stub_Factory_function_pointer (obj);
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::ORBInitInfo (stub), ORBInitInfo::_nil ());
        return default_proxy;

    }
  else 
    return
      ACE_reinterpret_cast
        (
          ORBInitInfo_ptr,
            obj->_tao_QueryInterface
              (
                ACE_reinterpret_cast
                  (
                    ptr_arith_t,
                    &ORBInitInfo::_narrow
                  )
              )
        );
}

PortableInterceptor::ORBInitInfo_ptr
PortableInterceptor::ORBInitInfo::_duplicate (ORBInitInfo_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

static const CORBA::Long _oc_PortableInterceptor_ORBInitInfo_ObjectId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x4f524249), ACE_NTOHL (0x6e697449), ACE_NTOHL (0x6e666f2f), ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744964), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:PortableInterceptor/ORBInitInfo/ObjectId:1.0
  9, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744964), ACE_NTOHL (0x0),  // name = ObjectId
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ORBInitInfo_ObjectId (CORBA::tk_alias, sizeof (_oc_PortableInterceptor_ORBInitInfo_ObjectId), (char *) &_oc_PortableInterceptor_ORBInitInfo_ObjectId, 0, sizeof (PortableInterceptor::ORBInitInfo::ObjectId));
CORBA::TypeCode_ptr PortableInterceptor::ORBInitInfo::_tc_ObjectId = &_tc_TAO_tc_PortableInterceptor_ORBInitInfo_ObjectId;

// default constructor
PortableInterceptor::ORBInitInfo::DuplicateName::DuplicateName (void)
  : CORBA_UserException ("IDL:PortableInterceptor/ORBInitInfo/DuplicateName:1.0")
{
}

// destructor - all members are of self managing types
PortableInterceptor::ORBInitInfo::DuplicateName::~DuplicateName (void)
{
}

void PortableInterceptor::ORBInitInfo::DuplicateName::_tao_any_destructor (void *x)
{
  DuplicateName *tmp = ACE_static_cast (DuplicateName*,x);
  delete tmp;
}

// copy constructor
PortableInterceptor::ORBInitInfo::DuplicateName::DuplicateName (const ::PortableInterceptor::ORBInitInfo::DuplicateName &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
    this->name = CORBA::string_dup (_tao_excp.name.in ());
}

// assignment operator
PortableInterceptor::ORBInitInfo::DuplicateName&
PortableInterceptor::ORBInitInfo::DuplicateName::operator= (const ::PortableInterceptor::ORBInitInfo::DuplicateName &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  this->name = CORBA::string_dup (_tao_excp.name.in ());
  return *this;
}

// narrow
PortableInterceptor::ORBInitInfo::DuplicateName *
PortableInterceptor::ORBInitInfo::DuplicateName::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableInterceptor/ORBInitInfo/DuplicateName:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (DuplicateName *, exc);
  else
    return 0;
}


void PortableInterceptor::ORBInitInfo::DuplicateName::_raise ()
{
  TAO_RAISE(*this);
}


void PortableInterceptor::ORBInitInfo::DuplicateName::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void PortableInterceptor::ORBInitInfo::DuplicateName::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *PortableInterceptor::ORBInitInfo::DuplicateName::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableInterceptor::ORBInitInfo::DuplicateName, 0);
  return retval;
}

PortableInterceptor::ORBInitInfo::DuplicateName::DuplicateName (
  const char * _tao_name
)
  : CORBA_UserException  (CORBA::string_dup ("IDL:PortableInterceptor/ORBInitInfo/DuplicateName:1.0"))
{
    this->name = CORBA::string_dup (_tao_name);
}

static const CORBA::Long _oc_PortableInterceptor_ORBInitInfo_DuplicateName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x4f524249), ACE_NTOHL (0x6e697449), ACE_NTOHL (0x6e666f2f), ACE_NTOHL (0x4475706c), ACE_NTOHL (0x69636174), ACE_NTOHL (0x654e616d), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:PortableInterceptor/ORBInitInfo/DuplicateName:1.0
  14, ACE_NTOHL (0x4475706c), ACE_NTOHL (0x69636174), ACE_NTOHL (0x654e616d), ACE_NTOHL (0x65000000),  // name = DuplicateName
  1, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ORBInitInfo_DuplicateName (CORBA::tk_except, sizeof (_oc_PortableInterceptor_ORBInitInfo_DuplicateName), (char *) &_oc_PortableInterceptor_ORBInitInfo_DuplicateName, 0, sizeof (PortableInterceptor::ORBInitInfo::DuplicateName));
CORBA::TypeCode_ptr PortableInterceptor::ORBInitInfo::_tc_DuplicateName = &_tc_TAO_tc_PortableInterceptor_ORBInitInfo_DuplicateName;


// TAO extension - the virtual _type method
CORBA::TypeCode_ptr PortableInterceptor::ORBInitInfo::DuplicateName::_type (void) const
{
  return ::PortableInterceptor::ORBInitInfo::_tc_DuplicateName;
}

// default constructor
PortableInterceptor::ORBInitInfo::InvalidName::InvalidName (void)
  : CORBA_UserException ("IDL:PortableInterceptor/ORBInitInfo/InvalidName:1.0")
{
}

// destructor - all members are of self managing types
PortableInterceptor::ORBInitInfo::InvalidName::~InvalidName (void)
{
}

void PortableInterceptor::ORBInitInfo::InvalidName::_tao_any_destructor (void *x)
{
  InvalidName *tmp = ACE_static_cast (InvalidName*,x);
  delete tmp;
}

// copy constructor
PortableInterceptor::ORBInitInfo::InvalidName::InvalidName (const ::PortableInterceptor::ORBInitInfo::InvalidName &_tao_excp)
  : CORBA_UserException (_tao_excp._id ())
{
}

// assignment operator
PortableInterceptor::ORBInitInfo::InvalidName&
PortableInterceptor::ORBInitInfo::InvalidName::operator= (const ::PortableInterceptor::ORBInitInfo::InvalidName &_tao_excp)
{

  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

// narrow
PortableInterceptor::ORBInitInfo::InvalidName *
PortableInterceptor::ORBInitInfo::InvalidName::_downcast (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:PortableInterceptor/ORBInitInfo/InvalidName:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (InvalidName *, exc);
  else
    return 0;
}


void PortableInterceptor::ORBInitInfo::InvalidName::_raise ()
{
  TAO_RAISE(*this);
}


void PortableInterceptor::ORBInitInfo::InvalidName::_tao_encode (
    TAO_OutputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  ) const
{
  if (cdr << *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}


void PortableInterceptor::ORBInitInfo::InvalidName::_tao_decode (
    TAO_InputCDR &cdr,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (cdr >> *this)
    return;
  ACE_THROW (CORBA::MARSHAL ());
}

// TAO extension - the _alloc method
CORBA::Exception *PortableInterceptor::ORBInitInfo::InvalidName::_alloc (void)
{
  CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::PortableInterceptor::ORBInitInfo::InvalidName, 0);
  return retval;
}

static const CORBA::Long _oc_PortableInterceptor_ORBInitInfo_InvalidName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x4f524249), ACE_NTOHL (0x6e697449), ACE_NTOHL (0x6e666f2f), ACE_NTOHL (0x496e7661), ACE_NTOHL (0x6c69644e), ACE_NTOHL (0x616d653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/ORBInitInfo/InvalidName:1.0
  12, ACE_NTOHL (0x496e7661), ACE_NTOHL (0x6c69644e), ACE_NTOHL (0x616d6500),  // name = InvalidName
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ORBInitInfo_InvalidName (CORBA::tk_except, sizeof (_oc_PortableInterceptor_ORBInitInfo_InvalidName), (char *) &_oc_PortableInterceptor_ORBInitInfo_InvalidName, 0, sizeof (PortableInterceptor::ORBInitInfo::InvalidName));
CORBA::TypeCode_ptr PortableInterceptor::ORBInitInfo::_tc_InvalidName = &_tc_TAO_tc_PortableInterceptor_ORBInitInfo_InvalidName;


// TAO extension - the virtual _type method
CORBA::TypeCode_ptr PortableInterceptor::ORBInitInfo::InvalidName::_type (void) const
{
  return ::PortableInterceptor::ORBInitInfo::_tc_InvalidName;
}

PortableInterceptor::StringSeq * PortableInterceptor::ORBInitInfo::arguments (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  PortableInterceptor::StringSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, PortableInterceptor::StringSeq, _tao_retval);
  PortableInterceptor::StringSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_arguments",
      14,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

char * PortableInterceptor::ORBInitInfo::orb_id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_orb_id",
      11,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN (0);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN (0);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN (0);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_safe_retval.inout ())
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), 0);

    break;
    
  }
return _tao_safe_retval._retn ();
}

void PortableInterceptor::ORBInitInfo::register_initial_reference (
    const char * id,
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ORBInitInfo::InvalidName
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ORBInitInfo_register_initial_reference_exceptiondata [] = 
  {
    {PortableInterceptor::ORBInitInfo::_tc_InvalidName, PortableInterceptor::ORBInitInfo::InvalidName::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "register_initial_reference",
      26,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id) &&
            (_tao_out << obj)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ORBInitInfo_register_initial_reference_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ORBInitInfo::resolve_initial_references (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ORBInitInfo::InvalidName
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ORBInitInfo_resolve_initial_references_exceptiondata [] = 
  {
    {PortableInterceptor::ORBInitInfo::_tc_InvalidName, PortableInterceptor::ORBInitInfo::InvalidName::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "resolve_initial_references",
      26,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << id)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ORBInitInfo_resolve_initial_references_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ORBInitInfo::add_client_request_interceptor (
    PortableInterceptor::ClientRequestInterceptor_ptr interceptor,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ORBInitInfo::DuplicateName
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ORBInitInfo_add_client_request_interceptor_exceptiondata [] = 
  {
    {PortableInterceptor::ORBInitInfo::_tc_DuplicateName, PortableInterceptor::ORBInitInfo::DuplicateName::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "add_client_request_interceptor",
      30,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << interceptor)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ORBInitInfo_add_client_request_interceptor_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ORBInitInfo::add_server_request_interceptor (
    PortableInterceptor::ServerRequestInterceptor_ptr interceptor,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ORBInitInfo::DuplicateName
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ORBInitInfo_add_server_request_interceptor_exceptiondata [] = 
  {
    {PortableInterceptor::ORBInitInfo::_tc_DuplicateName, PortableInterceptor::ORBInitInfo::DuplicateName::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "add_server_request_interceptor",
      30,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << interceptor)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ORBInitInfo_add_server_request_interceptor_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      break;
      
    }

}

void PortableInterceptor::ORBInitInfo::add_ior_interceptor (
    PortableInterceptor::IORInterceptor_ptr interceptor,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    PortableInterceptor::ORBInitInfo::DuplicateName
  ))
{
  
  static TAO_Exception_Data _tao_PortableInterceptor_ORBInitInfo_add_ior_interceptor_exceptiondata [] = 
  {
    {PortableInterceptor::ORBInitInfo::_tc_DuplicateName, PortableInterceptor::ORBInitInfo::DuplicateName::_alloc}
  };


  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "add_ior_interceptor",
      19,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << interceptor)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (_tao_PortableInterceptor_ORBInitInfo_add_ior_interceptor_exceptiondata, 1, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

PortableInterceptor::SlotId PortableInterceptor::ORBInitInfo::allocate_slot_id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  PortableInterceptor::SlotId _tao_retval = 0;
  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "allocate_slot_id",
      16,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK_RETURN  (_tao_retval);

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK_RETURN  (_tao_retval);

      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK_RETURN  (_tao_retval);

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

      }
      TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
      if (!(
            (_tao_in >> _tao_retval)
        ))
      ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    break;
    
  }
return _tao_retval;
}

void PortableInterceptor::ORBInitInfo::register_policy_factory (
    CORBA::PolicyType type,
    PortableInterceptor::PolicyFactory_ptr policy_factory,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "register_policy_factory",
      23,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << type) &&
            (_tao_out << policy_factory)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::ORBInitInfo::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/ORBInitInfo:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::ORBInitInfo::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, ORBInitInfo)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::ORBInitInfo::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/ORBInitInfo:1.0";
}


  static const CORBA::Long _oc_PortableInterceptor_ORBInitInfo[] =
  {
    TAO_ENCAP_BYTE_ORDER, // byte order
    40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x4f524249), ACE_NTOHL (0x6e697449), ACE_NTOHL (0x6e666f3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:PortableInterceptor/ORBInitInfo:1.0
    12, ACE_NTOHL (0x4f524249), ACE_NTOHL (0x6e697449), ACE_NTOHL (0x6e666f00),  // name = ORBInitInfo
};
  static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ORBInitInfo (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_ORBInitInfo), (char *) &_oc_PortableInterceptor_ORBInitInfo, 0, sizeof (PortableInterceptor::ORBInitInfo));
  TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
  TAO_NAMESPACE_BEGIN (PortableInterceptor)
  TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ORBInitInfo, &_tc_TAO_tc_PortableInterceptor_ORBInitInfo)
  TAO_NAMESPACE_END
    
  // default constructor
  PortableInterceptor::ORBInitializer::ORBInitializer (void)
  {}
  
  // destructor
  PortableInterceptor::ORBInitializer::~ORBInitializer (void)
  {}
  
  void PortableInterceptor::ORBInitializer::_tao_any_destructor (void *x)
  {
    ORBInitializer *tmp = ACE_static_cast (ORBInitializer*,x);
    CORBA::release (tmp);
  }

  PortableInterceptor::ORBInitializer_ptr PortableInterceptor::ORBInitializer::_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV
    )
  {
    if (CORBA::is_nil (obj))
      return ORBInitializer::_nil ();
    if (! obj->_is_local ())
      {
        CORBA::Boolean is_a = obj->_is_a ("IDL:PortableInterceptor/ORBInitializer:1.0", ACE_TRY_ENV);
        ACE_CHECK_RETURN (ORBInitializer::_nil ());
        if (is_a == 0)
          return ORBInitializer::_nil ();
      }
    return ORBInitializer::_unchecked_narrow (obj, ACE_TRY_ENV);
  }
  
  PortableInterceptor::ORBInitializer_ptr PortableInterceptor::ORBInitializer::_unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &
    )
  {
    if (CORBA::is_nil (obj))
      return ORBInitializer::_nil ();
    if (! obj->_is_local ())
      {
        TAO_Stub* stub = obj->_stubobj ();
        if (stub)
          stub->_incr_refcnt ();
        ORBInitializer_ptr default_proxy = ORBInitializer::_nil ();

        if (obj->_is_collocated () && _TAO_collocation_PortableInterceptor_ORBInitializer_Stub_Factory_function_pointer != 0)
          {
            default_proxy = _TAO_collocation_PortableInterceptor_ORBInitializer_Stub_Factory_function_pointer (obj);
          }
        if (CORBA::is_nil (default_proxy))
          ACE_NEW_RETURN (default_proxy, ::PortableInterceptor::ORBInitializer (stub), ORBInitializer::_nil ());
          return default_proxy;

      }
    else 
      return
        ACE_reinterpret_cast
          (
            ORBInitializer_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &ORBInitializer::_narrow
                    )
                )
          );
}

PortableInterceptor::ORBInitializer_ptr
PortableInterceptor::ORBInitializer::_duplicate (ORBInitializer_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

void PortableInterceptor::ORBInitializer::pre_init (
    PortableInterceptor::ORBInitInfo_ptr info,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "pre_init",
      8,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << info)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

void PortableInterceptor::ORBInitializer::post_init (
    PortableInterceptor::ORBInitInfo_ptr info,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  

  
  
  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "post_init",
      9,
      istub->orb_core ()
    );


    for (;;)
    {
      _tao_call.start (ACE_TRY_ENV);
      ACE_CHECK;

      CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
      
      _tao_call.prepare_header (
          ACE_static_cast (CORBA::Octet, _tao_response_flag), ACE_TRY_ENV
        );
      ACE_CHECK;

      TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
      if (!(
            (_tao_out << info)
        ))
      ACE_THROW (CORBA::MARSHAL());
      int _invoke_status =
        _tao_call.invoke (0, 0, ACE_TRY_ENV);
            ACE_CHECK;

      if (_invoke_status == TAO_INVOKE_RESTART)
        continue;
      if (_invoke_status != TAO_INVOKE_OK)
      {
        ACE_THROW (CORBA::UNKNOWN(TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES));
      }
      
      break;
      
    }

}

CORBA::Boolean PortableInterceptor::ORBInitializer::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:PortableInterceptor/ORBInitializer:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *PortableInterceptor::ORBInitializer::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &ACE_NESTED_CLASS (::PortableInterceptor, ORBInitializer)::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* PortableInterceptor::ORBInitializer::_interface_repository_id (void) const
{
  return "IDL:PortableInterceptor/ORBInitializer:1.0";
}


static const CORBA::Long _oc_PortableInterceptor_ORBInitializer[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  43, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72636570), ACE_NTOHL (0x746f722f), ACE_NTOHL (0x4f524249), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:PortableInterceptor/ORBInitializer:1.0
  15, ACE_NTOHL (0x4f524249), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65720000),  // name = ORBInitializer
};
static CORBA::TypeCode _tc_TAO_tc_PortableInterceptor_ORBInitializer (CORBA::tk_objref, sizeof (_oc_PortableInterceptor_ORBInitializer), (char *) &_oc_PortableInterceptor_ORBInitializer, 0, sizeof (PortableInterceptor::ORBInitializer));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableInterceptor)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ORBInitializer, &_tc_TAO_tc_PortableInterceptor_ORBInitializer)
TAO_NAMESPACE_END
void operator<<= (
    CORBA::Any &_tao_any,
    const PortableInterceptor::OctetSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_OctetSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::OctetSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::_tc_OctetSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableInterceptor::OctetSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::OctetSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableInterceptor::OctetSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableInterceptor::OctetSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_OctetSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableInterceptor::OctetSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableInterceptor::OctetSeq *tmp;
      ACE_NEW_RETURN (tmp, PortableInterceptor::OctetSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableInterceptor::_tc_OctetSeq,
            1,
            ACE_static_cast (void *, tmp),
            PortableInterceptor::OctetSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const PortableInterceptor::StringSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_StringSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::StringSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::_tc_StringSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableInterceptor::StringSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::StringSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableInterceptor::StringSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableInterceptor::StringSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_StringSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const PortableInterceptor::StringSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      PortableInterceptor::StringSeq *tmp;
      ACE_NEW_RETURN (tmp, PortableInterceptor::StringSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableInterceptor::_tc_StringSeq,
            1,
            ACE_static_cast (void *, tmp),
            PortableInterceptor::StringSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

PortableInterceptor::Interceptor_ptr (*_TAO_collocation_PortableInterceptor_Interceptor_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::Interceptor_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_Interceptor, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::Interceptor::_duplicate (_tao_elem),
        PortableInterceptor::Interceptor::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::Interceptor_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::Interceptor::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_Interceptor, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_Interceptor,
          1,
          _tao_elem,
          PortableInterceptor::Interceptor::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::Interceptor::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::Interceptor::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::Interceptor,PortableInterceptor::Interceptor_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::Interceptor,PortableInterceptor::Interceptor_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const PortableInterceptor::ForwardRequest &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::_tc_ForwardRequest,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ForwardRequest *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::_tc_ForwardRequest,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableInterceptor::ForwardRequest::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ForwardRequest *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableInterceptor::ForwardRequest*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableInterceptor::ForwardRequest *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_ForwardRequest, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableInterceptor::ForwardRequest *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableInterceptor::ForwardRequest *tmp;
      ACE_NEW_RETURN (tmp, PortableInterceptor::ForwardRequest, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:PortableInterceptor/ForwardRequest:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableInterceptor::_tc_ForwardRequest,
            1,
            tmp,
            PortableInterceptor::ForwardRequest::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableInterceptor::InvalidSlot &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::_tc_InvalidSlot,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::InvalidSlot *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::_tc_InvalidSlot,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableInterceptor::InvalidSlot::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::InvalidSlot *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableInterceptor::InvalidSlot*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableInterceptor::InvalidSlot *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_InvalidSlot, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableInterceptor::InvalidSlot *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableInterceptor::InvalidSlot *tmp;
      ACE_NEW_RETURN (tmp, PortableInterceptor::InvalidSlot, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:PortableInterceptor/InvalidSlot:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableInterceptor::_tc_InvalidSlot,
            1,
            tmp,
            PortableInterceptor::InvalidSlot::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

PortableInterceptor::Current_ptr (*_TAO_collocation_PortableInterceptor_Current_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::Current_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_Current, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::Current::_duplicate (_tao_elem),
        PortableInterceptor::Current::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::Current_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::Current::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_Current, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_Current,
          1,
          _tao_elem,
          PortableInterceptor::Current::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::Current::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::Current::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::Current,PortableInterceptor::Current_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::Current,PortableInterceptor::Current_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::RequestInfo_ptr (*_TAO_collocation_PortableInterceptor_RequestInfo_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::RequestInfo_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_RequestInfo, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::RequestInfo::_duplicate (_tao_elem),
        PortableInterceptor::RequestInfo::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::RequestInfo_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::RequestInfo::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_RequestInfo, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_RequestInfo,
          1,
          _tao_elem,
          PortableInterceptor::RequestInfo::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::RequestInfo::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::RequestInfo::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::RequestInfo,PortableInterceptor::RequestInfo_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::RequestInfo,PortableInterceptor::RequestInfo_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::ClientRequestInfo_ptr (*_TAO_collocation_PortableInterceptor_ClientRequestInfo_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ClientRequestInfo_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_ClientRequestInfo, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::ClientRequestInfo::_duplicate (_tao_elem),
        PortableInterceptor::ClientRequestInfo::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ClientRequestInfo_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::ClientRequestInfo::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_ClientRequestInfo, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_ClientRequestInfo,
          1,
          _tao_elem,
          PortableInterceptor::ClientRequestInfo::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::ClientRequestInfo::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::ClientRequestInfo::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::ClientRequestInfo,PortableInterceptor::ClientRequestInfo_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::ClientRequestInfo,PortableInterceptor::ClientRequestInfo_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::ServerRequestInfo_ptr (*_TAO_collocation_PortableInterceptor_ServerRequestInfo_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ServerRequestInfo_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_ServerRequestInfo, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::ServerRequestInfo::_duplicate (_tao_elem),
        PortableInterceptor::ServerRequestInfo::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ServerRequestInfo_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::ServerRequestInfo::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_ServerRequestInfo, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_ServerRequestInfo,
          1,
          _tao_elem,
          PortableInterceptor::ServerRequestInfo::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::ServerRequestInfo::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::ServerRequestInfo::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::ServerRequestInfo,PortableInterceptor::ServerRequestInfo_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::ServerRequestInfo,PortableInterceptor::ServerRequestInfo_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::ClientRequestInterceptor_ptr (*_TAO_collocation_PortableInterceptor_ClientRequestInterceptor_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ClientRequestInterceptor_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_ClientRequestInterceptor, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::ClientRequestInterceptor::_duplicate (_tao_elem),
        PortableInterceptor::ClientRequestInterceptor::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ClientRequestInterceptor_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::ClientRequestInterceptor::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_ClientRequestInterceptor, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_ClientRequestInterceptor,
          1,
          _tao_elem,
          PortableInterceptor::ClientRequestInterceptor::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::ClientRequestInterceptor::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::ClientRequestInterceptor::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::ClientRequestInterceptor,PortableInterceptor::ClientRequestInterceptor_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::ClientRequestInterceptor,PortableInterceptor::ClientRequestInterceptor_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::ServerRequestInterceptor_ptr (*_TAO_collocation_PortableInterceptor_ServerRequestInterceptor_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ServerRequestInterceptor_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_ServerRequestInterceptor, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::ServerRequestInterceptor::_duplicate (_tao_elem),
        PortableInterceptor::ServerRequestInterceptor::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ServerRequestInterceptor_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::ServerRequestInterceptor::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_ServerRequestInterceptor, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_ServerRequestInterceptor,
          1,
          _tao_elem,
          PortableInterceptor::ServerRequestInterceptor::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::ServerRequestInterceptor::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::ServerRequestInterceptor::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::ServerRequestInterceptor,PortableInterceptor::ServerRequestInterceptor_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::ServerRequestInterceptor,PortableInterceptor::ServerRequestInterceptor_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::IORInfo_ptr (*_TAO_collocation_PortableInterceptor_IORInfo_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::IORInfo_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_IORInfo, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::IORInfo::_duplicate (_tao_elem),
        PortableInterceptor::IORInfo::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::IORInfo_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::IORInfo::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_IORInfo, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_IORInfo,
          1,
          _tao_elem,
          PortableInterceptor::IORInfo::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::IORInfo::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::IORInfo::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::IORInfo,PortableInterceptor::IORInfo_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::IORInfo,PortableInterceptor::IORInfo_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::IORInterceptor_ptr (*_TAO_collocation_PortableInterceptor_IORInterceptor_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::IORInterceptor_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_IORInterceptor, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::IORInterceptor::_duplicate (_tao_elem),
        PortableInterceptor::IORInterceptor::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::IORInterceptor_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::IORInterceptor::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_IORInterceptor, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_IORInterceptor,
          1,
          _tao_elem,
          PortableInterceptor::IORInterceptor::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::IORInterceptor::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::IORInterceptor::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::IORInterceptor,PortableInterceptor::IORInterceptor_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::IORInterceptor,PortableInterceptor::IORInterceptor_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::PolicyFactory_ptr (*_TAO_collocation_PortableInterceptor_PolicyFactory_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::PolicyFactory_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_PolicyFactory, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::PolicyFactory::_duplicate (_tao_elem),
        PortableInterceptor::PolicyFactory::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::PolicyFactory_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::PolicyFactory::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_PolicyFactory, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_PolicyFactory,
          1,
          _tao_elem,
          PortableInterceptor::PolicyFactory::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::PolicyFactory::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::PolicyFactory::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::PolicyFactory,PortableInterceptor::PolicyFactory_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::PolicyFactory,PortableInterceptor::PolicyFactory_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

PortableInterceptor::ORBInitInfo_ptr (*_TAO_collocation_PortableInterceptor_ORBInitInfo_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ORBInitInfo_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_ORBInitInfo, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::ORBInitInfo::_duplicate (_tao_elem),
        PortableInterceptor::ORBInitInfo::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ORBInitInfo_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::ORBInitInfo::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_ORBInitInfo, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_ORBInitInfo,
          1,
          _tao_elem,
          PortableInterceptor::ORBInitInfo::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::ORBInitInfo::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::ORBInitInfo::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::ORBInitInfo,PortableInterceptor::ORBInitInfo_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::ORBInitInfo,PortableInterceptor::ORBInitInfo_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const PortableInterceptor::ORBInitInfo::DuplicateName &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::ORBInitInfo::_tc_DuplicateName,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ORBInitInfo::DuplicateName *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::ORBInitInfo::_tc_DuplicateName,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableInterceptor::ORBInitInfo::DuplicateName::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ORBInitInfo::DuplicateName *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableInterceptor::ORBInitInfo::DuplicateName*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableInterceptor::ORBInitInfo::DuplicateName *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::ORBInitInfo::_tc_DuplicateName, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableInterceptor::ORBInitInfo::DuplicateName *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableInterceptor::ORBInitInfo::DuplicateName *tmp;
      ACE_NEW_RETURN (tmp, PortableInterceptor::ORBInitInfo::DuplicateName, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:PortableInterceptor/ORBInitInfo/DuplicateName:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableInterceptor::ORBInitInfo::_tc_DuplicateName,
            1,
            tmp,
            PortableInterceptor::ORBInitInfo::DuplicateName::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const PortableInterceptor::ORBInitInfo::InvalidName &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::ORBInitInfo::_tc_InvalidName,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ORBInitInfo::InvalidName *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      PortableInterceptor::ORBInitInfo::_tc_InvalidName,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      PortableInterceptor::ORBInitInfo::InvalidName::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ORBInitInfo::InvalidName *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const PortableInterceptor::ORBInitInfo::InvalidName*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const PortableInterceptor::ORBInitInfo::InvalidName *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::ORBInitInfo::_tc_InvalidName, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableInterceptor::ORBInitInfo::InvalidName *)_tao_any.value ();
      return 1;
    }
    else
    {
      PortableInterceptor::ORBInitInfo::InvalidName *tmp;
      ACE_NEW_RETURN (tmp, PortableInterceptor::ORBInitInfo::InvalidName, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      CORBA::String_var interface_repository_id;
      if (!(stream >> interface_repository_id.out ()))
        return 0;
      if (ACE_OS::strcmp (
          interface_repository_id.in (),
          "IDL:PortableInterceptor/ORBInitInfo/InvalidName:1.0"))
        return 0;
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            PortableInterceptor::ORBInitInfo::_tc_InvalidName,
            1,
            tmp,
            PortableInterceptor::ORBInitInfo::InvalidName::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

PortableInterceptor::ORBInitializer_ptr (*_TAO_collocation_PortableInterceptor_ORBInitializer_Stub_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;
void operator<<= (CORBA::Any &_tao_any, PortableInterceptor::ORBInitializer_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        PortableInterceptor::_tc_ORBInitializer, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        PortableInterceptor::ORBInitializer::_duplicate (_tao_elem),
        PortableInterceptor::ORBInitializer::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableInterceptor::ORBInitializer_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = PortableInterceptor::ORBInitializer::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (PortableInterceptor::_tc_ORBInitializer, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          PortableInterceptor::_tc_ORBInitializer,
          1,
          _tao_elem,
          PortableInterceptor::ORBInitializer::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = PortableInterceptor::ORBInitializer::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = PortableInterceptor::ORBInitializer::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<PortableInterceptor::ORBInitializer,PortableInterceptor::ORBInitializer_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<PortableInterceptor::ORBInitializer,PortableInterceptor::ORBInitializer_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::OctetSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    {
      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
        ACE_static_cast (TAO_Unbounded_Sequence<CORBA::Octet>*, (PortableInterceptor::OctetSeq *)&_tao_sequence);
      if (oseq->mb ())
        return strm.write_octet_array_mb (oseq->mb ());
      else
        return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
    }
    
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.write_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::OctetSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    
#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
    if (ACE_BIT_DISABLED (strm.start ()->flags (),ACE_Message_Block::DONT_DELETE))
    {
      TAO_Unbounded_Sequence<CORBA::Octet> *oseq = 
        ACE_static_cast(TAO_Unbounded_Sequence<CORBA::Octet>*, &_tao_sequence);
      oseq->replace (_tao_seq_len, strm.start ());
      oseq->mb ()->wr_ptr (oseq->mb()->rd_ptr () + _tao_seq_len);
      strm.skip_bytes (_tao_seq_len);
      return 1;
    }
    else
      return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_seq_len);
    
#else /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
    return strm.read_octet_array (_tao_sequence.get_buffer (), _tao_sequence.length ());
  
#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 0 */
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const PortableInterceptor::StringSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    PortableInterceptor::StringSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

#endif /* TAO_HAS_INTERCEPTORS == 1 */
