// -*- C++ -*-
//
//$Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef TAO_IDL_INTERFACEC_H
#define TAO_IDL_INTERFACEC_H
#include "ace/pre.h"

#include "tao/TAO_Singleton.h"
#include "tao/corbafwd.h"
#include "tao/ifrfwd.h"
#include "tao/Any.h"
#include "tao/Object.h"
#include "tao/Managed_Types.h"
#include "tao/Sequence.h"
#include "tao/Typecode.h"
#include "tao/Remote_Object_Proxy_Impl.h"

#if (TAO_HAS_INTERFACE_REPOSITORY == 1)

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

  class TAO_Export CORBA_IRObject_var : public TAO_Base_var
  {
  public:
    CORBA_IRObject_var (void); // default constructor
    CORBA_IRObject_var (CORBA_IRObject_ptr p) : ptr_ (p) {}
    CORBA_IRObject_var (const CORBA_IRObject_var &); // copy constructor
    ~CORBA_IRObject_var (void); // destructor

    CORBA_IRObject_var &operator= (CORBA_IRObject_ptr);
    CORBA_IRObject_var &operator= (const CORBA_IRObject_var &);
    CORBA_IRObject_ptr operator-> (void) const;

    operator const CORBA_IRObject_ptr &() const;
    operator CORBA_IRObject_ptr &();
    // in, inout, out, _retn
    CORBA_IRObject_ptr in (void) const;
    CORBA_IRObject_ptr &inout (void);
    CORBA_IRObject_ptr &out (void);
    CORBA_IRObject_ptr _retn (void);
    CORBA_IRObject_ptr ptr (void) const;

  private:
    CORBA_IRObject_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CORBA_IRObject_var (const TAO_Base_var &rhs);
    CORBA_IRObject_var &operator= (const TAO_Base_var &rhs);
  };

  class TAO_Export CORBA_IRObject_out
  {
  public:
    CORBA_IRObject_out (CORBA_IRObject_ptr &);
    CORBA_IRObject_out (CORBA_IRObject_var &);
    CORBA_IRObject_out (const CORBA_IRObject_out &);
    CORBA_IRObject_out &operator= (const CORBA_IRObject_out &);
    CORBA_IRObject_out &operator= (const CORBA_IRObject_var &);
    CORBA_IRObject_out &operator= (CORBA_IRObject_ptr);
    operator CORBA_IRObject_ptr &();
    CORBA_IRObject_ptr &ptr (void);
    CORBA_IRObject_ptr operator-> (void);

  private:
    CORBA_IRObject_ptr &ptr_;
  };

  class _TAO_IRObject_Proxy_Impl;
  class _TAO_IRObject_Remote_Proxy_Impl;
  class _TAO_IRObject_Proxy_Broker;
  class _TAO_IRObject_Remote_Proxy_Broker;

  class TAO_Export CORBA_IRObject : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef CORBA_IRObject_ptr _ptr_type;
    typedef CORBA_IRObject_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static CORBA_IRObject_ptr _duplicate (CORBA_IRObject_ptr obj);
    static CORBA_IRObject_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static CORBA_IRObject_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static CORBA_IRObject_ptr _nil (void)
      {
        return (CORBA_IRObject_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual IR_DefinitionKind def_kind (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void destroy (
        CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  private:
    _TAO_IRObject_Proxy_Broker *the_TAO_IRObject_Proxy_Broker_;

  protected:
    CORBA_IRObject (int collocated = 0);

  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void _tao_setup_collocation (int collocated);

    CORBA_IRObject (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );

    friend class _TAO_IRObject_Remote_Proxy_Impl;
    friend class _TAO_IRObject_ThruPOA_Proxy_Impl;
    friend class _TAO_IRObject_Direct_Proxy_Impl;

    virtual ~CORBA_IRObject (void);
  private:
    CORBA_IRObject (const CORBA_IRObject &);
    void operator= (const CORBA_IRObject &);
  };


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_IRObject_Proxy_Impl : public virtual TAO_Object_Proxy_Impl
{
public:
  virtual ~_TAO_IRObject_Proxy_Impl (void) { }

  virtual IR_DefinitionKind def_kind (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void destroy (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_IRObject_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_IRObject_Remote_Proxy_Impl :
  public virtual _TAO_IRObject_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl
{
public:
  _TAO_IRObject_Remote_Proxy_Impl (void);

  virtual ~_TAO_IRObject_Remote_Proxy_Impl (void) { }

  virtual IR_DefinitionKind def_kind (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void destroy (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_IRObject_Proxy_Broker
{
public:
  virtual ~_TAO_IRObject_Proxy_Broker (void);

  virtual _TAO_IRObject_Proxy_Impl &select_proxy (
    CORBA_IRObject *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_IRObject_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_IRObject_Remote_Proxy_Broker : public virtual _TAO_IRObject_Proxy_Broker
{
public:
  _TAO_IRObject_Remote_Proxy_Broker (void);

  virtual ~_TAO_IRObject_Remote_Proxy_Broker (void);

  virtual _TAO_IRObject_Proxy_Impl &select_proxy (
    CORBA_IRObject *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_IRObject_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_IRObject_Remote_Proxy_Broker *the_TAO_IRObject_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


  class TAO_Export IR_Contained_var : public TAO_Base_var
  {
  public:
    IR_Contained_var (void); // default constructor
    IR_Contained_var (IR_Contained_ptr p) : ptr_ (p) {}
    IR_Contained_var (const IR_Contained_var &); // copy constructor
    ~IR_Contained_var (void); // destructor

    IR_Contained_var &operator= (IR_Contained_ptr);
    IR_Contained_var &operator= (const IR_Contained_var &);
    IR_Contained_ptr operator-> (void) const;

    operator const IR_Contained_ptr &() const;
    operator IR_Contained_ptr &();
    // in, inout, out, _retn
    IR_Contained_ptr in (void) const;
    IR_Contained_ptr &inout (void);
    IR_Contained_ptr &out (void);
    IR_Contained_ptr _retn (void);
    IR_Contained_ptr ptr (void) const;

  private:
    IR_Contained_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    IR_Contained_var (const TAO_Base_var &rhs);
    IR_Contained_var &operator= (const TAO_Base_var &rhs);
  };

  class TAO_Export IR_Contained_out
  {
  public:
    IR_Contained_out (IR_Contained_ptr &);
    IR_Contained_out (IR_Contained_var &);
    IR_Contained_out (const IR_Contained_out &);
    IR_Contained_out &operator= (const IR_Contained_out &);
    IR_Contained_out &operator= (const IR_Contained_var &);
    IR_Contained_out &operator= (IR_Contained_ptr);
    operator IR_Contained_ptr &();
    IR_Contained_ptr &ptr (void);
    IR_Contained_ptr operator-> (void);

  private:
    IR_Contained_ptr &ptr_;
  };

  class TAO_Export IR_Repository_var : public TAO_Base_var
  {
  public:
    IR_Repository_var (void); // default constructor
    IR_Repository_var (IR_Repository_ptr p) : ptr_ (p) {}
    IR_Repository_var (const IR_Repository_var &); // copy constructor
    ~IR_Repository_var (void); // destructor

    IR_Repository_var &operator= (IR_Repository_ptr);
    IR_Repository_var &operator= (const IR_Repository_var &);
    IR_Repository_ptr operator-> (void) const;

    operator const IR_Repository_ptr &() const;
    operator IR_Repository_ptr &();
    // in, inout, out, _retn
    IR_Repository_ptr in (void) const;
    IR_Repository_ptr &inout (void);
    IR_Repository_ptr &out (void);
    IR_Repository_ptr _retn (void);
    IR_Repository_ptr ptr (void) const;

  private:
    IR_Repository_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    IR_Repository_var (const TAO_Base_var &rhs);
    IR_Repository_var &operator= (const TAO_Base_var &rhs);
  };

  class TAO_Export IR_Repository_out
  {
  public:
    IR_Repository_out (IR_Repository_ptr &);
    IR_Repository_out (IR_Repository_var &);
    IR_Repository_out (const IR_Repository_out &);
    IR_Repository_out &operator= (const IR_Repository_out &);
    IR_Repository_out &operator= (const IR_Repository_var &);
    IR_Repository_out &operator= (IR_Repository_ptr);
    operator IR_Repository_ptr &();
    IR_Repository_ptr &ptr (void);
    IR_Repository_ptr operator-> (void);

  private:
    IR_Repository_ptr &ptr_;
  };

  class TAO_Export IR_Container_var : public TAO_Base_var
  {
  public:
    IR_Container_var (void); // default constructor
    IR_Container_var (IR_Container_ptr p) : ptr_ (p) {}
    IR_Container_var (const IR_Container_var &); // copy constructor
    ~IR_Container_var (void); // destructor

    IR_Container_var &operator= (IR_Container_ptr);
    IR_Container_var &operator= (const IR_Container_var &);
    IR_Container_ptr operator-> (void) const;

    operator const IR_Container_ptr &() const;
    operator IR_Container_ptr &();
    // in, inout, out, _retn
    IR_Container_ptr in (void) const;
    IR_Container_ptr &inout (void);
    IR_Container_ptr &out (void);
    IR_Container_ptr _retn (void);
    IR_Container_ptr ptr (void) const;

  private:
    IR_Container_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    IR_Container_var (const TAO_Base_var &rhs);
    IR_Container_var &operator= (const TAO_Base_var &rhs);
  };

  class TAO_Export IR_Container_out
  {
  public:
    IR_Container_out (IR_Container_ptr &);
    IR_Container_out (IR_Container_var &);
    IR_Container_out (const IR_Container_out &);
    IR_Container_out &operator= (const IR_Container_out &);
    IR_Container_out &operator= (const IR_Container_var &);
    IR_Container_out &operator= (IR_Container_ptr);
    operator IR_Container_ptr &();
    IR_Container_ptr &ptr (void);
    IR_Container_ptr operator-> (void);

  private:
    IR_Container_ptr &ptr_;
  };

// Forward Classes Declaration
  class _TAO_Contained_Proxy_Impl;
  class _TAO_Contained_Remote_Proxy_Impl;
  class _TAO_Contained_Proxy_Broker;
  class _TAO_Contained_Remote_Proxy_Broker;

  class TAO_Export IR_Contained: public virtual CORBA_IRObject
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef IR_Contained_ptr _ptr_type;
    typedef IR_Contained_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

    // the static operations
    static IR_Contained_ptr _duplicate (IR_Contained_ptr obj);
    static IR_Contained_ptr _narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static IR_Contained_ptr _unchecked_narrow (
        CORBA::Object_ptr obj,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    static IR_Contained_ptr _nil (void)
      {
        return (IR_Contained_ptr)0;
      }

    static void _tao_any_destructor (void*);

    virtual char * id (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void id (
        const char * id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * name (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void name (
        const char * name,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * version (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void version (
        const char * version,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual IR_Container_ptr defined_in (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual char * absolute_name (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual IR_Repository_ptr containing_repository (
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    struct Description;
    class Description_var;

    struct TAO_Export Description
    {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef Description_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

      static void _tao_any_destructor (void*);

      IR_DefinitionKind kind;
      CORBA::Any value;
    };

    class TAO_Export Description_var
    {
    public:
      Description_var (void); // default constructor
      Description_var (Description *);
      Description_var (const Description_var &); // copy constructor
      ~Description_var (void); // destructor

      Description_var &operator= (Description *);
      Description_var &operator= (const Description_var &);
      Description *operator-> (void);
      const Description *operator-> (void) const;

      operator const Description &() const;
      operator Description &();
      operator Description &() const;
      operator Description *&(); // variable-size types only

      // in, inout, out, _retn
      const Description &in (void) const;
      Description &inout (void);
      Description *&out (void);
      Description *_retn (void);
      Description *ptr (void) const;

    private:
      Description *ptr_;
    };

    class TAO_Export Description_out
    {
    public:
      Description_out (Description *&);
      Description_out (Description_var &);
      Description_out (const Description_out &);
      Description_out &operator= (const Description_out &);
      Description_out &operator= (Description *);
      operator Description *&();
      Description *&ptr (void);
      Description *operator-> (void);

    private:
      Description *&ptr_;
      // assignment from T_var not allowed
      void operator= (const Description_var &);
    };

    static CORBA::TypeCode_ptr _tc_Description;

    virtual IR_Contained::Description * describe     (
                        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual void move (
        IR_Container_ptr new_container,
        const char * new_name,
        const char * new_version,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

    virtual CORBA::Boolean _is_a (
        const CORBA::Char *type_id,
        CORBA::Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  private:
    _TAO_Contained_Proxy_Broker *the_TAO_Contained_Proxy_Broker_;

  protected:
    IR_Contained (int collocated = 0);

  protected:
    // This methods travese the inheritance tree and set the
    // parents piece of the given class in the right mode
    virtual void _tao_setup_collocation (int collocated);

    IR_Contained (
        TAO_Stub *objref,
        CORBA::Boolean _tao_collocated = 0,
        TAO_Abstract_ServantBase *servant = 0
      );

    friend class _TAO_Contained_Remote_Proxy_Impl;
    friend class _TAO_Contained_ThruPOA_Proxy_Impl;
    friend class _TAO_Contained_Direct_Proxy_Impl;

  virtual ~IR_Contained (void);
  private:
    IR_Contained (const IR_Contained &);
    void operator= (const IR_Contained &);

  };


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_Contained_Proxy_Impl :
  public virtual _TAO_IRObject_Proxy_Impl
{
public:
  virtual ~_TAO_Contained_Proxy_Impl (void) { }

    virtual char * id (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void id (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual char * name (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void name (
      CORBA_Object *_collocated_tao_target_,
      const char * name,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual char * version (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void version (
      CORBA_Object *_collocated_tao_target_,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_Container_ptr defined_in (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual char * absolute_name (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_Repository_ptr containing_repository (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_Contained::Description * describe (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void move (
      CORBA_Object *_collocated_tao_target_,
      IR_Container_ptr new_container,
      const char * new_name,
      const char * new_version,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_Contained_Proxy_Impl (void);
};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_Contained_Remote_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IRObject_Remote_Proxy_Impl

{
public:
  _TAO_Contained_Remote_Proxy_Impl (void);

  virtual ~_TAO_Contained_Remote_Proxy_Impl (void) { }

  virtual char * id (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void id (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual char * name (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void name (
      CORBA_Object *_collocated_tao_target_,
      const char * name,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual char * version (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void version (
      CORBA_Object *_collocated_tao_target_,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_Container_ptr defined_in (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual char * absolute_name (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_Repository_ptr containing_repository (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_Contained::Description * describe (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void move (
      CORBA_Object *_collocated_tao_target_,
      IR_Container_ptr new_container,
      const char * new_name,
      const char * new_version,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));
};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_Contained_Proxy_Broker
{
public:
  virtual ~_TAO_Contained_Proxy_Broker (void);

  virtual _TAO_Contained_Proxy_Impl &select_proxy (
    IR_Contained *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_Contained_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_Contained_Remote_Proxy_Broker : public virtual _TAO_Contained_Proxy_Broker
{
public:
  _TAO_Contained_Remote_Proxy_Broker (void);

  virtual ~_TAO_Contained_Remote_Proxy_Broker (void);

  virtual _TAO_Contained_Proxy_Impl &select_proxy (
    IR_Contained *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_Contained_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_Contained_Remote_Proxy_Broker *the_TAO_Contained_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

class TAO_Export IR_ModuleDef_var : public TAO_Base_var
{
public:
  IR_ModuleDef_var (void); // default constructor
  IR_ModuleDef_var (IR_ModuleDef_ptr p) : ptr_ (p) {}
  IR_ModuleDef_var (const IR_ModuleDef_var &); // copy constructor
  ~IR_ModuleDef_var (void); // destructor

  IR_ModuleDef_var &operator= (IR_ModuleDef_ptr);
  IR_ModuleDef_var &operator= (const IR_ModuleDef_var &);
  IR_ModuleDef_ptr operator-> (void) const;

  operator const IR_ModuleDef_ptr &() const;
  operator IR_ModuleDef_ptr &();
  // in, inout, out, _retn
  IR_ModuleDef_ptr in (void) const;
  IR_ModuleDef_ptr &inout (void);
  IR_ModuleDef_ptr &out (void);
  IR_ModuleDef_ptr _retn (void);
  IR_ModuleDef_ptr ptr (void) const;

private:
  IR_ModuleDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ModuleDef_var (const TAO_Base_var &rhs);
  IR_ModuleDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ModuleDef_out
{
public:
  IR_ModuleDef_out (IR_ModuleDef_ptr &);
  IR_ModuleDef_out (IR_ModuleDef_var &);
  IR_ModuleDef_out (const IR_ModuleDef_out &);
  IR_ModuleDef_out &operator= (const IR_ModuleDef_out &);
  IR_ModuleDef_out &operator= (const IR_ModuleDef_var &);
  IR_ModuleDef_out &operator= (IR_ModuleDef_ptr);
  operator IR_ModuleDef_ptr &();
  IR_ModuleDef_ptr &ptr (void);
  IR_ModuleDef_ptr operator-> (void);

private:
  IR_ModuleDef_ptr &ptr_;
};

class TAO_Export IR_ConstantDef_var : public TAO_Base_var
{
public:
  IR_ConstantDef_var (void); // default constructor
  IR_ConstantDef_var (IR_ConstantDef_ptr p) : ptr_ (p) {}
  IR_ConstantDef_var (const IR_ConstantDef_var &); // copy constructor
  ~IR_ConstantDef_var (void); // destructor

  IR_ConstantDef_var &operator= (IR_ConstantDef_ptr);
  IR_ConstantDef_var &operator= (const IR_ConstantDef_var &);
  IR_ConstantDef_ptr operator-> (void) const;

  operator const IR_ConstantDef_ptr &() const;
  operator IR_ConstantDef_ptr &();
  // in, inout, out, _retn
  IR_ConstantDef_ptr in (void) const;
  IR_ConstantDef_ptr &inout (void);
  IR_ConstantDef_ptr &out (void);
  IR_ConstantDef_ptr _retn (void);
  IR_ConstantDef_ptr ptr (void) const;

private:
  IR_ConstantDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ConstantDef_var (const TAO_Base_var &rhs);
  IR_ConstantDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ConstantDef_out
{
public:
  IR_ConstantDef_out (IR_ConstantDef_ptr &);
  IR_ConstantDef_out (IR_ConstantDef_var &);
  IR_ConstantDef_out (const IR_ConstantDef_out &);
  IR_ConstantDef_out &operator= (const IR_ConstantDef_out &);
  IR_ConstantDef_out &operator= (const IR_ConstantDef_var &);
  IR_ConstantDef_out &operator= (IR_ConstantDef_ptr);
  operator IR_ConstantDef_ptr &();
  IR_ConstantDef_ptr &ptr (void);
  IR_ConstantDef_ptr operator-> (void);

private:
  IR_ConstantDef_ptr &ptr_;
};

class TAO_Export IR_IDLType_var : public TAO_Base_var
{
public:
  IR_IDLType_var (void); // default constructor
  IR_IDLType_var (IR_IDLType_ptr p) : ptr_ (p) {}
  IR_IDLType_var (const IR_IDLType_var &); // copy constructor
  ~IR_IDLType_var (void); // destructor

  IR_IDLType_var &operator= (IR_IDLType_ptr);
  IR_IDLType_var &operator= (const IR_IDLType_var &);
  IR_IDLType_ptr operator-> (void) const;

  operator const IR_IDLType_ptr &() const;
  operator IR_IDLType_ptr &();
  // in, inout, out, _retn
  IR_IDLType_ptr in (void) const;
  IR_IDLType_ptr &inout (void);
  IR_IDLType_ptr &out (void);
  IR_IDLType_ptr _retn (void);
  IR_IDLType_ptr ptr (void) const;

private:
  IR_IDLType_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_IDLType_var (const TAO_Base_var &rhs);
  IR_IDLType_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_IDLType_out
{
public:
  IR_IDLType_out (IR_IDLType_ptr &);
  IR_IDLType_out (IR_IDLType_var &);
  IR_IDLType_out (const IR_IDLType_out &);
  IR_IDLType_out &operator= (const IR_IDLType_out &);
  IR_IDLType_out &operator= (const IR_IDLType_var &);
  IR_IDLType_out &operator= (IR_IDLType_ptr);
  operator IR_IDLType_ptr &();
  IR_IDLType_ptr &ptr (void);
  IR_IDLType_ptr operator-> (void);

private:
  IR_IDLType_ptr &ptr_;
};

class TAO_Export IR_StructDef_var : public TAO_Base_var
{
public:
  IR_StructDef_var (void); // default constructor
  IR_StructDef_var (IR_StructDef_ptr p) : ptr_ (p) {}
  IR_StructDef_var (const IR_StructDef_var &); // copy constructor
  ~IR_StructDef_var (void); // destructor

  IR_StructDef_var &operator= (IR_StructDef_ptr);
  IR_StructDef_var &operator= (const IR_StructDef_var &);
  IR_StructDef_ptr operator-> (void) const;

  operator const IR_StructDef_ptr &() const;
  operator IR_StructDef_ptr &();
  // in, inout, out, _retn
  IR_StructDef_ptr in (void) const;
  IR_StructDef_ptr &inout (void);
  IR_StructDef_ptr &out (void);
  IR_StructDef_ptr _retn (void);
  IR_StructDef_ptr ptr (void) const;

private:
  IR_StructDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_StructDef_var (const TAO_Base_var &rhs);
  IR_StructDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_StructDef_out
{
public:
  IR_StructDef_out (IR_StructDef_ptr &);
  IR_StructDef_out (IR_StructDef_var &);
  IR_StructDef_out (const IR_StructDef_out &);
  IR_StructDef_out &operator= (const IR_StructDef_out &);
  IR_StructDef_out &operator= (const IR_StructDef_var &);
  IR_StructDef_out &operator= (IR_StructDef_ptr);
  operator IR_StructDef_ptr &();
  IR_StructDef_ptr &ptr (void);
  IR_StructDef_ptr operator-> (void);

private:
  IR_StructDef_ptr &ptr_;
};

class TAO_Export IR_UnionDef_var : public TAO_Base_var
{
public:
  IR_UnionDef_var (void); // default constructor
  IR_UnionDef_var (IR_UnionDef_ptr p) : ptr_ (p) {}
  IR_UnionDef_var (const IR_UnionDef_var &); // copy constructor
  ~IR_UnionDef_var (void); // destructor

  IR_UnionDef_var &operator= (IR_UnionDef_ptr);
  IR_UnionDef_var &operator= (const IR_UnionDef_var &);
  IR_UnionDef_ptr operator-> (void) const;

  operator const IR_UnionDef_ptr &() const;
  operator IR_UnionDef_ptr &();
  // in, inout, out, _retn
  IR_UnionDef_ptr in (void) const;
  IR_UnionDef_ptr &inout (void);
  IR_UnionDef_ptr &out (void);
  IR_UnionDef_ptr _retn (void);
  IR_UnionDef_ptr ptr (void) const;

private:
  IR_UnionDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_UnionDef_var (const TAO_Base_var &rhs);
  IR_UnionDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_UnionDef_out
{
public:
  IR_UnionDef_out (IR_UnionDef_ptr &);
  IR_UnionDef_out (IR_UnionDef_var &);
  IR_UnionDef_out (const IR_UnionDef_out &);
  IR_UnionDef_out &operator= (const IR_UnionDef_out &);
  IR_UnionDef_out &operator= (const IR_UnionDef_var &);
  IR_UnionDef_out &operator= (IR_UnionDef_ptr);
  operator IR_UnionDef_ptr &();
  IR_UnionDef_ptr &ptr (void);
  IR_UnionDef_ptr operator-> (void);

private:
  IR_UnionDef_ptr &ptr_;
};

class TAO_Export IR_EnumDef_var : public TAO_Base_var
{
public:
  IR_EnumDef_var (void); // default constructor
  IR_EnumDef_var (IR_EnumDef_ptr p) : ptr_ (p) {}
  IR_EnumDef_var (const IR_EnumDef_var &); // copy constructor
  ~IR_EnumDef_var (void); // destructor

  IR_EnumDef_var &operator= (IR_EnumDef_ptr);
  IR_EnumDef_var &operator= (const IR_EnumDef_var &);
  IR_EnumDef_ptr operator-> (void) const;

  operator const IR_EnumDef_ptr &() const;
  operator IR_EnumDef_ptr &();
  // in, inout, out, _retn
  IR_EnumDef_ptr in (void) const;
  IR_EnumDef_ptr &inout (void);
  IR_EnumDef_ptr &out (void);
  IR_EnumDef_ptr _retn (void);
  IR_EnumDef_ptr ptr (void) const;

private:
  IR_EnumDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_EnumDef_var (const TAO_Base_var &rhs);
  IR_EnumDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_EnumDef_out
{
public:
  IR_EnumDef_out (IR_EnumDef_ptr &);
  IR_EnumDef_out (IR_EnumDef_var &);
  IR_EnumDef_out (const IR_EnumDef_out &);
  IR_EnumDef_out &operator= (const IR_EnumDef_out &);
  IR_EnumDef_out &operator= (const IR_EnumDef_var &);
  IR_EnumDef_out &operator= (IR_EnumDef_ptr);
  operator IR_EnumDef_ptr &();
  IR_EnumDef_ptr &ptr (void);
  IR_EnumDef_ptr operator-> (void);

private:
  IR_EnumDef_ptr &ptr_;
};

class TAO_Export IR_AliasDef_var : public TAO_Base_var
{
public:
  IR_AliasDef_var (void); // default constructor
  IR_AliasDef_var (IR_AliasDef_ptr p) : ptr_ (p) {}
  IR_AliasDef_var (const IR_AliasDef_var &); // copy constructor
  ~IR_AliasDef_var (void); // destructor

  IR_AliasDef_var &operator= (IR_AliasDef_ptr);
  IR_AliasDef_var &operator= (const IR_AliasDef_var &);
  IR_AliasDef_ptr operator-> (void) const;

  operator const IR_AliasDef_ptr &() const;
  operator IR_AliasDef_ptr &();
  // in, inout, out, _retn
  IR_AliasDef_ptr in (void) const;
  IR_AliasDef_ptr &inout (void);
  IR_AliasDef_ptr &out (void);
  IR_AliasDef_ptr _retn (void);
  IR_AliasDef_ptr ptr (void) const;

private:
  IR_AliasDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_AliasDef_var (const TAO_Base_var &rhs);
  IR_AliasDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_AliasDef_out
{
public:
  IR_AliasDef_out (IR_AliasDef_ptr &);
  IR_AliasDef_out (IR_AliasDef_var &);
  IR_AliasDef_out (const IR_AliasDef_out &);
  IR_AliasDef_out &operator= (const IR_AliasDef_out &);
  IR_AliasDef_out &operator= (const IR_AliasDef_var &);
  IR_AliasDef_out &operator= (IR_AliasDef_ptr);
  operator IR_AliasDef_ptr &();
  IR_AliasDef_ptr &ptr (void);
  IR_AliasDef_ptr operator-> (void);

private:
  IR_AliasDef_ptr &ptr_;
};

class TAO_Export IR_InterfaceDef_var : public TAO_Base_var
{
public:
  IR_InterfaceDef_var (void); // default constructor
  IR_InterfaceDef_var (IR_InterfaceDef_ptr p) : ptr_ (p) {}
  IR_InterfaceDef_var (const IR_InterfaceDef_var &); // copy constructor
  ~IR_InterfaceDef_var (void); // destructor

  IR_InterfaceDef_var &operator= (IR_InterfaceDef_ptr);
  IR_InterfaceDef_var &operator= (const IR_InterfaceDef_var &);
  IR_InterfaceDef_ptr operator-> (void) const;

  operator const IR_InterfaceDef_ptr &() const;
  operator IR_InterfaceDef_ptr &();
  // in, inout, out, _retn
  IR_InterfaceDef_ptr in (void) const;
  IR_InterfaceDef_ptr &inout (void);
  IR_InterfaceDef_ptr &out (void);
  IR_InterfaceDef_ptr _retn (void);
  IR_InterfaceDef_ptr ptr (void) const;

private:
  IR_InterfaceDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_InterfaceDef_var (const TAO_Base_var &rhs);
  IR_InterfaceDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_InterfaceDef_out
{
public:
  IR_InterfaceDef_out (IR_InterfaceDef_ptr &);
  IR_InterfaceDef_out (IR_InterfaceDef_var &);
  IR_InterfaceDef_out (const IR_InterfaceDef_out &);
  IR_InterfaceDef_out &operator= (const IR_InterfaceDef_out &);
  IR_InterfaceDef_out &operator= (const IR_InterfaceDef_var &);
  IR_InterfaceDef_out &operator= (IR_InterfaceDef_ptr);
  operator IR_InterfaceDef_ptr &();
  IR_InterfaceDef_ptr &ptr (void);
  IR_InterfaceDef_ptr operator-> (void);

private:
  IR_InterfaceDef_ptr &ptr_;
};

class TAO_Export IR_ExceptionDef_var : public TAO_Base_var
{
public:
  IR_ExceptionDef_var (void); // default constructor
  IR_ExceptionDef_var (IR_ExceptionDef_ptr p) : ptr_ (p) {}
  IR_ExceptionDef_var (const IR_ExceptionDef_var &); // copy constructor
  ~IR_ExceptionDef_var (void); // destructor

  IR_ExceptionDef_var &operator= (IR_ExceptionDef_ptr);
  IR_ExceptionDef_var &operator= (const IR_ExceptionDef_var &);
  IR_ExceptionDef_ptr operator-> (void) const;

  operator const IR_ExceptionDef_ptr &() const;
  operator IR_ExceptionDef_ptr &();
  // in, inout, out, _retn
  IR_ExceptionDef_ptr in (void) const;
  IR_ExceptionDef_ptr &inout (void);
  IR_ExceptionDef_ptr &out (void);
  IR_ExceptionDef_ptr _retn (void);
  IR_ExceptionDef_ptr ptr (void) const;

private:
  IR_ExceptionDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ExceptionDef_var (const TAO_Base_var &rhs);
  IR_ExceptionDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ExceptionDef_out
{
public:
  IR_ExceptionDef_out (IR_ExceptionDef_ptr &);
  IR_ExceptionDef_out (IR_ExceptionDef_var &);
  IR_ExceptionDef_out (const IR_ExceptionDef_out &);
  IR_ExceptionDef_out &operator= (const IR_ExceptionDef_out &);
  IR_ExceptionDef_out &operator= (const IR_ExceptionDef_var &);
  IR_ExceptionDef_out &operator= (IR_ExceptionDef_ptr);
  operator IR_ExceptionDef_ptr &();
  IR_ExceptionDef_ptr &ptr (void);
  IR_ExceptionDef_ptr operator-> (void);

private:
  IR_ExceptionDef_ptr &ptr_;
};

class TAO_Export IR_NativeDef_var : public TAO_Base_var
{
public:
  IR_NativeDef_var (void); // default constructor
  IR_NativeDef_var (IR_NativeDef_ptr p) : ptr_ (p) {}
  IR_NativeDef_var (const IR_NativeDef_var &); // copy constructor
  ~IR_NativeDef_var (void); // destructor

  IR_NativeDef_var &operator= (IR_NativeDef_ptr);
  IR_NativeDef_var &operator= (const IR_NativeDef_var &);
  IR_NativeDef_ptr operator-> (void) const;

  operator const IR_NativeDef_ptr &() const;
  operator IR_NativeDef_ptr &();
  // in, inout, out, _retn
  IR_NativeDef_ptr in (void) const;
  IR_NativeDef_ptr &inout (void);
  IR_NativeDef_ptr &out (void);
  IR_NativeDef_ptr _retn (void);
  IR_NativeDef_ptr ptr (void) const;

private:
  IR_NativeDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_NativeDef_var (const TAO_Base_var &rhs);
  IR_NativeDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_NativeDef_out
{
public:
  IR_NativeDef_out (IR_NativeDef_ptr &);
  IR_NativeDef_out (IR_NativeDef_var &);
  IR_NativeDef_out (const IR_NativeDef_out &);
  IR_NativeDef_out &operator= (const IR_NativeDef_out &);
  IR_NativeDef_out &operator= (const IR_NativeDef_var &);
  IR_NativeDef_out &operator= (IR_NativeDef_ptr);
  operator IR_NativeDef_ptr &();
  IR_NativeDef_ptr &ptr (void);
  IR_NativeDef_ptr operator-> (void);

private:
  IR_NativeDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_InterfaceDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq(const _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq &rhs);
    TAO_Object_Manager<IR_InterfaceDef,IR_InterfaceDef_var> operator[] (CORBA::ULong index) const;
    static IR_InterfaceDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_InterfaceDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_InterfaceDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_InterfaceDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_InterfaceDefSeq
// *************************************************************

class TAO_Export IR_InterfaceDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_InterfaceDef,IR_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_InterfaceDefSeq (void); // default ctor
  IR_InterfaceDefSeq (CORBA::ULong max); // uses max size
  IR_InterfaceDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_InterfaceDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_InterfaceDefSeq (const IR_InterfaceDefSeq &); // copy ctor
  ~IR_InterfaceDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_InterfaceDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_InterfaceDefSeq_var
// *************************************************************

class TAO_Export IR_InterfaceDefSeq_var
{
public:
  IR_InterfaceDefSeq_var (void); // default constructor
  IR_InterfaceDefSeq_var (IR_InterfaceDefSeq *);
  IR_InterfaceDefSeq_var (const IR_InterfaceDefSeq_var &); // copy constructor
  ~IR_InterfaceDefSeq_var (void); // destructor

  IR_InterfaceDefSeq_var &operator= (IR_InterfaceDefSeq *);
  IR_InterfaceDefSeq_var &operator= (const IR_InterfaceDefSeq_var &);
  IR_InterfaceDefSeq *operator-> (void);
  const IR_InterfaceDefSeq *operator-> (void) const;

  operator const IR_InterfaceDefSeq &() const;
  operator IR_InterfaceDefSeq &();
  operator IR_InterfaceDefSeq &() const;
  operator IR_InterfaceDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_InterfaceDef, IR_InterfaceDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_InterfaceDefSeq &in (void) const;
  IR_InterfaceDefSeq &inout (void);
  IR_InterfaceDefSeq *&out (void);
  IR_InterfaceDefSeq *_retn (void);
  IR_InterfaceDefSeq *ptr (void) const;

private:
  IR_InterfaceDefSeq *ptr_;
};

class TAO_Export IR_InterfaceDefSeq_out
{
public:
  IR_InterfaceDefSeq_out (IR_InterfaceDefSeq *&);
  IR_InterfaceDefSeq_out (IR_InterfaceDefSeq_var &);
  IR_InterfaceDefSeq_out (const IR_InterfaceDefSeq_out &);
  IR_InterfaceDefSeq_out &operator= (const IR_InterfaceDefSeq_out &);
  IR_InterfaceDefSeq_out &operator= (IR_InterfaceDefSeq *);
  operator IR_InterfaceDefSeq *&();
  IR_InterfaceDefSeq *&ptr (void);
  IR_InterfaceDefSeq *operator-> (void);
  TAO_Object_Manager<IR_InterfaceDef, IR_InterfaceDef_var> operator[] (CORBA::ULong index);

private:
  IR_InterfaceDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_InterfaceDefSeq_var &);
};

class TAO_Export IR_ValueDef_var : public TAO_Base_var
{
public:
  IR_ValueDef_var (void); // default constructor
  IR_ValueDef_var (IR_ValueDef_ptr p) : ptr_ (p) {}
  IR_ValueDef_var (const IR_ValueDef_var &); // copy constructor
  ~IR_ValueDef_var (void); // destructor

  IR_ValueDef_var &operator= (IR_ValueDef_ptr);
  IR_ValueDef_var &operator= (const IR_ValueDef_var &);
  IR_ValueDef_ptr operator-> (void) const;

  operator const IR_ValueDef_ptr &() const;
  operator IR_ValueDef_ptr &();
  // in, inout, out, _retn
  IR_ValueDef_ptr in (void) const;
  IR_ValueDef_ptr &inout (void);
  IR_ValueDef_ptr &out (void);
  IR_ValueDef_ptr _retn (void);
  IR_ValueDef_ptr ptr (void) const;

private:
  IR_ValueDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ValueDef_var (const TAO_Base_var &rhs);
  IR_ValueDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ValueDef_out
{
public:
  IR_ValueDef_out (IR_ValueDef_ptr &);
  IR_ValueDef_out (IR_ValueDef_var &);
  IR_ValueDef_out (const IR_ValueDef_out &);
  IR_ValueDef_out &operator= (const IR_ValueDef_out &);
  IR_ValueDef_out &operator= (const IR_ValueDef_var &);
  IR_ValueDef_out &operator= (IR_ValueDef_ptr);
  operator IR_ValueDef_ptr &();
  IR_ValueDef_ptr &ptr (void);
  IR_ValueDef_ptr operator-> (void);

private:
  IR_ValueDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ValueDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq &rhs);
    TAO_Object_Manager<IR_ValueDef,IR_ValueDef_var> operator[] (CORBA::ULong index) const;
    static IR_ValueDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_ValueDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_ValueDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ValueDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ValueDefSeq
// *************************************************************

class TAO_Export IR_ValueDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ValueDef,IR_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ValueDefSeq (void); // default ctor
  IR_ValueDefSeq (CORBA::ULong max); // uses max size
  IR_ValueDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ValueDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_ValueDefSeq (const IR_ValueDefSeq &); // copy ctor
  ~IR_ValueDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ValueDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ValueDefSeq_var
// *************************************************************

class TAO_Export IR_ValueDefSeq_var
{
public:
  IR_ValueDefSeq_var (void); // default constructor
  IR_ValueDefSeq_var (IR_ValueDefSeq *);
  IR_ValueDefSeq_var (const IR_ValueDefSeq_var &); // copy constructor
  ~IR_ValueDefSeq_var (void); // destructor

  IR_ValueDefSeq_var &operator= (IR_ValueDefSeq *);
  IR_ValueDefSeq_var &operator= (const IR_ValueDefSeq_var &);
  IR_ValueDefSeq *operator-> (void);
  const IR_ValueDefSeq *operator-> (void) const;

  operator const IR_ValueDefSeq &() const;
  operator IR_ValueDefSeq &();
  operator IR_ValueDefSeq &() const;
  operator IR_ValueDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_ValueDef, IR_ValueDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_ValueDefSeq &in (void) const;
  IR_ValueDefSeq &inout (void);
  IR_ValueDefSeq *&out (void);
  IR_ValueDefSeq *_retn (void);
  IR_ValueDefSeq *ptr (void) const;

private:
  IR_ValueDefSeq *ptr_;
};

class TAO_Export IR_ValueDefSeq_out
{
public:
  IR_ValueDefSeq_out (IR_ValueDefSeq *&);
  IR_ValueDefSeq_out (IR_ValueDefSeq_var &);
  IR_ValueDefSeq_out (const IR_ValueDefSeq_out &);
  IR_ValueDefSeq_out &operator= (const IR_ValueDefSeq_out &);
  IR_ValueDefSeq_out &operator= (IR_ValueDefSeq *);
  operator IR_ValueDefSeq *&();
  IR_ValueDefSeq *&ptr (void);
  IR_ValueDefSeq *operator-> (void);
  TAO_Object_Manager<IR_ValueDef, IR_ValueDef_var> operator[] (CORBA::ULong index);

private:
  IR_ValueDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ValueDefSeq_var &);
};

class TAO_Export IR_ValueBoxDef_var : public TAO_Base_var
{
public:
  IR_ValueBoxDef_var (void); // default constructor
  IR_ValueBoxDef_var (IR_ValueBoxDef_ptr p) : ptr_ (p) {}
  IR_ValueBoxDef_var (const IR_ValueBoxDef_var &); // copy constructor
  ~IR_ValueBoxDef_var (void); // destructor

  IR_ValueBoxDef_var &operator= (IR_ValueBoxDef_ptr);
  IR_ValueBoxDef_var &operator= (const IR_ValueBoxDef_var &);
  IR_ValueBoxDef_ptr operator-> (void) const;

  operator const IR_ValueBoxDef_ptr &() const;
  operator IR_ValueBoxDef_ptr &();
  // in, inout, out, _retn
  IR_ValueBoxDef_ptr in (void) const;
  IR_ValueBoxDef_ptr &inout (void);
  IR_ValueBoxDef_ptr &out (void);
  IR_ValueBoxDef_ptr _retn (void);
  IR_ValueBoxDef_ptr ptr (void) const;

private:
  IR_ValueBoxDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ValueBoxDef_var (const TAO_Base_var &rhs);
  IR_ValueBoxDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ValueBoxDef_out
{
public:
  IR_ValueBoxDef_out (IR_ValueBoxDef_ptr &);
  IR_ValueBoxDef_out (IR_ValueBoxDef_var &);
  IR_ValueBoxDef_out (const IR_ValueBoxDef_out &);
  IR_ValueBoxDef_out &operator= (const IR_ValueBoxDef_out &);
  IR_ValueBoxDef_out &operator= (const IR_ValueBoxDef_var &);
  IR_ValueBoxDef_out &operator= (IR_ValueBoxDef_ptr);
  operator IR_ValueBoxDef_ptr &();
  IR_ValueBoxDef_ptr &ptr (void);
  IR_ValueBoxDef_ptr operator-> (void);

private:
  IR_ValueBoxDef_ptr &ptr_;
};

class TAO_Export IR_ComponentDef_var : public TAO_Base_var
{
public:
  IR_ComponentDef_var (void); // default constructor
  IR_ComponentDef_var (IR_ComponentDef_ptr p) : ptr_ (p) {}
  IR_ComponentDef_var (const IR_ComponentDef_var &); // copy constructor
  ~IR_ComponentDef_var (void); // destructor

  IR_ComponentDef_var &operator= (IR_ComponentDef_ptr);
  IR_ComponentDef_var &operator= (const IR_ComponentDef_var &);
  IR_ComponentDef_ptr operator-> (void) const;

  operator const IR_ComponentDef_ptr &() const;
  operator IR_ComponentDef_ptr &();
  // in, inout, out, _retn
  IR_ComponentDef_ptr in (void) const;
  IR_ComponentDef_ptr &inout (void);
  IR_ComponentDef_ptr &out (void);
  IR_ComponentDef_ptr _retn (void);
  IR_ComponentDef_ptr ptr (void) const;

private:
  IR_ComponentDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ComponentDef_var (const TAO_Base_var &rhs);
  IR_ComponentDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ComponentDef_out
{
public:
  IR_ComponentDef_out (IR_ComponentDef_ptr &);
  IR_ComponentDef_out (IR_ComponentDef_var &);
  IR_ComponentDef_out (const IR_ComponentDef_out &);
  IR_ComponentDef_out &operator= (const IR_ComponentDef_out &);
  IR_ComponentDef_out &operator= (const IR_ComponentDef_var &);
  IR_ComponentDef_out &operator= (IR_ComponentDef_ptr);
  operator IR_ComponentDef_ptr &();
  IR_ComponentDef_ptr &ptr (void);
  IR_ComponentDef_ptr operator-> (void);

private:
  IR_ComponentDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ComponentDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq &rhs);
    TAO_Object_Manager<IR_ComponentDef,IR_ComponentDef_var> operator[] (CORBA::ULong index) const;
    static IR_ComponentDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_ComponentDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_ComponentDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ComponentDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ComponentDefSeq
// *************************************************************

class TAO_Export IR_ComponentDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ComponentDef,IR_ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ComponentDefSeq (void); // default ctor
  IR_ComponentDefSeq (CORBA::ULong max); // uses max size
  IR_ComponentDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ComponentDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_ComponentDefSeq (const IR_ComponentDefSeq &); // copy ctor
  ~IR_ComponentDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ComponentDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ComponentDefSeq_var
// *************************************************************

class TAO_Export IR_ComponentDefSeq_var
{
public:
  IR_ComponentDefSeq_var (void); // default constructor
  IR_ComponentDefSeq_var (IR_ComponentDefSeq *);
  IR_ComponentDefSeq_var (const IR_ComponentDefSeq_var &); // copy constructor
  ~IR_ComponentDefSeq_var (void); // destructor

  IR_ComponentDefSeq_var &operator= (IR_ComponentDefSeq *);
  IR_ComponentDefSeq_var &operator= (const IR_ComponentDefSeq_var &);
  IR_ComponentDefSeq *operator-> (void);
  const IR_ComponentDefSeq *operator-> (void) const;

  operator const IR_ComponentDefSeq &() const;
  operator IR_ComponentDefSeq &();
  operator IR_ComponentDefSeq &() const;
  operator IR_ComponentDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_ComponentDef, IR_ComponentDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_ComponentDefSeq &in (void) const;
  IR_ComponentDefSeq &inout (void);
  IR_ComponentDefSeq *&out (void);
  IR_ComponentDefSeq *_retn (void);
  IR_ComponentDefSeq *ptr (void) const;

private:
  IR_ComponentDefSeq *ptr_;
};

class TAO_Export IR_ComponentDefSeq_out
{
public:
  IR_ComponentDefSeq_out (IR_ComponentDefSeq *&);
  IR_ComponentDefSeq_out (IR_ComponentDefSeq_var &);
  IR_ComponentDefSeq_out (const IR_ComponentDefSeq_out &);
  IR_ComponentDefSeq_out &operator= (const IR_ComponentDefSeq_out &);
  IR_ComponentDefSeq_out &operator= (IR_ComponentDefSeq *);
  operator IR_ComponentDefSeq *&();
  IR_ComponentDefSeq *&ptr (void);
  IR_ComponentDefSeq *operator-> (void);
  TAO_Object_Manager<IR_ComponentDef, IR_ComponentDef_var> operator[] (CORBA::ULong index);

private:
  IR_ComponentDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ComponentDefSeq_var &);
};

class TAO_Export IR_ProvidesDef_var : public TAO_Base_var
{
public:
  IR_ProvidesDef_var (void); // default constructor
  IR_ProvidesDef_var (IR_ProvidesDef_ptr p) : ptr_ (p) {}
  IR_ProvidesDef_var (const IR_ProvidesDef_var &); // copy constructor
  ~IR_ProvidesDef_var (void); // destructor

  IR_ProvidesDef_var &operator= (IR_ProvidesDef_ptr);
  IR_ProvidesDef_var &operator= (const IR_ProvidesDef_var &);
  IR_ProvidesDef_ptr operator-> (void) const;

  operator const IR_ProvidesDef_ptr &() const;
  operator IR_ProvidesDef_ptr &();
  // in, inout, out, _retn
  IR_ProvidesDef_ptr in (void) const;
  IR_ProvidesDef_ptr &inout (void);
  IR_ProvidesDef_ptr &out (void);
  IR_ProvidesDef_ptr _retn (void);
  IR_ProvidesDef_ptr ptr (void) const;

private:
  IR_ProvidesDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ProvidesDef_var (const TAO_Base_var &rhs);
  IR_ProvidesDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ProvidesDef_out
{
public:
  IR_ProvidesDef_out (IR_ProvidesDef_ptr &);
  IR_ProvidesDef_out (IR_ProvidesDef_var &);
  IR_ProvidesDef_out (const IR_ProvidesDef_out &);
  IR_ProvidesDef_out &operator= (const IR_ProvidesDef_out &);
  IR_ProvidesDef_out &operator= (const IR_ProvidesDef_var &);
  IR_ProvidesDef_out &operator= (IR_ProvidesDef_ptr);
  operator IR_ProvidesDef_ptr &();
  IR_ProvidesDef_ptr &ptr (void);
  IR_ProvidesDef_ptr operator-> (void);

private:
  IR_ProvidesDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ProvidesDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq &rhs);
    TAO_Object_Manager<IR_ProvidesDef,IR_ProvidesDef_var> operator[] (CORBA::ULong index) const;
    static IR_ProvidesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_ProvidesDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_ProvidesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ProvidesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ProvidesDefSeq
// *************************************************************

class TAO_Export IR_ProvidesDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ProvidesDef,IR_ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ProvidesDefSeq (void); // default ctor
  IR_ProvidesDefSeq (CORBA::ULong max); // uses max size
  IR_ProvidesDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ProvidesDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_ProvidesDefSeq (const IR_ProvidesDefSeq &); // copy ctor
  ~IR_ProvidesDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ProvidesDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ProvidesDefSeq_var
// *************************************************************

class TAO_Export IR_ProvidesDefSeq_var
{
public:
  IR_ProvidesDefSeq_var (void); // default constructor
  IR_ProvidesDefSeq_var (IR_ProvidesDefSeq *);
  IR_ProvidesDefSeq_var (const IR_ProvidesDefSeq_var &); // copy constructor
  ~IR_ProvidesDefSeq_var (void); // destructor

  IR_ProvidesDefSeq_var &operator= (IR_ProvidesDefSeq *);
  IR_ProvidesDefSeq_var &operator= (const IR_ProvidesDefSeq_var &);
  IR_ProvidesDefSeq *operator-> (void);
  const IR_ProvidesDefSeq *operator-> (void) const;

  operator const IR_ProvidesDefSeq &() const;
  operator IR_ProvidesDefSeq &();
  operator IR_ProvidesDefSeq &() const;
  operator IR_ProvidesDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_ProvidesDef, IR_ProvidesDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_ProvidesDefSeq &in (void) const;
  IR_ProvidesDefSeq &inout (void);
  IR_ProvidesDefSeq *&out (void);
  IR_ProvidesDefSeq *_retn (void);
  IR_ProvidesDefSeq *ptr (void) const;

private:
  IR_ProvidesDefSeq *ptr_;
};

class TAO_Export IR_ProvidesDefSeq_out
{
public:
  IR_ProvidesDefSeq_out (IR_ProvidesDefSeq *&);
  IR_ProvidesDefSeq_out (IR_ProvidesDefSeq_var &);
  IR_ProvidesDefSeq_out (const IR_ProvidesDefSeq_out &);
  IR_ProvidesDefSeq_out &operator= (const IR_ProvidesDefSeq_out &);
  IR_ProvidesDefSeq_out &operator= (IR_ProvidesDefSeq *);
  operator IR_ProvidesDefSeq *&();
  IR_ProvidesDefSeq *&ptr (void);
  IR_ProvidesDefSeq *operator-> (void);
  TAO_Object_Manager<IR_ProvidesDef, IR_ProvidesDef_var> operator[] (CORBA::ULong index);

private:
  IR_ProvidesDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ProvidesDefSeq_var &);
};

class TAO_Export IR_UsesDef_var : public TAO_Base_var
{
public:
  IR_UsesDef_var (void); // default constructor
  IR_UsesDef_var (IR_UsesDef_ptr p) : ptr_ (p) {}
  IR_UsesDef_var (const IR_UsesDef_var &); // copy constructor
  ~IR_UsesDef_var (void); // destructor

  IR_UsesDef_var &operator= (IR_UsesDef_ptr);
  IR_UsesDef_var &operator= (const IR_UsesDef_var &);
  IR_UsesDef_ptr operator-> (void) const;

  operator const IR_UsesDef_ptr &() const;
  operator IR_UsesDef_ptr &();
  // in, inout, out, _retn
  IR_UsesDef_ptr in (void) const;
  IR_UsesDef_ptr &inout (void);
  IR_UsesDef_ptr &out (void);
  IR_UsesDef_ptr _retn (void);
  IR_UsesDef_ptr ptr (void) const;

private:
  IR_UsesDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_UsesDef_var (const TAO_Base_var &rhs);
  IR_UsesDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_UsesDef_out
{
public:
  IR_UsesDef_out (IR_UsesDef_ptr &);
  IR_UsesDef_out (IR_UsesDef_var &);
  IR_UsesDef_out (const IR_UsesDef_out &);
  IR_UsesDef_out &operator= (const IR_UsesDef_out &);
  IR_UsesDef_out &operator= (const IR_UsesDef_var &);
  IR_UsesDef_out &operator= (IR_UsesDef_ptr);
  operator IR_UsesDef_ptr &();
  IR_UsesDef_ptr &ptr (void);
  IR_UsesDef_ptr operator-> (void);

private:
  IR_UsesDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_UsesDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq &rhs);
    TAO_Object_Manager<IR_UsesDef,IR_UsesDef_var> operator[] (CORBA::ULong index) const;
    static IR_UsesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_UsesDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_UsesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_UsesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_UsesDefSeq
// *************************************************************

class TAO_Export IR_UsesDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_UsesDef,IR_UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_UsesDefSeq (void); // default ctor
  IR_UsesDefSeq (CORBA::ULong max); // uses max size
  IR_UsesDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_UsesDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_UsesDefSeq (const IR_UsesDefSeq &); // copy ctor
  ~IR_UsesDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_UsesDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_UsesDefSeq_var
// *************************************************************

class TAO_Export IR_UsesDefSeq_var
{
public:
  IR_UsesDefSeq_var (void); // default constructor
  IR_UsesDefSeq_var (IR_UsesDefSeq *);
  IR_UsesDefSeq_var (const IR_UsesDefSeq_var &); // copy constructor
  ~IR_UsesDefSeq_var (void); // destructor

  IR_UsesDefSeq_var &operator= (IR_UsesDefSeq *);
  IR_UsesDefSeq_var &operator= (const IR_UsesDefSeq_var &);
  IR_UsesDefSeq *operator-> (void);
  const IR_UsesDefSeq *operator-> (void) const;

  operator const IR_UsesDefSeq &() const;
  operator IR_UsesDefSeq &();
  operator IR_UsesDefSeq &() const;
  operator IR_UsesDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_UsesDef, IR_UsesDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_UsesDefSeq &in (void) const;
  IR_UsesDefSeq &inout (void);
  IR_UsesDefSeq *&out (void);
  IR_UsesDefSeq *_retn (void);
  IR_UsesDefSeq *ptr (void) const;

private:
  IR_UsesDefSeq *ptr_;
};

class TAO_Export IR_UsesDefSeq_out
{
public:
  IR_UsesDefSeq_out (IR_UsesDefSeq *&);
  IR_UsesDefSeq_out (IR_UsesDefSeq_var &);
  IR_UsesDefSeq_out (const IR_UsesDefSeq_out &);
  IR_UsesDefSeq_out &operator= (const IR_UsesDefSeq_out &);
  IR_UsesDefSeq_out &operator= (IR_UsesDefSeq *);
  operator IR_UsesDefSeq *&();
  IR_UsesDefSeq *&ptr (void);
  IR_UsesDefSeq *operator-> (void);
  TAO_Object_Manager<IR_UsesDef, IR_UsesDef_var> operator[] (CORBA::ULong index);

private:
  IR_UsesDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_UsesDefSeq_var &);
};

class TAO_Export IR_HomeDef_var : public TAO_Base_var
{
public:
  IR_HomeDef_var (void); // default constructor
  IR_HomeDef_var (IR_HomeDef_ptr p) : ptr_ (p) {}
  IR_HomeDef_var (const IR_HomeDef_var &); // copy constructor
  ~IR_HomeDef_var (void); // destructor

  IR_HomeDef_var &operator= (IR_HomeDef_ptr);
  IR_HomeDef_var &operator= (const IR_HomeDef_var &);
  IR_HomeDef_ptr operator-> (void) const;

  operator const IR_HomeDef_ptr &() const;
  operator IR_HomeDef_ptr &();
  // in, inout, out, _retn
  IR_HomeDef_ptr in (void) const;
  IR_HomeDef_ptr &inout (void);
  IR_HomeDef_ptr &out (void);
  IR_HomeDef_ptr _retn (void);
  IR_HomeDef_ptr ptr (void) const;

private:
  IR_HomeDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_HomeDef_var (const TAO_Base_var &rhs);
  IR_HomeDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_HomeDef_out
{
public:
  IR_HomeDef_out (IR_HomeDef_ptr &);
  IR_HomeDef_out (IR_HomeDef_var &);
  IR_HomeDef_out (const IR_HomeDef_out &);
  IR_HomeDef_out &operator= (const IR_HomeDef_out &);
  IR_HomeDef_out &operator= (const IR_HomeDef_var &);
  IR_HomeDef_out &operator= (IR_HomeDef_ptr);
  operator IR_HomeDef_ptr &();
  IR_HomeDef_ptr &ptr (void);
  IR_HomeDef_ptr operator-> (void);

private:
  IR_HomeDef_ptr &ptr_;
};


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_HomeDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq(const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq &rhs);
    TAO_Object_Manager<IR_HomeDef,IR_HomeDef_var> operator[] (CORBA::ULong index) const;
    static IR_HomeDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_HomeDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_HomeDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_HomeDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_HomeDefSeq
// *************************************************************

class TAO_Export IR_HomeDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_HomeDef,IR_HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_HomeDefSeq (void); // default ctor
  IR_HomeDefSeq (CORBA::ULong max); // uses max size
  IR_HomeDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_HomeDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_HomeDefSeq (const IR_HomeDefSeq &); // copy ctor
  ~IR_HomeDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_HomeDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_HomeDefSeq_var
// *************************************************************

class TAO_Export IR_HomeDefSeq_var
{
public:
  IR_HomeDefSeq_var (void); // default constructor
  IR_HomeDefSeq_var (IR_HomeDefSeq *);
  IR_HomeDefSeq_var (const IR_HomeDefSeq_var &); // copy constructor
  ~IR_HomeDefSeq_var (void); // destructor

  IR_HomeDefSeq_var &operator= (IR_HomeDefSeq *);
  IR_HomeDefSeq_var &operator= (const IR_HomeDefSeq_var &);
  IR_HomeDefSeq *operator-> (void);
  const IR_HomeDefSeq *operator-> (void) const;

  operator const IR_HomeDefSeq &() const;
  operator IR_HomeDefSeq &();
  operator IR_HomeDefSeq &() const;
  operator IR_HomeDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_HomeDef, IR_HomeDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_HomeDefSeq &in (void) const;
  IR_HomeDefSeq &inout (void);
  IR_HomeDefSeq *&out (void);
  IR_HomeDefSeq *_retn (void);
  IR_HomeDefSeq *ptr (void) const;

private:
  IR_HomeDefSeq *ptr_;
};

class TAO_Export IR_HomeDefSeq_out
{
public:
  IR_HomeDefSeq_out (IR_HomeDefSeq *&);
  IR_HomeDefSeq_out (IR_HomeDefSeq_var &);
  IR_HomeDefSeq_out (const IR_HomeDefSeq_out &);
  IR_HomeDefSeq_out &operator= (const IR_HomeDefSeq_out &);
  IR_HomeDefSeq_out &operator= (IR_HomeDefSeq *);
  operator IR_HomeDefSeq *&();
  IR_HomeDefSeq *&ptr (void);
  IR_HomeDefSeq *operator-> (void);
  TAO_Object_Manager<IR_HomeDef, IR_HomeDef_var> operator[] (CORBA::ULong index);

private:
  IR_HomeDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_HomeDefSeq_var &);
};

class TAO_Export IR_EventDef_var : public TAO_Base_var
{
public:
  IR_EventDef_var (void); // default constructor
  IR_EventDef_var (IR_EventDef_ptr p) : ptr_ (p) {}
  IR_EventDef_var (const IR_EventDef_var &); // copy constructor
  ~IR_EventDef_var (void); // destructor

  IR_EventDef_var &operator= (IR_EventDef_ptr);
  IR_EventDef_var &operator= (const IR_EventDef_var &);
  IR_EventDef_ptr operator-> (void) const;

  operator const IR_EventDef_ptr &() const;
  operator IR_EventDef_ptr &();
  // in, inout, out, _retn
  IR_EventDef_ptr in (void) const;
  IR_EventDef_ptr &inout (void);
  IR_EventDef_ptr &out (void);
  IR_EventDef_ptr _retn (void);
  IR_EventDef_ptr ptr (void) const;

private:
  IR_EventDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_EventDef_var (const TAO_Base_var &rhs);
  IR_EventDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_EventDef_out
{
public:
  IR_EventDef_out (IR_EventDef_ptr &);
  IR_EventDef_out (IR_EventDef_var &);
  IR_EventDef_out (const IR_EventDef_out &);
  IR_EventDef_out &operator= (const IR_EventDef_out &);
  IR_EventDef_out &operator= (const IR_EventDef_var &);
  IR_EventDef_out &operator= (IR_EventDef_ptr);
  operator IR_EventDef_ptr &();
  IR_EventDef_ptr &ptr (void);
  IR_EventDef_ptr operator-> (void);

private:
  IR_EventDef_ptr &ptr_;
};

class TAO_Export IR_EmitsDef_var : public TAO_Base_var
{
public:
  IR_EmitsDef_var (void); // default constructor
  IR_EmitsDef_var (IR_EmitsDef_ptr p) : ptr_ (p) {}
  IR_EmitsDef_var (const IR_EmitsDef_var &); // copy constructor
  ~IR_EmitsDef_var (void); // destructor

  IR_EmitsDef_var &operator= (IR_EmitsDef_ptr);
  IR_EmitsDef_var &operator= (const IR_EmitsDef_var &);
  IR_EmitsDef_ptr operator-> (void) const;

  operator const IR_EmitsDef_ptr &() const;
  operator IR_EmitsDef_ptr &();
  // in, inout, out, _retn
  IR_EmitsDef_ptr in (void) const;
  IR_EmitsDef_ptr &inout (void);
  IR_EmitsDef_ptr &out (void);
  IR_EmitsDef_ptr _retn (void);
  IR_EmitsDef_ptr ptr (void) const;

private:
  IR_EmitsDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_EmitsDef_var (const TAO_Base_var &rhs);
  IR_EmitsDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_EmitsDef_out
{
public:
  IR_EmitsDef_out (IR_EmitsDef_ptr &);
  IR_EmitsDef_out (IR_EmitsDef_var &);
  IR_EmitsDef_out (const IR_EmitsDef_out &);
  IR_EmitsDef_out &operator= (const IR_EmitsDef_out &);
  IR_EmitsDef_out &operator= (const IR_EmitsDef_var &);
  IR_EmitsDef_out &operator= (IR_EmitsDef_ptr);
  operator IR_EmitsDef_ptr &();
  IR_EmitsDef_ptr &ptr (void);
  IR_EmitsDef_ptr operator-> (void);

private:
  IR_EmitsDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_EmitsDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq(const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq &rhs);
    TAO_Object_Manager<IR_EmitsDef,IR_EmitsDef_var> operator[] (CORBA::ULong index) const;
    static IR_EmitsDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_EmitsDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_EmitsDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_EmitsDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_EmitsDefSeq
// *************************************************************

class TAO_Export IR_EmitsDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_EmitsDef,IR_EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_EmitsDefSeq (void); // default ctor
  IR_EmitsDefSeq (CORBA::ULong max); // uses max size
  IR_EmitsDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_EmitsDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_EmitsDefSeq (const IR_EmitsDefSeq &); // copy ctor
  ~IR_EmitsDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_EmitsDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_EmitsDefSeq_var
// *************************************************************

class TAO_Export IR_EmitsDefSeq_var
{
public:
  IR_EmitsDefSeq_var (void); // default constructor
  IR_EmitsDefSeq_var (IR_EmitsDefSeq *);
  IR_EmitsDefSeq_var (const IR_EmitsDefSeq_var &); // copy constructor
  ~IR_EmitsDefSeq_var (void); // destructor

  IR_EmitsDefSeq_var &operator= (IR_EmitsDefSeq *);
  IR_EmitsDefSeq_var &operator= (const IR_EmitsDefSeq_var &);
  IR_EmitsDefSeq *operator-> (void);
  const IR_EmitsDefSeq *operator-> (void) const;

  operator const IR_EmitsDefSeq &() const;
  operator IR_EmitsDefSeq &();
  operator IR_EmitsDefSeq &() const;
  operator IR_EmitsDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_EmitsDef, IR_EmitsDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_EmitsDefSeq &in (void) const;
  IR_EmitsDefSeq &inout (void);
  IR_EmitsDefSeq *&out (void);
  IR_EmitsDefSeq *_retn (void);
  IR_EmitsDefSeq *ptr (void) const;

private:
  IR_EmitsDefSeq *ptr_;
};

class TAO_Export IR_EmitsDefSeq_out
{
public:
  IR_EmitsDefSeq_out (IR_EmitsDefSeq *&);
  IR_EmitsDefSeq_out (IR_EmitsDefSeq_var &);
  IR_EmitsDefSeq_out (const IR_EmitsDefSeq_out &);
  IR_EmitsDefSeq_out &operator= (const IR_EmitsDefSeq_out &);
  IR_EmitsDefSeq_out &operator= (IR_EmitsDefSeq *);
  operator IR_EmitsDefSeq *&();
  IR_EmitsDefSeq *&ptr (void);
  IR_EmitsDefSeq *operator-> (void);
  TAO_Object_Manager<IR_EmitsDef, IR_EmitsDef_var> operator[] (CORBA::ULong index);

private:
  IR_EmitsDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_EmitsDefSeq_var &);
};

class TAO_Export IR_PublishesDef_var : public TAO_Base_var
{
public:
  IR_PublishesDef_var (void); // default constructor
  IR_PublishesDef_var (IR_PublishesDef_ptr p) : ptr_ (p) {}
  IR_PublishesDef_var (const IR_PublishesDef_var &); // copy constructor
  ~IR_PublishesDef_var (void); // destructor

  IR_PublishesDef_var &operator= (IR_PublishesDef_ptr);
  IR_PublishesDef_var &operator= (const IR_PublishesDef_var &);
  IR_PublishesDef_ptr operator-> (void) const;

  operator const IR_PublishesDef_ptr &() const;
  operator IR_PublishesDef_ptr &();
  // in, inout, out, _retn
  IR_PublishesDef_ptr in (void) const;
  IR_PublishesDef_ptr &inout (void);
  IR_PublishesDef_ptr &out (void);
  IR_PublishesDef_ptr _retn (void);
  IR_PublishesDef_ptr ptr (void) const;

private:
  IR_PublishesDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_PublishesDef_var (const TAO_Base_var &rhs);
  IR_PublishesDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_PublishesDef_out
{
public:
  IR_PublishesDef_out (IR_PublishesDef_ptr &);
  IR_PublishesDef_out (IR_PublishesDef_var &);
  IR_PublishesDef_out (const IR_PublishesDef_out &);
  IR_PublishesDef_out &operator= (const IR_PublishesDef_out &);
  IR_PublishesDef_out &operator= (const IR_PublishesDef_var &);
  IR_PublishesDef_out &operator= (IR_PublishesDef_ptr);
  operator IR_PublishesDef_ptr &();
  IR_PublishesDef_ptr &ptr (void);
  IR_PublishesDef_ptr operator-> (void);

private:
  IR_PublishesDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_PublishesDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq &rhs);
    TAO_Object_Manager<IR_PublishesDef,IR_PublishesDef_var> operator[] (CORBA::ULong index) const;
    static IR_PublishesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_PublishesDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_PublishesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_PublishesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_PublishesDefSeq
// *************************************************************

class TAO_Export IR_PublishesDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_PublishesDef,IR_PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_PublishesDefSeq (void); // default ctor
  IR_PublishesDefSeq (CORBA::ULong max); // uses max size
  IR_PublishesDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_PublishesDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_PublishesDefSeq (const IR_PublishesDefSeq &); // copy ctor
  ~IR_PublishesDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_PublishesDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_PublishesDefSeq_var
// *************************************************************

class TAO_Export IR_PublishesDefSeq_var
{
public:
  IR_PublishesDefSeq_var (void); // default constructor
  IR_PublishesDefSeq_var (IR_PublishesDefSeq *);
  IR_PublishesDefSeq_var (const IR_PublishesDefSeq_var &); // copy constructor
  ~IR_PublishesDefSeq_var (void); // destructor

  IR_PublishesDefSeq_var &operator= (IR_PublishesDefSeq *);
  IR_PublishesDefSeq_var &operator= (const IR_PublishesDefSeq_var &);
  IR_PublishesDefSeq *operator-> (void);
  const IR_PublishesDefSeq *operator-> (void) const;

  operator const IR_PublishesDefSeq &() const;
  operator IR_PublishesDefSeq &();
  operator IR_PublishesDefSeq &() const;
  operator IR_PublishesDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_PublishesDef, IR_PublishesDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_PublishesDefSeq &in (void) const;
  IR_PublishesDefSeq &inout (void);
  IR_PublishesDefSeq *&out (void);
  IR_PublishesDefSeq *_retn (void);
  IR_PublishesDefSeq *ptr (void) const;

private:
  IR_PublishesDefSeq *ptr_;
};

class TAO_Export IR_PublishesDefSeq_out
{
public:
  IR_PublishesDefSeq_out (IR_PublishesDefSeq *&);
  IR_PublishesDefSeq_out (IR_PublishesDefSeq_var &);
  IR_PublishesDefSeq_out (const IR_PublishesDefSeq_out &);
  IR_PublishesDefSeq_out &operator= (const IR_PublishesDefSeq_out &);
  IR_PublishesDefSeq_out &operator= (IR_PublishesDefSeq *);
  operator IR_PublishesDefSeq *&();
  IR_PublishesDefSeq *&ptr (void);
  IR_PublishesDefSeq *operator-> (void);
  TAO_Object_Manager<IR_PublishesDef, IR_PublishesDef_var> operator[] (CORBA::ULong index);

private:
  IR_PublishesDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_PublishesDefSeq_var &);
};

class TAO_Export IR_ConsumesDef_var : public TAO_Base_var
{
public:
  IR_ConsumesDef_var (void); // default constructor
  IR_ConsumesDef_var (IR_ConsumesDef_ptr p) : ptr_ (p) {}
  IR_ConsumesDef_var (const IR_ConsumesDef_var &); // copy constructor
  ~IR_ConsumesDef_var (void); // destructor

  IR_ConsumesDef_var &operator= (IR_ConsumesDef_ptr);
  IR_ConsumesDef_var &operator= (const IR_ConsumesDef_var &);
  IR_ConsumesDef_ptr operator-> (void) const;

  operator const IR_ConsumesDef_ptr &() const;
  operator IR_ConsumesDef_ptr &();
  // in, inout, out, _retn
  IR_ConsumesDef_ptr in (void) const;
  IR_ConsumesDef_ptr &inout (void);
  IR_ConsumesDef_ptr &out (void);
  IR_ConsumesDef_ptr _retn (void);
  IR_ConsumesDef_ptr ptr (void) const;

private:
  IR_ConsumesDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ConsumesDef_var (const TAO_Base_var &rhs);
  IR_ConsumesDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ConsumesDef_out
{
public:
  IR_ConsumesDef_out (IR_ConsumesDef_ptr &);
  IR_ConsumesDef_out (IR_ConsumesDef_var &);
  IR_ConsumesDef_out (const IR_ConsumesDef_out &);
  IR_ConsumesDef_out &operator= (const IR_ConsumesDef_out &);
  IR_ConsumesDef_out &operator= (const IR_ConsumesDef_var &);
  IR_ConsumesDef_out &operator= (IR_ConsumesDef_ptr);
  operator IR_ConsumesDef_ptr &();
  IR_ConsumesDef_ptr &ptr (void);
  IR_ConsumesDef_ptr operator-> (void);

private:
  IR_ConsumesDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ConsumesDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq &rhs);
    TAO_Object_Manager<IR_ConsumesDef,IR_ConsumesDef_var> operator[] (CORBA::ULong index) const;
    static IR_ConsumesDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_ConsumesDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_ConsumesDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ConsumesDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ConsumesDefSeq
// *************************************************************

class TAO_Export IR_ConsumesDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ConsumesDef,IR_ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ConsumesDefSeq (void); // default ctor
  IR_ConsumesDefSeq (CORBA::ULong max); // uses max size
  IR_ConsumesDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ConsumesDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_ConsumesDefSeq (const IR_ConsumesDefSeq &); // copy ctor
  ~IR_ConsumesDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ConsumesDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ConsumesDefSeq_var
// *************************************************************

class TAO_Export IR_ConsumesDefSeq_var
{
public:
  IR_ConsumesDefSeq_var (void); // default constructor
  IR_ConsumesDefSeq_var (IR_ConsumesDefSeq *);
  IR_ConsumesDefSeq_var (const IR_ConsumesDefSeq_var &); // copy constructor
  ~IR_ConsumesDefSeq_var (void); // destructor

  IR_ConsumesDefSeq_var &operator= (IR_ConsumesDefSeq *);
  IR_ConsumesDefSeq_var &operator= (const IR_ConsumesDefSeq_var &);
  IR_ConsumesDefSeq *operator-> (void);
  const IR_ConsumesDefSeq *operator-> (void) const;

  operator const IR_ConsumesDefSeq &() const;
  operator IR_ConsumesDefSeq &();
  operator IR_ConsumesDefSeq &() const;
  operator IR_ConsumesDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_ConsumesDef, IR_ConsumesDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_ConsumesDefSeq &in (void) const;
  IR_ConsumesDefSeq &inout (void);
  IR_ConsumesDefSeq *&out (void);
  IR_ConsumesDefSeq *_retn (void);
  IR_ConsumesDefSeq *ptr (void) const;

private:
  IR_ConsumesDefSeq *ptr_;
};

class TAO_Export IR_ConsumesDefSeq_out
{
public:
  IR_ConsumesDefSeq_out (IR_ConsumesDefSeq *&);
  IR_ConsumesDefSeq_out (IR_ConsumesDefSeq_var &);
  IR_ConsumesDefSeq_out (const IR_ConsumesDefSeq_out &);
  IR_ConsumesDefSeq_out &operator= (const IR_ConsumesDefSeq_out &);
  IR_ConsumesDefSeq_out &operator= (IR_ConsumesDefSeq *);
  operator IR_ConsumesDefSeq *&();
  IR_ConsumesDefSeq *&ptr (void);
  IR_ConsumesDefSeq *operator-> (void);
  TAO_Object_Manager<IR_ConsumesDef, IR_ConsumesDef_var> operator[] (CORBA::ULong index);

private:
  IR_ConsumesDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ConsumesDefSeq_var &);
};

class TAO_Export IR_FactoryDef_var : public TAO_Base_var
{
public:
  IR_FactoryDef_var (void); // default constructor
  IR_FactoryDef_var (IR_FactoryDef_ptr p) : ptr_ (p) {}
  IR_FactoryDef_var (const IR_FactoryDef_var &); // copy constructor
  ~IR_FactoryDef_var (void); // destructor

  IR_FactoryDef_var &operator= (IR_FactoryDef_ptr);
  IR_FactoryDef_var &operator= (const IR_FactoryDef_var &);
  IR_FactoryDef_ptr operator-> (void) const;

  operator const IR_FactoryDef_ptr &() const;
  operator IR_FactoryDef_ptr &();
  // in, inout, out, _retn
  IR_FactoryDef_ptr in (void) const;
  IR_FactoryDef_ptr &inout (void);
  IR_FactoryDef_ptr &out (void);
  IR_FactoryDef_ptr _retn (void);
  IR_FactoryDef_ptr ptr (void) const;

private:
  IR_FactoryDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_FactoryDef_var (const TAO_Base_var &rhs);
  IR_FactoryDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_FactoryDef_out
{
public:
  IR_FactoryDef_out (IR_FactoryDef_ptr &);
  IR_FactoryDef_out (IR_FactoryDef_var &);
  IR_FactoryDef_out (const IR_FactoryDef_out &);
  IR_FactoryDef_out &operator= (const IR_FactoryDef_out &);
  IR_FactoryDef_out &operator= (const IR_FactoryDef_var &);
  IR_FactoryDef_out &operator= (IR_FactoryDef_ptr);
  operator IR_FactoryDef_ptr &();
  IR_FactoryDef_ptr &ptr (void);
  IR_FactoryDef_ptr operator-> (void);

private:
  IR_FactoryDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_FactoryDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq(const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq &rhs);
    TAO_Object_Manager<IR_FactoryDef,IR_FactoryDef_var> operator[] (CORBA::ULong index) const;
    static IR_FactoryDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_FactoryDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_FactoryDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_FactoryDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_FactoryDefSeq
// *************************************************************

class TAO_Export IR_FactoryDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_FactoryDef,IR_FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_FactoryDefSeq (void); // default ctor
  IR_FactoryDefSeq (CORBA::ULong max); // uses max size
  IR_FactoryDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_FactoryDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_FactoryDefSeq (const IR_FactoryDefSeq &); // copy ctor
  ~IR_FactoryDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_FactoryDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_FactoryDefSeq_var
// *************************************************************

class TAO_Export IR_FactoryDefSeq_var
{
public:
  IR_FactoryDefSeq_var (void); // default constructor
  IR_FactoryDefSeq_var (IR_FactoryDefSeq *);
  IR_FactoryDefSeq_var (const IR_FactoryDefSeq_var &); // copy constructor
  ~IR_FactoryDefSeq_var (void); // destructor

  IR_FactoryDefSeq_var &operator= (IR_FactoryDefSeq *);
  IR_FactoryDefSeq_var &operator= (const IR_FactoryDefSeq_var &);
  IR_FactoryDefSeq *operator-> (void);
  const IR_FactoryDefSeq *operator-> (void) const;

  operator const IR_FactoryDefSeq &() const;
  operator IR_FactoryDefSeq &();
  operator IR_FactoryDefSeq &() const;
  operator IR_FactoryDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_FactoryDef, IR_FactoryDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_FactoryDefSeq &in (void) const;
  IR_FactoryDefSeq &inout (void);
  IR_FactoryDefSeq *&out (void);
  IR_FactoryDefSeq *_retn (void);
  IR_FactoryDefSeq *ptr (void) const;

private:
  IR_FactoryDefSeq *ptr_;
};

class TAO_Export IR_FactoryDefSeq_out
{
public:
  IR_FactoryDefSeq_out (IR_FactoryDefSeq *&);
  IR_FactoryDefSeq_out (IR_FactoryDefSeq_var &);
  IR_FactoryDefSeq_out (const IR_FactoryDefSeq_out &);
  IR_FactoryDefSeq_out &operator= (const IR_FactoryDefSeq_out &);
  IR_FactoryDefSeq_out &operator= (IR_FactoryDefSeq *);
  operator IR_FactoryDefSeq *&();
  IR_FactoryDefSeq *&ptr (void);
  IR_FactoryDefSeq *operator-> (void);
  TAO_Object_Manager<IR_FactoryDef, IR_FactoryDef_var> operator[] (CORBA::ULong index);

private:
  IR_FactoryDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_FactoryDefSeq_var &);
};

class TAO_Export IR_FinderDef_var : public TAO_Base_var
{
public:
  IR_FinderDef_var (void); // default constructor
  IR_FinderDef_var (IR_FinderDef_ptr p) : ptr_ (p) {}
  IR_FinderDef_var (const IR_FinderDef_var &); // copy constructor
  ~IR_FinderDef_var (void); // destructor

  IR_FinderDef_var &operator= (IR_FinderDef_ptr);
  IR_FinderDef_var &operator= (const IR_FinderDef_var &);
  IR_FinderDef_ptr operator-> (void) const;

  operator const IR_FinderDef_ptr &() const;
  operator IR_FinderDef_ptr &();
  // in, inout, out, _retn
  IR_FinderDef_ptr in (void) const;
  IR_FinderDef_ptr &inout (void);
  IR_FinderDef_ptr &out (void);
  IR_FinderDef_ptr _retn (void);
  IR_FinderDef_ptr ptr (void) const;

private:
  IR_FinderDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_FinderDef_var (const TAO_Base_var &rhs);
  IR_FinderDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_FinderDef_out
{
public:
  IR_FinderDef_out (IR_FinderDef_ptr &);
  IR_FinderDef_out (IR_FinderDef_var &);
  IR_FinderDef_out (const IR_FinderDef_out &);
  IR_FinderDef_out &operator= (const IR_FinderDef_out &);
  IR_FinderDef_out &operator= (const IR_FinderDef_var &);
  IR_FinderDef_out &operator= (IR_FinderDef_ptr);
  operator IR_FinderDef_ptr &();
  IR_FinderDef_ptr &ptr (void);
  IR_FinderDef_ptr operator-> (void);

private:
  IR_FinderDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_FinderDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq(const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq &rhs);
    TAO_Object_Manager<IR_FinderDef,IR_FinderDef_var> operator[] (CORBA::ULong index) const;
    static IR_FinderDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_FinderDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_FinderDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_FinderDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_FinderDefSeq
// *************************************************************

class TAO_Export IR_FinderDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_FinderDef,IR_FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_FinderDefSeq (void); // default ctor
  IR_FinderDefSeq (CORBA::ULong max); // uses max size
  IR_FinderDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_FinderDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_FinderDefSeq (const IR_FinderDefSeq &); // copy ctor
  ~IR_FinderDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_FinderDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_FinderDefSeq_var
// *************************************************************

class TAO_Export IR_FinderDefSeq_var
{
public:
  IR_FinderDefSeq_var (void); // default constructor
  IR_FinderDefSeq_var (IR_FinderDefSeq *);
  IR_FinderDefSeq_var (const IR_FinderDefSeq_var &); // copy constructor
  ~IR_FinderDefSeq_var (void); // destructor

  IR_FinderDefSeq_var &operator= (IR_FinderDefSeq *);
  IR_FinderDefSeq_var &operator= (const IR_FinderDefSeq_var &);
  IR_FinderDefSeq *operator-> (void);
  const IR_FinderDefSeq *operator-> (void) const;

  operator const IR_FinderDefSeq &() const;
  operator IR_FinderDefSeq &();
  operator IR_FinderDefSeq &() const;
  operator IR_FinderDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_FinderDef, IR_FinderDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_FinderDefSeq &in (void) const;
  IR_FinderDefSeq &inout (void);
  IR_FinderDefSeq *&out (void);
  IR_FinderDefSeq *_retn (void);
  IR_FinderDefSeq *ptr (void) const;

private:
  IR_FinderDefSeq *ptr_;
};

class TAO_Export IR_FinderDefSeq_out
{
public:
  IR_FinderDefSeq_out (IR_FinderDefSeq *&);
  IR_FinderDefSeq_out (IR_FinderDefSeq_var &);
  IR_FinderDefSeq_out (const IR_FinderDefSeq_out &);
  IR_FinderDefSeq_out &operator= (const IR_FinderDefSeq_out &);
  IR_FinderDefSeq_out &operator= (IR_FinderDefSeq *);
  operator IR_FinderDefSeq *&();
  IR_FinderDefSeq *&ptr (void);
  IR_FinderDefSeq *operator-> (void);
  TAO_Object_Manager<IR_FinderDef, IR_FinderDef_var> operator[] (CORBA::ULong index);

private:
  IR_FinderDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_FinderDefSeq_var &);
};

class TAO_Export IR_PrimaryKeyDef_var : public TAO_Base_var
{
public:
  IR_PrimaryKeyDef_var (void); // default constructor
  IR_PrimaryKeyDef_var (IR_PrimaryKeyDef_ptr p) : ptr_ (p) {}
  IR_PrimaryKeyDef_var (const IR_PrimaryKeyDef_var &); // copy constructor
  ~IR_PrimaryKeyDef_var (void); // destructor

  IR_PrimaryKeyDef_var &operator= (IR_PrimaryKeyDef_ptr);
  IR_PrimaryKeyDef_var &operator= (const IR_PrimaryKeyDef_var &);
  IR_PrimaryKeyDef_ptr operator-> (void) const;

  operator const IR_PrimaryKeyDef_ptr &() const;
  operator IR_PrimaryKeyDef_ptr &();
  // in, inout, out, _retn
  IR_PrimaryKeyDef_ptr in (void) const;
  IR_PrimaryKeyDef_ptr &inout (void);
  IR_PrimaryKeyDef_ptr &out (void);
  IR_PrimaryKeyDef_ptr _retn (void);
  IR_PrimaryKeyDef_ptr ptr (void) const;

private:
  IR_PrimaryKeyDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_PrimaryKeyDef_var (const TAO_Base_var &rhs);
  IR_PrimaryKeyDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_PrimaryKeyDef_out
{
public:
  IR_PrimaryKeyDef_out (IR_PrimaryKeyDef_ptr &);
  IR_PrimaryKeyDef_out (IR_PrimaryKeyDef_var &);
  IR_PrimaryKeyDef_out (const IR_PrimaryKeyDef_out &);
  IR_PrimaryKeyDef_out &operator= (const IR_PrimaryKeyDef_out &);
  IR_PrimaryKeyDef_out &operator= (const IR_PrimaryKeyDef_var &);
  IR_PrimaryKeyDef_out &operator= (IR_PrimaryKeyDef_ptr);
  operator IR_PrimaryKeyDef_ptr &();
  IR_PrimaryKeyDef_ptr &ptr (void);
  IR_PrimaryKeyDef_ptr operator-> (void);

private:
  IR_PrimaryKeyDef_ptr &ptr_;
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_ContainedSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_ContainedSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ContainedSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ContainedSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_Contained* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_ContainedSeq(const _TAO_Unbounded_Object_Sequence_IR_ContainedSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ContainedSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ContainedSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_ContainedSeq &rhs);
    TAO_Object_Manager<IR_Contained,IR_Contained_var> operator[] (CORBA::ULong index) const;
    static IR_Contained **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_Contained **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_Contained* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_Contained* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ContainedSeq
// *************************************************************

class TAO_Export IR_ContainedSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_Contained,IR_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ContainedSeq (void); // default ctor
  IR_ContainedSeq (CORBA::ULong max); // uses max size
  IR_ContainedSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_Contained_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_ContainedSeq (const IR_ContainedSeq &); // copy ctor
  ~IR_ContainedSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ContainedSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ContainedSeq_var
// *************************************************************

class TAO_Export IR_ContainedSeq_var
{
public:
  IR_ContainedSeq_var (void); // default constructor
  IR_ContainedSeq_var (IR_ContainedSeq *);
  IR_ContainedSeq_var (const IR_ContainedSeq_var &); // copy constructor
  ~IR_ContainedSeq_var (void); // destructor

  IR_ContainedSeq_var &operator= (IR_ContainedSeq *);
  IR_ContainedSeq_var &operator= (const IR_ContainedSeq_var &);
  IR_ContainedSeq *operator-> (void);
  const IR_ContainedSeq *operator-> (void) const;

  operator const IR_ContainedSeq &() const;
  operator IR_ContainedSeq &();
  operator IR_ContainedSeq &() const;
  operator IR_ContainedSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_Contained, IR_Contained_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_ContainedSeq &in (void) const;
  IR_ContainedSeq &inout (void);
  IR_ContainedSeq *&out (void);
  IR_ContainedSeq *_retn (void);
  IR_ContainedSeq *ptr (void) const;

private:
  IR_ContainedSeq *ptr_;
};


class TAO_Export IR_ContainedSeq_out
{
public:
  IR_ContainedSeq_out (IR_ContainedSeq *&);
  IR_ContainedSeq_out (IR_ContainedSeq_var &);
  IR_ContainedSeq_out (const IR_ContainedSeq_out &);
  IR_ContainedSeq_out &operator= (const IR_ContainedSeq_out &);
  IR_ContainedSeq_out &operator= (IR_ContainedSeq *);
  operator IR_ContainedSeq *&();
  IR_ContainedSeq *&ptr (void);
  IR_ContainedSeq *operator-> (void);
  TAO_Object_Manager<IR_Contained, IR_Contained_var> operator[] (CORBA::ULong index);

private:
  IR_ContainedSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ContainedSeq_var &);
};

struct TAO_Export IR_StructMember
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_StructMember_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  CORBA::TypeCode_var type;
  IR_IDLType_var type_def;
};

class TAO_Export IR_StructMember_var
{
public:
  IR_StructMember_var (void); // default constructor
  IR_StructMember_var (IR_StructMember *);
  IR_StructMember_var (const IR_StructMember_var &); // copy constructor
  ~IR_StructMember_var (void); // destructor

  IR_StructMember_var &operator= (IR_StructMember *);
  IR_StructMember_var &operator= (const IR_StructMember_var &);
  IR_StructMember *operator-> (void);
  const IR_StructMember *operator-> (void) const;

  operator const IR_StructMember &() const;
  operator IR_StructMember &();
  operator IR_StructMember &() const;
  operator IR_StructMember *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_StructMember &in (void) const;
  IR_StructMember &inout (void);
  IR_StructMember *&out (void);
  IR_StructMember *_retn (void);
  IR_StructMember *ptr (void) const;

private:
  IR_StructMember *ptr_;
};

class TAO_Export IR_StructMember_out
{
public:
  IR_StructMember_out (IR_StructMember *&);
  IR_StructMember_out (IR_StructMember_var &);
  IR_StructMember_out (const IR_StructMember_out &);
  IR_StructMember_out &operator= (const IR_StructMember_out &);
  IR_StructMember_out &operator= (IR_StructMember *);
  operator IR_StructMember *&();
  IR_StructMember *&ptr (void);
  IR_StructMember *operator-> (void);

private:
  IR_StructMember *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_StructMember_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_StructMemberSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_StructMemberSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_StructMemberSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_StructMemberSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_StructMember *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_StructMemberSeq (const _TAO_Unbounded_Sequence_IR_StructMemberSeq &rhs);
    _TAO_Unbounded_Sequence_IR_StructMemberSeq &operator= (const _TAO_Unbounded_Sequence_IR_StructMemberSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_StructMemberSeq (void); // Dtor.
    // = Accessors.
    IR_StructMember &operator[] (CORBA::ULong i);
    const IR_StructMember &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_StructMember *allocbuf (CORBA::ULong size);
    static void freebuf (IR_StructMember *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_StructMember *get_buffer (CORBA::Boolean orphan = 0);
    const IR_StructMember *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_StructMember *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_StructMemberSeq
// *************************************************************

class TAO_Export IR_StructMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_StructMemberSeq (void); // default ctor
  IR_StructMemberSeq (CORBA::ULong max); // uses max size
  IR_StructMemberSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_StructMember *buffer,
    CORBA::Boolean release = 0
  );
  IR_StructMemberSeq (const IR_StructMemberSeq &); // copy ctor
  ~IR_StructMemberSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_StructMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_StructMemberSeq_var
// *************************************************************

class TAO_Export IR_StructMemberSeq_var
{
public:
  IR_StructMemberSeq_var (void); // default constructor
  IR_StructMemberSeq_var (IR_StructMemberSeq *);
  IR_StructMemberSeq_var (const IR_StructMemberSeq_var &); // copy constructor
  ~IR_StructMemberSeq_var (void); // destructor

  IR_StructMemberSeq_var &operator= (IR_StructMemberSeq *);
  IR_StructMemberSeq_var &operator= (const IR_StructMemberSeq_var &);
  IR_StructMemberSeq *operator-> (void);
  const IR_StructMemberSeq *operator-> (void) const;

  operator const IR_StructMemberSeq &() const;
  operator IR_StructMemberSeq &();
  operator IR_StructMemberSeq &() const;
  operator IR_StructMemberSeq *&(); // variable-size base types only

  IR_StructMember & operator[] (CORBA::ULong index);
  const IR_StructMember & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_StructMemberSeq &in (void) const;
  IR_StructMemberSeq &inout (void);
  IR_StructMemberSeq *&out (void);
  IR_StructMemberSeq *_retn (void);
  IR_StructMemberSeq *ptr (void) const;

private:
  IR_StructMemberSeq *ptr_;
};

class TAO_Export IR_StructMemberSeq_out
{
public:
  IR_StructMemberSeq_out (IR_StructMemberSeq *&);
  IR_StructMemberSeq_out (IR_StructMemberSeq_var &);
  IR_StructMemberSeq_out (const IR_StructMemberSeq_out &);
  IR_StructMemberSeq_out &operator= (const IR_StructMemberSeq_out &);
  IR_StructMemberSeq_out &operator= (IR_StructMemberSeq *);
  operator IR_StructMemberSeq *&();
  IR_StructMemberSeq *&ptr (void);
  IR_StructMemberSeq *operator-> (void);
  IR_StructMember & operator[] (CORBA::ULong index);

private:
  IR_StructMemberSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_StructMemberSeq_var &);
};

struct TAO_Export IR_Initializer
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_Initializer_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  IR_StructMemberSeq members;
  TAO_String_Manager name;
};

class TAO_Export IR_Initializer_var
{
public:
  IR_Initializer_var (void); // default constructor
  IR_Initializer_var (IR_Initializer *);
  IR_Initializer_var (const IR_Initializer_var &); // copy constructor
  ~IR_Initializer_var (void); // destructor

  IR_Initializer_var &operator= (IR_Initializer *);
  IR_Initializer_var &operator= (const IR_Initializer_var &);
  IR_Initializer *operator-> (void);
  const IR_Initializer *operator-> (void) const;

  operator const IR_Initializer &() const;
  operator IR_Initializer &();
  operator IR_Initializer &() const;
  operator IR_Initializer *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_Initializer &in (void) const;
  IR_Initializer &inout (void);
  IR_Initializer *&out (void);
  IR_Initializer *_retn (void);
  IR_Initializer *ptr (void) const;

private:
  IR_Initializer *ptr_;
};

class TAO_Export IR_Initializer_out
{
public:
  IR_Initializer_out (IR_Initializer *&);
  IR_Initializer_out (IR_Initializer_var &);
  IR_Initializer_out (const IR_Initializer_out &);
  IR_Initializer_out &operator= (const IR_Initializer_out &);
  IR_Initializer_out &operator= (IR_Initializer *);
  operator IR_Initializer *&();
  IR_Initializer *&ptr (void);
  IR_Initializer *operator-> (void);

private:
  IR_Initializer *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_Initializer_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_InitializerSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_InitializerSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_InitializerSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_InitializerSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_Initializer *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_InitializerSeq (const _TAO_Unbounded_Sequence_IR_InitializerSeq &rhs);
    _TAO_Unbounded_Sequence_IR_InitializerSeq &operator= (const _TAO_Unbounded_Sequence_IR_InitializerSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_InitializerSeq (void); // Dtor.
    // = Accessors.
    IR_Initializer &operator[] (CORBA::ULong i);
    const IR_Initializer &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_Initializer *allocbuf (CORBA::ULong size);
    static void freebuf (IR_Initializer *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_Initializer *get_buffer (CORBA::Boolean orphan = 0);
    const IR_Initializer *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_Initializer *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_InitializerSeq
// *************************************************************

class TAO_Export IR_InitializerSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_InitializerSeq (void); // default ctor
  IR_InitializerSeq (CORBA::ULong max); // uses max size
  IR_InitializerSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_Initializer *buffer,
    CORBA::Boolean release = 0
  );
  IR_InitializerSeq (const IR_InitializerSeq &); // copy ctor
  ~IR_InitializerSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_InitializerSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_InitializerSeq_var
// *************************************************************

class TAO_Export IR_InitializerSeq_var
{
public:
  IR_InitializerSeq_var (void); // default constructor
  IR_InitializerSeq_var (IR_InitializerSeq *);
  IR_InitializerSeq_var (const IR_InitializerSeq_var &); // copy constructor
  ~IR_InitializerSeq_var (void); // destructor

  IR_InitializerSeq_var &operator= (IR_InitializerSeq *);
  IR_InitializerSeq_var &operator= (const IR_InitializerSeq_var &);
  IR_InitializerSeq *operator-> (void);
  const IR_InitializerSeq *operator-> (void) const;

  operator const IR_InitializerSeq &() const;
  operator IR_InitializerSeq &();
  operator IR_InitializerSeq &() const;
  operator IR_InitializerSeq *&(); // variable-size base types only

  IR_Initializer & operator[] (CORBA::ULong index);
  const IR_Initializer & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_InitializerSeq &in (void) const;
  IR_InitializerSeq &inout (void);
  IR_InitializerSeq *&out (void);
  IR_InitializerSeq *_retn (void);
  IR_InitializerSeq *ptr (void) const;

private:
  IR_InitializerSeq *ptr_;
};

class TAO_Export IR_InitializerSeq_out
{
public:
  IR_InitializerSeq_out (IR_InitializerSeq *&);
  IR_InitializerSeq_out (IR_InitializerSeq_var &);
  IR_InitializerSeq_out (const IR_InitializerSeq_out &);
  IR_InitializerSeq_out &operator= (const IR_InitializerSeq_out &);
  IR_InitializerSeq_out &operator= (IR_InitializerSeq *);
  operator IR_InitializerSeq *&();
  IR_InitializerSeq *&ptr (void);
  IR_InitializerSeq *operator-> (void);
  IR_Initializer & operator[] (CORBA::ULong index);

private:
  IR_InitializerSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_InitializerSeq_var &);
};

struct TAO_Export IR_UnionMember
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_UnionMember_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  CORBA::Any label;
  CORBA::TypeCode_var type;
  IR_IDLType_var type_def;
};

class TAO_Export IR_UnionMember_var
{
public:
  IR_UnionMember_var (void); // default constructor
  IR_UnionMember_var (IR_UnionMember *);
  IR_UnionMember_var (const IR_UnionMember_var &); // copy constructor
  ~IR_UnionMember_var (void); // destructor

  IR_UnionMember_var &operator= (IR_UnionMember *);
  IR_UnionMember_var &operator= (const IR_UnionMember_var &);
  IR_UnionMember *operator-> (void);
  const IR_UnionMember *operator-> (void) const;

  operator const IR_UnionMember &() const;
  operator IR_UnionMember &();
  operator IR_UnionMember &() const;
  operator IR_UnionMember *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_UnionMember &in (void) const;
  IR_UnionMember &inout (void);
  IR_UnionMember *&out (void);
  IR_UnionMember *_retn (void);
  IR_UnionMember *ptr (void) const;

private:
  IR_UnionMember *ptr_;
};

class TAO_Export IR_UnionMember_out
{
public:
  IR_UnionMember_out (IR_UnionMember *&);
  IR_UnionMember_out (IR_UnionMember_var &);
  IR_UnionMember_out (const IR_UnionMember_out &);
  IR_UnionMember_out &operator= (const IR_UnionMember_out &);
  IR_UnionMember_out &operator= (IR_UnionMember *);
  operator IR_UnionMember *&();
  IR_UnionMember *&ptr (void);
  IR_UnionMember *operator-> (void);

private:
  IR_UnionMember *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_UnionMember_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_UnionMemberSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_UnionMemberSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_UnionMemberSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_UnionMemberSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_UnionMember *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_UnionMemberSeq (const _TAO_Unbounded_Sequence_IR_UnionMemberSeq &rhs);
    _TAO_Unbounded_Sequence_IR_UnionMemberSeq &operator= (const _TAO_Unbounded_Sequence_IR_UnionMemberSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_UnionMemberSeq (void); // Dtor.
    // = Accessors.
    IR_UnionMember &operator[] (CORBA::ULong i);
    const IR_UnionMember &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_UnionMember *allocbuf (CORBA::ULong size);
    static void freebuf (IR_UnionMember *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_UnionMember *get_buffer (CORBA::Boolean orphan = 0);
    const IR_UnionMember *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_UnionMember *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_UnionMemberSeq
// *************************************************************

class TAO_Export IR_UnionMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_UnionMemberSeq (void); // default ctor
  IR_UnionMemberSeq (CORBA::ULong max); // uses max size
  IR_UnionMemberSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_UnionMember *buffer,
    CORBA::Boolean release = 0
  );
  IR_UnionMemberSeq (const IR_UnionMemberSeq &); // copy ctor
  ~IR_UnionMemberSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_UnionMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_UnionMemberSeq_var
// *************************************************************

class TAO_Export IR_UnionMemberSeq_var
{
public:
  IR_UnionMemberSeq_var (void); // default constructor
  IR_UnionMemberSeq_var (IR_UnionMemberSeq *);
  IR_UnionMemberSeq_var (const IR_UnionMemberSeq_var &); // copy constructor
  ~IR_UnionMemberSeq_var (void); // destructor

  IR_UnionMemberSeq_var &operator= (IR_UnionMemberSeq *);
  IR_UnionMemberSeq_var &operator= (const IR_UnionMemberSeq_var &);
  IR_UnionMemberSeq *operator-> (void);
  const IR_UnionMemberSeq *operator-> (void) const;

  operator const IR_UnionMemberSeq &() const;
  operator IR_UnionMemberSeq &();
  operator IR_UnionMemberSeq &() const;
  operator IR_UnionMemberSeq *&(); // variable-size base types only

  IR_UnionMember & operator[] (CORBA::ULong index);
  const IR_UnionMember & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_UnionMemberSeq &in (void) const;
  IR_UnionMemberSeq &inout (void);
  IR_UnionMemberSeq *&out (void);
  IR_UnionMemberSeq *_retn (void);
  IR_UnionMemberSeq *ptr (void) const;

private:
  IR_UnionMemberSeq *ptr_;
};

class TAO_Export IR_UnionMemberSeq_out
{
public:
  IR_UnionMemberSeq_out (IR_UnionMemberSeq *&);
  IR_UnionMemberSeq_out (IR_UnionMemberSeq_var &);
  IR_UnionMemberSeq_out (const IR_UnionMemberSeq_out &);
  IR_UnionMemberSeq_out &operator= (const IR_UnionMemberSeq_out &);
  IR_UnionMemberSeq_out &operator= (IR_UnionMemberSeq *);
  operator IR_UnionMemberSeq *&();
  IR_UnionMemberSeq *&ptr (void);
  IR_UnionMemberSeq *operator-> (void);
  IR_UnionMember & operator[] (CORBA::ULong index);

private:
  IR_UnionMemberSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_UnionMemberSeq_var &);
};

// *************************************************************
// IR_EnumMemberSeq
// *************************************************************

class TAO_Export IR_EnumMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_EnumMemberSeq (void); // default ctor
  IR_EnumMemberSeq (CORBA::ULong max); // uses max size
  IR_EnumMemberSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    char * *buffer,
    CORBA::Boolean release = 0
  );
  IR_EnumMemberSeq (const IR_EnumMemberSeq &); // copy ctor
  ~IR_EnumMemberSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_EnumMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_EnumMemberSeq_var
// *************************************************************

class TAO_Export IR_EnumMemberSeq_var
{
public:
  IR_EnumMemberSeq_var (void); // default constructor
  IR_EnumMemberSeq_var (IR_EnumMemberSeq *);
  IR_EnumMemberSeq_var (const IR_EnumMemberSeq_var &); // copy constructor
  ~IR_EnumMemberSeq_var (void); // destructor

  IR_EnumMemberSeq_var &operator= (IR_EnumMemberSeq *);
  IR_EnumMemberSeq_var &operator= (const IR_EnumMemberSeq_var &);
  IR_EnumMemberSeq *operator-> (void);
  const IR_EnumMemberSeq *operator-> (void) const;

  operator const IR_EnumMemberSeq &() const;
  operator IR_EnumMemberSeq &();
  operator IR_EnumMemberSeq &() const;
  operator IR_EnumMemberSeq *&(); // variable-size base types only

  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_EnumMemberSeq &in (void) const;
  IR_EnumMemberSeq &inout (void);
  IR_EnumMemberSeq *&out (void);
  IR_EnumMemberSeq *_retn (void);
  IR_EnumMemberSeq *ptr (void) const;

private:
  IR_EnumMemberSeq *ptr_;
};

class TAO_Export IR_EnumMemberSeq_out
{
public:
  IR_EnumMemberSeq_out (IR_EnumMemberSeq *&);
  IR_EnumMemberSeq_out (IR_EnumMemberSeq_var &);
  IR_EnumMemberSeq_out (const IR_EnumMemberSeq_out &);
  IR_EnumMemberSeq_out &operator= (const IR_EnumMemberSeq_out &);
  IR_EnumMemberSeq_out &operator= (IR_EnumMemberSeq *);
  operator IR_EnumMemberSeq *&();
  IR_EnumMemberSeq *&ptr (void);
  IR_EnumMemberSeq *operator-> (void);
  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

private:
  IR_EnumMemberSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_EnumMemberSeq_var &);
};

// Forward Classes Declaration
class _TAO_Container_Proxy_Impl;
class _TAO_Container_Remote_Proxy_Impl;
class _TAO_Container_Proxy_Broker;
class _TAO_Container_Remote_Proxy_Broker;

class TAO_Export IR_Container: public virtual CORBA_IRObject
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_Container_ptr _ptr_type;
  typedef IR_Container_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_Container_ptr _duplicate (IR_Container_ptr obj);
  static IR_Container_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_Container_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_Container_ptr _nil (void)
    {
      return (IR_Container_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_Contained_ptr lookup (
      const char * search_name,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ContainedSeq * contents (
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ContainedSeq * lookup_name (
      const char * search_name,
      CORBA::Long levels_to_search,
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  struct Description;
  class Description_var;

  struct TAO_Export Description
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Description_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    IR_Contained_var contained_object;
    IR_DefinitionKind kind;
    CORBA::Any value;
  };

  class TAO_Export Description_var
  {
  public:
    Description_var (void); // default constructor
    Description_var (Description *);
    Description_var (const Description_var &); // copy constructor
    ~Description_var (void); // destructor

    Description_var &operator= (Description *);
    Description_var &operator= (const Description_var &);
    Description *operator-> (void);
    const Description *operator-> (void) const;

    operator const Description &() const;
    operator Description &();
    operator Description &() const;
    operator Description *&(); // variable-size types only

    // in, inout, out, _retn
    const Description &in (void) const;
    Description &inout (void);
    Description *&out (void);
    Description *_retn (void);
    Description *ptr (void) const;

  private:
    Description *ptr_;
  };

  class TAO_Export Description_out
  {
  public:
    Description_out (Description *&);
    Description_out (Description_var &);
    Description_out (const Description_out &);
    Description_out &operator= (const Description_out &);
    Description_out &operator= (Description *);
    operator Description *&();
    Description *&ptr (void);
    Description *operator-> (void);

  private:
    Description *&ptr_;
    // assignment from T_var not allowed
    void operator= (const Description_var &);
  };

  static CORBA::TypeCode_ptr _tc_Description;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        Description *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (const _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq &rhs);
      _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq &operator= (const _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (void); // Dtor.
      // = Accessors.
      Description &operator[] (CORBA::ULong i);
      const Description &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static Description *allocbuf (CORBA::ULong size);
      static void freebuf (Description *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      Description *get_buffer (CORBA::Boolean orphan = 0);
      const Description *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        Description *data,
        CORBA::Boolean release);
    };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

  class DescriptionSeq_var;

  // *************************************************************
  // DescriptionSeq
  // *************************************************************

  class TAO_Export DescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    DescriptionSeq (void); // default ctor
    DescriptionSeq (CORBA::ULong max); // uses max size
    DescriptionSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      Description *buffer,
      CORBA::Boolean release = 0
    );
    DescriptionSeq (const DescriptionSeq &); // copy ctor
    ~DescriptionSeq (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef DescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };

  // *************************************************************
  // class IR_Container::DescriptionSeq_var
  // *************************************************************

  class TAO_Export DescriptionSeq_var
  {
  public:
    DescriptionSeq_var (void); // default constructor
    DescriptionSeq_var (DescriptionSeq *);
    DescriptionSeq_var (const DescriptionSeq_var &); // copy constructor
    ~DescriptionSeq_var (void); // destructor

    DescriptionSeq_var &operator= (DescriptionSeq *);
    DescriptionSeq_var &operator= (const DescriptionSeq_var &);
    DescriptionSeq *operator-> (void);
    const DescriptionSeq *operator-> (void) const;

    operator const DescriptionSeq &() const;
    operator DescriptionSeq &();
    operator DescriptionSeq &() const;
    operator DescriptionSeq *&(); // variable-size base types only

    Description & operator[] (CORBA::ULong index);
    const Description & operator[] (CORBA::ULong index) const;
    // in, inout, out, _retn
    const DescriptionSeq &in (void) const;
    DescriptionSeq &inout (void);
    DescriptionSeq *&out (void);
    DescriptionSeq *_retn (void);
    DescriptionSeq *ptr (void) const;

  private:
    DescriptionSeq *ptr_;
  };

  class TAO_Export DescriptionSeq_out
  {
  public:
    DescriptionSeq_out (DescriptionSeq *&);
    DescriptionSeq_out (DescriptionSeq_var &);
    DescriptionSeq_out (const DescriptionSeq_out &);
    DescriptionSeq_out &operator= (const DescriptionSeq_out &);
    DescriptionSeq_out &operator= (DescriptionSeq *);
    operator DescriptionSeq *&();
    DescriptionSeq *&ptr (void);
    DescriptionSeq *operator-> (void);
    Description & operator[] (CORBA::ULong index);

  private:
    DescriptionSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const DescriptionSeq_var &);
  };

  static CORBA::TypeCode_ptr _tc_DescriptionSeq;

  virtual IR_Container::DescriptionSeq * describe_contents (
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Long max_returned_objs,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ModuleDef_ptr create_module (
      const char * id,
      const char * name,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ConstantDef_ptr create_constant (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_StructDef_ptr create_struct (
      const char * id,
      const char * name,
      const char * version,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_UnionDef_ptr create_union (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr discriminator_type,
      const IR_UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_EnumDef_ptr create_enum (
      const char * id,
      const char * name,
      const char * version,
      const IR_EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_AliasDef_ptr create_alias (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr original_type,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_InterfaceDef_ptr create_interface (
      const char * id,
      const char * name,
      const char * version,
      const IR_InterfaceDefSeq & base_interfaces,
      CORBA::Boolean is_abstract,
      CORBA::Boolean is_local,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDef_ptr create_value (
      const char * id,
      const char * name,
      const char * version,
      CORBA::Boolean is_custom,
      CORBA::Boolean is_abstract,
      IR_ValueDef_ptr base_value,
      CORBA::Boolean is_truncatable,
      const IR_ValueDefSeq & abstract_base_values,
      const IR_InterfaceDefSeq & supported_interfaces,
      const IR_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueBoxDef_ptr create_value_box (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ExceptionDef_ptr create_exception (
      const char * id,
      const char * name,
      const char * version,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_NativeDef_ptr create_native (
      const char * id,
      const char * name,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_Container_Proxy_Broker *the_TAO_Container_Proxy_Broker_;

protected:
  IR_Container (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_Container (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_Container_Remote_Proxy_Impl;
  friend class _TAO_Container_ThruPOA_Proxy_Impl;
  friend class _TAO_Container_Direct_Proxy_Impl;

  virtual ~IR_Container (void);
private:
  IR_Container (const IR_Container &);
  void operator= (const IR_Container &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_Container_Proxy_Impl :
  public virtual _TAO_IRObject_Proxy_Impl
{
public:
  virtual ~_TAO_Container_Proxy_Impl (void) { }

  virtual IR_Contained_ptr lookup (
      CORBA_Object *_collocated_tao_target_,
      const char * search_name,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ContainedSeq * contents (
      CORBA_Object *_collocated_tao_target_,
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ContainedSeq * lookup_name (
      CORBA_Object *_collocated_tao_target_,
      const char * search_name,
      CORBA::Long levels_to_search,
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_Container::DescriptionSeq * describe_contents (
      CORBA_Object *_collocated_tao_target_,
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Long max_returned_objs,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ModuleDef_ptr create_module (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ConstantDef_ptr create_constant (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_StructDef_ptr create_struct (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_UnionDef_ptr create_union (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr discriminator_type,
      const IR_UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_EnumDef_ptr create_enum (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_AliasDef_ptr create_alias (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr original_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_InterfaceDef_ptr create_interface (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_InterfaceDefSeq & base_interfaces,
      CORBA::Boolean is_abstract,
      CORBA::Boolean is_local,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ValueDef_ptr create_value (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::Boolean is_custom,
      CORBA::Boolean is_abstract,
      IR_ValueDef_ptr base_value,
      CORBA::Boolean is_truncatable,
      const IR_ValueDefSeq & abstract_base_values,
      const IR_InterfaceDefSeq & supported_interfaces,
      const IR_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ValueBoxDef_ptr create_value_box (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ExceptionDef_ptr create_exception (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_NativeDef_ptr create_native (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_Container_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_Container_Remote_Proxy_Impl :
  public virtual _TAO_Container_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IRObject_Remote_Proxy_Impl

{
public:
  _TAO_Container_Remote_Proxy_Impl (void);

  virtual ~_TAO_Container_Remote_Proxy_Impl (void) { }

  virtual IR_Contained_ptr lookup (
      CORBA_Object *_collocated_tao_target_,
      const char * search_name,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ContainedSeq * contents (
      CORBA_Object *_collocated_tao_target_,
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ContainedSeq * lookup_name (
      CORBA_Object *_collocated_tao_target_,
      const char * search_name,
      CORBA::Long levels_to_search,
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_Container::DescriptionSeq * describe_contents (
      CORBA_Object *_collocated_tao_target_,
      IR_DefinitionKind limit_type,
      CORBA::Boolean exclude_inherited,
      CORBA::Long max_returned_objs,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ModuleDef_ptr create_module (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ConstantDef_ptr create_constant (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_StructDef_ptr create_struct (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_UnionDef_ptr create_union (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr discriminator_type,
      const IR_UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_EnumDef_ptr create_enum (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_AliasDef_ptr create_alias (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr original_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_InterfaceDef_ptr create_interface (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_InterfaceDefSeq & base_interfaces,
      CORBA::Boolean is_abstract,
      CORBA::Boolean is_local,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDef_ptr create_value (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::Boolean is_custom,
      CORBA::Boolean is_abstract,
      IR_ValueDef_ptr base_value,
      CORBA::Boolean is_truncatable,
      const IR_ValueDefSeq & abstract_base_values,
      const IR_InterfaceDefSeq & supported_interfaces,
      const IR_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueBoxDef_ptr create_value_box (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ExceptionDef_ptr create_exception (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_NativeDef_ptr create_native (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));
};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_Container_Proxy_Broker
{
public:
  virtual ~_TAO_Container_Proxy_Broker (void);

  virtual _TAO_Container_Proxy_Impl &select_proxy (
    IR_Container *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_Container_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_Container_Remote_Proxy_Broker : public virtual _TAO_Container_Proxy_Broker
{
public:
  _TAO_Container_Remote_Proxy_Broker (void);

  virtual ~_TAO_Container_Remote_Proxy_Broker (void);

  virtual _TAO_Container_Proxy_Impl &select_proxy (
    IR_Container *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_Container_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_Container_Remote_Proxy_Broker *the_TAO_Container_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_IDLType_Proxy_Impl;
class _TAO_IDLType_Remote_Proxy_Impl;
class _TAO_IDLType_Proxy_Broker;
class _TAO_IDLType_Remote_Proxy_Broker;

class TAO_Export IR_IDLType: public virtual CORBA_IRObject
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_IDLType_ptr _ptr_type;
  typedef IR_IDLType_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_IDLType_ptr _duplicate (IR_IDLType_ptr obj);
  static IR_IDLType_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_IDLType_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_IDLType_ptr _nil (void)
    {
      return (IR_IDLType_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type   (
                  CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_IDLType_Proxy_Broker *the_TAO_IDLType_Proxy_Broker_;

protected:
  IR_IDLType (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_IDLType (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_IDLType_Remote_Proxy_Impl;
  friend class _TAO_IDLType_ThruPOA_Proxy_Impl;
  friend class _TAO_IDLType_Direct_Proxy_Impl;

  virtual ~IR_IDLType (void);
private:
  IR_IDLType (const IR_IDLType &);
  void operator= (const IR_IDLType &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_IDLType_Proxy_Impl :
  public virtual _TAO_IRObject_Proxy_Impl
{
public:
  virtual ~_TAO_IDLType_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
       CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_IDLType_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_IDLType_Remote_Proxy_Impl :
  public virtual _TAO_IDLType_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IRObject_Remote_Proxy_Impl

{
public:
  _TAO_IDLType_Remote_Proxy_Impl (void);

  virtual ~_TAO_IDLType_Remote_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type   (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_IDLType_Proxy_Broker
{
public:
  virtual ~_TAO_IDLType_Proxy_Broker (void);

  virtual _TAO_IDLType_Proxy_Impl &select_proxy (
    IR_IDLType *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_IDLType_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_IDLType_Remote_Proxy_Broker : public virtual _TAO_IDLType_Proxy_Broker
{
public:
  _TAO_IDLType_Remote_Proxy_Broker (void);

  virtual ~_TAO_IDLType_Remote_Proxy_Broker (void);

  virtual _TAO_IDLType_Proxy_Impl &select_proxy (
    IR_IDLType *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_IDLType_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_IDLType_Remote_Proxy_Broker *the_TAO_IDLType_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

class TAO_Export IR_PrimitiveDef_var : public TAO_Base_var
{
public:
  IR_PrimitiveDef_var (void); // default constructor
  IR_PrimitiveDef_var (IR_PrimitiveDef_ptr p) : ptr_ (p) {}
  IR_PrimitiveDef_var (const IR_PrimitiveDef_var &); // copy constructor
  ~IR_PrimitiveDef_var (void); // destructor

  IR_PrimitiveDef_var &operator= (IR_PrimitiveDef_ptr);
  IR_PrimitiveDef_var &operator= (const IR_PrimitiveDef_var &);
  IR_PrimitiveDef_ptr operator-> (void) const;

  operator const IR_PrimitiveDef_ptr &() const;
  operator IR_PrimitiveDef_ptr &();
  // in, inout, out, _retn
  IR_PrimitiveDef_ptr in (void) const;
  IR_PrimitiveDef_ptr &inout (void);
  IR_PrimitiveDef_ptr &out (void);
  IR_PrimitiveDef_ptr _retn (void);
  IR_PrimitiveDef_ptr ptr (void) const;

private:
  IR_PrimitiveDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_PrimitiveDef_var (const TAO_Base_var &rhs);
  IR_PrimitiveDef_var &operator= (const TAO_Base_var &rhs);
};


class TAO_Export IR_PrimitiveDef_out
{
public:
  IR_PrimitiveDef_out (IR_PrimitiveDef_ptr &);
  IR_PrimitiveDef_out (IR_PrimitiveDef_var &);
  IR_PrimitiveDef_out (const IR_PrimitiveDef_out &);
  IR_PrimitiveDef_out &operator= (const IR_PrimitiveDef_out &);
  IR_PrimitiveDef_out &operator= (const IR_PrimitiveDef_var &);
  IR_PrimitiveDef_out &operator= (IR_PrimitiveDef_ptr);
  operator IR_PrimitiveDef_ptr &();
  IR_PrimitiveDef_ptr &ptr (void);
  IR_PrimitiveDef_ptr operator-> (void);

private:
  IR_PrimitiveDef_ptr &ptr_;
};

class TAO_Export IR_StringDef_var : public TAO_Base_var
{
public:
  IR_StringDef_var (void); // default constructor
  IR_StringDef_var (IR_StringDef_ptr p) : ptr_ (p) {}
  IR_StringDef_var (const IR_StringDef_var &); // copy constructor
  ~IR_StringDef_var (void); // destructor

  IR_StringDef_var &operator= (IR_StringDef_ptr);
  IR_StringDef_var &operator= (const IR_StringDef_var &);
  IR_StringDef_ptr operator-> (void) const;

  operator const IR_StringDef_ptr &() const;
  operator IR_StringDef_ptr &();
  // in, inout, out, _retn
  IR_StringDef_ptr in (void) const;
  IR_StringDef_ptr &inout (void);
  IR_StringDef_ptr &out (void);
  IR_StringDef_ptr _retn (void);
  IR_StringDef_ptr ptr (void) const;

private:
  IR_StringDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_StringDef_var (const TAO_Base_var &rhs);
  IR_StringDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_StringDef_out
{
public:
  IR_StringDef_out (IR_StringDef_ptr &);
  IR_StringDef_out (IR_StringDef_var &);
  IR_StringDef_out (const IR_StringDef_out &);
  IR_StringDef_out &operator= (const IR_StringDef_out &);
  IR_StringDef_out &operator= (const IR_StringDef_var &);
  IR_StringDef_out &operator= (IR_StringDef_ptr);
  operator IR_StringDef_ptr &();
  IR_StringDef_ptr &ptr (void);
  IR_StringDef_ptr operator-> (void);

private:
  IR_StringDef_ptr &ptr_;
};

class TAO_Export IR_SequenceDef_var : public TAO_Base_var
{
public:
  IR_SequenceDef_var (void); // default constructor
  IR_SequenceDef_var (IR_SequenceDef_ptr p) : ptr_ (p) {}
  IR_SequenceDef_var (const IR_SequenceDef_var &); // copy constructor
  ~IR_SequenceDef_var (void); // destructor

  IR_SequenceDef_var &operator= (IR_SequenceDef_ptr);
  IR_SequenceDef_var &operator= (const IR_SequenceDef_var &);
  IR_SequenceDef_ptr operator-> (void) const;

  operator const IR_SequenceDef_ptr &() const;
  operator IR_SequenceDef_ptr &();
  // in, inout, out, _retn
  IR_SequenceDef_ptr in (void) const;
  IR_SequenceDef_ptr &inout (void);
  IR_SequenceDef_ptr &out (void);
  IR_SequenceDef_ptr _retn (void);
  IR_SequenceDef_ptr ptr (void) const;

private:
  IR_SequenceDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_SequenceDef_var (const TAO_Base_var &rhs);
  IR_SequenceDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_SequenceDef_out
{
public:
  IR_SequenceDef_out (IR_SequenceDef_ptr &);
  IR_SequenceDef_out (IR_SequenceDef_var &);
  IR_SequenceDef_out (const IR_SequenceDef_out &);
  IR_SequenceDef_out &operator= (const IR_SequenceDef_out &);
  IR_SequenceDef_out &operator= (const IR_SequenceDef_var &);
  IR_SequenceDef_out &operator= (IR_SequenceDef_ptr);
  operator IR_SequenceDef_ptr &();
  IR_SequenceDef_ptr &ptr (void);
  IR_SequenceDef_ptr operator-> (void);

private:
  IR_SequenceDef_ptr &ptr_;
};

class TAO_Export IR_ArrayDef_var : public TAO_Base_var
{
public:
  IR_ArrayDef_var (void); // default constructor
  IR_ArrayDef_var (IR_ArrayDef_ptr p) : ptr_ (p) {}
  IR_ArrayDef_var (const IR_ArrayDef_var &); // copy constructor
  ~IR_ArrayDef_var (void); // destructor

  IR_ArrayDef_var &operator= (IR_ArrayDef_ptr);
  IR_ArrayDef_var &operator= (const IR_ArrayDef_var &);
  IR_ArrayDef_ptr operator-> (void) const;

  operator const IR_ArrayDef_ptr &() const;
  operator IR_ArrayDef_ptr &();
  // in, inout, out, _retn
  IR_ArrayDef_ptr in (void) const;
  IR_ArrayDef_ptr &inout (void);
  IR_ArrayDef_ptr &out (void);
  IR_ArrayDef_ptr _retn (void);
  IR_ArrayDef_ptr ptr (void) const;

private:
  IR_ArrayDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ArrayDef_var (const TAO_Base_var &rhs);
  IR_ArrayDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ArrayDef_out
{
public:
  IR_ArrayDef_out (IR_ArrayDef_ptr &);
  IR_ArrayDef_out (IR_ArrayDef_var &);
  IR_ArrayDef_out (const IR_ArrayDef_out &);
  IR_ArrayDef_out &operator= (const IR_ArrayDef_out &);
  IR_ArrayDef_out &operator= (const IR_ArrayDef_var &);
  IR_ArrayDef_out &operator= (IR_ArrayDef_ptr);
  operator IR_ArrayDef_ptr &();
  IR_ArrayDef_ptr &ptr (void);
  IR_ArrayDef_ptr operator-> (void);

private:
  IR_ArrayDef_ptr &ptr_;
};

class TAO_Export IR_WstringDef_var : public TAO_Base_var
{
public:
  IR_WstringDef_var (void); // default constructor
  IR_WstringDef_var (IR_WstringDef_ptr p) : ptr_ (p) {}
  IR_WstringDef_var (const IR_WstringDef_var &); // copy constructor
  ~IR_WstringDef_var (void); // destructor

  IR_WstringDef_var &operator= (IR_WstringDef_ptr);
  IR_WstringDef_var &operator= (const IR_WstringDef_var &);
  IR_WstringDef_ptr operator-> (void) const;

  operator const IR_WstringDef_ptr &() const;
  operator IR_WstringDef_ptr &();
  // in, inout, out, _retn
  IR_WstringDef_ptr in (void) const;
  IR_WstringDef_ptr &inout (void);
  IR_WstringDef_ptr &out (void);
  IR_WstringDef_ptr _retn (void);
  IR_WstringDef_ptr ptr (void) const;

private:
  IR_WstringDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_WstringDef_var (const TAO_Base_var &rhs);
  IR_WstringDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_WstringDef_out
{
public:
  IR_WstringDef_out (IR_WstringDef_ptr &);
  IR_WstringDef_out (IR_WstringDef_var &);
  IR_WstringDef_out (const IR_WstringDef_out &);
  IR_WstringDef_out &operator= (const IR_WstringDef_out &);
  IR_WstringDef_out &operator= (const IR_WstringDef_var &);
  IR_WstringDef_out &operator= (IR_WstringDef_ptr);
  operator IR_WstringDef_ptr &();
  IR_WstringDef_ptr &ptr (void);
  IR_WstringDef_ptr operator-> (void);

private:
  IR_WstringDef_ptr &ptr_;
};

class TAO_Export IR_FixedDef_var : public TAO_Base_var
{
public:
  IR_FixedDef_var (void); // default constructor
  IR_FixedDef_var (IR_FixedDef_ptr p) : ptr_ (p) {}
  IR_FixedDef_var (const IR_FixedDef_var &); // copy constructor
  ~IR_FixedDef_var (void); // destructor

  IR_FixedDef_var &operator= (IR_FixedDef_ptr);
  IR_FixedDef_var &operator= (const IR_FixedDef_var &);
  IR_FixedDef_ptr operator-> (void) const;

  operator const IR_FixedDef_ptr &() const;
  operator IR_FixedDef_ptr &();
  // in, inout, out, _retn
  IR_FixedDef_ptr in (void) const;
  IR_FixedDef_ptr &inout (void);
  IR_FixedDef_ptr &out (void);
  IR_FixedDef_ptr _retn (void);
  IR_FixedDef_ptr ptr (void) const;

private:
  IR_FixedDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_FixedDef_var (const TAO_Base_var &rhs);
  IR_FixedDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_FixedDef_out
{
public:
  IR_FixedDef_out (IR_FixedDef_ptr &);
  IR_FixedDef_out (IR_FixedDef_var &);
  IR_FixedDef_out (const IR_FixedDef_out &);
  IR_FixedDef_out &operator= (const IR_FixedDef_out &);
  IR_FixedDef_out &operator= (const IR_FixedDef_var &);
  IR_FixedDef_out &operator= (IR_FixedDef_ptr);
  operator IR_FixedDef_ptr &();
  IR_FixedDef_ptr &ptr (void);
  IR_FixedDef_ptr operator-> (void);

private:
  IR_FixedDef_ptr &ptr_;
};

// Forward Classes Declaration
class _TAO_Repository_Proxy_Impl;
class _TAO_Repository_Remote_Proxy_Impl;
class _TAO_Repository_Proxy_Broker;
class _TAO_Repository_Remote_Proxy_Broker;

class TAO_Export IR_Repository: public virtual IR_Container
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_Repository_ptr _ptr_type;
  typedef IR_Repository_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_Repository_ptr _duplicate (IR_Repository_ptr obj);
  static IR_Repository_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_Repository_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_Repository_ptr _nil (void)
    {
      return (IR_Repository_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_Contained_ptr lookup_id (
      const char * search_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr get_canonical_typecode (
      CORBA::TypeCode_ptr tc,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PrimitiveDef_ptr get_primitive (
      IR_PrimitiveKind kind,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_StringDef_ptr create_string (
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_WstringDef_ptr create_wstring (
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_SequenceDef_ptr create_sequence (
      CORBA::ULong bound,
      IR_IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ArrayDef_ptr create_array (
      CORBA::ULong length,
      IR_IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FixedDef_ptr create_fixed (
      CORBA::UShort digits,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_Repository_Proxy_Broker *the_TAO_Repository_Proxy_Broker_;

protected:
  IR_Repository (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_Repository (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_Repository_Remote_Proxy_Impl;
  friend class _TAO_Repository_ThruPOA_Proxy_Impl;
  friend class _TAO_Repository_Direct_Proxy_Impl;

  virtual ~IR_Repository (void);
private:
  IR_Repository (const IR_Repository &);
  void operator= (const IR_Repository &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_Repository_Proxy_Impl :
  public virtual _TAO_Container_Proxy_Impl
{
public:
  virtual ~_TAO_Repository_Proxy_Impl (void) { }

  virtual IR_Contained_ptr lookup_id (
      CORBA_Object *_collocated_tao_target_,
      const char * search_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::TypeCode_ptr get_canonical_typecode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::TypeCode_ptr tc,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_PrimitiveDef_ptr get_primitive (
      CORBA_Object *_collocated_tao_target_,
      IR_PrimitiveKind kind,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_StringDef_ptr create_string (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_WstringDef_ptr create_wstring (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_SequenceDef_ptr create_sequence (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      IR_IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ArrayDef_ptr create_array (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong length,
      IR_IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_FixedDef_ptr create_fixed (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_Repository_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_Repository_Remote_Proxy_Impl :
  public virtual _TAO_Repository_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl

{
public:
  _TAO_Repository_Remote_Proxy_Impl (void);

  virtual ~_TAO_Repository_Remote_Proxy_Impl (void) { }

  virtual IR_Contained_ptr lookup_id (
      CORBA_Object *_collocated_tao_target_,
      const char * search_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr get_canonical_typecode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::TypeCode_ptr tc,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PrimitiveDef_ptr get_primitive (
      CORBA_Object *_collocated_tao_target_,
      IR_PrimitiveKind kind,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_StringDef_ptr create_string (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_WstringDef_ptr create_wstring (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_SequenceDef_ptr create_sequence (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      IR_IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ArrayDef_ptr create_array (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong length,
      IR_IDLType_ptr element_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FixedDef_ptr create_fixed (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_Repository_Proxy_Broker
{
public:
  virtual ~_TAO_Repository_Proxy_Broker (void);

  virtual _TAO_Repository_Proxy_Impl &select_proxy (
    IR_Repository *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_Repository_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_Repository_Remote_Proxy_Broker : public virtual _TAO_Repository_Proxy_Broker
{
public:
  _TAO_Repository_Remote_Proxy_Broker (void);

  virtual ~_TAO_Repository_Remote_Proxy_Broker (void);

  virtual _TAO_Repository_Proxy_Impl &select_proxy (
    IR_Repository *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_Repository_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_Repository_Remote_Proxy_Broker *the_TAO_Repository_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

class TAO_Export IR_ComponentRepository_var : public TAO_Base_var
{
public:
  IR_ComponentRepository_var (void); // default constructor
  IR_ComponentRepository_var (IR_ComponentRepository_ptr p) : ptr_ (p) {}
  IR_ComponentRepository_var (const IR_ComponentRepository_var &); // copy constructor
  ~IR_ComponentRepository_var (void); // destructor

  IR_ComponentRepository_var &operator= (IR_ComponentRepository_ptr);
  IR_ComponentRepository_var &operator= (const IR_ComponentRepository_var &);
  IR_ComponentRepository_ptr operator-> (void) const;

  operator const IR_ComponentRepository_ptr &() const;
  operator IR_ComponentRepository_ptr &();
  // in, inout, out, _retn
  IR_ComponentRepository_ptr in (void) const;
  IR_ComponentRepository_ptr &inout (void);
  IR_ComponentRepository_ptr &out (void);
  IR_ComponentRepository_ptr _retn (void);
  IR_ComponentRepository_ptr ptr (void) const;

private:
  IR_ComponentRepository_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ComponentRepository_var (const TAO_Base_var &rhs);
  IR_ComponentRepository_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ComponentRepository_out
{
public:
  IR_ComponentRepository_out (IR_ComponentRepository_ptr &);
  IR_ComponentRepository_out (IR_ComponentRepository_var &);
  IR_ComponentRepository_out (const IR_ComponentRepository_out &);
  IR_ComponentRepository_out &operator= (const IR_ComponentRepository_out &);
  IR_ComponentRepository_out &operator= (const IR_ComponentRepository_var &);
  IR_ComponentRepository_out &operator= (IR_ComponentRepository_ptr);
  operator IR_ComponentRepository_ptr &();
  IR_ComponentRepository_ptr &ptr (void);
  IR_ComponentRepository_ptr operator-> (void);

private:
  IR_ComponentRepository_ptr &ptr_;
};

// Forward Classes Declaration
class _TAO_ComponentRepository_Proxy_Impl;
class _TAO_ComponentRepository_Remote_Proxy_Impl;
class _TAO_ComponentRepository_Proxy_Broker;
class _TAO_ComponentRepository_Remote_Proxy_Broker;

class TAO_Export IR_ComponentRepository: public virtual IR_Repository
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ComponentRepository_ptr _ptr_type;
  typedef IR_ComponentRepository_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ComponentRepository_ptr _duplicate (IR_ComponentRepository_ptr obj);
  static IR_ComponentRepository_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ComponentRepository_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ComponentRepository_ptr _nil (void)
    {
      return (IR_ComponentRepository_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_ComponentDef_ptr create_component (
      const char * id,
      const char * name,
      const char * version,
      IR_ComponentDef_ptr base_component,
      const IR_InterfaceDefSeq & supports_interfaces,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_HomeDef_ptr create_home (
      const char * id,
      const char * name,
      const char * version,
      IR_HomeDef_ptr base_home,
      IR_ComponentDef_ptr managed_component,
      IR_ValueDef_ptr primary_key,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ComponentRepository_Proxy_Broker *the_TAO_ComponentRepository_Proxy_Broker_;

protected:
  IR_ComponentRepository (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ComponentRepository (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ComponentRepository_Remote_Proxy_Impl;
  friend class _TAO_ComponentRepository_ThruPOA_Proxy_Impl;
  friend class _TAO_ComponentRepository_Direct_Proxy_Impl;

  virtual ~IR_ComponentRepository (void);
private:
  IR_ComponentRepository (const IR_ComponentRepository &);
  void operator= (const IR_ComponentRepository &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ComponentRepository_Proxy_Impl :
  public virtual _TAO_Repository_Proxy_Impl
{
public:
  virtual ~_TAO_ComponentRepository_Proxy_Impl (void) { }

  virtual IR_ComponentDef_ptr create_component (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ComponentDef_ptr base_component,
      const IR_InterfaceDefSeq & supports_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_HomeDef_ptr create_home (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_HomeDef_ptr base_home,
      IR_ComponentDef_ptr managed_component,
      IR_ValueDef_ptr primary_key,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ComponentRepository_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ComponentRepository_Remote_Proxy_Impl :
  public virtual _TAO_ComponentRepository_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Repository_Remote_Proxy_Impl

{
public:
  _TAO_ComponentRepository_Remote_Proxy_Impl (void);

  virtual ~_TAO_ComponentRepository_Remote_Proxy_Impl (void) { }

  virtual IR_ComponentDef_ptr create_component (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ComponentDef_ptr base_component,
      const IR_InterfaceDefSeq & supports_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_HomeDef_ptr create_home (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_HomeDef_ptr base_home,
      IR_ComponentDef_ptr managed_component,
      IR_ValueDef_ptr primary_key,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ComponentRepository_Proxy_Broker
{
public:
  virtual ~_TAO_ComponentRepository_Proxy_Broker (void);

  virtual _TAO_ComponentRepository_Proxy_Impl &select_proxy (
    IR_ComponentRepository *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ComponentRepository_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ComponentRepository_Remote_Proxy_Broker : public virtual _TAO_ComponentRepository_Proxy_Broker
{
public:
  _TAO_ComponentRepository_Remote_Proxy_Broker (void);

  virtual ~_TAO_ComponentRepository_Remote_Proxy_Broker (void);

  virtual _TAO_ComponentRepository_Proxy_Impl &select_proxy (
    IR_ComponentRepository *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ComponentRepository_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ComponentRepository_Remote_Proxy_Broker *the_TAO_ComponentRepository_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_ModuleDef_Proxy_Impl;
class _TAO_ModuleDef_Remote_Proxy_Impl;
class _TAO_ModuleDef_Proxy_Broker;
class _TAO_ModuleDef_Remote_Proxy_Broker;

class TAO_Export IR_ModuleDef: public virtual IR_Container, public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ModuleDef_ptr _ptr_type;
  typedef IR_ModuleDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ModuleDef_ptr _duplicate (IR_ModuleDef_ptr obj);
  static IR_ModuleDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ModuleDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ModuleDef_ptr _nil (void)
    {
      return (IR_ModuleDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ModuleDef_Proxy_Broker *the_TAO_ModuleDef_Proxy_Broker_;

protected:
  IR_ModuleDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ModuleDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ModuleDef_Remote_Proxy_Impl;
  friend class _TAO_ModuleDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ModuleDef_Direct_Proxy_Impl;

  virtual ~IR_ModuleDef (void);
private:
  IR_ModuleDef (const IR_ModuleDef &);
  void operator= (const IR_ModuleDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


  ///////////////////////////////////////////////////////////////////////
  //                    Base  Impl. Declaration
  //

  class TAO_Export _TAO_ModuleDef_Proxy_Impl :
    public virtual _TAO_Container_Proxy_Impl,
    public virtual _TAO_Contained_Proxy_Impl
  {
  public:
    virtual ~_TAO_ModuleDef_Proxy_Impl (void) { }

  protected:
    _TAO_ModuleDef_Proxy_Impl (void);

  };

  //
  //                Base  Proxy Impl. Declaration
  ///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ModuleDef_Remote_Proxy_Impl :
  public virtual _TAO_ModuleDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_ModuleDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ModuleDef_Remote_Proxy_Impl (void) { }

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ModuleDef_Proxy_Broker
{
public:
  virtual ~_TAO_ModuleDef_Proxy_Broker (void);

  virtual _TAO_ModuleDef_Proxy_Impl &select_proxy (
    IR_ModuleDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ModuleDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ModuleDef_Remote_Proxy_Broker : public virtual _TAO_ModuleDef_Proxy_Broker
{
public:
  _TAO_ModuleDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ModuleDef_Remote_Proxy_Broker (void);

  virtual _TAO_ModuleDef_Proxy_Impl &select_proxy (
    IR_ModuleDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ModuleDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ModuleDef_Remote_Proxy_Broker *the_TAO_ModuleDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_ModuleDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ModuleDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
};

class TAO_Export IR_ModuleDescription_var
{
public:
  IR_ModuleDescription_var (void); // default constructor
  IR_ModuleDescription_var (IR_ModuleDescription *);
  IR_ModuleDescription_var (const IR_ModuleDescription_var &); // copy constructor
  ~IR_ModuleDescription_var (void); // destructor

  IR_ModuleDescription_var &operator= (IR_ModuleDescription *);
  IR_ModuleDescription_var &operator= (const IR_ModuleDescription_var &);
  IR_ModuleDescription *operator-> (void);
  const IR_ModuleDescription *operator-> (void) const;

  operator const IR_ModuleDescription &() const;
  operator IR_ModuleDescription &();
  operator IR_ModuleDescription &() const;
  operator IR_ModuleDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_ModuleDescription &in (void) const;
  IR_ModuleDescription &inout (void);
  IR_ModuleDescription *&out (void);
  IR_ModuleDescription *_retn (void);
  IR_ModuleDescription *ptr (void) const;

private:
  IR_ModuleDescription *ptr_;
};

class TAO_Export IR_ModuleDescription_out
{
public:
  IR_ModuleDescription_out (IR_ModuleDescription *&);
  IR_ModuleDescription_out (IR_ModuleDescription_var &);
  IR_ModuleDescription_out (const IR_ModuleDescription_out &);
  IR_ModuleDescription_out &operator= (const IR_ModuleDescription_out &);
  IR_ModuleDescription_out &operator= (IR_ModuleDescription *);
  operator IR_ModuleDescription *&();
  IR_ModuleDescription *&ptr (void);
  IR_ModuleDescription *operator-> (void);

private:
  IR_ModuleDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ModuleDescription_var &);
};

// Forward Classes Declaration
class _TAO_ConstantDef_Proxy_Impl;
class _TAO_ConstantDef_Remote_Proxy_Impl;
class _TAO_ConstantDef_Proxy_Broker;
class _TAO_ConstantDef_Remote_Proxy_Broker;

class TAO_Export IR_ConstantDef: public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ConstantDef_ptr _ptr_type;
  typedef IR_ConstantDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ConstantDef_ptr _duplicate (IR_ConstantDef_ptr obj);
  static IR_ConstantDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ConstantDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ConstantDef_ptr _nil (void)
    {
      return (IR_ConstantDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type   (
                  CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr type_def (
        CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Any * value (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void value (
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ConstantDef_Proxy_Broker *the_TAO_ConstantDef_Proxy_Broker_;

protected:
  IR_ConstantDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ConstantDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ConstantDef_Remote_Proxy_Impl;
  friend class _TAO_ConstantDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ConstantDef_Direct_Proxy_Impl;

  virtual ~IR_ConstantDef (void);
private:
  IR_ConstantDef (const IR_ConstantDef &);
  void operator= (const IR_ConstantDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ConstantDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_ConstantDef_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Any * value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void value (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ConstantDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ConstantDef_Remote_Proxy_Impl :
  public virtual _TAO_ConstantDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_ConstantDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ConstantDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
       CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Any * value   (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void value   (
      CORBA_Object *_collocated_tao_target_,
      const CORBA::Any & value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ConstantDef_Proxy_Broker
{
public:
  virtual ~_TAO_ConstantDef_Proxy_Broker (void);

  virtual _TAO_ConstantDef_Proxy_Impl &select_proxy (
    IR_ConstantDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ConstantDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ConstantDef_Remote_Proxy_Broker : public virtual _TAO_ConstantDef_Proxy_Broker
{
public:
  _TAO_ConstantDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ConstantDef_Remote_Proxy_Broker (void);

  virtual _TAO_ConstantDef_Proxy_Impl &select_proxy (
    IR_ConstantDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ConstantDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ConstantDef_Remote_Proxy_Broker *the_TAO_ConstantDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_ConstantDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ConstantDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
  CORBA::Any value;
};

class TAO_Export IR_ConstantDescription_var
{
public:
  IR_ConstantDescription_var (void); // default constructor
  IR_ConstantDescription_var (IR_ConstantDescription *);
  IR_ConstantDescription_var (const IR_ConstantDescription_var &); // copy constructor
  ~IR_ConstantDescription_var (void); // destructor

  IR_ConstantDescription_var &operator= (IR_ConstantDescription *);
  IR_ConstantDescription_var &operator= (const IR_ConstantDescription_var &);
  IR_ConstantDescription *operator-> (void);
  const IR_ConstantDescription *operator-> (void) const;

  operator const IR_ConstantDescription &() const;
  operator IR_ConstantDescription &();
  operator IR_ConstantDescription &() const;
  operator IR_ConstantDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_ConstantDescription &in (void) const;
  IR_ConstantDescription &inout (void);
  IR_ConstantDescription *&out (void);
  IR_ConstantDescription *_retn (void);
  IR_ConstantDescription *ptr (void) const;

private:
  IR_ConstantDescription *ptr_;
};

class TAO_Export IR_ConstantDescription_out
{
public:
  IR_ConstantDescription_out (IR_ConstantDescription *&);
  IR_ConstantDescription_out (IR_ConstantDescription_var &);
  IR_ConstantDescription_out (const IR_ConstantDescription_out &);
  IR_ConstantDescription_out &operator= (const IR_ConstantDescription_out &);
  IR_ConstantDescription_out &operator= (IR_ConstantDescription *);
  operator IR_ConstantDescription *&();
  IR_ConstantDescription *&ptr (void);
  IR_ConstantDescription *operator-> (void);

private:
  IR_ConstantDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ConstantDescription_var &);
};

class TAO_Export IR_TypedefDef_var : public TAO_Base_var
{
public:
  IR_TypedefDef_var (void); // default constructor
  IR_TypedefDef_var (IR_TypedefDef_ptr p) : ptr_ (p) {}
  IR_TypedefDef_var (const IR_TypedefDef_var &); // copy constructor
  ~IR_TypedefDef_var (void); // destructor

  IR_TypedefDef_var &operator= (IR_TypedefDef_ptr);
  IR_TypedefDef_var &operator= (const IR_TypedefDef_var &);
  IR_TypedefDef_ptr operator-> (void) const;

  operator const IR_TypedefDef_ptr &() const;
  operator IR_TypedefDef_ptr &();
  // in, inout, out, _retn
  IR_TypedefDef_ptr in (void) const;
  IR_TypedefDef_ptr &inout (void);
  IR_TypedefDef_ptr &out (void);
  IR_TypedefDef_ptr _retn (void);
  IR_TypedefDef_ptr ptr (void) const;

private:
  IR_TypedefDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_TypedefDef_var (const TAO_Base_var &rhs);
  IR_TypedefDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_TypedefDef_out
{
public:
  IR_TypedefDef_out (IR_TypedefDef_ptr &);
  IR_TypedefDef_out (IR_TypedefDef_var &);
  IR_TypedefDef_out (const IR_TypedefDef_out &);
  IR_TypedefDef_out &operator= (const IR_TypedefDef_out &);
  IR_TypedefDef_out &operator= (const IR_TypedefDef_var &);
  IR_TypedefDef_out &operator= (IR_TypedefDef_ptr);
  operator IR_TypedefDef_ptr &();
  IR_TypedefDef_ptr &ptr (void);
  IR_TypedefDef_ptr operator-> (void);

private:
  IR_TypedefDef_ptr &ptr_;
};

// Forward Classes Declaration
class _TAO_TypedefDef_Proxy_Impl;
class _TAO_TypedefDef_Remote_Proxy_Impl;
class _TAO_TypedefDef_Proxy_Broker;
class _TAO_TypedefDef_Remote_Proxy_Broker;

class TAO_Export IR_TypedefDef: public virtual IR_Contained, public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_TypedefDef_ptr _ptr_type;
  typedef IR_TypedefDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_TypedefDef_ptr _duplicate (IR_TypedefDef_ptr obj);
  static IR_TypedefDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_TypedefDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_TypedefDef_ptr _nil (void)
    {
      return (IR_TypedefDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_TypedefDef_Proxy_Broker *the_TAO_TypedefDef_Proxy_Broker_;

protected:
  IR_TypedefDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_TypedefDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_TypedefDef_Remote_Proxy_Impl;
  friend class _TAO_TypedefDef_ThruPOA_Proxy_Impl;
  friend class _TAO_TypedefDef_Direct_Proxy_Impl;

  virtual ~IR_TypedefDef (void);
private:
  IR_TypedefDef (const IR_TypedefDef &);
  void operator= (const IR_TypedefDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


  ///////////////////////////////////////////////////////////////////////
  //                    Base  Impl. Declaration
  //

  class TAO_Export _TAO_TypedefDef_Proxy_Impl :
    public virtual _TAO_Contained_Proxy_Impl,
    public virtual _TAO_IDLType_Proxy_Impl
  {
  public:
    virtual ~_TAO_TypedefDef_Proxy_Impl (void) { }

  protected:
    _TAO_TypedefDef_Proxy_Impl (void);

  };

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_TypedefDef_Remote_Proxy_Impl :
  public virtual _TAO_TypedefDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_TypedefDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_TypedefDef_Remote_Proxy_Impl (void) { }

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_TypedefDef_Proxy_Broker
{
public:
  virtual ~_TAO_TypedefDef_Proxy_Broker (void);

  virtual _TAO_TypedefDef_Proxy_Impl &select_proxy (
    IR_TypedefDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_TypedefDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_TypedefDef_Remote_Proxy_Broker : public virtual _TAO_TypedefDef_Proxy_Broker
{
public:
  _TAO_TypedefDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_TypedefDef_Remote_Proxy_Broker (void);

  virtual _TAO_TypedefDef_Proxy_Impl &select_proxy (
    IR_TypedefDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_TypedefDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_TypedefDef_Remote_Proxy_Broker *the_TAO_TypedefDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_TypeDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_TypeDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
};

class TAO_Export IR_TypeDescription_var
{
public:
  IR_TypeDescription_var (void); // default constructor
  IR_TypeDescription_var (IR_TypeDescription *);
  IR_TypeDescription_var (const IR_TypeDescription_var &); // copy constructor
  ~IR_TypeDescription_var (void); // destructor

  IR_TypeDescription_var &operator= (IR_TypeDescription *);
  IR_TypeDescription_var &operator= (const IR_TypeDescription_var &);
  IR_TypeDescription *operator-> (void);
  const IR_TypeDescription *operator-> (void) const;

  operator const IR_TypeDescription &() const;
  operator IR_TypeDescription &();
  operator IR_TypeDescription &() const;
  operator IR_TypeDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_TypeDescription &in (void) const;
  IR_TypeDescription &inout (void);
  IR_TypeDescription *&out (void);
  IR_TypeDescription *_retn (void);
  IR_TypeDescription *ptr (void) const;

private:
  IR_TypeDescription *ptr_;
};

class TAO_Export IR_TypeDescription_out
{
public:
  IR_TypeDescription_out (IR_TypeDescription *&);
  IR_TypeDescription_out (IR_TypeDescription_var &);
  IR_TypeDescription_out (const IR_TypeDescription_out &);
  IR_TypeDescription_out &operator= (const IR_TypeDescription_out &);
  IR_TypeDescription_out &operator= (IR_TypeDescription *);
  operator IR_TypeDescription *&();
  IR_TypeDescription *&ptr (void);
  IR_TypeDescription *operator-> (void);

private:
  IR_TypeDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_TypeDescription_var &);
};

// Forward Classes Declaration
class _TAO_StructDef_Proxy_Impl;
class _TAO_StructDef_Remote_Proxy_Impl;
class _TAO_StructDef_Proxy_Broker;
class _TAO_StructDef_Remote_Proxy_Broker;

class TAO_Export IR_StructDef: public virtual IR_TypedefDef, public virtual IR_Container
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_StructDef_ptr _ptr_type;
  typedef IR_StructDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_StructDef_ptr _duplicate (IR_StructDef_ptr obj);
  static IR_StructDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_StructDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_StructDef_ptr _nil (void)
    {
      return (IR_StructDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_StructMemberSeq * members   (
                  CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members   (
            const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_StructDef_Proxy_Broker *the_TAO_StructDef_Proxy_Broker_;

protected:
  IR_StructDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_StructDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_StructDef_Remote_Proxy_Impl;
  friend class _TAO_StructDef_ThruPOA_Proxy_Impl;
  friend class _TAO_StructDef_Direct_Proxy_Impl;

  virtual ~IR_StructDef (void);
private:
  IR_StructDef (const IR_StructDef &);
  void operator= (const IR_StructDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_StructDef_Proxy_Impl :
  public virtual _TAO_TypedefDef_Proxy_Impl,
  public virtual _TAO_Container_Proxy_Impl
{
public:
  virtual ~_TAO_StructDef_Proxy_Impl (void) { }

  virtual IR_StructMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_StructDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_StructDef_Remote_Proxy_Impl :
  public virtual _TAO_StructDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl

{
public:
  _TAO_StructDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_StructDef_Remote_Proxy_Impl (void) { }

  virtual IR_StructMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_StructDef_Proxy_Broker
{
public:
  virtual ~_TAO_StructDef_Proxy_Broker (void);

  virtual _TAO_StructDef_Proxy_Impl &select_proxy (
    IR_StructDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_StructDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_StructDef_Remote_Proxy_Broker : public virtual _TAO_StructDef_Proxy_Broker
{
public:
  _TAO_StructDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_StructDef_Remote_Proxy_Broker (void);

  virtual _TAO_StructDef_Proxy_Impl &select_proxy (
    IR_StructDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_StructDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_StructDef_Remote_Proxy_Broker *the_TAO_StructDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_UnionDef_Proxy_Impl;
class _TAO_UnionDef_Remote_Proxy_Impl;
class _TAO_UnionDef_Proxy_Broker;
class _TAO_UnionDef_Remote_Proxy_Broker;

class TAO_Export IR_UnionDef: public virtual IR_TypedefDef, public virtual IR_Container
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_UnionDef_ptr _ptr_type;
  typedef IR_UnionDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_UnionDef_ptr _duplicate (IR_UnionDef_ptr obj);
  static IR_UnionDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_UnionDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_UnionDef_ptr _nil (void)
    {
      return (IR_UnionDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr discriminator_type (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr discriminator_type_def (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void discriminator_type_def (
      IR_IDLType_ptr discriminator_type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_UnionMemberSeq * members (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      const IR_UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_UnionDef_Proxy_Broker *the_TAO_UnionDef_Proxy_Broker_;

protected:
  IR_UnionDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_UnionDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_UnionDef_Remote_Proxy_Impl;
  friend class _TAO_UnionDef_ThruPOA_Proxy_Impl;
  friend class _TAO_UnionDef_Direct_Proxy_Impl;

  virtual ~IR_UnionDef (void);
private:
 IR_UnionDef (const IR_UnionDef &);
  void operator= (const IR_UnionDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_UnionDef_Proxy_Impl :
  public virtual _TAO_TypedefDef_Proxy_Impl,
  public virtual _TAO_Container_Proxy_Impl
{
public:
  virtual ~_TAO_UnionDef_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr discriminator_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_IDLType_ptr discriminator_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void discriminator_type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr discriminator_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_UnionMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void members   (
      CORBA_Object *_collocated_tao_target_,
      const IR_UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_UnionDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_UnionDef_Remote_Proxy_Impl :
  public virtual _TAO_UnionDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl

{
public:
  _TAO_UnionDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_UnionDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr discriminator_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr discriminator_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void discriminator_type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr discriminator_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_UnionMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const IR_UnionMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_UnionDef_Proxy_Broker
{
public:
  virtual ~_TAO_UnionDef_Proxy_Broker (void);

  virtual _TAO_UnionDef_Proxy_Impl &select_proxy (
    IR_UnionDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_UnionDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_UnionDef_Remote_Proxy_Broker : public virtual _TAO_UnionDef_Proxy_Broker
{
public:
  _TAO_UnionDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_UnionDef_Remote_Proxy_Broker (void);

  virtual _TAO_UnionDef_Proxy_Impl &select_proxy (
    IR_UnionDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_UnionDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_UnionDef_Remote_Proxy_Broker *the_TAO_UnionDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_EnumDef_Proxy_Impl;
class _TAO_EnumDef_Remote_Proxy_Impl;
class _TAO_EnumDef_Proxy_Broker;
class _TAO_EnumDef_Remote_Proxy_Broker;

class TAO_Export IR_EnumDef: public virtual IR_TypedefDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_EnumDef_ptr _ptr_type;
  typedef IR_EnumDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_EnumDef_ptr _duplicate (IR_EnumDef_ptr obj);
  static IR_EnumDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_EnumDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_EnumDef_ptr _nil (void)
    {
      return (IR_EnumDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_EnumMemberSeq * members (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      const IR_EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_EnumDef_Proxy_Broker *the_TAO_EnumDef_Proxy_Broker_;

protected:
  IR_EnumDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_EnumDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_EnumDef_Remote_Proxy_Impl;
  friend class _TAO_EnumDef_ThruPOA_Proxy_Impl;
  friend class _TAO_EnumDef_Direct_Proxy_Impl;

  virtual ~IR_EnumDef (void);
private:
  IR_EnumDef (const IR_EnumDef &);
  void operator= (const IR_EnumDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_EnumDef_Proxy_Impl :
  public virtual _TAO_TypedefDef_Proxy_Impl
{
public:
  virtual ~_TAO_EnumDef_Proxy_Impl (void) { }

  virtual IR_EnumMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void members   (
      CORBA_Object *_collocated_tao_target_,
      const IR_EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_EnumDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_EnumDef_Remote_Proxy_Impl :
  public virtual _TAO_EnumDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl

{
public:
  _TAO_EnumDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_EnumDef_Remote_Proxy_Impl (void) { }

  virtual IR_EnumMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const IR_EnumMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_EnumDef_Proxy_Broker
{
public:
  virtual ~_TAO_EnumDef_Proxy_Broker (void);

  virtual _TAO_EnumDef_Proxy_Impl &select_proxy (
    IR_EnumDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_EnumDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_EnumDef_Remote_Proxy_Broker : public virtual _TAO_EnumDef_Proxy_Broker
{
public:
  _TAO_EnumDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_EnumDef_Remote_Proxy_Broker (void);

  virtual _TAO_EnumDef_Proxy_Impl &select_proxy (
    IR_EnumDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_EnumDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_EnumDef_Remote_Proxy_Broker *the_TAO_EnumDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_AliasDef_Proxy_Impl;
class _TAO_AliasDef_Remote_Proxy_Impl;
class _TAO_AliasDef_Proxy_Broker;
class _TAO_AliasDef_Remote_Proxy_Broker;

class TAO_Export IR_AliasDef: public virtual IR_TypedefDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_AliasDef_ptr _ptr_type;
  typedef IR_AliasDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_AliasDef_ptr _duplicate (IR_AliasDef_ptr obj);
  static IR_AliasDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_AliasDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_AliasDef_ptr _nil (void)
    {
      return (IR_AliasDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_IDLType_ptr original_type_def (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void original_type_def   (
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_AliasDef_Proxy_Broker *the_TAO_AliasDef_Proxy_Broker_;

protected:
  IR_AliasDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_AliasDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_AliasDef_Remote_Proxy_Impl;
  friend class _TAO_AliasDef_ThruPOA_Proxy_Impl;
  friend class _TAO_AliasDef_Direct_Proxy_Impl;

  virtual ~IR_AliasDef (void);
private:
  IR_AliasDef (const IR_AliasDef &);
  void operator= (const IR_AliasDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_AliasDef_Proxy_Impl :
  public virtual _TAO_TypedefDef_Proxy_Impl
{
public:
  virtual ~_TAO_AliasDef_Proxy_Impl (void) { }

  virtual IR_IDLType_ptr original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void original_type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_AliasDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_AliasDef_Remote_Proxy_Impl :
  public virtual _TAO_AliasDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl

{
public:
  _TAO_AliasDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_AliasDef_Remote_Proxy_Impl (void) { }

  virtual IR_IDLType_ptr original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void original_type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_AliasDef_Proxy_Broker
{
public:
  virtual ~_TAO_AliasDef_Proxy_Broker (void);

  virtual _TAO_AliasDef_Proxy_Impl &select_proxy (
    IR_AliasDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_AliasDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_AliasDef_Remote_Proxy_Broker : public virtual _TAO_AliasDef_Proxy_Broker
{
public:
  _TAO_AliasDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_AliasDef_Remote_Proxy_Broker (void);

  virtual _TAO_AliasDef_Proxy_Impl &select_proxy (
    IR_AliasDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_AliasDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_AliasDef_Remote_Proxy_Broker *the_TAO_AliasDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_NativeDef_Proxy_Impl;
class _TAO_NativeDef_Remote_Proxy_Impl;
class _TAO_NativeDef_Proxy_Broker;
class _TAO_NativeDef_Remote_Proxy_Broker;

class TAO_Export IR_NativeDef: public virtual IR_TypedefDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_NativeDef_ptr _ptr_type;
  typedef IR_NativeDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_NativeDef_ptr _duplicate (IR_NativeDef_ptr obj);
  static IR_NativeDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_NativeDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_NativeDef_ptr _nil (void)
    {
      return (IR_NativeDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_NativeDef_Proxy_Broker *the_TAO_NativeDef_Proxy_Broker_;

protected:
  IR_NativeDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_NativeDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_NativeDef_Remote_Proxy_Impl;
  friend class _TAO_NativeDef_ThruPOA_Proxy_Impl;
  friend class _TAO_NativeDef_Direct_Proxy_Impl;

  virtual ~IR_NativeDef (void);
private:
  IR_NativeDef (const IR_NativeDef &);
  void operator= (const IR_NativeDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_NativeDef_Proxy_Impl :
  public virtual _TAO_TypedefDef_Proxy_Impl
{
public:
  virtual ~_TAO_NativeDef_Proxy_Impl (void) { }

protected:
  _TAO_NativeDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_NativeDef_Remote_Proxy_Impl :
  public virtual _TAO_NativeDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl

{
public:
  _TAO_NativeDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_NativeDef_Remote_Proxy_Impl (void) { }

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_NativeDef_Proxy_Broker
{
public:
  virtual ~_TAO_NativeDef_Proxy_Broker (void);

  virtual _TAO_NativeDef_Proxy_Impl &select_proxy (
    IR_NativeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_NativeDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_NativeDef_Remote_Proxy_Broker : public virtual _TAO_NativeDef_Proxy_Broker
{
public:
  _TAO_NativeDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_NativeDef_Remote_Proxy_Broker (void);

  virtual _TAO_NativeDef_Proxy_Impl &select_proxy (
    IR_NativeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_NativeDef_Remote_Proxy_Impl remote_proxy_impl_;
};

// This funxtion is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

_TAO_NativeDef_Remote_Proxy_Broker *the_TAO_NativeDef_Remote_Proxy_Broker (void);

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_PrimitiveDef_Proxy_Impl;
class _TAO_PrimitiveDef_Remote_Proxy_Impl;
class _TAO_PrimitiveDef_Proxy_Broker;
class _TAO_PrimitiveDef_Remote_Proxy_Broker;

class TAO_Export IR_PrimitiveDef: public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_PrimitiveDef_ptr _ptr_type;
  typedef IR_PrimitiveDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_PrimitiveDef_ptr _duplicate (IR_PrimitiveDef_ptr obj);
  static IR_PrimitiveDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_PrimitiveDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_PrimitiveDef_ptr _nil (void)
    {
      return (IR_PrimitiveDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_PrimitiveKind kind (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_PrimitiveDef_Proxy_Broker *the_TAO_PrimitiveDef_Proxy_Broker_;

protected:
  IR_PrimitiveDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_PrimitiveDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_PrimitiveDef_Remote_Proxy_Impl;
  friend class _TAO_PrimitiveDef_ThruPOA_Proxy_Impl;
  friend class _TAO_PrimitiveDef_Direct_Proxy_Impl;

  virtual ~IR_PrimitiveDef (void);
private:
  IR_PrimitiveDef (const IR_PrimitiveDef &);
  void operator= (const IR_PrimitiveDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_PrimitiveDef_Proxy_Impl :
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_PrimitiveDef_Proxy_Impl (void) { }

  virtual IR_PrimitiveKind kind (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_PrimitiveDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_PrimitiveDef_Remote_Proxy_Impl :
  public virtual _TAO_PrimitiveDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_PrimitiveDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_PrimitiveDef_Remote_Proxy_Impl (void) { }

  virtual IR_PrimitiveKind kind (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_PrimitiveDef_Proxy_Broker
{
public:
  virtual ~_TAO_PrimitiveDef_Proxy_Broker (void);

  virtual _TAO_PrimitiveDef_Proxy_Impl &select_proxy (
    IR_PrimitiveDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_PrimitiveDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_PrimitiveDef_Remote_Proxy_Broker : public virtual _TAO_PrimitiveDef_Proxy_Broker
{
public:
  _TAO_PrimitiveDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_PrimitiveDef_Remote_Proxy_Broker (void);

  virtual _TAO_PrimitiveDef_Proxy_Impl &select_proxy (
    IR_PrimitiveDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_PrimitiveDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_PrimitiveDef_Remote_Proxy_Broker *the_TAO_PrimitiveDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_StringDef_Proxy_Impl;
class _TAO_StringDef_Remote_Proxy_Impl;
class _TAO_StringDef_Proxy_Broker;
class _TAO_StringDef_Remote_Proxy_Broker;

class TAO_Export IR_StringDef: public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_StringDef_ptr _ptr_type;
  typedef IR_StringDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_StringDef_ptr _duplicate (IR_StringDef_ptr obj);
  static IR_StringDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_StringDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_StringDef_ptr _nil (void)
    {
      return (IR_StringDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::ULong bound (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_StringDef_Proxy_Broker *the_TAO_StringDef_Proxy_Broker_;

protected:
  IR_StringDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_StringDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_StringDef_Remote_Proxy_Impl;
  friend class _TAO_StringDef_ThruPOA_Proxy_Impl;
  friend class _TAO_StringDef_Direct_Proxy_Impl;

  virtual ~IR_StringDef (void);
private:
  IR_StringDef (const IR_StringDef &);
  void operator= (const IR_StringDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_StringDef_Proxy_Impl :
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_StringDef_Proxy_Impl (void) { }

  virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_StringDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_StringDef_Remote_Proxy_Impl :
  public virtual _TAO_StringDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_StringDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_StringDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_StringDef_Proxy_Broker
{
public:
  virtual ~_TAO_StringDef_Proxy_Broker (void);

  virtual _TAO_StringDef_Proxy_Impl &select_proxy (
    IR_StringDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_StringDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_StringDef_Remote_Proxy_Broker : public virtual _TAO_StringDef_Proxy_Broker
{
public:
  _TAO_StringDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_StringDef_Remote_Proxy_Broker (void);

  virtual _TAO_StringDef_Proxy_Impl &select_proxy (
    IR_StringDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_StringDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_StringDef_Remote_Proxy_Broker *the_TAO_StringDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_WstringDef_Proxy_Impl;
class _TAO_WstringDef_Remote_Proxy_Impl;
class _TAO_WstringDef_Proxy_Broker;
class _TAO_WstringDef_Remote_Proxy_Broker;

class TAO_Export IR_WstringDef: public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_WstringDef_ptr _ptr_type;
  typedef IR_WstringDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_WstringDef_ptr _duplicate (IR_WstringDef_ptr obj);
  static IR_WstringDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_WstringDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_WstringDef_ptr _nil (void)
    {
      return (IR_WstringDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::ULong bound (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_WstringDef_Proxy_Broker *the_TAO_WstringDef_Proxy_Broker_;

protected:
  IR_WstringDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_WstringDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_WstringDef_Remote_Proxy_Impl;
  friend class _TAO_WstringDef_ThruPOA_Proxy_Impl;
  friend class _TAO_WstringDef_Direct_Proxy_Impl;

  virtual ~IR_WstringDef (void);
private:
  IR_WstringDef (const IR_WstringDef &);
  void operator= (const IR_WstringDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_WstringDef_Proxy_Impl :
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_WstringDef_Proxy_Impl (void) { }

  virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_WstringDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_WstringDef_Remote_Proxy_Impl :
  public virtual _TAO_WstringDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_WstringDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_WstringDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_WstringDef_Proxy_Broker
{
public:
  virtual ~_TAO_WstringDef_Proxy_Broker (void);

  virtual _TAO_WstringDef_Proxy_Impl &select_proxy (
    IR_WstringDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_WstringDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_WstringDef_Remote_Proxy_Broker : public virtual _TAO_WstringDef_Proxy_Broker
{
public:
  _TAO_WstringDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_WstringDef_Remote_Proxy_Broker (void);

  virtual _TAO_WstringDef_Proxy_Impl &select_proxy (
    IR_WstringDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_WstringDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_WstringDef_Remote_Proxy_Broker *the_TAO_WstringDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_FixedDef_Proxy_Impl;
class _TAO_FixedDef_Remote_Proxy_Impl;
class _TAO_FixedDef_Proxy_Broker;
class _TAO_FixedDef_Remote_Proxy_Broker;

class TAO_Export IR_FixedDef: public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_FixedDef_ptr _ptr_type;
  typedef IR_FixedDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_FixedDef_ptr _duplicate (IR_FixedDef_ptr obj);
  static IR_FixedDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_FixedDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_FixedDef_ptr _nil (void)
    {
      return (IR_FixedDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::UShort digits   (
                  CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void digits (
      CORBA::UShort digits,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Short scale (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void scale (
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_FixedDef_Proxy_Broker *the_TAO_FixedDef_Proxy_Broker_;

protected:
  IR_FixedDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_FixedDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_FixedDef_Remote_Proxy_Impl;
  friend class _TAO_FixedDef_ThruPOA_Proxy_Impl;
  friend class _TAO_FixedDef_Direct_Proxy_Impl;

  virtual ~IR_FixedDef (void);
private:
  IR_FixedDef (const IR_FixedDef &);
  void operator= (const IR_FixedDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_FixedDef_Proxy_Impl :
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_FixedDef_Proxy_Impl (void) { }

  virtual CORBA::UShort digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Short scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_FixedDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_FixedDef_Remote_Proxy_Impl :
  public virtual _TAO_FixedDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_FixedDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_FixedDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::UShort digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void digits (
      CORBA_Object *_collocated_tao_target_,
      CORBA::UShort digits,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Short scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void scale (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Short scale,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_FixedDef_Proxy_Broker
{
public:
  virtual ~_TAO_FixedDef_Proxy_Broker (void);

  virtual _TAO_FixedDef_Proxy_Impl &select_proxy (
    IR_FixedDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_FixedDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_FixedDef_Remote_Proxy_Broker : public virtual _TAO_FixedDef_Proxy_Broker
{
public:
  _TAO_FixedDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_FixedDef_Remote_Proxy_Broker (void);

  virtual _TAO_FixedDef_Proxy_Impl &select_proxy (
    IR_FixedDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_FixedDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_FixedDef_Remote_Proxy_Broker *the_TAO_FixedDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_SequenceDef_Proxy_Impl;
class _TAO_SequenceDef_Remote_Proxy_Impl;
class _TAO_SequenceDef_Proxy_Broker;
class _TAO_SequenceDef_Remote_Proxy_Broker;

class TAO_Export IR_SequenceDef: public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_SequenceDef_ptr _ptr_type;
  typedef IR_SequenceDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_SequenceDef_ptr _duplicate (IR_SequenceDef_ptr obj);
  static IR_SequenceDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_SequenceDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_SequenceDef_ptr _nil (void)
    {
      return (IR_SequenceDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::ULong bound (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr element_type (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr element_type_def (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void element_type_def (
      IR_IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_SequenceDef_Proxy_Broker *the_TAO_SequenceDef_Proxy_Broker_;

protected:
  IR_SequenceDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_SequenceDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_SequenceDef_Remote_Proxy_Impl;
  friend class _TAO_SequenceDef_ThruPOA_Proxy_Impl;
  friend class _TAO_SequenceDef_Direct_Proxy_Impl;

  virtual ~IR_SequenceDef (void);
private:
  IR_SequenceDef (const IR_SequenceDef &);
  void operator= (const IR_SequenceDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_SequenceDef_Proxy_Impl :
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_SequenceDef_Proxy_Impl (void) { }

  virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::TypeCode_ptr element_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_IDLType_ptr element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void element_type_def   (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_SequenceDef_Proxy_Impl (void);

};


//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_SequenceDef_Remote_Proxy_Impl :
  public virtual _TAO_SequenceDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_SequenceDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_SequenceDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::ULong bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void bound (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong bound,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr element_type(
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr element_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void element_type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_SequenceDef_Proxy_Broker
{
public:
  virtual ~_TAO_SequenceDef_Proxy_Broker (void);

  virtual _TAO_SequenceDef_Proxy_Impl &select_proxy (
    IR_SequenceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_SequenceDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_SequenceDef_Remote_Proxy_Broker : public virtual _TAO_SequenceDef_Proxy_Broker
{
public:
  _TAO_SequenceDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_SequenceDef_Remote_Proxy_Broker (void);

  virtual _TAO_SequenceDef_Proxy_Impl &select_proxy (
    IR_SequenceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_SequenceDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_SequenceDef_Remote_Proxy_Broker *the_TAO_SequenceDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_ArrayDef_Proxy_Impl;
class _TAO_ArrayDef_Remote_Proxy_Impl;
class _TAO_ArrayDef_Proxy_Broker;
class _TAO_ArrayDef_Remote_Proxy_Broker;

class TAO_Export IR_ArrayDef: public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ArrayDef_ptr _ptr_type;
  typedef IR_ArrayDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ArrayDef_ptr _duplicate (IR_ArrayDef_ptr obj);
  static IR_ArrayDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ArrayDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ArrayDef_ptr _nil (void)
    {
      return (IR_ArrayDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::ULong length (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void length (
      CORBA::ULong length,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr element_type (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr element_type_def (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void element_type_def (
      IR_IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ArrayDef_Proxy_Broker *the_TAO_ArrayDef_Proxy_Broker_;

protected:
  IR_ArrayDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ArrayDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ArrayDef_Remote_Proxy_Impl;
  friend class _TAO_ArrayDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ArrayDef_Direct_Proxy_Impl;

  virtual ~IR_ArrayDef (void);
private:
  IR_ArrayDef (const IR_ArrayDef &);
  void operator= (const IR_ArrayDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ArrayDef_Proxy_Impl :
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_ArrayDef_Proxy_Impl (void) { }

  virtual CORBA::ULong length (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void length (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong length,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::TypeCode_ptr element_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_IDLType_ptr element_type_def (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void element_type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ArrayDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ArrayDef_Remote_Proxy_Impl :
  public virtual _TAO_ArrayDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_ArrayDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ArrayDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::ULong length (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void length (
      CORBA_Object *_collocated_tao_target_,
      CORBA::ULong length,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::TypeCode_ptr element_type   (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr element_type_def   (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void element_type_def   (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr element_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ArrayDef_Proxy_Broker
{
public:
  virtual ~_TAO_ArrayDef_Proxy_Broker (void);

  virtual _TAO_ArrayDef_Proxy_Impl &select_proxy (
    IR_ArrayDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ArrayDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ArrayDef_Remote_Proxy_Broker : public virtual _TAO_ArrayDef_Proxy_Broker
{
public:
  _TAO_ArrayDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ArrayDef_Remote_Proxy_Broker (void);

  virtual _TAO_ArrayDef_Proxy_Impl &select_proxy (
    IR_ArrayDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ArrayDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ArrayDef_Remote_Proxy_Broker *the_TAO_ArrayDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_ExceptionDef_Proxy_Impl;
class _TAO_ExceptionDef_Remote_Proxy_Impl;
class _TAO_ExceptionDef_Proxy_Broker;
class _TAO_ExceptionDef_Remote_Proxy_Broker;

class TAO_Export IR_ExceptionDef
  : public virtual IR_Contained,
    public virtual IR_Container
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ExceptionDef_ptr _ptr_type;
  typedef IR_ExceptionDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ExceptionDef_ptr _duplicate (IR_ExceptionDef_ptr obj);
  static IR_ExceptionDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ExceptionDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ExceptionDef_ptr _nil (void)
    {
      return (IR_ExceptionDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_StructMemberSeq * members (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ExceptionDef_Proxy_Broker *the_TAO_ExceptionDef_Proxy_Broker_;

protected:
  IR_ExceptionDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ExceptionDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ExceptionDef_Remote_Proxy_Impl;
  friend class _TAO_ExceptionDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ExceptionDef_Direct_Proxy_Impl;

  virtual ~IR_ExceptionDef (void);
private:
  IR_ExceptionDef (const IR_ExceptionDef &);
  void operator= (const IR_ExceptionDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ExceptionDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl,
  public virtual _TAO_Container_Proxy_Impl
{
public:
  virtual ~_TAO_ExceptionDef_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_StructMemberSeq * members   (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void members   (
      CORBA_Object *_collocated_tao_target_,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ExceptionDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ExceptionDef_Remote_Proxy_Impl :
  public virtual _TAO_ExceptionDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl

{
public:
  _TAO_ExceptionDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ExceptionDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_StructMemberSeq * members (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void members (
      CORBA_Object *_collocated_tao_target_,
      const IR_StructMemberSeq & members,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ExceptionDef_Proxy_Broker
{
public:
  virtual ~_TAO_ExceptionDef_Proxy_Broker (void);

  virtual _TAO_ExceptionDef_Proxy_Impl &select_proxy (
    IR_ExceptionDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ExceptionDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ExceptionDef_Remote_Proxy_Broker : public virtual _TAO_ExceptionDef_Proxy_Broker
{
public:
  _TAO_ExceptionDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ExceptionDef_Remote_Proxy_Broker (void);

  virtual _TAO_ExceptionDef_Proxy_Impl &select_proxy (
    IR_ExceptionDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ExceptionDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ExceptionDef_Remote_Proxy_Broker *the_TAO_ExceptionDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_ExceptionDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ExceptionDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
};

class TAO_Export IR_ExceptionDescription_var
{
public:
  IR_ExceptionDescription_var (void); // default constructor
  IR_ExceptionDescription_var (IR_ExceptionDescription *);
  IR_ExceptionDescription_var (const IR_ExceptionDescription_var &); // copy constructor
  ~IR_ExceptionDescription_var (void); // destructor

  IR_ExceptionDescription_var &operator= (IR_ExceptionDescription *);
  IR_ExceptionDescription_var &operator= (const IR_ExceptionDescription_var &);
  IR_ExceptionDescription *operator-> (void);
  const IR_ExceptionDescription *operator-> (void) const;

  operator const IR_ExceptionDescription &() const;
  operator IR_ExceptionDescription &();
  operator IR_ExceptionDescription &() const;
  operator IR_ExceptionDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_ExceptionDescription &in (void) const;
  IR_ExceptionDescription &inout (void);
  IR_ExceptionDescription *&out (void);
  IR_ExceptionDescription *_retn (void);
  IR_ExceptionDescription *ptr (void) const;

private:
  IR_ExceptionDescription *ptr_;
};

class TAO_Export IR_ExceptionDescription_out
{
public:
  IR_ExceptionDescription_out (IR_ExceptionDescription *&);
  IR_ExceptionDescription_out (IR_ExceptionDescription_var &);
  IR_ExceptionDescription_out (const IR_ExceptionDescription_out &);
  IR_ExceptionDescription_out &operator= (const IR_ExceptionDescription_out &);
  IR_ExceptionDescription_out &operator= (IR_ExceptionDescription *);
  operator IR_ExceptionDescription *&();
  IR_ExceptionDescription *&ptr (void);
  IR_ExceptionDescription *operator-> (void);

private:
  IR_ExceptionDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ExceptionDescription_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ExceptionDef* *value,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq(const _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq &rhs);
    virtual ~_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (void);
    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq &operator= (const _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq &rhs);
    TAO_Object_Manager<IR_ExceptionDef,IR_ExceptionDef_var> operator[] (CORBA::ULong index) const;
    static IR_ExceptionDef **allocbuf (CORBA::ULong nelems);
    static void freebuf (IR_ExceptionDef **buffer);
    // The Base_Sequence functions, please see tao/Sequence.h
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    IR_ExceptionDef* *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ExceptionDef* *get_buffer (void) const;
    virtual void _shrink_buffer (CORBA::ULong nl, CORBA::ULong ol);
    virtual void _downcast (
        void* target,
        CORBA_Object *src,
        CORBA_Environment &ACE_TRY_ENV =
          TAO_default_environment ()
      );
    virtual CORBA_Object* _upcast (void *src) const;

  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ExceptionDefSeq
// *************************************************************

class TAO_Export IR_ExceptionDefSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ExceptionDef,IR_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ExceptionDefSeq (void); // default ctor
  IR_ExceptionDefSeq (CORBA::ULong max); // uses max size
  IR_ExceptionDefSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ExceptionDef_ptr *buffer,
    CORBA::Boolean release = 0
  );
  IR_ExceptionDefSeq (const IR_ExceptionDefSeq &); // copy ctor
  ~IR_ExceptionDefSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ExceptionDefSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ExceptionDefSeq_var
// *************************************************************

class TAO_Export IR_ExceptionDefSeq_var
{
public:
  IR_ExceptionDefSeq_var (void); // default constructor
  IR_ExceptionDefSeq_var (IR_ExceptionDefSeq *);
  IR_ExceptionDefSeq_var (const IR_ExceptionDefSeq_var &); // copy constructor
  ~IR_ExceptionDefSeq_var (void); // destructor

  IR_ExceptionDefSeq_var &operator= (IR_ExceptionDefSeq *);
  IR_ExceptionDefSeq_var &operator= (const IR_ExceptionDefSeq_var &);
  IR_ExceptionDefSeq *operator-> (void);
  const IR_ExceptionDefSeq *operator-> (void) const;

  operator const IR_ExceptionDefSeq &() const;
  operator IR_ExceptionDefSeq &();
  operator IR_ExceptionDefSeq &() const;
  operator IR_ExceptionDefSeq *&(); // variable-size base types only

  TAO_Object_Manager<IR_ExceptionDef, IR_ExceptionDef_var> operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_ExceptionDefSeq &in (void) const;
  IR_ExceptionDefSeq &inout (void);
  IR_ExceptionDefSeq *&out (void);
  IR_ExceptionDefSeq *_retn (void);
  IR_ExceptionDefSeq *ptr (void) const;

private:
  IR_ExceptionDefSeq *ptr_;
};

class TAO_Export IR_ExceptionDefSeq_out
{
public:
  IR_ExceptionDefSeq_out (IR_ExceptionDefSeq *&);
  IR_ExceptionDefSeq_out (IR_ExceptionDefSeq_var &);
  IR_ExceptionDefSeq_out (const IR_ExceptionDefSeq_out &);
  IR_ExceptionDefSeq_out &operator= (const IR_ExceptionDefSeq_out &);
  IR_ExceptionDefSeq_out &operator= (IR_ExceptionDefSeq *);
  operator IR_ExceptionDefSeq *&();
  IR_ExceptionDefSeq *&ptr (void);
  IR_ExceptionDefSeq *operator-> (void);
  TAO_Object_Manager<IR_ExceptionDef, IR_ExceptionDef_var> operator[] (CORBA::ULong index);

private:
  IR_ExceptionDefSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ExceptionDefSeq_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ExceptionDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (const _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq &rhs);
    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (void); // Dtor.
    // = Accessors.
    IR_ExceptionDescription &operator[] (CORBA::ULong i);
    const IR_ExceptionDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_ExceptionDescription *allocbuf (CORBA::ULong size);
    static void freebuf (IR_ExceptionDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_ExceptionDescription *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ExceptionDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_ExceptionDescription *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ExcDescriptionSeq
// *************************************************************

class TAO_Export IR_ExcDescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ExcDescriptionSeq (void); // default ctor
  IR_ExcDescriptionSeq (CORBA::ULong max); // uses max size
  IR_ExcDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ExceptionDescription *buffer,
    CORBA::Boolean release = 0
  );
  IR_ExcDescriptionSeq (const IR_ExcDescriptionSeq &); // copy ctor
  ~IR_ExcDescriptionSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ExcDescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ExcDescriptionSeq_var
// *************************************************************

class TAO_Export IR_ExcDescriptionSeq_var
{
public:
  IR_ExcDescriptionSeq_var (void); // default constructor
  IR_ExcDescriptionSeq_var (IR_ExcDescriptionSeq *);
  IR_ExcDescriptionSeq_var (const IR_ExcDescriptionSeq_var &); // copy constructor
  ~IR_ExcDescriptionSeq_var (void); // destructor

  IR_ExcDescriptionSeq_var &operator= (IR_ExcDescriptionSeq *);
  IR_ExcDescriptionSeq_var &operator= (const IR_ExcDescriptionSeq_var &);
  IR_ExcDescriptionSeq *operator-> (void);
  const IR_ExcDescriptionSeq *operator-> (void) const;

  operator const IR_ExcDescriptionSeq &() const;
  operator IR_ExcDescriptionSeq &();
  operator IR_ExcDescriptionSeq &() const;
  operator IR_ExcDescriptionSeq *&(); // variable-size base types only

  IR_ExceptionDescription & operator[] (CORBA::ULong index);
  const IR_ExceptionDescription & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_ExcDescriptionSeq &in (void) const;
  IR_ExcDescriptionSeq &inout (void);
  IR_ExcDescriptionSeq *&out (void);
  IR_ExcDescriptionSeq *_retn (void);
  IR_ExcDescriptionSeq *ptr (void) const;

private:
  IR_ExcDescriptionSeq *ptr_;
};

class TAO_Export IR_ExcDescriptionSeq_out
{
public:
  IR_ExcDescriptionSeq_out (IR_ExcDescriptionSeq *&);
  IR_ExcDescriptionSeq_out (IR_ExcDescriptionSeq_var &);
  IR_ExcDescriptionSeq_out (const IR_ExcDescriptionSeq_out &);
  IR_ExcDescriptionSeq_out &operator= (const IR_ExcDescriptionSeq_out &);
  IR_ExcDescriptionSeq_out &operator= (IR_ExcDescriptionSeq *);
  operator IR_ExcDescriptionSeq *&();
  IR_ExcDescriptionSeq *&ptr (void);
  IR_ExcDescriptionSeq *operator-> (void);
  IR_ExceptionDescription & operator[] (CORBA::ULong index);

private:
  IR_ExcDescriptionSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ExcDescriptionSeq_var &);
};

class TAO_Export IR_AttributeDef_var : public TAO_Base_var
{
public:
  IR_AttributeDef_var (void); // default constructor
  IR_AttributeDef_var (IR_AttributeDef_ptr p) : ptr_ (p) {}
  IR_AttributeDef_var (const IR_AttributeDef_var &); // copy constructor
  ~IR_AttributeDef_var (void); // destructor

  IR_AttributeDef_var &operator= (IR_AttributeDef_ptr);
  IR_AttributeDef_var &operator= (const IR_AttributeDef_var &);
  IR_AttributeDef_ptr operator-> (void) const;

  operator const IR_AttributeDef_ptr &() const;
  operator IR_AttributeDef_ptr &();
  // in, inout, out, _retn
  IR_AttributeDef_ptr in (void) const;
  IR_AttributeDef_ptr &inout (void);
  IR_AttributeDef_ptr &out (void);
  IR_AttributeDef_ptr _retn (void);
  IR_AttributeDef_ptr ptr (void) const;

private:
  IR_AttributeDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_AttributeDef_var (const TAO_Base_var &rhs);
  IR_AttributeDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_AttributeDef_out
{
public:
  IR_AttributeDef_out (IR_AttributeDef_ptr &);
  IR_AttributeDef_out (IR_AttributeDef_var &);
  IR_AttributeDef_out (const IR_AttributeDef_out &);
  IR_AttributeDef_out &operator= (const IR_AttributeDef_out &);
  IR_AttributeDef_out &operator= (const IR_AttributeDef_var &);
  IR_AttributeDef_out &operator= (IR_AttributeDef_ptr);
  operator IR_AttributeDef_ptr &();
  IR_AttributeDef_ptr &ptr (void);
  IR_AttributeDef_ptr operator-> (void);

private:
  IR_AttributeDef_ptr &ptr_;
};

// Forward Classes Declaration
class _TAO_AttributeDef_Proxy_Impl;
class _TAO_AttributeDef_Remote_Proxy_Impl;
class _TAO_AttributeDef_Proxy_Broker;
class _TAO_AttributeDef_Remote_Proxy_Broker;

class TAO_Export IR_AttributeDef: public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_AttributeDef_ptr _ptr_type;
  typedef IR_AttributeDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_AttributeDef_ptr _duplicate (IR_AttributeDef_ptr obj);
  static IR_AttributeDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_AttributeDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_AttributeDef_ptr _nil (void)
    {
      return (IR_AttributeDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr type_def (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_AttributeMode mode (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void mode (
      IR_AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_AttributeDef_Proxy_Broker *the_TAO_AttributeDef_Proxy_Broker_;

protected:
  IR_AttributeDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_AttributeDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_AttributeDef_Remote_Proxy_Impl;
  friend class _TAO_AttributeDef_ThruPOA_Proxy_Impl;
  friend class _TAO_AttributeDef_Direct_Proxy_Impl;

  virtual ~IR_AttributeDef (void);
private:
  IR_AttributeDef (const IR_AttributeDef &);
  void operator= (const IR_AttributeDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_AttributeDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_AttributeDef_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_AttributeMode mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void mode (
      CORBA_Object *_collocated_tao_target_,
      IR_AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_AttributeDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_AttributeDef_Remote_Proxy_Impl :
  public virtual _TAO_AttributeDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_AttributeDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_AttributeDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_AttributeMode mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void mode (
      CORBA_Object *_collocated_tao_target_,
      IR_AttributeMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_AttributeDef_Proxy_Broker
{
public:
  virtual ~_TAO_AttributeDef_Proxy_Broker (void);

  virtual _TAO_AttributeDef_Proxy_Impl &select_proxy (
    IR_AttributeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_AttributeDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_AttributeDef_Remote_Proxy_Broker : public virtual _TAO_AttributeDef_Proxy_Broker
{
public:
  _TAO_AttributeDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_AttributeDef_Remote_Proxy_Broker (void);

  virtual _TAO_AttributeDef_Proxy_Impl &select_proxy (
    IR_AttributeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_AttributeDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_AttributeDef_Remote_Proxy_Broker *the_TAO_AttributeDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_AttributeDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_AttributeDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
  IR_AttributeMode mode;
  IR_ExcDescriptionSeq get_exceptions;
  IR_ExcDescriptionSeq put_exceptions;
};

class TAO_Export IR_AttributeDescription_var
{
public:
  IR_AttributeDescription_var (void); // default constructor
  IR_AttributeDescription_var (IR_AttributeDescription *);
  IR_AttributeDescription_var (const IR_AttributeDescription_var &); // copy constructor
  ~IR_AttributeDescription_var (void); // destructor

  IR_AttributeDescription_var &operator= (IR_AttributeDescription *);
  IR_AttributeDescription_var &operator= (const IR_AttributeDescription_var &);
  IR_AttributeDescription *operator-> (void);
  const IR_AttributeDescription *operator-> (void) const;

  operator const IR_AttributeDescription &() const;
  operator IR_AttributeDescription &();
  operator IR_AttributeDescription &() const;
  operator IR_AttributeDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_AttributeDescription &in (void) const;
  IR_AttributeDescription &inout (void);
  IR_AttributeDescription *&out (void);
  IR_AttributeDescription *_retn (void);
  IR_AttributeDescription *ptr (void) const;

private:
  IR_AttributeDescription *ptr_;
};

class TAO_Export IR_AttributeDescription_out
{
public:
  IR_AttributeDescription_out (IR_AttributeDescription *&);
  IR_AttributeDescription_out (IR_AttributeDescription_var &);
  IR_AttributeDescription_out (const IR_AttributeDescription_out &);
  IR_AttributeDescription_out &operator= (const IR_AttributeDescription_out &);
  IR_AttributeDescription_out &operator= (IR_AttributeDescription *);
  operator IR_AttributeDescription *&();
  IR_AttributeDescription *&ptr (void);
  IR_AttributeDescription *operator-> (void);

private:
  IR_AttributeDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_AttributeDescription_var &);
};

struct TAO_Export IR_ParameterDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ParameterDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  CORBA::TypeCode_var type;
  IR_IDLType_var type_def;
  IR_ParameterMode mode;
};

class TAO_Export IR_ParameterDescription_var
{
public:
  IR_ParameterDescription_var (void); // default constructor
  IR_ParameterDescription_var (IR_ParameterDescription *);
  IR_ParameterDescription_var (const IR_ParameterDescription_var &); // copy constructor
  ~IR_ParameterDescription_var (void); // destructor

  IR_ParameterDescription_var &operator= (IR_ParameterDescription *);
  IR_ParameterDescription_var &operator= (const IR_ParameterDescription_var &);
  IR_ParameterDescription *operator-> (void);
  const IR_ParameterDescription *operator-> (void) const;

  operator const IR_ParameterDescription &() const;
  operator IR_ParameterDescription &();
  operator IR_ParameterDescription &() const;
  operator IR_ParameterDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_ParameterDescription &in (void) const;
  IR_ParameterDescription &inout (void);
  IR_ParameterDescription *&out (void);
  IR_ParameterDescription *_retn (void);
  IR_ParameterDescription *ptr (void) const;

private:
  IR_ParameterDescription *ptr_;
};

class TAO_Export IR_ParameterDescription_out
{
public:
  IR_ParameterDescription_out (IR_ParameterDescription *&);
  IR_ParameterDescription_out (IR_ParameterDescription_var &);
  IR_ParameterDescription_out (const IR_ParameterDescription_out &);
  IR_ParameterDescription_out &operator= (const IR_ParameterDescription_out &);
  IR_ParameterDescription_out &operator= (IR_ParameterDescription *);
  operator IR_ParameterDescription *&();
  IR_ParameterDescription *&ptr (void);
  IR_ParameterDescription *operator-> (void);

private:
  IR_ParameterDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ParameterDescription_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_ParDescriptionSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ParameterDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq (const _TAO_Unbounded_Sequence_IR_ParDescriptionSeq &rhs);
    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_IR_ParDescriptionSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (void); // Dtor.
    // = Accessors.
    IR_ParameterDescription &operator[] (CORBA::ULong i);
    const IR_ParameterDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_ParameterDescription *allocbuf (CORBA::ULong size);
    static void freebuf (IR_ParameterDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_ParameterDescription *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ParameterDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_ParameterDescription *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ParDescriptionSeq
// *************************************************************

class TAO_Export IR_ParDescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ParDescriptionSeq (void); // default ctor
  IR_ParDescriptionSeq (CORBA::ULong max); // uses max size
  IR_ParDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ParameterDescription *buffer,
    CORBA::Boolean release = 0
  );
  IR_ParDescriptionSeq (const IR_ParDescriptionSeq &); // copy ctor
  ~IR_ParDescriptionSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ParDescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ParDescriptionSeq_var
// *************************************************************

class TAO_Export IR_ParDescriptionSeq_var
{
public:
  IR_ParDescriptionSeq_var (void); // default constructor
  IR_ParDescriptionSeq_var (IR_ParDescriptionSeq *);
  IR_ParDescriptionSeq_var (const IR_ParDescriptionSeq_var &); // copy constructor
  ~IR_ParDescriptionSeq_var (void); // destructor

  IR_ParDescriptionSeq_var &operator= (IR_ParDescriptionSeq *);
  IR_ParDescriptionSeq_var &operator= (const IR_ParDescriptionSeq_var &);
  IR_ParDescriptionSeq *operator-> (void);
  const IR_ParDescriptionSeq *operator-> (void) const;

  operator const IR_ParDescriptionSeq &() const;
  operator IR_ParDescriptionSeq &();
  operator IR_ParDescriptionSeq &() const;
  operator IR_ParDescriptionSeq *&(); // variable-size base types only

  IR_ParameterDescription & operator[] (CORBA::ULong index);
  const IR_ParameterDescription & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_ParDescriptionSeq &in (void) const;
  IR_ParDescriptionSeq &inout (void);
  IR_ParDescriptionSeq *&out (void);
  IR_ParDescriptionSeq *_retn (void);
  IR_ParDescriptionSeq *ptr (void) const;

private:
  IR_ParDescriptionSeq *ptr_;
};

class TAO_Export IR_ParDescriptionSeq_out
{
public:
  IR_ParDescriptionSeq_out (IR_ParDescriptionSeq *&);
  IR_ParDescriptionSeq_out (IR_ParDescriptionSeq_var &);
  IR_ParDescriptionSeq_out (const IR_ParDescriptionSeq_out &);
  IR_ParDescriptionSeq_out &operator= (const IR_ParDescriptionSeq_out &);
  IR_ParDescriptionSeq_out &operator= (IR_ParDescriptionSeq *);
  operator IR_ParDescriptionSeq *&();
  IR_ParDescriptionSeq *&ptr (void);
  IR_ParDescriptionSeq *operator-> (void);
  IR_ParameterDescription & operator[] (CORBA::ULong index);

private:
  IR_ParDescriptionSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ParDescriptionSeq_var &);
};

// *************************************************************
// IR_ContextIdSeq
// *************************************************************

class TAO_Export IR_ContextIdSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ContextIdSeq (void); // default ctor
  IR_ContextIdSeq (CORBA::ULong max); // uses max size
  IR_ContextIdSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    char * *buffer,
    CORBA::Boolean release = 0
  );
  IR_ContextIdSeq (const IR_ContextIdSeq &); // copy ctor
  ~IR_ContextIdSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ContextIdSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ContextIdSeq_var
// *************************************************************

class TAO_Export IR_ContextIdSeq_var
{
public:
  IR_ContextIdSeq_var (void); // default constructor
  IR_ContextIdSeq_var (IR_ContextIdSeq *);
  IR_ContextIdSeq_var (const IR_ContextIdSeq_var &); // copy constructor
  ~IR_ContextIdSeq_var (void); // destructor

  IR_ContextIdSeq_var &operator= (IR_ContextIdSeq *);
  IR_ContextIdSeq_var &operator= (const IR_ContextIdSeq_var &);
  IR_ContextIdSeq *operator-> (void);
  const IR_ContextIdSeq *operator-> (void) const;

  operator const IR_ContextIdSeq &() const;
  operator IR_ContextIdSeq &();
  operator IR_ContextIdSeq &() const;
  operator IR_ContextIdSeq *&(); // variable-size base types only

  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_ContextIdSeq &in (void) const;
  IR_ContextIdSeq &inout (void);
  IR_ContextIdSeq *&out (void);
  IR_ContextIdSeq *_retn (void);
  IR_ContextIdSeq *ptr (void) const;

private:
  IR_ContextIdSeq *ptr_;
};

class TAO_Export IR_ContextIdSeq_out
{
public:
  IR_ContextIdSeq_out (IR_ContextIdSeq *&);
  IR_ContextIdSeq_out (IR_ContextIdSeq_var &);
  IR_ContextIdSeq_out (const IR_ContextIdSeq_out &);
  IR_ContextIdSeq_out &operator= (const IR_ContextIdSeq_out &);
  IR_ContextIdSeq_out &operator= (IR_ContextIdSeq *);
  operator IR_ContextIdSeq *&();
  IR_ContextIdSeq *&ptr (void);
  IR_ContextIdSeq *operator-> (void);
  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

private:
  IR_ContextIdSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ContextIdSeq_var &);
};

class TAO_Export IR_OperationDef_var : public TAO_Base_var
{
public:
  IR_OperationDef_var (void); // default constructor
  IR_OperationDef_var (IR_OperationDef_ptr p) : ptr_ (p) {}
  IR_OperationDef_var (const IR_OperationDef_var &); // copy constructor
  ~IR_OperationDef_var (void); // destructor

  IR_OperationDef_var &operator= (IR_OperationDef_ptr);
  IR_OperationDef_var &operator= (const IR_OperationDef_var &);
  IR_OperationDef_ptr operator-> (void) const;

  operator const IR_OperationDef_ptr &() const;
  operator IR_OperationDef_ptr &();
  // in, inout, out, _retn
  IR_OperationDef_ptr in (void) const;
  IR_OperationDef_ptr &inout (void);
  IR_OperationDef_ptr &out (void);
  IR_OperationDef_ptr _retn (void);
  IR_OperationDef_ptr ptr (void) const;

private:
  IR_OperationDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_OperationDef_var (const TAO_Base_var &rhs);
  IR_OperationDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_OperationDef_out
{
public:
  IR_OperationDef_out (IR_OperationDef_ptr &);
  IR_OperationDef_out (IR_OperationDef_var &);
  IR_OperationDef_out (const IR_OperationDef_out &);
  IR_OperationDef_out &operator= (const IR_OperationDef_out &);
  IR_OperationDef_out &operator= (const IR_OperationDef_var &);
  IR_OperationDef_out &operator= (IR_OperationDef_ptr);
  operator IR_OperationDef_ptr &();
  IR_OperationDef_ptr &ptr (void);
  IR_OperationDef_ptr operator-> (void);

private:
  IR_OperationDef_ptr &ptr_;
};

// Forward Classes Declaration
class _TAO_OperationDef_Proxy_Impl;
class _TAO_OperationDef_Remote_Proxy_Impl;
class _TAO_OperationDef_Proxy_Broker;
class _TAO_OperationDef_Remote_Proxy_Broker;

class TAO_Export IR_OperationDef: public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_OperationDef_ptr _ptr_type;
  typedef IR_OperationDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_OperationDef_ptr _duplicate (IR_OperationDef_ptr obj);
  static IR_OperationDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_OperationDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_OperationDef_ptr _nil (void)
    {
      return (IR_OperationDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr result   (
                  CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr result_def (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void result_def (
      IR_IDLType_ptr result_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ParDescriptionSeq * params (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void params (
      const IR_ParDescriptionSeq & params,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_OperationMode mode (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void mode (
      IR_OperationMode mode,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ContextIdSeq * contexts (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void contexts (
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ExceptionDefSeq * exceptions (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void exceptions (
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_OperationDef_Proxy_Broker *the_TAO_OperationDef_Proxy_Broker_;

protected:
  IR_OperationDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_OperationDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_OperationDef_Remote_Proxy_Impl;
  friend class _TAO_OperationDef_ThruPOA_Proxy_Impl;
  friend class _TAO_OperationDef_Direct_Proxy_Impl;

  virtual ~IR_OperationDef (void);
private:
  IR_OperationDef (const IR_OperationDef &);
  void operator= (const IR_OperationDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_OperationDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_OperationDef_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr result (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_IDLType_ptr result_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void result_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr result_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ParDescriptionSeq * params (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void params (
      CORBA_Object *_collocated_tao_target_,
      const IR_ParDescriptionSeq & params,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_OperationMode mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void mode (
      CORBA_Object *_collocated_tao_target_,
      IR_OperationMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ContextIdSeq * contexts (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void contexts (
      CORBA_Object *_collocated_tao_target_,
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ExceptionDefSeq * exceptions (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void exceptions (
      CORBA_Object *_collocated_tao_target_,
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_OperationDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_OperationDef_Remote_Proxy_Impl :
  public virtual _TAO_OperationDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_OperationDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_OperationDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr result (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr result_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void result_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr result_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ParDescriptionSeq * params (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void params (
      CORBA_Object *_collocated_tao_target_,
      const IR_ParDescriptionSeq & params,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_OperationMode mode (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void mode (
      CORBA_Object *_collocated_tao_target_,
      IR_OperationMode mode,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ContextIdSeq * contexts (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void contexts (
      CORBA_Object *_collocated_tao_target_,
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ExceptionDefSeq * exceptions (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void exceptions (
      CORBA_Object *_collocated_tao_target_,
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_OperationDef_Proxy_Broker
{
public:
  virtual ~_TAO_OperationDef_Proxy_Broker (void);

  virtual _TAO_OperationDef_Proxy_Impl &select_proxy (
    IR_OperationDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_OperationDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_OperationDef_Remote_Proxy_Broker : public virtual _TAO_OperationDef_Proxy_Broker
{
public:
  _TAO_OperationDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_OperationDef_Remote_Proxy_Broker (void);

  virtual _TAO_OperationDef_Proxy_Impl &select_proxy (
    IR_OperationDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_OperationDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_OperationDef_Remote_Proxy_Broker *the_TAO_OperationDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_OperationDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_OperationDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var result;
  IR_OperationMode mode;
  IR_ContextIdSeq contexts;
  IR_ParDescriptionSeq parameters;
  IR_ExcDescriptionSeq exceptions;
};

class TAO_Export IR_OperationDescription_var
{
public:
  IR_OperationDescription_var (void); // default constructor
  IR_OperationDescription_var (IR_OperationDescription *);
  IR_OperationDescription_var (const IR_OperationDescription_var &); // copy constructor
  ~IR_OperationDescription_var (void); // destructor

  IR_OperationDescription_var &operator= (IR_OperationDescription *);
  IR_OperationDescription_var &operator= (const IR_OperationDescription_var &);
  IR_OperationDescription *operator-> (void);
  const IR_OperationDescription *operator-> (void) const;

  operator const IR_OperationDescription &() const;
  operator IR_OperationDescription &();
  operator IR_OperationDescription &() const;
  operator IR_OperationDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_OperationDescription &in (void) const;
  IR_OperationDescription &inout (void);
  IR_OperationDescription *&out (void);
  IR_OperationDescription *_retn (void);
  IR_OperationDescription *ptr (void) const;

private:
  IR_OperationDescription *ptr_;
};

class TAO_Export IR_OperationDescription_out
{
public:
  IR_OperationDescription_out (IR_OperationDescription *&);
  IR_OperationDescription_out (IR_OperationDescription_var &);
  IR_OperationDescription_out (const IR_OperationDescription_out &);
  IR_OperationDescription_out &operator= (const IR_OperationDescription_out &);
  IR_OperationDescription_out &operator= (IR_OperationDescription *);
  operator IR_OperationDescription *&();
  IR_OperationDescription *&ptr (void);
  IR_OperationDescription *operator-> (void);

private:
  IR_OperationDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_OperationDescription_var &);
};

// *************************************************************
// IR_RepositoryIdSeq
// *************************************************************

class TAO_Export IR_RepositoryIdSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_RepositoryIdSeq (void); // default ctor
  IR_RepositoryIdSeq (CORBA::ULong max); // uses max size
  IR_RepositoryIdSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    char * *buffer,
    CORBA::Boolean release = 0
  );
  IR_RepositoryIdSeq (const IR_RepositoryIdSeq &); // copy ctor
  ~IR_RepositoryIdSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_RepositoryIdSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_RepositoryIdSeq_var
// *************************************************************

class TAO_Export IR_RepositoryIdSeq_var
{
public:
  IR_RepositoryIdSeq_var (void); // default constructor
  IR_RepositoryIdSeq_var (IR_RepositoryIdSeq *);
  IR_RepositoryIdSeq_var (const IR_RepositoryIdSeq_var &); // copy constructor
  ~IR_RepositoryIdSeq_var (void); // destructor

  IR_RepositoryIdSeq_var &operator= (IR_RepositoryIdSeq *);
  IR_RepositoryIdSeq_var &operator= (const IR_RepositoryIdSeq_var &);
  IR_RepositoryIdSeq *operator-> (void);
  const IR_RepositoryIdSeq *operator-> (void) const;

  operator const IR_RepositoryIdSeq &() const;
  operator IR_RepositoryIdSeq &();
  operator IR_RepositoryIdSeq &() const;
  operator IR_RepositoryIdSeq *&(); // variable-size base types only

  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

  // in, inout, out, _retn
  const IR_RepositoryIdSeq &in (void) const;
  IR_RepositoryIdSeq &inout (void);
  IR_RepositoryIdSeq *&out (void);
  IR_RepositoryIdSeq *_retn (void);
  IR_RepositoryIdSeq *ptr (void) const;

private:
  IR_RepositoryIdSeq *ptr_;
};

class TAO_Export IR_RepositoryIdSeq_out
{
public:
  IR_RepositoryIdSeq_out (IR_RepositoryIdSeq *&);
  IR_RepositoryIdSeq_out (IR_RepositoryIdSeq_var &);
  IR_RepositoryIdSeq_out (const IR_RepositoryIdSeq_out &);
  IR_RepositoryIdSeq_out &operator= (const IR_RepositoryIdSeq_out &);
  IR_RepositoryIdSeq_out &operator= (IR_RepositoryIdSeq *);
  operator IR_RepositoryIdSeq *&();
  IR_RepositoryIdSeq *&ptr (void);
  IR_RepositoryIdSeq *operator-> (void);
  TAO_SeqElem_String_Manager operator[] (CORBA::ULong index);

private:
  IR_RepositoryIdSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_RepositoryIdSeq_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_OpDescriptionSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_OperationDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq (const _TAO_Unbounded_Sequence_IR_OpDescriptionSeq &rhs);
    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_IR_OpDescriptionSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (void); // Dtor.
    // = Accessors.
    IR_OperationDescription &operator[] (CORBA::ULong i);
    const IR_OperationDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_OperationDescription *allocbuf (CORBA::ULong size);
    static void freebuf (IR_OperationDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_OperationDescription *get_buffer (CORBA::Boolean orphan = 0);
    const IR_OperationDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_OperationDescription *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_OpDescriptionSeq
// *************************************************************

class TAO_Export IR_OpDescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_OpDescriptionSeq (void); // default ctor
  IR_OpDescriptionSeq (CORBA::ULong max); // uses max size
  IR_OpDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_OperationDescription *buffer,
    CORBA::Boolean release = 0
  );
  IR_OpDescriptionSeq (const IR_OpDescriptionSeq &); // copy ctor
  ~IR_OpDescriptionSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_OpDescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_OpDescriptionSeq_var
// *************************************************************

class TAO_Export IR_OpDescriptionSeq_var
{
public:
  IR_OpDescriptionSeq_var (void); // default constructor
  IR_OpDescriptionSeq_var (IR_OpDescriptionSeq *);
  IR_OpDescriptionSeq_var (const IR_OpDescriptionSeq_var &); // copy constructor
  ~IR_OpDescriptionSeq_var (void); // destructor

  IR_OpDescriptionSeq_var &operator= (IR_OpDescriptionSeq *);
  IR_OpDescriptionSeq_var &operator= (const IR_OpDescriptionSeq_var &);
  IR_OpDescriptionSeq *operator-> (void);
  const IR_OpDescriptionSeq *operator-> (void) const;

  operator const IR_OpDescriptionSeq &() const;
  operator IR_OpDescriptionSeq &();
  operator IR_OpDescriptionSeq &() const;
  operator IR_OpDescriptionSeq *&(); // variable-size base types only

  IR_OperationDescription & operator[] (CORBA::ULong index);
  const IR_OperationDescription & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_OpDescriptionSeq &in (void) const;
  IR_OpDescriptionSeq &inout (void);
  IR_OpDescriptionSeq *&out (void);
  IR_OpDescriptionSeq *_retn (void);
  IR_OpDescriptionSeq *ptr (void) const;

private:
  IR_OpDescriptionSeq *ptr_;
};

class TAO_Export IR_OpDescriptionSeq_out
{
public:
  IR_OpDescriptionSeq_out (IR_OpDescriptionSeq *&);
  IR_OpDescriptionSeq_out (IR_OpDescriptionSeq_var &);
  IR_OpDescriptionSeq_out (const IR_OpDescriptionSeq_out &);
  IR_OpDescriptionSeq_out &operator= (const IR_OpDescriptionSeq_out &);
  IR_OpDescriptionSeq_out &operator= (IR_OpDescriptionSeq *);
  operator IR_OpDescriptionSeq *&();
  IR_OpDescriptionSeq *&ptr (void);
  IR_OpDescriptionSeq *operator-> (void);
  IR_OperationDescription & operator[] (CORBA::ULong index);

private:
  IR_OpDescriptionSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_OpDescriptionSeq_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_AttributeDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (const _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq &rhs);
    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq &operator= (const _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (void); // Dtor.
    // = Accessors.
    IR_AttributeDescription &operator[] (CORBA::ULong i);
    const IR_AttributeDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_AttributeDescription *allocbuf (CORBA::ULong size);
    static void freebuf (IR_AttributeDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_AttributeDescription *get_buffer (CORBA::Boolean orphan = 0);
    const IR_AttributeDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_AttributeDescription *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_AttrDescriptionSeq
// *************************************************************

class TAO_Export IR_AttrDescriptionSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_AttrDescriptionSeq (void); // default ctor
  IR_AttrDescriptionSeq (CORBA::ULong max); // uses max size
  IR_AttrDescriptionSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_AttributeDescription *buffer,
    CORBA::Boolean release = 0
  );
  IR_AttrDescriptionSeq (const IR_AttrDescriptionSeq &); // copy ctor
  ~IR_AttrDescriptionSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_AttrDescriptionSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};


// *************************************************************
// class IR_AttrDescriptionSeq_var
// *************************************************************

class TAO_Export IR_AttrDescriptionSeq_var
{
public:
  IR_AttrDescriptionSeq_var (void); // default constructor
  IR_AttrDescriptionSeq_var (IR_AttrDescriptionSeq *);
  IR_AttrDescriptionSeq_var (const IR_AttrDescriptionSeq_var &); // copy constructor
  ~IR_AttrDescriptionSeq_var (void); // destructor

  IR_AttrDescriptionSeq_var &operator= (IR_AttrDescriptionSeq *);
  IR_AttrDescriptionSeq_var &operator= (const IR_AttrDescriptionSeq_var &);
  IR_AttrDescriptionSeq *operator-> (void);
  const IR_AttrDescriptionSeq *operator-> (void) const;

  operator const IR_AttrDescriptionSeq &() const;
  operator IR_AttrDescriptionSeq &();
  operator IR_AttrDescriptionSeq &() const;
  operator IR_AttrDescriptionSeq *&(); // variable-size base types only

  IR_AttributeDescription & operator[] (CORBA::ULong index);
  const IR_AttributeDescription & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_AttrDescriptionSeq &in (void) const;
  IR_AttrDescriptionSeq &inout (void);
  IR_AttrDescriptionSeq *&out (void);
  IR_AttrDescriptionSeq *_retn (void);
  IR_AttrDescriptionSeq *ptr (void) const;

private:
  IR_AttrDescriptionSeq *ptr_;
};

class TAO_Export IR_AttrDescriptionSeq_out
{
public:
  IR_AttrDescriptionSeq_out (IR_AttrDescriptionSeq *&);
  IR_AttrDescriptionSeq_out (IR_AttrDescriptionSeq_var &);
  IR_AttrDescriptionSeq_out (const IR_AttrDescriptionSeq_out &);
  IR_AttrDescriptionSeq_out &operator= (const IR_AttrDescriptionSeq_out &);
  IR_AttrDescriptionSeq_out &operator= (IR_AttrDescriptionSeq *);
  operator IR_AttrDescriptionSeq *&();
  IR_AttrDescriptionSeq *&ptr (void);
  IR_AttrDescriptionSeq *operator-> (void);
  IR_AttributeDescription & operator[] (CORBA::ULong index);

private:
  IR_AttrDescriptionSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_AttrDescriptionSeq_var &);
};

// Forward Classes Declaration
class _TAO_InterfaceDef_Proxy_Impl;
class _TAO_InterfaceDef_Remote_Proxy_Impl;
class _TAO_InterfaceDef_Proxy_Broker;
class _TAO_InterfaceDef_Remote_Proxy_Broker;

class TAO_Export IR_InterfaceDef: public virtual IR_Container, public virtual IR_Contained, public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_InterfaceDef_ptr _ptr_type;
  typedef IR_InterfaceDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_InterfaceDef_ptr _duplicate (IR_InterfaceDef_ptr obj);
  static IR_InterfaceDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_InterfaceDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_InterfaceDef_ptr _nil (void)
    {
      return (IR_InterfaceDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_InterfaceDefSeq * base_interfaces (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void base_interfaces (
      const IR_InterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_abstract (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_abstract (
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_local (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_local (
      CORBA::Boolean is_local,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_a (
      const char * interface_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_AttributeDef_ptr create_attribute (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      IR_AttributeMode mode,
      const IR_ExceptionDefSeq & get_exceptions,
      const IR_ExceptionDefSeq & put_exceptions,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_OperationDef_ptr create_operation (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr result,
      IR_OperationMode mode,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_InterfaceDef_Proxy_Broker *the_TAO_InterfaceDef_Proxy_Broker_;

protected:
  IR_InterfaceDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_InterfaceDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_InterfaceDef_Remote_Proxy_Impl;
  friend class _TAO_InterfaceDef_ThruPOA_Proxy_Impl;
  friend class _TAO_InterfaceDef_Direct_Proxy_Impl;

  virtual ~IR_InterfaceDef (void);
private:
  IR_InterfaceDef (const IR_InterfaceDef &);
  void operator= (const IR_InterfaceDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_InterfaceDef_Proxy_Impl :
  public virtual _TAO_Container_Proxy_Impl,
  public virtual _TAO_Contained_Proxy_Impl,
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_InterfaceDef_Proxy_Impl (void) { }

  virtual IR_InterfaceDefSeq * base_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void base_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const IR_InterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_local (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void is_local (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_local,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * interface_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_AttributeDef_ptr create_attribute (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      IR_AttributeMode mode,
      const IR_ExceptionDefSeq & get_exceptions,
      const IR_ExceptionDefSeq & put_exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_OperationDef_ptr create_operation (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr result,
      IR_OperationMode mode,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_InterfaceDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_InterfaceDef_Remote_Proxy_Impl :
  public virtual _TAO_InterfaceDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_InterfaceDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_InterfaceDef_Remote_Proxy_Impl (void) { }

  virtual IR_InterfaceDefSeq * base_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void base_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const IR_InterfaceDefSeq & base_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_local (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_local (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_local,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * interface_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_AttributeDef_ptr create_attribute (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      IR_AttributeMode mode,
      const IR_ExceptionDefSeq & get_exceptions,
      const IR_ExceptionDefSeq & put_exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_OperationDef_ptr create_operation (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr result,
      IR_OperationMode mode,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_InterfaceDef_Proxy_Broker
{
public:
  virtual ~_TAO_InterfaceDef_Proxy_Broker (void);

  virtual _TAO_InterfaceDef_Proxy_Impl &select_proxy (
    IR_InterfaceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_InterfaceDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_InterfaceDef_Remote_Proxy_Broker : public virtual _TAO_InterfaceDef_Proxy_Broker
{
public:
  _TAO_InterfaceDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_InterfaceDef_Remote_Proxy_Broker (void);

  virtual _TAO_InterfaceDef_Proxy_Impl &select_proxy (
    IR_InterfaceDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_InterfaceDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_InterfaceDef_Remote_Proxy_Broker *the_TAO_InterfaceDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_InterfaceDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_InterfaceDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  IR_OpDescriptionSeq operations;
  IR_AttrDescriptionSeq attributes;
  IR_RepositoryIdSeq base_interfaces;
  CORBA::TypeCode_var type;
  CORBA::Boolean is_abstract;
  CORBA::Boolean is_local;
};

class TAO_Export IR_InterfaceDescription_var
{
public:
  IR_InterfaceDescription_var (void); // default constructor
  IR_InterfaceDescription_var (IR_InterfaceDescription *);
  IR_InterfaceDescription_var (const IR_InterfaceDescription_var &); // copy constructor
  ~IR_InterfaceDescription_var (void); // destructor

  IR_InterfaceDescription_var &operator= (IR_InterfaceDescription *);
  IR_InterfaceDescription_var &operator= (const IR_InterfaceDescription_var &);
  IR_InterfaceDescription *operator-> (void);
  const IR_InterfaceDescription *operator-> (void) const;

  operator const IR_InterfaceDescription &() const;
  operator IR_InterfaceDescription &();
  operator IR_InterfaceDescription &() const;
  operator IR_InterfaceDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_InterfaceDescription &in (void) const;
  IR_InterfaceDescription &inout (void);
  IR_InterfaceDescription *&out (void);
  IR_InterfaceDescription *_retn (void);
  IR_InterfaceDescription *ptr (void) const;

private:
  IR_InterfaceDescription *ptr_;
};

class TAO_Export IR_InterfaceDescription_out
{
public:
  IR_InterfaceDescription_out (IR_InterfaceDescription *&);
  IR_InterfaceDescription_out (IR_InterfaceDescription_var &);
  IR_InterfaceDescription_out (const IR_InterfaceDescription_out &);
  IR_InterfaceDescription_out &operator= (const IR_InterfaceDescription_out &);
  IR_InterfaceDescription_out &operator= (IR_InterfaceDescription *);
  operator IR_InterfaceDescription *&();
  IR_InterfaceDescription *&ptr (void);
  IR_InterfaceDescription *operator-> (void);

private:
  IR_InterfaceDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_InterfaceDescription_var &);
};

struct TAO_Export IR_ValueMember
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ValueMember_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  CORBA::TypeCode_var type;
  IR_IDLType_var type_def;
  CORBA::Visibility access;
};

class TAO_Export IR_ValueMember_var
{
public:
  IR_ValueMember_var (void); // default constructor
  IR_ValueMember_var (IR_ValueMember *);
  IR_ValueMember_var (const IR_ValueMember_var &); // copy constructor
  ~IR_ValueMember_var (void); // destructor

  IR_ValueMember_var &operator= (IR_ValueMember *);
  IR_ValueMember_var &operator= (const IR_ValueMember_var &);
  IR_ValueMember *operator-> (void);
  const IR_ValueMember *operator-> (void) const;

  operator const IR_ValueMember &() const;
  operator IR_ValueMember &();
  operator IR_ValueMember &() const;
  operator IR_ValueMember *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_ValueMember &in (void) const;
  IR_ValueMember &inout (void);
  IR_ValueMember *&out (void);
  IR_ValueMember *_retn (void);
  IR_ValueMember *ptr (void) const;

private:
  IR_ValueMember *ptr_;
};

class TAO_Export IR_ValueMember_out
{
public:
  IR_ValueMember_out (IR_ValueMember *&);
  IR_ValueMember_out (IR_ValueMember_var &);
  IR_ValueMember_out (const IR_ValueMember_out &);
  IR_ValueMember_out &operator= (const IR_ValueMember_out &);
  IR_ValueMember_out &operator= (IR_ValueMember *);
  operator IR_ValueMember *&();
  IR_ValueMember *&ptr (void);
  IR_ValueMember *operator-> (void);

private:
  IR_ValueMember *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ValueMember_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_ValueMemberSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_ValueMemberSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_ValueMemberSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_ValueMemberSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ValueMember *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_ValueMemberSeq (const _TAO_Unbounded_Sequence_IR_ValueMemberSeq &rhs);
    _TAO_Unbounded_Sequence_IR_ValueMemberSeq &operator= (const _TAO_Unbounded_Sequence_IR_ValueMemberSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_ValueMemberSeq (void); // Dtor.
    // = Accessors.
    IR_ValueMember &operator[] (CORBA::ULong i);
    const IR_ValueMember &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_ValueMember *allocbuf (CORBA::ULong size);
    static void freebuf (IR_ValueMember *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_ValueMember *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ValueMember *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_ValueMember *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ValueMemberSeq
// *************************************************************

class TAO_Export IR_ValueMemberSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ValueMemberSeq (void); // default ctor
  IR_ValueMemberSeq (CORBA::ULong max); // uses max size
  IR_ValueMemberSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ValueMember *buffer,
    CORBA::Boolean release = 0
  );
  IR_ValueMemberSeq (const IR_ValueMemberSeq &); // copy ctor
  ~IR_ValueMemberSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ValueMemberSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ValueMemberSeq_var
// *************************************************************

class TAO_Export IR_ValueMemberSeq_var
{
public:
  IR_ValueMemberSeq_var (void); // default constructor
  IR_ValueMemberSeq_var (IR_ValueMemberSeq *);
  IR_ValueMemberSeq_var (const IR_ValueMemberSeq_var &); // copy constructor
  ~IR_ValueMemberSeq_var (void); // destructor

  IR_ValueMemberSeq_var &operator= (IR_ValueMemberSeq *);
  IR_ValueMemberSeq_var &operator= (const IR_ValueMemberSeq_var &);
  IR_ValueMemberSeq *operator-> (void);
  const IR_ValueMemberSeq *operator-> (void) const;

  operator const IR_ValueMemberSeq &() const;
  operator IR_ValueMemberSeq &();
  operator IR_ValueMemberSeq &() const;
  operator IR_ValueMemberSeq *&(); // variable-size base types only

  IR_ValueMember & operator[] (CORBA::ULong index);
  const IR_ValueMember & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_ValueMemberSeq &in (void) const;
  IR_ValueMemberSeq &inout (void);
  IR_ValueMemberSeq *&out (void);
  IR_ValueMemberSeq *_retn (void);
  IR_ValueMemberSeq *ptr (void) const;

private:
  IR_ValueMemberSeq *ptr_;
};

class TAO_Export IR_ValueMemberSeq_out
{
public:
  IR_ValueMemberSeq_out (IR_ValueMemberSeq *&);
  IR_ValueMemberSeq_out (IR_ValueMemberSeq_var &);
  IR_ValueMemberSeq_out (const IR_ValueMemberSeq_out &);
  IR_ValueMemberSeq_out &operator= (const IR_ValueMemberSeq_out &);
  IR_ValueMemberSeq_out &operator= (IR_ValueMemberSeq *);
  operator IR_ValueMemberSeq *&();
  IR_ValueMemberSeq *&ptr (void);
  IR_ValueMemberSeq *operator-> (void);
  IR_ValueMember & operator[] (CORBA::ULong index);

private:
  IR_ValueMemberSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ValueMemberSeq_var &);
};

class TAO_Export IR_ValueMemberDef_var : public TAO_Base_var
{
public:
  IR_ValueMemberDef_var (void); // default constructor
  IR_ValueMemberDef_var (IR_ValueMemberDef_ptr p) : ptr_ (p) {}
  IR_ValueMemberDef_var (const IR_ValueMemberDef_var &); // copy constructor
  ~IR_ValueMemberDef_var (void); // destructor

  IR_ValueMemberDef_var &operator= (IR_ValueMemberDef_ptr);
  IR_ValueMemberDef_var &operator= (const IR_ValueMemberDef_var &);
  IR_ValueMemberDef_ptr operator-> (void) const;

  operator const IR_ValueMemberDef_ptr &() const;
  operator IR_ValueMemberDef_ptr &();
  // in, inout, out, _retn
  IR_ValueMemberDef_ptr in (void) const;
  IR_ValueMemberDef_ptr &inout (void);
  IR_ValueMemberDef_ptr &out (void);
  IR_ValueMemberDef_ptr _retn (void);
  IR_ValueMemberDef_ptr ptr (void) const;

private:
  IR_ValueMemberDef_ptr ptr_;
  // Unimplemented - prevents widening assignment.
  IR_ValueMemberDef_var (const TAO_Base_var &rhs);
  IR_ValueMemberDef_var &operator= (const TAO_Base_var &rhs);
};

class TAO_Export IR_ValueMemberDef_out
{
public:
  IR_ValueMemberDef_out (IR_ValueMemberDef_ptr &);
  IR_ValueMemberDef_out (IR_ValueMemberDef_var &);
  IR_ValueMemberDef_out (const IR_ValueMemberDef_out &);
  IR_ValueMemberDef_out &operator= (const IR_ValueMemberDef_out &);
  IR_ValueMemberDef_out &operator= (const IR_ValueMemberDef_var &);
  IR_ValueMemberDef_out &operator= (IR_ValueMemberDef_ptr);
  operator IR_ValueMemberDef_ptr &();
  IR_ValueMemberDef_ptr &ptr (void);
  IR_ValueMemberDef_ptr operator-> (void);

private:
  IR_ValueMemberDef_ptr &ptr_;
};

// Forward Classes Declaration
class _TAO_ValueMemberDef_Proxy_Impl;
class _TAO_ValueMemberDef_Remote_Proxy_Impl;
class _TAO_ValueMemberDef_Proxy_Broker;
class _TAO_ValueMemberDef_Remote_Proxy_Broker;

class TAO_Export IR_ValueMemberDef: public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ValueMemberDef_ptr _ptr_type;
  typedef IR_ValueMemberDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ValueMemberDef_ptr _duplicate (IR_ValueMemberDef_ptr obj);
  static IR_ValueMemberDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ValueMemberDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ValueMemberDef_ptr _nil (void)
    {
      return (IR_ValueMemberDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::TypeCode_ptr type   (
                  CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr type_def (
     CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Visibility access (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void access (
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ValueMemberDef_Proxy_Broker *the_TAO_ValueMemberDef_Proxy_Broker_;

protected:
  IR_ValueMemberDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ValueMemberDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ValueMemberDef_Remote_Proxy_Impl;
  friend class _TAO_ValueMemberDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ValueMemberDef_Direct_Proxy_Impl;

  virtual ~IR_ValueMemberDef (void);
private:
  IR_ValueMemberDef (const IR_ValueMemberDef &);
  void operator= (const IR_ValueMemberDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ValueMemberDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_ValueMemberDef_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Visibility access (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void access (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ValueMemberDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ValueMemberDef_Remote_Proxy_Impl :
  public virtual _TAO_ValueMemberDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_ValueMemberDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ValueMemberDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::TypeCode_ptr type (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_IDLType_ptr type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Visibility access (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void access (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ValueMemberDef_Proxy_Broker
{
public:
  virtual ~_TAO_ValueMemberDef_Proxy_Broker (void);

  virtual _TAO_ValueMemberDef_Proxy_Impl &select_proxy (
    IR_ValueMemberDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ValueMemberDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ValueMemberDef_Remote_Proxy_Broker : public virtual _TAO_ValueMemberDef_Proxy_Broker
{
public:
  _TAO_ValueMemberDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ValueMemberDef_Remote_Proxy_Broker (void);

  virtual _TAO_ValueMemberDef_Proxy_Impl &select_proxy (
    IR_ValueMemberDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ValueMemberDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ValueMemberDef_Remote_Proxy_Broker *the_TAO_ValueMemberDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_ValueDef_Proxy_Impl;
class _TAO_ValueDef_Remote_Proxy_Impl;
class _TAO_ValueDef_Proxy_Broker;
class _TAO_ValueDef_Remote_Proxy_Broker;

class TAO_Export IR_ValueDef: public virtual IR_Container, public virtual IR_Contained, public virtual IR_IDLType
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ValueDef_ptr _ptr_type;
  typedef IR_ValueDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ValueDef_ptr _duplicate (IR_ValueDef_ptr obj);
  static IR_ValueDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ValueDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ValueDef_ptr _nil (void)
    {
      return (IR_ValueDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_InterfaceDefSeq * supported_interfaces (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void supported_interfaces (
      const IR_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_InitializerSeq * initializers (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void initializers (
      const IR_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDef_ptr base_value (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void base_value (
      IR_ValueDef_ptr base_value,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDefSeq * abstract_base_values (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void abstract_base_values (
      const IR_ValueDefSeq & abstract_base_values,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_abstract (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_abstract (
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_custom (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_custom (
      CORBA::Boolean is_custom,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_truncatable (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_truncatable (
      CORBA::Boolean is_truncatable,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_a (
      const char * id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueMemberDef_ptr create_value_member (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_AttributeDef_ptr create_attribute (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      IR_AttributeMode mode,
      const IR_ExceptionDefSeq & get_exceptions,
      const IR_ExceptionDefSeq & put_exceptions,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_OperationDef_ptr create_operation (
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr result,
      IR_OperationMode mode,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ValueDef_Proxy_Broker *the_TAO_ValueDef_Proxy_Broker_;

protected:
  IR_ValueDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ValueDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ValueDef_Remote_Proxy_Impl;
  friend class _TAO_ValueDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ValueDef_Direct_Proxy_Impl;

  virtual ~IR_ValueDef (void);
private:
  IR_ValueDef (const IR_ValueDef &);
  void operator= (const IR_ValueDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ValueDef_Proxy_Impl :
  public virtual _TAO_Container_Proxy_Impl,
  public virtual _TAO_Contained_Proxy_Impl,
  public virtual _TAO_IDLType_Proxy_Impl
{
public:
  virtual ~_TAO_ValueDef_Proxy_Impl (void) { }

  virtual IR_InterfaceDefSeq * supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const IR_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_InitializerSeq * initializers (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void initializers (
      CORBA_Object *_collocated_tao_target_,
      const IR_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ValueDef_ptr base_value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void base_value (
      CORBA_Object *_collocated_tao_target_,
      IR_ValueDef_ptr base_value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ValueDefSeq * abstract_base_values (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void abstract_base_values (
      CORBA_Object *_collocated_tao_target_,
      const IR_ValueDefSeq & abstract_base_values,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_custom (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void is_custom (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_custom,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_truncatable (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void is_truncatable (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_truncatable,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ValueMemberDef_ptr create_value_member (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_AttributeDef_ptr create_attribute (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      IR_AttributeMode mode,
      const IR_ExceptionDefSeq & get_exceptions,
      const IR_ExceptionDefSeq & put_exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_OperationDef_ptr create_operation (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr result,
      IR_OperationMode mode,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ValueDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ValueDef_Remote_Proxy_Impl :
  public virtual _TAO_ValueDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Container_Remote_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl,
  public virtual _TAO_IDLType_Remote_Proxy_Impl

{
public:
  _TAO_ValueDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ValueDef_Remote_Proxy_Impl (void) { }

  virtual IR_InterfaceDefSeq * supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const IR_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_InitializerSeq * initializers (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void initializers (
      CORBA_Object *_collocated_tao_target_,
      const IR_InitializerSeq & initializers,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDef_ptr base_value (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void base_value (
      CORBA_Object *_collocated_tao_target_,
      IR_ValueDef_ptr base_value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDefSeq * abstract_base_values (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void abstract_base_values (
      CORBA_Object *_collocated_tao_target_,
      const IR_ValueDefSeq & abstract_base_values,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_abstract (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_abstract,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_custom (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_custom (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_custom,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_truncatable (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void is_truncatable (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Boolean is_truncatable,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueMemberDef_ptr create_value_member (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      CORBA::Visibility access,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_AttributeDef_ptr create_attribute (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr type,
      IR_AttributeMode mode,
      const IR_ExceptionDefSeq & get_exceptions,
      const IR_ExceptionDefSeq & put_exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_OperationDef_ptr create_operation (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_IDLType_ptr result,
      IR_OperationMode mode,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      const IR_ContextIdSeq & contexts,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ValueDef_Proxy_Broker
{
public:
  virtual ~_TAO_ValueDef_Proxy_Broker (void);

  virtual _TAO_ValueDef_Proxy_Impl &select_proxy (
    IR_ValueDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ValueDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ValueDef_Remote_Proxy_Broker : public virtual _TAO_ValueDef_Proxy_Broker
{
public:
  _TAO_ValueDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ValueDef_Remote_Proxy_Broker (void);

  virtual _TAO_ValueDef_Proxy_Impl &select_proxy (
    IR_ValueDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ValueDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ValueDef_Remote_Proxy_Broker *the_TAO_ValueDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_ValueDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ValueDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  CORBA::Boolean is_abstract;
  CORBA::Boolean is_custom;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  IR_OpDescriptionSeq operations;
  IR_AttrDescriptionSeq attributes;
  IR_ValueMemberSeq members;
  IR_InitializerSeq initializers;
  IR_RepositoryIdSeq supported_interfaces;
  IR_RepositoryIdSeq abstract_base_values;
  CORBA::Boolean is_truncatable;
  TAO_String_Manager base_value;
  CORBA::TypeCode_var type;
};

class TAO_Export IR_ValueDescription_var
{
public:
  IR_ValueDescription_var (void); // default constructor
  IR_ValueDescription_var (IR_ValueDescription *);
  IR_ValueDescription_var (const IR_ValueDescription_var &); // copy constructor
  ~IR_ValueDescription_var (void); // destructor

  IR_ValueDescription_var &operator= (IR_ValueDescription *);
  IR_ValueDescription_var &operator= (const IR_ValueDescription_var &);
  IR_ValueDescription *operator-> (void);
  const IR_ValueDescription *operator-> (void) const;

  operator const IR_ValueDescription &() const;
  operator IR_ValueDescription &();
  operator IR_ValueDescription &() const;
  operator IR_ValueDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_ValueDescription &in (void) const;
  IR_ValueDescription &inout (void);
  IR_ValueDescription *&out (void);
  IR_ValueDescription *_retn (void);
  IR_ValueDescription *ptr (void) const;

private:
  IR_ValueDescription *ptr_;
};

class TAO_Export IR_ValueDescription_out
{
public:
  IR_ValueDescription_out (IR_ValueDescription *&);
  IR_ValueDescription_out (IR_ValueDescription_var &);
  IR_ValueDescription_out (const IR_ValueDescription_out &);
  IR_ValueDescription_out &operator= (const IR_ValueDescription_out &);
  IR_ValueDescription_out &operator= (IR_ValueDescription *);
  operator IR_ValueDescription *&();
  IR_ValueDescription *&ptr (void);
  IR_ValueDescription *operator-> (void);

private:
  IR_ValueDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ValueDescription_var &);
};

// Forward Classes Declaration
class _TAO_ValueBoxDef_Proxy_Impl;
class _TAO_ValueBoxDef_Remote_Proxy_Impl;
class _TAO_ValueBoxDef_Proxy_Broker;
class _TAO_ValueBoxDef_Remote_Proxy_Broker;

class TAO_Export IR_ValueBoxDef: public virtual IR_TypedefDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ValueBoxDef_ptr _ptr_type;
  typedef IR_ValueBoxDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ValueBoxDef_ptr _duplicate (IR_ValueBoxDef_ptr obj);
  static IR_ValueBoxDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ValueBoxDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ValueBoxDef_ptr _nil (void)
    {
      return (IR_ValueBoxDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_IDLType_ptr original_type_def (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void original_type_def (
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ValueBoxDef_Proxy_Broker *the_TAO_ValueBoxDef_Proxy_Broker_;

protected:
  IR_ValueBoxDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ValueBoxDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ValueBoxDef_Remote_Proxy_Impl;
  friend class _TAO_ValueBoxDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ValueBoxDef_Direct_Proxy_Impl;

  virtual ~IR_ValueBoxDef (void);
private:
  IR_ValueBoxDef (const IR_ValueBoxDef &);
  void operator= (const IR_ValueBoxDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ValueBoxDef_Proxy_Impl :
  public virtual _TAO_TypedefDef_Proxy_Impl
{
public:
  virtual ~_TAO_ValueBoxDef_Proxy_Impl (void) { }

  virtual IR_IDLType_ptr original_type_def (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void original_type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ValueBoxDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ValueBoxDef_Remote_Proxy_Impl :
  public virtual _TAO_ValueBoxDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_TypedefDef_Remote_Proxy_Impl

{
public:
  _TAO_ValueBoxDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ValueBoxDef_Remote_Proxy_Impl (void) { }

  virtual IR_IDLType_ptr original_type_def (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void original_type_def (
      CORBA_Object *_collocated_tao_target_,
      IR_IDLType_ptr original_type_def,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ValueBoxDef_Proxy_Broker
{
public:
  virtual ~_TAO_ValueBoxDef_Proxy_Broker (void);

  virtual _TAO_ValueBoxDef_Proxy_Impl &select_proxy (
    IR_ValueBoxDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ValueBoxDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ValueBoxDef_Remote_Proxy_Broker : public virtual _TAO_ValueBoxDef_Proxy_Broker
{
public:
  _TAO_ValueBoxDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ValueBoxDef_Remote_Proxy_Broker (void);

  virtual _TAO_ValueBoxDef_Proxy_Impl &select_proxy (
    IR_ValueBoxDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ValueBoxDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ValueBoxDef_Remote_Proxy_Broker *the_TAO_ValueBoxDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_ProvidesDef_Proxy_Impl;
class _TAO_ProvidesDef_Remote_Proxy_Impl;
class _TAO_ProvidesDef_Proxy_Broker;
class _TAO_ProvidesDef_Remote_Proxy_Broker;

class TAO_Export IR_ProvidesDef: public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ProvidesDef_ptr _ptr_type;
  typedef IR_ProvidesDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ProvidesDef_ptr _duplicate (IR_ProvidesDef_ptr obj);
  static IR_ProvidesDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ProvidesDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ProvidesDef_ptr _nil (void)
    {
      return (IR_ProvidesDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_InterfaceDef_ptr interface_type (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ProvidesDef_Proxy_Broker *the_TAO_ProvidesDef_Proxy_Broker_;

protected:
  IR_ProvidesDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ProvidesDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ProvidesDef_Remote_Proxy_Impl;
  friend class _TAO_ProvidesDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ProvidesDef_Direct_Proxy_Impl;

  virtual ~IR_ProvidesDef (void);
private:
  IR_ProvidesDef (const IR_ProvidesDef &);
  void operator= (const IR_ProvidesDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ProvidesDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_ProvidesDef_Proxy_Impl (void) { }

  virtual IR_InterfaceDef_ptr interface_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ProvidesDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ProvidesDef_Remote_Proxy_Impl :
  public virtual _TAO_ProvidesDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_ProvidesDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ProvidesDef_Remote_Proxy_Impl (void) { }

  virtual IR_InterfaceDef_ptr interface_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ProvidesDef_Proxy_Broker
{
public:
  virtual ~_TAO_ProvidesDef_Proxy_Broker (void);

  virtual _TAO_ProvidesDef_Proxy_Impl &select_proxy (
    IR_ProvidesDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ProvidesDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ProvidesDef_Remote_Proxy_Broker : public virtual _TAO_ProvidesDef_Proxy_Broker
{
public:
  _TAO_ProvidesDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ProvidesDef_Remote_Proxy_Broker (void);

  virtual _TAO_ProvidesDef_Proxy_Impl &select_proxy (
    IR_ProvidesDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ProvidesDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ProvidesDef_Remote_Proxy_Broker *the_TAO_ProvidesDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_ProvidesDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ProvidesDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  IR_InterfaceDef_var interface_type;
};

class TAO_Export IR_ProvidesDescription_var
{
public:
  IR_ProvidesDescription_var (void); // default constructor
  IR_ProvidesDescription_var (IR_ProvidesDescription *);
  IR_ProvidesDescription_var (const IR_ProvidesDescription_var &); // copy constructor
  ~IR_ProvidesDescription_var (void); // destructor

  IR_ProvidesDescription_var &operator= (IR_ProvidesDescription *);
  IR_ProvidesDescription_var &operator= (const IR_ProvidesDescription_var &);
  IR_ProvidesDescription *operator-> (void);
  const IR_ProvidesDescription *operator-> (void) const;

  operator const IR_ProvidesDescription &() const;
  operator IR_ProvidesDescription &();
  operator IR_ProvidesDescription &() const;
  operator IR_ProvidesDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_ProvidesDescription &in (void) const;
  IR_ProvidesDescription &inout (void);
  IR_ProvidesDescription *&out (void);
  IR_ProvidesDescription *_retn (void);
  IR_ProvidesDescription *ptr (void) const;

private:
  IR_ProvidesDescription *ptr_;
};

class TAO_Export IR_ProvidesDescription_out
{
public:
  IR_ProvidesDescription_out (IR_ProvidesDescription *&);
  IR_ProvidesDescription_out (IR_ProvidesDescription_var &);
  IR_ProvidesDescription_out (const IR_ProvidesDescription_out &);
  IR_ProvidesDescription_out &operator= (const IR_ProvidesDescription_out &);
  IR_ProvidesDescription_out &operator= (IR_ProvidesDescription *);
  operator IR_ProvidesDescription *&();
  IR_ProvidesDescription *&ptr (void);
  IR_ProvidesDescription *operator-> (void);

private:
  IR_ProvidesDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ProvidesDescription_var &);
};

// Forward Classes Declaration
class _TAO_UsesDef_Proxy_Impl;
class _TAO_UsesDef_Remote_Proxy_Impl;
class _TAO_UsesDef_Proxy_Broker;
class _TAO_UsesDef_Remote_Proxy_Broker;

class TAO_Export IR_UsesDef: public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_UsesDef_ptr _ptr_type;
  typedef IR_UsesDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_UsesDef_ptr _duplicate (IR_UsesDef_ptr obj);
  static IR_UsesDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_UsesDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_UsesDef_ptr _nil (void)
    {
      return (IR_UsesDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_InterfaceDef_ptr interface_type (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_multiple (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_UsesDef_Proxy_Broker *the_TAO_UsesDef_Proxy_Broker_;

protected:
  IR_UsesDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_UsesDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_UsesDef_Remote_Proxy_Impl;
  friend class _TAO_UsesDef_ThruPOA_Proxy_Impl;
  friend class _TAO_UsesDef_Direct_Proxy_Impl;

  virtual ~IR_UsesDef (void);
private:
  IR_UsesDef (const IR_UsesDef &);
  void operator= (const IR_UsesDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_UsesDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_UsesDef_Proxy_Impl (void) { }

  virtual IR_InterfaceDef_ptr interface_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_multiple (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_UsesDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_UsesDef_Remote_Proxy_Impl :
  public virtual _TAO_UsesDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_UsesDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_UsesDef_Remote_Proxy_Impl (void) { }

  virtual IR_InterfaceDef_ptr interface_type (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_multiple (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_UsesDef_Proxy_Broker
{
public:
  virtual ~_TAO_UsesDef_Proxy_Broker (void);

  virtual _TAO_UsesDef_Proxy_Impl &select_proxy (
    IR_UsesDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_UsesDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_UsesDef_Remote_Proxy_Broker : public virtual _TAO_UsesDef_Proxy_Broker
{
public:
  _TAO_UsesDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_UsesDef_Remote_Proxy_Broker (void);

  virtual _TAO_UsesDef_Proxy_Impl &select_proxy (
    IR_UsesDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_UsesDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_UsesDef_Remote_Proxy_Broker *the_TAO_UsesDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_UsesDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_UsesDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  IR_InterfaceDef_var interface_type;
  CORBA::Boolean is_multiple;
};

class TAO_Export IR_UsesDescription_var
{
public:
  IR_UsesDescription_var (void); // default constructor
  IR_UsesDescription_var (IR_UsesDescription *);
  IR_UsesDescription_var (const IR_UsesDescription_var &); // copy constructor
  ~IR_UsesDescription_var (void); // destructor

  IR_UsesDescription_var &operator= (IR_UsesDescription *);
  IR_UsesDescription_var &operator= (const IR_UsesDescription_var &);
  IR_UsesDescription *operator-> (void);
  const IR_UsesDescription *operator-> (void) const;

  operator const IR_UsesDescription &() const;
  operator IR_UsesDescription &();
  operator IR_UsesDescription &() const;
  operator IR_UsesDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_UsesDescription &in (void) const;
  IR_UsesDescription &inout (void);
  IR_UsesDescription *&out (void);
  IR_UsesDescription *_retn (void);
  IR_UsesDescription *ptr (void) const;

private:
  IR_UsesDescription *ptr_;
};

class TAO_Export IR_UsesDescription_out
{
public:
  IR_UsesDescription_out (IR_UsesDescription *&);
  IR_UsesDescription_out (IR_UsesDescription_var &);
  IR_UsesDescription_out (const IR_UsesDescription_out &);
  IR_UsesDescription_out &operator= (const IR_UsesDescription_out &);
  IR_UsesDescription_out &operator= (IR_UsesDescription *);
  operator IR_UsesDescription *&();
  IR_UsesDescription *&ptr (void);
  IR_UsesDescription *operator-> (void);

private:
  IR_UsesDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_UsesDescription_var &);
};

TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_IR_UsesDescription;

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_ProvidesDescSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_ProvidesDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq (const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs);
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &operator= (const _TAO_Unbounded_Sequence_IR_ProvidesDescSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void); // Dtor.
    // = Accessors.
    IR_ProvidesDescription &operator[] (CORBA::ULong i);
    const IR_ProvidesDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_ProvidesDescription *allocbuf (CORBA::ULong size);
    static void freebuf (IR_ProvidesDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_ProvidesDescription *get_buffer (CORBA::Boolean orphan = 0);
    const IR_ProvidesDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_ProvidesDescription *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_ProvidesDescSeq
// *************************************************************

class TAO_Export IR_ProvidesDescSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_ProvidesDescSeq (void); // default ctor
  IR_ProvidesDescSeq (CORBA::ULong max); // uses max size
  IR_ProvidesDescSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_ProvidesDescription *buffer,
    CORBA::Boolean release = 0
  );
  IR_ProvidesDescSeq (const IR_ProvidesDescSeq &); // copy ctor
  ~IR_ProvidesDescSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ProvidesDescSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_ProvidesDescSeq_var
// *************************************************************

class TAO_Export IR_ProvidesDescSeq_var
{
public:
  IR_ProvidesDescSeq_var (void); // default constructor
  IR_ProvidesDescSeq_var (IR_ProvidesDescSeq *);
  IR_ProvidesDescSeq_var (const IR_ProvidesDescSeq_var &); // copy constructor
  ~IR_ProvidesDescSeq_var (void); // destructor

  IR_ProvidesDescSeq_var &operator= (IR_ProvidesDescSeq *);
  IR_ProvidesDescSeq_var &operator= (const IR_ProvidesDescSeq_var &);
  IR_ProvidesDescSeq *operator-> (void);
  const IR_ProvidesDescSeq *operator-> (void) const;

  operator const IR_ProvidesDescSeq &() const;
  operator IR_ProvidesDescSeq &();
  operator IR_ProvidesDescSeq &() const;
  operator IR_ProvidesDescSeq *&(); // variable-size base types only

  IR_ProvidesDescription & operator[] (CORBA::ULong index);
  const IR_ProvidesDescription & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_ProvidesDescSeq &in (void) const;
  IR_ProvidesDescSeq &inout (void);
  IR_ProvidesDescSeq *&out (void);
  IR_ProvidesDescSeq *_retn (void);
  IR_ProvidesDescSeq *ptr (void) const;

private:
  IR_ProvidesDescSeq *ptr_;
};

class TAO_Export IR_ProvidesDescSeq_out
{
public:
  IR_ProvidesDescSeq_out (IR_ProvidesDescSeq *&);
  IR_ProvidesDescSeq_out (IR_ProvidesDescSeq_var &);
  IR_ProvidesDescSeq_out (const IR_ProvidesDescSeq_out &);
  IR_ProvidesDescSeq_out &operator= (const IR_ProvidesDescSeq_out &);
  IR_ProvidesDescSeq_out &operator= (IR_ProvidesDescSeq *);
  operator IR_ProvidesDescSeq *&();
  IR_ProvidesDescSeq *&ptr (void);
  IR_ProvidesDescSeq *operator-> (void);
  IR_ProvidesDescription & operator[] (CORBA::ULong index);

private:
  IR_ProvidesDescSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ProvidesDescSeq_var &);
};

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

  class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IR_UsesDescSeq : public TAO_Unbounded_Base_Sequence
  {
  public:
    // = Initialization and termination methods.

    _TAO_Unbounded_Sequence_IR_UsesDescSeq (void); // Default constructor.
    _TAO_Unbounded_Sequence_IR_UsesDescSeq (CORBA::ULong maximum);
    _TAO_Unbounded_Sequence_IR_UsesDescSeq (CORBA::ULong maximum,
      CORBA::ULong length,
      IR_UsesDescription *data,
      CORBA::Boolean release = 0);
    _TAO_Unbounded_Sequence_IR_UsesDescSeq (const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs);
    _TAO_Unbounded_Sequence_IR_UsesDescSeq &operator= (const _TAO_Unbounded_Sequence_IR_UsesDescSeq &rhs);
    virtual ~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void); // Dtor.
    // = Accessors.
    IR_UsesDescription &operator[] (CORBA::ULong i);
    const IR_UsesDescription &operator[] (CORBA::ULong i) const;
    // = Static operations.
    static IR_UsesDescription *allocbuf (CORBA::ULong size);
    static void freebuf (IR_UsesDescription *buffer);
    virtual void _allocate_buffer (CORBA::ULong length);
    virtual void _deallocate_buffer (void);
    // Implement the TAO_Base_Sequence methods (see Sequence.h)

    IR_UsesDescription *get_buffer (CORBA::Boolean orphan = 0);
    const IR_UsesDescription *get_buffer (void) const;
    void replace (CORBA::ULong max,
      CORBA::ULong length,
      IR_UsesDescription *data,
      CORBA::Boolean release);
  };

#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

// *************************************************************
// IR_UsesDescSeq
// *************************************************************

class TAO_Export IR_UsesDescSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
{
public:
  IR_UsesDescSeq (void); // default ctor
  IR_UsesDescSeq (CORBA::ULong max); // uses max size
  IR_UsesDescSeq (
    CORBA::ULong max,
    CORBA::ULong length,
    IR_UsesDescription *buffer,
    CORBA::Boolean release = 0
  );
  IR_UsesDescSeq (const IR_UsesDescSeq &); // copy ctor
  ~IR_UsesDescSeq (void);
  static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_UsesDescSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

};

// *************************************************************
// class IR_UsesDescSeq_var
// *************************************************************

class TAO_Export IR_UsesDescSeq_var
{
public:
  IR_UsesDescSeq_var (void); // default constructor
  IR_UsesDescSeq_var (IR_UsesDescSeq *);
  IR_UsesDescSeq_var (const IR_UsesDescSeq_var &); // copy constructor
  ~IR_UsesDescSeq_var (void); // destructor

  IR_UsesDescSeq_var &operator= (IR_UsesDescSeq *);
  IR_UsesDescSeq_var &operator= (const IR_UsesDescSeq_var &);
  IR_UsesDescSeq *operator-> (void);
  const IR_UsesDescSeq *operator-> (void) const;

  operator const IR_UsesDescSeq &() const;
  operator IR_UsesDescSeq &();
  operator IR_UsesDescSeq &() const;
  operator IR_UsesDescSeq *&(); // variable-size base types only

  IR_UsesDescription & operator[] (CORBA::ULong index);
  const IR_UsesDescription & operator[] (CORBA::ULong index) const;

  // in, inout, out, _retn
  const IR_UsesDescSeq &in (void) const;
  IR_UsesDescSeq &inout (void);
  IR_UsesDescSeq *&out (void);
  IR_UsesDescSeq *_retn (void);
  IR_UsesDescSeq *ptr (void) const;

private:
  IR_UsesDescSeq *ptr_;
};

class TAO_Export IR_UsesDescSeq_out
{
public:
  IR_UsesDescSeq_out (IR_UsesDescSeq *&);
  IR_UsesDescSeq_out (IR_UsesDescSeq_var &);
  IR_UsesDescSeq_out (const IR_UsesDescSeq_out &);
  IR_UsesDescSeq_out &operator= (const IR_UsesDescSeq_out &);
  IR_UsesDescSeq_out &operator= (IR_UsesDescSeq *);
  operator IR_UsesDescSeq *&();
  IR_UsesDescSeq *&ptr (void);
  IR_UsesDescSeq *operator-> (void);
  IR_UsesDescription & operator[] (CORBA::ULong index);

private:
  IR_UsesDescSeq *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_UsesDescSeq_var &);
};

// Forward Classes Declaration
class _TAO_EventDef_Proxy_Impl;
class _TAO_EventDef_Remote_Proxy_Impl;
class _TAO_EventDef_Proxy_Broker;
class _TAO_EventDef_Remote_Proxy_Broker;

class TAO_Export IR_EventDef: public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_EventDef_ptr _ptr_type;
  typedef IR_EventDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_EventDef_ptr _duplicate (IR_EventDef_ptr obj);
  static IR_EventDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_EventDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_EventDef_ptr _nil (void)
    {
      return (IR_EventDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean is_a (
      const char * event_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDef_ptr event (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_EventDef_Proxy_Broker *the_TAO_EventDef_Proxy_Broker_;

protected:
  IR_EventDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_EventDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_EventDef_Remote_Proxy_Impl;
  friend class _TAO_EventDef_ThruPOA_Proxy_Impl;
  friend class _TAO_EventDef_Direct_Proxy_Impl;

  virtual ~IR_EventDef (void);
private:
  IR_EventDef (const IR_EventDef &);
  void operator= (const IR_EventDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_EventDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_EventDef_Proxy_Impl (void) { }

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * event_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ValueDef_ptr event (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_EventDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_EventDef_Remote_Proxy_Impl :
  public virtual _TAO_EventDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_EventDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_EventDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * event_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDef_ptr event (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_EventDef_Proxy_Broker
{
public:
  virtual ~_TAO_EventDef_Proxy_Broker (void);

  virtual _TAO_EventDef_Proxy_Impl &select_proxy (
    IR_EventDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_EventDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_EventDef_Remote_Proxy_Broker : public virtual _TAO_EventDef_Proxy_Broker
{
public:
  _TAO_EventDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_EventDef_Remote_Proxy_Broker (void);

  virtual _TAO_EventDef_Proxy_Impl &select_proxy (
    IR_EventDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_EventDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_EventDef_Remote_Proxy_Broker *the_TAO_EventDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_EventDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_EventDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  IR_ValueDef_var value;
};

class TAO_Export IR_EventDescription_var
{
public:
  IR_EventDescription_var (void); // default constructor
  IR_EventDescription_var (IR_EventDescription *);
  IR_EventDescription_var (const IR_EventDescription_var &); // copy constructor
  ~IR_EventDescription_var (void); // destructor

  IR_EventDescription_var &operator= (IR_EventDescription *);
  IR_EventDescription_var &operator= (const IR_EventDescription_var &);
  IR_EventDescription *operator-> (void);
  const IR_EventDescription *operator-> (void) const;

  operator const IR_EventDescription &() const;
  operator IR_EventDescription &();
  operator IR_EventDescription &() const;
  operator IR_EventDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_EventDescription &in (void) const;
  IR_EventDescription &inout (void);
  IR_EventDescription *&out (void);
  IR_EventDescription *_retn (void);
  IR_EventDescription *ptr (void) const;

private:
  IR_EventDescription *ptr_;
};

class TAO_Export IR_EventDescription_out
{
public:
  IR_EventDescription_out (IR_EventDescription *&);
  IR_EventDescription_out (IR_EventDescription_var &);
  IR_EventDescription_out (const IR_EventDescription_out &);
  IR_EventDescription_out &operator= (const IR_EventDescription_out &);
  IR_EventDescription_out &operator= (IR_EventDescription *);
  operator IR_EventDescription *&();
  IR_EventDescription *&ptr (void);
  IR_EventDescription *operator-> (void);

private:
  IR_EventDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_EventDescription_var &);
};

// Forward Classes Declaration
class _TAO_EmitsDef_Proxy_Impl;
class _TAO_EmitsDef_Remote_Proxy_Impl;
class _TAO_EmitsDef_Proxy_Broker;
class _TAO_EmitsDef_Remote_Proxy_Broker;

class TAO_Export IR_EmitsDef: public virtual IR_EventDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_EmitsDef_ptr _ptr_type;
  typedef IR_EmitsDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_EmitsDef_ptr _duplicate (IR_EmitsDef_ptr obj);
  static IR_EmitsDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_EmitsDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_EmitsDef_ptr _nil (void)
    {
      return (IR_EmitsDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_EmitsDef_Proxy_Broker *the_TAO_EmitsDef_Proxy_Broker_;

protected:
  IR_EmitsDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_EmitsDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_EmitsDef_Remote_Proxy_Impl;
  friend class _TAO_EmitsDef_ThruPOA_Proxy_Impl;
  friend class _TAO_EmitsDef_Direct_Proxy_Impl;

  virtual ~IR_EmitsDef (void);
private:
  IR_EmitsDef (const IR_EmitsDef &);
  void operator= (const IR_EmitsDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_EmitsDef_Proxy_Impl
  : public virtual _TAO_EventDef_Proxy_Impl
{
public:
  virtual ~_TAO_EmitsDef_Proxy_Impl (void) { }

protected:
  _TAO_EmitsDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_EmitsDef_Remote_Proxy_Impl :
  public virtual _TAO_EmitsDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_EventDef_Remote_Proxy_Impl

{
public:
  _TAO_EmitsDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_EmitsDef_Remote_Proxy_Impl (void) { }

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_EmitsDef_Proxy_Broker
{
public:
  virtual ~_TAO_EmitsDef_Proxy_Broker (void);

  virtual _TAO_EmitsDef_Proxy_Impl &select_proxy (
    IR_EmitsDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_EmitsDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_EmitsDef_Remote_Proxy_Broker : public virtual _TAO_EmitsDef_Proxy_Broker
{
public:
  _TAO_EmitsDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_EmitsDef_Remote_Proxy_Broker (void);

  virtual _TAO_EmitsDef_Proxy_Impl &select_proxy (
    IR_EmitsDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_EmitsDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_EmitsDef_Remote_Proxy_Broker *the_TAO_EmitsDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

class _TAO_PublishesDef_Proxy_Impl;
class _TAO_PublishesDef_Remote_Proxy_Impl;
class _TAO_PublishesDef_Proxy_Broker;
class _TAO_PublishesDef_Remote_Proxy_Broker;

class TAO_Export IR_PublishesDef: public virtual IR_EventDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_PublishesDef_ptr _ptr_type;
  typedef IR_PublishesDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_PublishesDef_ptr _duplicate (IR_PublishesDef_ptr obj);
  static IR_PublishesDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_PublishesDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_PublishesDef_ptr _nil (void)
    {
      return (IR_PublishesDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_PublishesDef_Proxy_Broker *the_TAO_PublishesDef_Proxy_Broker_;

protected:
  IR_PublishesDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_PublishesDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_PublishesDef_Remote_Proxy_Impl;
  friend class _TAO_PublishesDef_ThruPOA_Proxy_Impl;
  friend class _TAO_PublishesDef_Direct_Proxy_Impl;

  virtual ~IR_PublishesDef (void);
private:
  IR_PublishesDef (const IR_PublishesDef &);
  void operator= (const IR_PublishesDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_PublishesDef_Proxy_Impl
  : public virtual _TAO_EventDef_Proxy_Impl
{
public:
  virtual ~_TAO_PublishesDef_Proxy_Impl (void) { }

protected:
  _TAO_PublishesDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_PublishesDef_Remote_Proxy_Impl :
  public virtual _TAO_PublishesDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_EventDef_Remote_Proxy_Impl

{
public:
  _TAO_PublishesDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_PublishesDef_Remote_Proxy_Impl (void) { }

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_PublishesDef_Proxy_Broker
{
public:
  virtual ~_TAO_PublishesDef_Proxy_Broker (void);

  virtual _TAO_PublishesDef_Proxy_Impl &select_proxy (
    IR_PublishesDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_PublishesDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_PublishesDef_Remote_Proxy_Broker : public virtual _TAO_PublishesDef_Proxy_Broker
{
public:
  _TAO_PublishesDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_PublishesDef_Remote_Proxy_Broker (void);

  virtual _TAO_PublishesDef_Proxy_Impl &select_proxy (
    IR_PublishesDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_PublishesDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_PublishesDef_Remote_Proxy_Broker *the_TAO_PublishesDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_ConsumesDef_Proxy_Impl;
class _TAO_ConsumesDef_Remote_Proxy_Impl;
class _TAO_ConsumesDef_Proxy_Broker;
class _TAO_ConsumesDef_Remote_Proxy_Broker;

class TAO_Export IR_ConsumesDef: public virtual IR_EventDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ConsumesDef_ptr _ptr_type;
  typedef IR_ConsumesDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ConsumesDef_ptr _duplicate (IR_ConsumesDef_ptr obj);
  static IR_ConsumesDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ConsumesDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ConsumesDef_ptr _nil (void)
    {
      return (IR_ConsumesDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ConsumesDef_Proxy_Broker *the_TAO_ConsumesDef_Proxy_Broker_;

protected:
  IR_ConsumesDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ConsumesDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ConsumesDef_Remote_Proxy_Impl;
  friend class _TAO_ConsumesDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ConsumesDef_Direct_Proxy_Impl;

  virtual ~IR_ConsumesDef (void);
private:
  IR_ConsumesDef (const IR_ConsumesDef &);
  void operator= (const IR_ConsumesDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ConsumesDef_Proxy_Impl
  : public virtual _TAO_EventDef_Proxy_Impl
{
public:
  virtual ~_TAO_ConsumesDef_Proxy_Impl (void) { }

protected:
  _TAO_ConsumesDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ConsumesDef_Remote_Proxy_Impl :
  public virtual _TAO_ConsumesDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_EventDef_Remote_Proxy_Impl

{
public:
  _TAO_ConsumesDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ConsumesDef_Remote_Proxy_Impl (void) { }

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ConsumesDef_Proxy_Broker
{
public:
  virtual ~_TAO_ConsumesDef_Proxy_Broker (void);

  virtual _TAO_ConsumesDef_Proxy_Impl &select_proxy (
    IR_ConsumesDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ConsumesDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ConsumesDef_Remote_Proxy_Broker : public virtual _TAO_ConsumesDef_Proxy_Broker
{
public:
  _TAO_ConsumesDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ConsumesDef_Remote_Proxy_Broker (void);

  virtual _TAO_ConsumesDef_Proxy_Impl &select_proxy (
    IR_ConsumesDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ConsumesDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ConsumesDef_Remote_Proxy_Broker *the_TAO_ConsumesDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_ComponentDef_Proxy_Impl;
class _TAO_ComponentDef_Remote_Proxy_Impl;
class _TAO_ComponentDef_Proxy_Broker;
class _TAO_ComponentDef_Remote_Proxy_Broker;

class TAO_Export IR_ComponentDef: public virtual IR_InterfaceDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ComponentDef_ptr _ptr_type;
  typedef IR_ComponentDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_ComponentDef_ptr _duplicate (IR_ComponentDef_ptr obj);
  static IR_ComponentDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ComponentDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_ComponentDef_ptr _nil (void)
    {
      return (IR_ComponentDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_InterfaceDefSeq * supported_interfaces (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void supported_interfaces (
      const IR_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ComponentDef_ptr base_component (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ProvidesDefSeq * provides_interfaces (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_UsesDefSeq * uses_interfaces (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_EmitsDefSeq * emits_events (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PublishesDefSeq * publishes_events (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ConsumesDefSeq * consumes_events (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_basic (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ProvidesDef_ptr create_provides (
      const char * id,
      const char * name,
      const char * version,
      IR_InterfaceDef_ptr interface_type,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_UsesDef_ptr create_uses (
      const char * id,
      const char * name,
      const char * version,
      IR_InterfaceDef_ptr interface_type,
      CORBA::Boolean is_multiple,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_EmitsDef_ptr create_emits (
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PublishesDef_ptr create_publishes (
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ConsumesDef_ptr create_consumes (
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_ComponentDef_Proxy_Broker *the_TAO_ComponentDef_Proxy_Broker_;

protected:
  IR_ComponentDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_ComponentDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_ComponentDef_Remote_Proxy_Impl;
  friend class _TAO_ComponentDef_ThruPOA_Proxy_Impl;
  friend class _TAO_ComponentDef_Direct_Proxy_Impl;

  virtual ~IR_ComponentDef (void);
private:
  IR_ComponentDef (const IR_ComponentDef &);
  void operator= (const IR_ComponentDef &);
};

// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_ComponentDef_Proxy_Impl :
  public virtual _TAO_InterfaceDef_Proxy_Impl
{
public:
  virtual ~_TAO_ComponentDef_Proxy_Impl (void) { }

  virtual IR_InterfaceDefSeq * supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual void supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const IR_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ComponentDef_ptr base_component (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ProvidesDefSeq * provides_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_UsesDefSeq * uses_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_EmitsDefSeq * emits_events (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_PublishesDefSeq * publishes_events (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ConsumesDefSeq * consumes_events (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_basic (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ProvidesDef_ptr create_provides (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_InterfaceDef_ptr interface_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_UsesDef_ptr create_uses (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_InterfaceDef_ptr interface_type,
      CORBA::Boolean is_multiple,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_EmitsDef_ptr create_emits (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_PublishesDef_ptr create_publishes (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ConsumesDef_ptr create_consumes (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_ComponentDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_ComponentDef_Remote_Proxy_Impl :
  public virtual _TAO_ComponentDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_InterfaceDef_Remote_Proxy_Impl

{
public:
  _TAO_ComponentDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_ComponentDef_Remote_Proxy_Impl (void) { }

  virtual IR_InterfaceDefSeq * supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual void supported_interfaces (
      CORBA_Object *_collocated_tao_target_,
      const IR_InterfaceDefSeq & supported_interfaces,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ComponentDef_ptr base_component (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ProvidesDefSeq * provides_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_UsesDefSeq * uses_interfaces (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_EmitsDefSeq * emits_events (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PublishesDefSeq * publishes_events (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ConsumesDefSeq * consumes_events (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_basic (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ProvidesDef_ptr create_provides (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_InterfaceDef_ptr interface_type,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_UsesDef_ptr create_uses (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_InterfaceDef_ptr interface_type,
      CORBA::Boolean is_multiple,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_EmitsDef_ptr create_emits (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PublishesDef_ptr create_publishes (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ConsumesDef_ptr create_consumes (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr value,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_ComponentDef_Proxy_Broker
{
public:
  virtual ~_TAO_ComponentDef_Proxy_Broker (void);

  virtual _TAO_ComponentDef_Proxy_Impl &select_proxy (
    IR_ComponentDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_ComponentDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_ComponentDef_Remote_Proxy_Broker : public virtual _TAO_ComponentDef_Proxy_Broker
{
public:
  _TAO_ComponentDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_ComponentDef_Remote_Proxy_Broker (void);

  virtual _TAO_ComponentDef_Proxy_Impl &select_proxy (
    IR_ComponentDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_ComponentDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_ComponentDef_Remote_Proxy_Broker *the_TAO_ComponentDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_ComponentDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_ComponentDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  TAO_String_Manager base_component;
  IR_RepositoryIdSeq supports_interfaces;
  IR_ProvidesDefSeq provides_interfaces;
  IR_UsesDefSeq uses_interfaces;
  IR_AttrDescriptionSeq attributes;
  IR_EmitsDefSeq emits_events;
  IR_PublishesDefSeq publishes_events;
  IR_ConsumesDefSeq consumes_events;
  CORBA::Boolean is_basic;
};

class TAO_Export IR_ComponentDescription_var
{
public:
  IR_ComponentDescription_var (void); // default constructor
  IR_ComponentDescription_var (IR_ComponentDescription *);
  IR_ComponentDescription_var (const IR_ComponentDescription_var &); // copy constructor
  ~IR_ComponentDescription_var (void); // destructor

  IR_ComponentDescription_var &operator= (IR_ComponentDescription *);
  IR_ComponentDescription_var &operator= (const IR_ComponentDescription_var &);
  IR_ComponentDescription *operator-> (void);
  const IR_ComponentDescription *operator-> (void) const;

  operator const IR_ComponentDescription &() const;
  operator IR_ComponentDescription &();
  operator IR_ComponentDescription &() const;
  operator IR_ComponentDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_ComponentDescription &in (void) const;
  IR_ComponentDescription &inout (void);
  IR_ComponentDescription *&out (void);
  IR_ComponentDescription *_retn (void);
  IR_ComponentDescription *ptr (void) const;

private:
  IR_ComponentDescription *ptr_;
};

class TAO_Export IR_ComponentDescription_out
{
public:
  IR_ComponentDescription_out (IR_ComponentDescription *&);
  IR_ComponentDescription_out (IR_ComponentDescription_var &);
  IR_ComponentDescription_out (const IR_ComponentDescription_out &);
  IR_ComponentDescription_out &operator= (const IR_ComponentDescription_out &);
  IR_ComponentDescription_out &operator= (IR_ComponentDescription *);
  operator IR_ComponentDescription *&();
  IR_ComponentDescription *&ptr (void);
  IR_ComponentDescription *operator-> (void);

private:
  IR_ComponentDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_ComponentDescription_var &);
};

// Forward Classes Declaration
class _TAO_PrimaryKeyDef_Proxy_Impl;
class _TAO_PrimaryKeyDef_Remote_Proxy_Impl;
class _TAO_PrimaryKeyDef_Proxy_Broker;
class _TAO_PrimaryKeyDef_Remote_Proxy_Broker;

class TAO_Export IR_PrimaryKeyDef: public virtual IR_Contained
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_PrimaryKeyDef_ptr _ptr_type;
  typedef IR_PrimaryKeyDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_PrimaryKeyDef_ptr _duplicate (IR_PrimaryKeyDef_ptr obj);
  static IR_PrimaryKeyDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_PrimaryKeyDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_PrimaryKeyDef_ptr _nil (void)
    {
      return (IR_PrimaryKeyDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean is_a (
      const char * primary_key_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDef_ptr primary_key (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_PrimaryKeyDef_Proxy_Broker *the_TAO_PrimaryKeyDef_Proxy_Broker_;

protected:
  IR_PrimaryKeyDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_PrimaryKeyDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_PrimaryKeyDef_Remote_Proxy_Impl;
 friend class _TAO_PrimaryKeyDef_ThruPOA_Proxy_Impl;
   friend class _TAO_PrimaryKeyDef_Direct_Proxy_Impl;

  virtual ~IR_PrimaryKeyDef (void);
private:
  IR_PrimaryKeyDef (const IR_PrimaryKeyDef &);
  void operator= (const IR_PrimaryKeyDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_PrimaryKeyDef_Proxy_Impl :
  public virtual _TAO_Contained_Proxy_Impl
{
public:
  virtual ~_TAO_PrimaryKeyDef_Proxy_Impl (void) { }

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * primary_key_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ValueDef_ptr primary_key (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_PrimaryKeyDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_PrimaryKeyDef_Remote_Proxy_Impl :
  public virtual _TAO_PrimaryKeyDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_Contained_Remote_Proxy_Impl

{
public:
  _TAO_PrimaryKeyDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_PrimaryKeyDef_Remote_Proxy_Impl (void) { }

  virtual CORBA::Boolean is_a (
      CORBA_Object *_collocated_tao_target_,
      const char * primary_key_id,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ValueDef_ptr primary_key (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_PrimaryKeyDef_Proxy_Broker
{
public:
  virtual ~_TAO_PrimaryKeyDef_Proxy_Broker (void);

  virtual _TAO_PrimaryKeyDef_Proxy_Impl &select_proxy (
    IR_PrimaryKeyDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_PrimaryKeyDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_PrimaryKeyDef_Remote_Proxy_Broker : public virtual _TAO_PrimaryKeyDef_Proxy_Broker
{
public:
  _TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);

  virtual _TAO_PrimaryKeyDef_Proxy_Impl &select_proxy (
    IR_PrimaryKeyDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_PrimaryKeyDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_PrimaryKeyDef_Remote_Proxy_Broker *the_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_PrimaryKeyDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_PrimaryKeyDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  IR_ValueDef_var primary_key;
};

class TAO_Export IR_PrimaryKeyDescription_var
{
public:
  IR_PrimaryKeyDescription_var (void); // default constructor
  IR_PrimaryKeyDescription_var (IR_PrimaryKeyDescription *);
  IR_PrimaryKeyDescription_var (const IR_PrimaryKeyDescription_var &); // copy constructor
  ~IR_PrimaryKeyDescription_var (void); // destructor

  IR_PrimaryKeyDescription_var &operator= (IR_PrimaryKeyDescription *);
  IR_PrimaryKeyDescription_var &operator= (const IR_PrimaryKeyDescription_var &);
  IR_PrimaryKeyDescription *operator-> (void);
  const IR_PrimaryKeyDescription *operator-> (void) const;

  operator const IR_PrimaryKeyDescription &() const;
  operator IR_PrimaryKeyDescription &();
  operator IR_PrimaryKeyDescription &() const;
  operator IR_PrimaryKeyDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_PrimaryKeyDescription &in (void) const;
  IR_PrimaryKeyDescription &inout (void);
  IR_PrimaryKeyDescription *&out (void);
  IR_PrimaryKeyDescription *_retn (void);
  IR_PrimaryKeyDescription *ptr (void) const;

private:
  IR_PrimaryKeyDescription *ptr_;
};

class TAO_Export IR_PrimaryKeyDescription_out
{
public:
  IR_PrimaryKeyDescription_out (IR_PrimaryKeyDescription *&);
  IR_PrimaryKeyDescription_out (IR_PrimaryKeyDescription_var &);
  IR_PrimaryKeyDescription_out (const IR_PrimaryKeyDescription_out &);
  IR_PrimaryKeyDescription_out &operator= (const IR_PrimaryKeyDescription_out &);
  IR_PrimaryKeyDescription_out &operator= (IR_PrimaryKeyDescription *);
  operator IR_PrimaryKeyDescription *&();
  IR_PrimaryKeyDescription *&ptr (void);
  IR_PrimaryKeyDescription *operator-> (void);

private:
  IR_PrimaryKeyDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_PrimaryKeyDescription_var &);
};

// Forward Classes Declaration
class _TAO_FactoryDef_Proxy_Impl;
class _TAO_FactoryDef_Remote_Proxy_Impl;
class _TAO_FactoryDef_Proxy_Broker;
class _TAO_FactoryDef_Remote_Proxy_Broker;

class TAO_Export IR_FactoryDef: public virtual IR_OperationDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_FactoryDef_ptr _ptr_type;
  typedef IR_FactoryDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_FactoryDef_ptr _duplicate (IR_FactoryDef_ptr obj);
  static IR_FactoryDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_FactoryDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_FactoryDef_ptr _nil (void)
    {
      return (IR_FactoryDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_FactoryDef_Proxy_Broker *the_TAO_FactoryDef_Proxy_Broker_;

protected:
  IR_FactoryDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_FactoryDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_FactoryDef_Remote_Proxy_Impl;
  friend class _TAO_FactoryDef_ThruPOA_Proxy_Impl;
  friend class _TAO_FactoryDef_Direct_Proxy_Impl;

  virtual ~IR_FactoryDef (void);
private:
  IR_FactoryDef (const IR_FactoryDef &);
  void operator= (const IR_FactoryDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_FactoryDef_Proxy_Impl
  : public virtual _TAO_OperationDef_Proxy_Impl
{
public:
  virtual ~_TAO_FactoryDef_Proxy_Impl (void) { }

protected:
  _TAO_FactoryDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_FactoryDef_Remote_Proxy_Impl :
  public virtual _TAO_FactoryDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_OperationDef_Remote_Proxy_Impl

{
public:
  _TAO_FactoryDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_FactoryDef_Remote_Proxy_Impl (void) { }

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_FactoryDef_Proxy_Broker
{
public:
  virtual ~_TAO_FactoryDef_Proxy_Broker (void);

  virtual _TAO_FactoryDef_Proxy_Impl &select_proxy (
    IR_FactoryDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_FactoryDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_FactoryDef_Remote_Proxy_Broker : public virtual _TAO_FactoryDef_Proxy_Broker
{
public:
  _TAO_FactoryDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_FactoryDef_Remote_Proxy_Broker (void);

  virtual _TAO_FactoryDef_Proxy_Impl &select_proxy (
    IR_FactoryDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_FactoryDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_FactoryDef_Remote_Proxy_Broker *the_TAO_FactoryDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_FinderDef_Proxy_Impl;
class _TAO_FinderDef_Remote_Proxy_Impl;
class _TAO_FinderDef_Proxy_Broker;
class _TAO_FinderDef_Remote_Proxy_Broker;

class TAO_Export IR_FinderDef: public virtual IR_OperationDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_FinderDef_ptr _ptr_type;
  typedef IR_FinderDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_FinderDef_ptr _duplicate (IR_FinderDef_ptr obj);
  static IR_FinderDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_FinderDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_FinderDef_ptr _nil (void)
    {
      return (IR_FinderDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_FinderDef_Proxy_Broker *the_TAO_FinderDef_Proxy_Broker_;

protected:
  IR_FinderDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_FinderDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_FinderDef_Remote_Proxy_Impl;
  friend class _TAO_FinderDef_ThruPOA_Proxy_Impl;
  friend class _TAO_FinderDef_Direct_Proxy_Impl;

  virtual ~IR_FinderDef (void);
private:
  IR_FinderDef (const IR_FinderDef &);
  void operator= (const IR_FinderDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_FinderDef_Proxy_Impl
  : public virtual _TAO_OperationDef_Proxy_Impl
{
public:
  virtual ~_TAO_FinderDef_Proxy_Impl (void) { }

protected:
  _TAO_FinderDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_FinderDef_Remote_Proxy_Impl :
  public virtual _TAO_FinderDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_OperationDef_Remote_Proxy_Impl

{
public:
  _TAO_FinderDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_FinderDef_Remote_Proxy_Impl (void) { }

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_FinderDef_Proxy_Broker
{
public:
  virtual ~_TAO_FinderDef_Proxy_Broker (void);

  virtual _TAO_FinderDef_Proxy_Impl &select_proxy (
    IR_FinderDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_FinderDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_FinderDef_Remote_Proxy_Broker : public virtual _TAO_FinderDef_Proxy_Broker
{
public:
  _TAO_FinderDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_FinderDef_Remote_Proxy_Broker (void);

  virtual _TAO_FinderDef_Proxy_Impl &select_proxy (
    IR_FinderDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_FinderDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_FinderDef_Remote_Proxy_Broker *the_TAO_FinderDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

// Forward Classes Declaration
class _TAO_HomeDef_Proxy_Impl;
class _TAO_HomeDef_Remote_Proxy_Impl;
class _TAO_HomeDef_Proxy_Broker;
class _TAO_HomeDef_Remote_Proxy_Broker;

class TAO_Export IR_HomeDef: public virtual IR_InterfaceDef
{
public:
#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_HomeDef_ptr _ptr_type;
  typedef IR_HomeDef_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  // the static operations
  static IR_HomeDef_ptr _duplicate (IR_HomeDef_ptr obj);
  static IR_HomeDef_ptr _narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_HomeDef_ptr _unchecked_narrow (
      CORBA::Object_ptr obj,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  static IR_HomeDef_ptr _nil (void)
    {
      return (IR_HomeDef_ptr)0;
    }

  static void _tao_any_destructor (void*);

  virtual IR_HomeDef_ptr base_home   (
                  CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ComponentDef_ptr managed_component (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PrimaryKeyDef_ptr primary_key (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FactoryDefSeq * factories (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FinderDefSeq * finders (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_basic (
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PrimaryKeyDef_ptr create_primary_key (
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr primary_key,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FactoryDef_ptr create_factory (
      const char * id,
      const char * name,
      const char * version,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FinderDef_ptr create_finder (
      const char * id,
      const char * name,
      const char * version,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean _is_a (
      const CORBA::Char *type_id,
      CORBA::Environment &ACE_TRY_ENV =
        TAO_default_environment ()
    );
  virtual void *_tao_QueryInterface (ptr_arith_t type);

  virtual const char* _interface_repository_id (void) const;

private:
  _TAO_HomeDef_Proxy_Broker *the_TAO_HomeDef_Proxy_Broker_;

protected:
  IR_HomeDef (int collocated = 0);

protected:
  // This methods travese the inheritance tree and set the
  // parents piece of the given class in the right mode
  virtual void _tao_setup_collocation (int collocated);

  IR_HomeDef (
      TAO_Stub *objref,
      CORBA::Boolean _tao_collocated = 0,
      TAO_Abstract_ServantBase *servant = 0
    );

  friend class _TAO_HomeDef_Remote_Proxy_Impl;
  friend class _TAO_HomeDef_ThruPOA_Proxy_Impl;
  friend class _TAO_HomeDef_Direct_Proxy_Impl;

  virtual ~IR_HomeDef (void);
private:
  IR_HomeDef (const IR_HomeDef &);
  void operator= (const IR_HomeDef &);
};


// The Proxy Implementations are used by each interface to
// perform a call. Each different implementation encapsulate
// an invocation logics.


///////////////////////////////////////////////////////////////////////
//                    Base  Impl. Declaration
//

class TAO_Export _TAO_HomeDef_Proxy_Impl :
  public virtual _TAO_InterfaceDef_Proxy_Impl
{
public:
  virtual ~_TAO_HomeDef_Proxy_Impl (void) { }

  virtual IR_HomeDef_ptr base_home (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_ComponentDef_ptr managed_component (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_PrimaryKeyDef_ptr primary_key (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_FactoryDefSeq * factories (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_FinderDefSeq * finders   (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual CORBA::Boolean is_basic   (
      CORBA_Object *_collocated_tao_target_,
            CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_PrimaryKeyDef_ptr create_primary_key   (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr primary_key,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_FactoryDef_ptr create_factory   (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

  virtual IR_FinderDef_ptr create_finder   (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    )) = 0;

protected:
  _TAO_HomeDef_Proxy_Impl (void);

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                    Remote  Impl. Declaration
//

class TAO_Export _TAO_HomeDef_Remote_Proxy_Impl :
  public virtual _TAO_HomeDef_Proxy_Impl,
  public virtual TAO_Remote_Object_Proxy_Impl,
  public virtual _TAO_InterfaceDef_Remote_Proxy_Impl

{
public:
  _TAO_HomeDef_Remote_Proxy_Impl (void);

  virtual ~_TAO_HomeDef_Remote_Proxy_Impl (void) { }

  virtual IR_HomeDef_ptr base_home (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_ComponentDef_ptr managed_component (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PrimaryKeyDef_ptr primary_key (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FactoryDefSeq * factories (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FinderDefSeq * finders (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual CORBA::Boolean is_basic (
      CORBA_Object *_collocated_tao_target_,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_PrimaryKeyDef_ptr create_primary_key (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      IR_ValueDef_ptr primary_key,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FactoryDef_ptr create_factory (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual IR_FinderDef_ptr create_finder   (
      CORBA_Object *_collocated_tao_target_,
      const char * id,
      const char * name,
      const char * version,
      const IR_ParDescriptionSeq & params,
      const IR_ExceptionDefSeq & exceptions,
      CORBA::Environment &ACE_TRY_ENV
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

};

//
//                Base  Proxy Impl. Declaration
///////////////////////////////////////////////////////////////////////


// The Proxy Brokers are used by each interface to get
// the right proxy for performing a call. In the new
// collocation scheme, the proxy to be used can vary on
// a call by call basis.



///////////////////////////////////////////////////////////////////////
//                 Base Proxy Broker Declaration
//

class TAO_Export _TAO_HomeDef_Proxy_Broker
{
public:
  virtual ~_TAO_HomeDef_Proxy_Broker (void);

  virtual _TAO_HomeDef_Proxy_Impl &select_proxy (
    IR_HomeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  ) = 0;

protected:
  _TAO_HomeDef_Proxy_Broker (void);

};


//
//              End Base Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//                 Remote Proxy Broker Declaration
//

class TAO_Export _TAO_HomeDef_Remote_Proxy_Broker : public virtual _TAO_HomeDef_Proxy_Broker
{
public:
  _TAO_HomeDef_Remote_Proxy_Broker (void);

  virtual ~_TAO_HomeDef_Remote_Proxy_Broker (void);

  virtual _TAO_HomeDef_Proxy_Impl &select_proxy (
    IR_HomeDef *object,
    CORBA_Environment &ACE_TRY_ENV = TAO_default_environment ()
  );

private:
  _TAO_HomeDef_Remote_Proxy_Impl remote_proxy_impl_;
// This member function is used to get an handle to the unique instance
// of the Remote Proxy Broker that is available for a given
// interface.

public:
  static _TAO_HomeDef_Remote_Proxy_Broker *the_TAO_HomeDef_Remote_Proxy_Broker (void);
};

//
//              End Remote Proxy Broker Declaration
///////////////////////////////////////////////////////////////////////

struct TAO_Export IR_HomeDescription
{

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
  typedef IR_HomeDescription_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  static void _tao_any_destructor (void*);

  TAO_String_Manager name;
  TAO_String_Manager id;
  TAO_String_Manager defined_in;
  TAO_String_Manager version;
  TAO_String_Manager base_home;
  TAO_String_Manager managed_component;
  IR_PrimaryKeyDef_var primary_key_def;
  IR_FactoryDefSeq factories;
  IR_FinderDefSeq finders;
  IR_OpDescriptionSeq operations;
  IR_AttrDescriptionSeq attributes;
  CORBA::Boolean is_basic;
};

class TAO_Export IR_HomeDescription_var
{
public:
  IR_HomeDescription_var (void); // default constructor
  IR_HomeDescription_var (IR_HomeDescription *);
  IR_HomeDescription_var (const IR_HomeDescription_var &); // copy constructor
  ~IR_HomeDescription_var (void); // destructor

  IR_HomeDescription_var &operator= (IR_HomeDescription *);
  IR_HomeDescription_var &operator= (const IR_HomeDescription_var &);
  IR_HomeDescription *operator-> (void);
  const IR_HomeDescription *operator-> (void) const;

  operator const IR_HomeDescription &() const;
  operator IR_HomeDescription &();
  operator IR_HomeDescription &() const;
  operator IR_HomeDescription *&(); // variable-size types only

  // in, inout, out, _retn
  const IR_HomeDescription &in (void) const;
  IR_HomeDescription &inout (void);
  IR_HomeDescription *&out (void);
  IR_HomeDescription *_retn (void);
  IR_HomeDescription *ptr (void) const;

private:
  IR_HomeDescription *ptr_;
};

class TAO_Export IR_HomeDescription_out
{
public:
  IR_HomeDescription_out (IR_HomeDescription *&);
  IR_HomeDescription_out (IR_HomeDescription_var &);
  IR_HomeDescription_out (const IR_HomeDescription_out &);
  IR_HomeDescription_out &operator= (const IR_HomeDescription_out &);
  IR_HomeDescription_out &operator= (IR_HomeDescription *);
  operator IR_HomeDescription *&();
  IR_HomeDescription *&ptr (void);
  IR_HomeDescription *operator-> (void);

private:
  IR_HomeDescription *&ptr_;
  // assignment from T_var not allowed
  void operator= (const IR_HomeDescription_var &);
};

TAO_Export void operator<<= (CORBA::Any &, IR_DefinitionKind);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_DefinitionKind &);
extern TAO_Export _TAO_IRObject_Proxy_Broker * (*_TAO_IRObject_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface CORBA_IRObject
TAO_Export void operator<<= (CORBA::Any &, CORBA_IRObject_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, CORBA_IRObject *&);
extern TAO_Export _TAO_Contained_Proxy_Broker * (*_TAO_Contained_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_Contained
TAO_Export void operator<<= (CORBA::Any &, IR_Contained_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_Contained *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_Contained::Description &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_Contained::Description*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_Contained::Description *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_Contained::Description *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_InterfaceDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_InterfaceDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_InterfaceDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_InterfaceDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ValueDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ValueDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ValueDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ValueDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ComponentDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ComponentDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ComponentDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ComponentDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ProvidesDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ProvidesDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ProvidesDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ProvidesDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_UsesDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_UsesDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_UsesDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_UsesDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_HomeDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_HomeDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_HomeDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_HomeDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_EmitsDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_EmitsDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_EmitsDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_EmitsDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_PublishesDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_PublishesDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_PublishesDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_PublishesDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ConsumesDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ConsumesDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ConsumesDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ConsumesDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_FactoryDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_FactoryDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_FactoryDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_FactoryDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_FinderDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_FinderDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_FinderDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_FinderDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ContainedSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ContainedSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ContainedSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ContainedSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_StructMember &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_StructMember*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_StructMember *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_StructMember *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_StructMemberSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_StructMemberSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_StructMemberSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_StructMemberSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_Initializer &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_Initializer*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_Initializer *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_Initializer *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_InitializerSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_InitializerSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_InitializerSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_InitializerSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_UnionMember &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_UnionMember*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_UnionMember *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_UnionMember *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_UnionMemberSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_UnionMemberSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_UnionMemberSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_UnionMemberSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_EnumMemberSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_EnumMemberSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_EnumMemberSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_EnumMemberSeq *&);
extern TAO_Export _TAO_Container_Proxy_Broker * (*_TAO_Container_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_Container
TAO_Export void operator<<= (CORBA::Any &, IR_Container_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_Container *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_Container::Description &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_Container::Description*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_Container::Description *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_Container::Description *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_Container::DescriptionSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_Container::DescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_Container::DescriptionSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_Container::DescriptionSeq *&);
extern TAO_Export _TAO_IDLType_Proxy_Broker * (*_TAO_IDLType_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_IDLType
TAO_Export void operator<<= (CORBA::Any &, IR_IDLType_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_IDLType *&);
TAO_Export void operator<<= (CORBA::Any &, IR_PrimitiveKind);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_PrimitiveKind &);
extern TAO_Export _TAO_Repository_Proxy_Broker * (*_TAO_Repository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_Repository
TAO_Export void operator<<= (CORBA::Any &, IR_Repository_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_Repository *&);
extern TAO_Export _TAO_ComponentRepository_Proxy_Broker * (*_TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ComponentRepository
TAO_Export void operator<<= (CORBA::Any &, IR_ComponentRepository_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ComponentRepository *&);
extern TAO_Export _TAO_ModuleDef_Proxy_Broker * (*_TAO_ModuleDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ModuleDef
TAO_Export void operator<<= (CORBA::Any &, IR_ModuleDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ModuleDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ModuleDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ModuleDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ModuleDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ModuleDescription *&);
extern TAO_Export _TAO_ConstantDef_Proxy_Broker * (*_TAO_ConstantDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ConstantDef
TAO_Export void operator<<= (CORBA::Any &, IR_ConstantDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ConstantDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ConstantDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ConstantDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ConstantDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ConstantDescription *&);
extern TAO_Export _TAO_TypedefDef_Proxy_Broker * (*_TAO_TypedefDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_TypedefDef
TAO_Export void operator<<= (CORBA::Any &, IR_TypedefDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_TypedefDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_TypeDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_TypeDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_TypeDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_TypeDescription *&);
extern TAO_Export _TAO_StructDef_Proxy_Broker * (*_TAO_StructDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_StructDef
TAO_Export void operator<<= (CORBA::Any &, IR_StructDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_StructDef *&);
extern TAO_Export _TAO_UnionDef_Proxy_Broker * (*_TAO_UnionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_UnionDef
TAO_Export void operator<<= (CORBA::Any &, IR_UnionDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_UnionDef *&);
extern TAO_Export _TAO_EnumDef_Proxy_Broker * (*_TAO_EnumDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_EnumDef
TAO_Export void operator<<= (CORBA::Any &, IR_EnumDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_EnumDef *&);
extern TAO_Export _TAO_AliasDef_Proxy_Broker * (*_TAO_AliasDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_AliasDef
TAO_Export void operator<<= (CORBA::Any &, IR_AliasDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_AliasDef *&);
extern TAO_Export _TAO_NativeDef_Proxy_Broker * (*_TAO_NativeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_NativeDef
TAO_Export void operator<<= (CORBA::Any &, IR_NativeDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_NativeDef *&);
extern TAO_Export _TAO_PrimitiveDef_Proxy_Broker * (*_TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_PrimitiveDef
TAO_Export void operator<<= (CORBA::Any &, IR_PrimitiveDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_PrimitiveDef *&);
extern TAO_Export _TAO_StringDef_Proxy_Broker * (*_TAO_StringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_StringDef
TAO_Export void operator<<= (CORBA::Any &, IR_StringDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_StringDef *&);
extern TAO_Export _TAO_WstringDef_Proxy_Broker * (*_TAO_WstringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_WstringDef
TAO_Export void operator<<= (CORBA::Any &, IR_WstringDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_WstringDef *&);
extern TAO_Export _TAO_FixedDef_Proxy_Broker * (*_TAO_FixedDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_FixedDef
TAO_Export void operator<<= (CORBA::Any &, IR_FixedDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_FixedDef *&);
extern TAO_Export _TAO_SequenceDef_Proxy_Broker * (*_TAO_SequenceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_SequenceDef
TAO_Export void operator<<= (CORBA::Any &, IR_SequenceDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_SequenceDef *&);
extern TAO_Export _TAO_ArrayDef_Proxy_Broker * (*_TAO_ArrayDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ArrayDef
TAO_Export void operator<<= (CORBA::Any &, IR_ArrayDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ArrayDef *&);
extern TAO_Export _TAO_ExceptionDef_Proxy_Broker * (*_TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ExceptionDef
TAO_Export void operator<<= (CORBA::Any &, IR_ExceptionDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ExceptionDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ExceptionDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ExceptionDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ExceptionDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ExceptionDescription *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ExceptionDefSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ExceptionDefSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ExceptionDefSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ExceptionDefSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ExcDescriptionSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ExcDescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ExcDescriptionSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ExcDescriptionSeq *&);
TAO_Export void operator<<= (CORBA::Any &, IR_AttributeMode);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_AttributeMode &);
extern TAO_Export _TAO_AttributeDef_Proxy_Broker * (*_TAO_AttributeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_AttributeDef
TAO_Export void operator<<= (CORBA::Any &, IR_AttributeDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_AttributeDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_AttributeDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_AttributeDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_AttributeDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_AttributeDescription *&);
TAO_Export void operator<<= (CORBA::Any &, IR_OperationMode);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_OperationMode &);
TAO_Export void operator<<= (CORBA::Any &, IR_ParameterMode);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ParameterMode &);
TAO_Export void operator<<= (CORBA::Any &, const IR_ParameterDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ParameterDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ParameterDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ParameterDescription *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ParDescriptionSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ParDescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ParDescriptionSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ParDescriptionSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ContextIdSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ContextIdSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ContextIdSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ContextIdSeq *&);
extern TAO_Export _TAO_OperationDef_Proxy_Broker * (*_TAO_OperationDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_OperationDef
TAO_Export void operator<<= (CORBA::Any &, IR_OperationDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_OperationDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_OperationDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_OperationDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_OperationDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_OperationDescription *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_RepositoryIdSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_RepositoryIdSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_RepositoryIdSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_RepositoryIdSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_OpDescriptionSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_OpDescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_OpDescriptionSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_OpDescriptionSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_AttrDescriptionSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_AttrDescriptionSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_AttrDescriptionSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_AttrDescriptionSeq *&);
extern TAO_Export _TAO_InterfaceDef_Proxy_Broker * (*_TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_InterfaceDef
TAO_Export void operator<<= (CORBA::Any &, IR_InterfaceDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_InterfaceDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_InterfaceDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_InterfaceDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_InterfaceDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_InterfaceDescription *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ValueMember &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ValueMember*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ValueMember *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ValueMember *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ValueMemberSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ValueMemberSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ValueMemberSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ValueMemberSeq *&);
extern TAO_Export _TAO_ValueMemberDef_Proxy_Broker * (*_TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ValueMemberDef
TAO_Export void operator<<= (CORBA::Any &, IR_ValueMemberDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ValueMemberDef *&);
extern TAO_Export _TAO_ValueDef_Proxy_Broker * (*_TAO_ValueDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ValueDef
TAO_Export void operator<<= (CORBA::Any &, IR_ValueDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ValueDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ValueDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ValueDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ValueDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ValueDescription *&);
extern TAO_Export _TAO_ValueBoxDef_Proxy_Broker * (*_TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ValueBoxDef
TAO_Export void operator<<= (CORBA::Any &, IR_ValueBoxDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ValueBoxDef *&);
extern TAO_Export _TAO_ProvidesDef_Proxy_Broker * (*_TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ProvidesDef
TAO_Export void operator<<= (CORBA::Any &, IR_ProvidesDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ProvidesDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ProvidesDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ProvidesDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ProvidesDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ProvidesDescription *&);
extern TAO_Export _TAO_UsesDef_Proxy_Broker * (*_TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_UsesDef
TAO_Export void operator<<= (CORBA::Any &, IR_UsesDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_UsesDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_UsesDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_UsesDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_UsesDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_UsesDescription *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ProvidesDescSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ProvidesDescSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ProvidesDescSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ProvidesDescSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_UsesDescSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_UsesDescSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_UsesDescSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_UsesDescSeq *&);
extern TAO_Export _TAO_EventDef_Proxy_Broker * (*_TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_EventDef
TAO_Export void operator<<= (CORBA::Any &, IR_EventDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_EventDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_EventDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_EventDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_EventDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_EventDescription *&);
extern TAO_Export _TAO_EmitsDef_Proxy_Broker * (*_TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_EmitsDef
TAO_Export void operator<<= (CORBA::Any &, IR_EmitsDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_EmitsDef *&);
extern TAO_Export _TAO_PublishesDef_Proxy_Broker * (*_TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_PublishesDef
TAO_Export void operator<<= (CORBA::Any &, IR_PublishesDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_PublishesDef *&);
extern TAO_Export _TAO_ConsumesDef_Proxy_Broker * (*_TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ConsumesDef
TAO_Export void operator<<= (CORBA::Any &, IR_ConsumesDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ConsumesDef *&);
extern TAO_Export _TAO_ComponentDef_Proxy_Broker * (*_TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_ComponentDef
TAO_Export void operator<<= (CORBA::Any &, IR_ComponentDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ComponentDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_ComponentDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_ComponentDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_ComponentDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_ComponentDescription *&);
extern TAO_Export _TAO_PrimaryKeyDef_Proxy_Broker * (*_TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_PrimaryKeyDef
TAO_Export void operator<<= (CORBA::Any &, IR_PrimaryKeyDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_PrimaryKeyDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_PrimaryKeyDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_PrimaryKeyDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_PrimaryKeyDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_PrimaryKeyDescription *&);
extern TAO_Export _TAO_FactoryDef_Proxy_Broker * (*_TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_FactoryDef
TAO_Export void operator<<= (CORBA::Any &, IR_FactoryDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_FactoryDef *&);
extern TAO_Export _TAO_FinderDef_Proxy_Broker * (*_TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_FinderDef
TAO_Export void operator<<= (CORBA::Any &, IR_FinderDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_FinderDef *&);
extern TAO_Export _TAO_HomeDef_Proxy_Broker * (*_TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  );
// Any operators for interface IR_HomeDef
TAO_Export void operator<<= (CORBA::Any &, IR_HomeDef_ptr);
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_HomeDef *&);
TAO_Export void operator<<= (CORBA::Any &, const IR_HomeDescription &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IR_HomeDescription*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IR_HomeDescription *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IR_HomeDescription *&);

#ifndef __ACE_INLINE__

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_DefinitionKind &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_DefinitionKind &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const CORBA_IRObject_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, CORBA_IRObject_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_Contained_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_Contained_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_Contained::Description &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_Contained::Description &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_InterfaceDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_InterfaceDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ValueDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ValueDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ComponentDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ComponentDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ProvidesDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ProvidesDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_UsesDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_UsesDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_HomeDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_HomeDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_EmitsDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_EmitsDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_PublishesDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_PublishesDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ConsumesDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ConsumesDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_FactoryDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_FactoryDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_FinderDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_FinderDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ContainedSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ContainedSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_StructMember &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_StructMember &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_StructMemberSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_StructMemberSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_Initializer &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_Initializer &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_InitializerSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_InitializerSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_UnionMember &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_UnionMember &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_UnionMemberSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_UnionMemberSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_EnumMemberSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_EnumMemberSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_Container_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_Container_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_Container::Description &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_Container::Description &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_Container::DescriptionSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_Container::DescriptionSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_IDLType_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_IDLType_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_PrimitiveKind &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_PrimitiveKind &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_Repository_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_Repository_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ComponentRepository_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ComponentRepository_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ModuleDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ModuleDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ModuleDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ModuleDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ConstantDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ConstantDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ConstantDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ConstantDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_TypedefDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_TypedefDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_TypeDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_TypeDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_StructDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_StructDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_UnionDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_UnionDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_EnumDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_EnumDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_AliasDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_AliasDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_NativeDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_NativeDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_PrimitiveDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_PrimitiveDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_StringDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_StringDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_WstringDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_WstringDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_FixedDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_FixedDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_SequenceDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_SequenceDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ArrayDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ArrayDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ExceptionDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ExceptionDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ExceptionDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ExceptionDescription &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ExceptionDefSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ExceptionDefSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ExcDescriptionSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ExcDescriptionSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_AttributeMode &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::AttributeMode &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_AttributeDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_AttributeDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_AttributeDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_AttributeDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_OperationMode &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::OperationMode &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ParameterMode &); //
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR::ParameterMode &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ParameterDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ParameterDescription &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ParDescriptionSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ParDescriptionSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ContextIdSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ContextIdSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_OperationDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_OperationDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_OperationDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_OperationDescription &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_RepositoryIdSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_RepositoryIdSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_OpDescriptionSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_OpDescriptionSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_AttrDescriptionSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_AttrDescriptionSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_InterfaceDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_InterfaceDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_InterfaceDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_InterfaceDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ValueMember &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ValueMember &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ValueMemberSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ValueMemberSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ValueMemberDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ValueMemberDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ValueDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ValueDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ValueDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ValueDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ValueBoxDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ValueBoxDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ProvidesDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ProvidesDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ProvidesDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ProvidesDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_UsesDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_UsesDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_UsesDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_UsesDescription &);

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_ProvidesDescSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_ProvidesDescSeq &
  );

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IR_UsesDescSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IR_UsesDescSeq &
  );

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_EventDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_EventDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_EventDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_EventDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_EmitsDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_EmitsDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_PublishesDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_PublishesDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ConsumesDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ConsumesDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ComponentDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ComponentDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_ComponentDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_ComponentDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_PrimaryKeyDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_PrimaryKeyDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_PrimaryKeyDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_PrimaryKeyDescription &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_FactoryDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_FactoryDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_FinderDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_FinderDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_HomeDef_ptr );
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_HomeDef_ptr &);
TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IR_HomeDescription &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IR_HomeDescription &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "InterfaceC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#endif /* TAO_HAS_INTERFACE_REPOSITORY == 1 */
#include "ace/post.h"
#endif /* ifndef */
