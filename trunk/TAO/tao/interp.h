// This may look like C, but it's really -*- C++ -*-
// $Id$

// ============================================================================
//
// = LIBRARY
//    TAO
//
// = FILENAME
//    interp.h
//
// = DESCRIPTION
//    Header file for TAO's IIOP interpreter.
//
// = AUTHOR
//     Douglas C. Schmidt
//
// ============================================================================

#if !defined (TAO_INTERP_H)
#define TAO_INTERP_H

class TAO_Export TAO_Interp
{
  // = TITLE
  //   TAO's CORBA TypeCode interpreter, which traverses GIOP/IIOP
  //   data structures.
  //
  // = DESCRIPTION
  //   This uses the standard C/C++ representation for data, and knows
  //   how to do things like align and pad according to standard
  //   rules.  It is driven by CDR marshaled representations of
  //   TypeCodes.
  //
  //   It does two key things: (a) calculate size and alignment
  //   restrictions for the data type described by any given typecode;
  //   and (b) "visits" each element of a data type in the order those
  //   elements are defined in the type's IDL definition.
  //
  //   A typical use is that some application-specific "visit"
  //   function will be called with a typecode and data value.  Then
  //   that "visit" function may choose to use the interpreter's
  //   knowledge of the environment's size, padding, and alignment
  //   rules to help it examine each of the constituents of complex
  //   data values.  It does so by making a call to
  //   <TypeCode::traverse>, and passing itself for future recursive
  //   calls.
  //
  //   NOTE that this module has system dependent parts, and so should
  //   be examined when porting to new CPU architectures, compilers,
  //   and so forth to make sure it correctly implements the
  //   appropriate binary interfaces.
  //
  //   Issues of concern are primarily that sizes and representations
  //   of CORBA primitive data types are correct (key issues are
  //   verified when the ORB initializes) and that the alignment rules
  //   are recognized.
  //
  //   Also, exceptions have vtables in them, which may cause trouble
  //   if they aren't located at the very beginning by the compiler in
  //   question.
  //
  //   So for example, moving to another CPU architecture which still
  //   uses standard sized two's complement integers and IEEE floating
  //   point, and expects "natural" alignment, won't be hard.  Even
  //   using PC style tightly packed data is simple; the alignment
  //   rules are just simpler.  Most volume microprocessors used in
  //   1995 are correctly supported.
  //
  //   Using data representations that are far from the standard C/C++
  //   style data layout is probably not practical with this
  //   implementation.  LISP systems, as one example, probably won't
  //   use "in-memory" representations much like C/C++, even though
  //   its "wire form" could directly match CDR.
  //
  //   ALSO, the treatment of exceptions may need to be examined in
  //   language environments which actually rely on C++ exceptions.
  //   The RTTI data that identifies exceptions can easily be ignored
  //   by this interpreter (if it's taught about that compiler's RTTI)
  //   but it may not be practical for any code not generated by that
  //   specific C++ compiler to store such data in the right place to
  //   look like a C++ exception, or to throw exceptions when that's
  //   needed.  (RTTI == "Run Time Typing Information", needed to make
  //   C++ exceptions work correctly and partially exposed to users by
  //   the ANSI standards comittee.  It provides type-safe
  //   "downcasting" and other features previously unavailable in
  //   C++.)
  //
  //   THREADING NOTE: Data structures being traversed should only be
  //   modified by the thread doing the traversal.  The interpretive
  //   code itself is reentrant (recursive!) so presents no threading
  //   issues; only the data being fed to the interpreter must be
  //   protected against concurrency.
public:
  static void init_table (void);
  // Initialize TAO's TypeCode table.



private:
  struct Table_Element
  {
    size_t size_;
    size_t alignment_;
    attribute_calculator *calc_;
    param_skip_rtn *skipper_;
  };

  static Table_Element table_[CORBA::TC_KIND_COUNT];
  // Table supporting calculation of size and alignment requirements
  // for any one instance of a given data types.
  //
  // This is indexed via CDR's TCKind values, which are "frozen" as
  // part of the CDR standard.  Entries hold either the size and
  // alignment values for that data type, or a pointer to a function
  // that is used to calculate those values.  Function pointers are
  // normally needed only for constructed types.
  //
  // A "skipper" routine is provided for some data types whose size is
  // known statically (e.g. objrefs, structures, strings) but whose
  // typecodes have parameters that sometimes need to be ignored when
  // found in a CDR stream.  Any attribute calculator routine always
  // skips parameters in the CDR input stream, so no type with such a
  // routine also needs a "skipper".
  //
  // Rather than growing a set of processor-specific #ifdefs, we
  // calculate most of this table (except functions) at ORB
  // initialization time.
};

#endif /* TAO_INTERP_H */
