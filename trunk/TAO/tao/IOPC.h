// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#ifndef _TAO_IDL_ORIG_IOPC_H_
#define _TAO_IDL_ORIG_IOPC_H_

#include "ace/pre.h"
#include "TAO_Export.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

#include "Any.h"
#include "Object.h"
#include "Exception.h"
#include "CDR.h"
#include "Sequence.h"

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO TAO_Export

#if defined (TAO_EXPORT_NESTED_CLASSES)
#  if defined (TAO_EXPORT_NESTED_MACRO)
#    undef TAO_EXPORT_NESTED_MACRO
#  endif /* defined (TAO_EXPORT_NESTED_MACRO) */
#  define TAO_EXPORT_NESTED_MACRO TAO_Export
#endif /* TAO_EXPORT_NESTED_CLASSES */

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#endif /* _MSC_VER >= 1200 */
#pragma warning(disable:4250)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option push -w-rvl -w-rch -w-ccc -w-inl
#endif /* __BORLANDC__ */

#if defined (IOR)
#undef IOR
#endif /* IOR */

TAO_NAMESPACE  IOP
{
  typedef CORBA::ULong ProfileId;
  typedef CORBA::ULong_out ProfileId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ProfileId;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_INTERNET_IOP;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_MULTIPLE_COMPONENTS;

  struct TaggedProfile;
  class TaggedProfile_var;

  struct TAO_Export TaggedProfile
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TaggedProfile_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (IOP, ProfileId) tag;

#if !defined (_IOP_TAGGEDPROFILE__TAO_SEQ_OCTET_CH_)
#define _IOP_TAGGEDPROFILE__TAO_SEQ_OCTET_CH_

    class _tao_seq_Octet;
    class _tao_seq_Octet_var;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release = 0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_Octet_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */

    };

#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _profile_data_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          _tao_seq_Octet profile_data;
  };

  class TAO_Export TaggedProfile_var
  {
  public:
    TaggedProfile_var (void); // default constructor
    TaggedProfile_var (TaggedProfile *);
    TaggedProfile_var (const TaggedProfile_var &); // copy constructor
    ~TaggedProfile_var (void); // destructor

    TaggedProfile_var &operator= (TaggedProfile *);
    TaggedProfile_var &operator= (const TaggedProfile_var &);
    TaggedProfile *operator-> (void);
    const TaggedProfile *operator-> (void) const;

    operator const TaggedProfile &() const;
    operator TaggedProfile &();
    operator TaggedProfile &() const;
    operator TaggedProfile *&(); // variable-size types only

    // in, inout, out, _retn
    const TaggedProfile &in (void) const;
    TaggedProfile &inout (void);
    TaggedProfile *&out (void);
    TaggedProfile *_retn (void);
    TaggedProfile *ptr (void) const;

  private:
    TaggedProfile *ptr_;
  };

  class TAO_Export TaggedProfile_out
  {
  public:
    TaggedProfile_out (TaggedProfile *&);
    TaggedProfile_out (TaggedProfile_var &);
    TaggedProfile_out (const TaggedProfile_out &);
    TaggedProfile_out &operator= (const TaggedProfile_out &);
    TaggedProfile_out &operator= (TaggedProfile *);
    operator TaggedProfile *&();
    TaggedProfile *&ptr (void);
    TaggedProfile *operator-> (void);

  private:
    TaggedProfile *&ptr_;
    // assignment from T_var not allowed
    void operator= (const TaggedProfile_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TaggedProfile;

  struct IOR;
  class IOR_var;

  struct TAO_Export IOR
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef IOR_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    TAO_String_Manager type_id;

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IOP_IOR__TAO_SEQ_TAGGEDPROFILE_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IOP_IOR__TAO_SEQ_TAGGEDPROFILE_CH_

      class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile : public TAO_Unbounded_Base_Sequence
      {
      public:
        // = Initialization and termination methods.

        _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile (void); // Default constructor.
        _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile (CORBA::ULong maximum);
        _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile (CORBA::ULong maximum,
          CORBA::ULong length,
          ACE_NESTED_CLASS (IOP, TaggedProfile) *data,
          CORBA::Boolean release = 0);
        _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile (const _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile &rhs);
        _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile &operator= (const _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile &rhs);
        virtual ~_TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile (void); // Dtor.
        // = Accessors.
        ACE_NESTED_CLASS (IOP, TaggedProfile) &operator[] (CORBA::ULong i);
        const ACE_NESTED_CLASS (IOP, TaggedProfile) &operator[] (CORBA::ULong i) const;
        // = Static operations.
        static ACE_NESTED_CLASS (IOP, TaggedProfile) *allocbuf (CORBA::ULong size);
        static void freebuf (ACE_NESTED_CLASS (IOP, TaggedProfile) *buffer);
        virtual void _allocate_buffer (CORBA::ULong length);
        virtual void _deallocate_buffer (void);
        // Implement the TAO_Base_Sequence methods (see Sequence.h)

        ACE_NESTED_CLASS (IOP, TaggedProfile) *get_buffer (CORBA::Boolean orphan = 0);
        const ACE_NESTED_CLASS (IOP, TaggedProfile) *get_buffer (void) const;
        void replace (CORBA::ULong max,
          CORBA::ULong length,
          ACE_NESTED_CLASS (IOP, TaggedProfile) *data,
          CORBA::Boolean release);
      };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IOP_IOR__TAO_SEQ_TAGGEDPROFILE_CH_)
#define _IOP_IOR__TAO_SEQ_TAGGEDPROFILE_CH_

    class _tao_seq_TaggedProfile;
    class _tao_seq_TaggedProfile_var;

    // *************************************************************
    // _tao_seq_TaggedProfile
    // *************************************************************

    class TAO_Export _tao_seq_TaggedProfile : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      _TAO_Unbounded_Sequence_IOP_IOR__tao_seq_TaggedProfile
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<ACE_NESTED_CLASS (IOP, TaggedProfile)>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      _tao_seq_TaggedProfile (void); // default ctor
      _tao_seq_TaggedProfile (CORBA::ULong max); // uses max size
      _tao_seq_TaggedProfile (
        CORBA::ULong max,
        CORBA::ULong length,
        ACE_NESTED_CLASS (IOP, TaggedProfile) *buffer,
        CORBA::Boolean release = 0
      );
      _tao_seq_TaggedProfile (const _tao_seq_TaggedProfile &); // copy ctor
      ~_tao_seq_TaggedProfile (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_TaggedProfile_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    };

#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_TaggedProfile _profiles_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          _tao_seq_TaggedProfile profiles;
  };

  class TAO_Export IOR_var
  {
  public:
    IOR_var (void); // default constructor
    IOR_var (IOR *);
    IOR_var (const IOR_var &); // copy constructor
    ~IOR_var (void); // destructor

    IOR_var &operator= (IOR *);
    IOR_var &operator= (const IOR_var &);
    IOR *operator-> (void);
    const IOR *operator-> (void) const;

    operator const IOR &() const;
    operator IOR &();
    operator IOR &() const;
    operator IOR *&(); // variable-size types only

    // in, inout, out, _retn
    const IOR &in (void) const;
    IOR &inout (void);
    IOR *&out (void);
    IOR *_retn (void);
    IOR *ptr (void) const;

  private:
    IOR *ptr_;
  };

  class TAO_Export IOR_out
  {
  public:
    IOR_out (IOR *&);
    IOR_out (IOR_var &);
    IOR_out (const IOR_out &);
    IOR_out &operator= (const IOR_out &);
    IOR_out &operator= (IOR *);
    operator IOR *&();
    IOR *&ptr (void);
    IOR *operator-> (void);

  private:
    IOR *&ptr_;
    // assignment from T_var not allowed
    void operator= (const IOR_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_IOR;

  typedef CORBA::ULong ComponentId;
  typedef CORBA::ULong_out ComponentId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ComponentId;

  struct TaggedComponent;
  class TaggedComponent_var;

  struct TAO_Export TaggedComponent
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TaggedComponent_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (IOP, ComponentId) tag;

#if !defined (_IOP_TAGGEDCOMPONENT__TAO_SEQ_OCTET_CH_)
#define _IOP_TAGGEDCOMPONENT__TAO_SEQ_OCTET_CH_

    class _tao_seq_Octet;
    class _tao_seq_Octet_var;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release = 0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_Octet_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */

    };

#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _component_data_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          _tao_seq_Octet component_data;
  };

  class TAO_Export TaggedComponent_var
  {
  public:
    TaggedComponent_var (void); // default constructor
    TaggedComponent_var (TaggedComponent *);
    TaggedComponent_var (const TaggedComponent_var &); // copy constructor
    ~TaggedComponent_var (void); // destructor

    TaggedComponent_var &operator= (TaggedComponent *);
    TaggedComponent_var &operator= (const TaggedComponent_var &);
    TaggedComponent *operator-> (void);
    const TaggedComponent *operator-> (void) const;

    operator const TaggedComponent &() const;
    operator TaggedComponent &();
    operator TaggedComponent &() const;
    operator TaggedComponent *&(); // variable-size types only

    // in, inout, out, _retn
    const TaggedComponent &in (void) const;
    TaggedComponent &inout (void);
    TaggedComponent *&out (void);
    TaggedComponent *_retn (void);
    TaggedComponent *ptr (void) const;

  private:
    TaggedComponent *ptr_;
  };

  class TAO_Export TaggedComponent_out
  {
  public:
    TaggedComponent_out (TaggedComponent *&);
    TaggedComponent_out (TaggedComponent_var &);
    TaggedComponent_out (const TaggedComponent_out &);
    TaggedComponent_out &operator= (const TaggedComponent_out &);
    TaggedComponent_out &operator= (TaggedComponent *);
    operator TaggedComponent *&();
    TaggedComponent *&ptr (void);
    TaggedComponent *operator-> (void);

  private:
    TaggedComponent *&ptr_;
    // assignment from T_var not allowed
    void operator= (const TaggedComponent_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TaggedComponent;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IOP_MULTIPLECOMPONENTPROFILE_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IOP_MULTIPLECOMPONENTPROFILE_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile (void); // Default constructor.
      _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile (CORBA::ULong maximum,
        CORBA::ULong length,
        TaggedComponent *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile (const _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile &rhs);
      _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile &operator= (const _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile &rhs);
      virtual ~_TAO_Unbounded_Sequence_IOP_MultipleComponentProfile (void); // Dtor.
      // = Accessors.
      TaggedComponent &operator[] (CORBA::ULong i);
      const TaggedComponent &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static TaggedComponent *allocbuf (CORBA::ULong size);
      static void freebuf (TaggedComponent *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      TaggedComponent *get_buffer (CORBA::Boolean orphan = 0);
      const TaggedComponent *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        TaggedComponent *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IOP_MULTIPLECOMPONENTPROFILE_CH_)
#define _IOP_MULTIPLECOMPONENTPROFILE_CH_

  class MultipleComponentProfile;
  class MultipleComponentProfile_var;

  // *************************************************************
  // MultipleComponentProfile
  // *************************************************************

  class TAO_Export MultipleComponentProfile : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_IOP_MultipleComponentProfile
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<TaggedComponent>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    MultipleComponentProfile (void); // default ctor
    MultipleComponentProfile (CORBA::ULong max); // uses max size
    MultipleComponentProfile (
      CORBA::ULong max,
      CORBA::ULong length,
      TaggedComponent *buffer,
      CORBA::Boolean release = 0
    );
    MultipleComponentProfile (const MultipleComponentProfile &); // copy ctor
    ~MultipleComponentProfile (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef MultipleComponentProfile_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };

#endif /* end #if !defined */


#if !defined (_IOP_MULTIPLECOMPONENTPROFILE___VAR_CH_)
#define _IOP_MULTIPLECOMPONENTPROFILE___VAR_CH_

  // *************************************************************
  // class IOP::MultipleComponentProfile_var
  // *************************************************************

  class TAO_Export MultipleComponentProfile_var
  {
  public:
    MultipleComponentProfile_var (void); // default constructor
    MultipleComponentProfile_var (MultipleComponentProfile *);
    MultipleComponentProfile_var (const MultipleComponentProfile_var &); // copy constructor
    ~MultipleComponentProfile_var (void); // destructor

    MultipleComponentProfile_var &operator= (MultipleComponentProfile *);
    MultipleComponentProfile_var &operator= (const MultipleComponentProfile_var &);
    MultipleComponentProfile *operator-> (void);
    const MultipleComponentProfile *operator-> (void) const;

    operator const MultipleComponentProfile &() const;
    operator MultipleComponentProfile &();
    operator MultipleComponentProfile &() const;
    operator MultipleComponentProfile *&(); // variable-size base types only

    TaggedComponent & operator[] (CORBA::ULong index);
    const TaggedComponent & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const MultipleComponentProfile &in (void) const;
    MultipleComponentProfile &inout (void);
    MultipleComponentProfile *&out (void);
    MultipleComponentProfile *_retn (void);
    MultipleComponentProfile *ptr (void) const;

  private:
    MultipleComponentProfile *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_IOP_MULTIPLECOMPONENTPROFILE___OUT_CH_)
#define _IOP_MULTIPLECOMPONENTPROFILE___OUT_CH_

  class TAO_Export MultipleComponentProfile_out
  {
  public:
    MultipleComponentProfile_out (MultipleComponentProfile *&);
    MultipleComponentProfile_out (MultipleComponentProfile_var &);
    MultipleComponentProfile_out (const MultipleComponentProfile_out &);
    MultipleComponentProfile_out &operator= (const MultipleComponentProfile_out &);
    MultipleComponentProfile_out &operator= (MultipleComponentProfile *);
    operator MultipleComponentProfile *&();
    MultipleComponentProfile *&ptr (void);
    MultipleComponentProfile *operator-> (void);
    TaggedComponent & operator[] (CORBA::ULong index);

  private:
    MultipleComponentProfile *&ptr_;
    // assignment from T_var not allowed
    void operator= (const MultipleComponentProfile_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_MultipleComponentProfile;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IOP_TAGGEDCOMPONENTLIST_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IOP_TAGGEDCOMPONENTLIST_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IOP_TaggedComponentList : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_IOP_TaggedComponentList (void); // Default constructor.
      _TAO_Unbounded_Sequence_IOP_TaggedComponentList (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_IOP_TaggedComponentList (CORBA::ULong maximum,
        CORBA::ULong length,
        TaggedComponent *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_IOP_TaggedComponentList (const _TAO_Unbounded_Sequence_IOP_TaggedComponentList &rhs);
      _TAO_Unbounded_Sequence_IOP_TaggedComponentList &operator= (const _TAO_Unbounded_Sequence_IOP_TaggedComponentList &rhs);
      virtual ~_TAO_Unbounded_Sequence_IOP_TaggedComponentList (void); // Dtor.
      // = Accessors.
      TaggedComponent &operator[] (CORBA::ULong i);
      const TaggedComponent &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static TaggedComponent *allocbuf (CORBA::ULong size);
      static void freebuf (TaggedComponent *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      TaggedComponent *get_buffer (CORBA::Boolean orphan = 0);
      const TaggedComponent *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        TaggedComponent *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IOP_TAGGEDCOMPONENTLIST_CH_)
#define _IOP_TAGGEDCOMPONENTLIST_CH_

  class TaggedComponentList;
  class TaggedComponentList_var;

  // *************************************************************
  // TaggedComponentList
  // *************************************************************

  class TAO_Export TaggedComponentList : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_IOP_TaggedComponentList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<TaggedComponent>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    TaggedComponentList (void); // default ctor
    TaggedComponentList (CORBA::ULong max); // uses max size
    TaggedComponentList (
      CORBA::ULong max,
      CORBA::ULong length,
      TaggedComponent *buffer,
      CORBA::Boolean release = 0
    );
    TaggedComponentList (const TaggedComponentList &); // copy ctor
    ~TaggedComponentList (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TaggedComponentList_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };

#endif /* end #if !defined */


#if !defined (_IOP_TAGGEDCOMPONENTLIST___VAR_CH_)
#define _IOP_TAGGEDCOMPONENTLIST___VAR_CH_

  // *************************************************************
  // class IOP::TaggedComponentList_var
  // *************************************************************

  class TAO_Export TaggedComponentList_var
  {
  public:
    TaggedComponentList_var (void); // default constructor
    TaggedComponentList_var (TaggedComponentList *);
    TaggedComponentList_var (const TaggedComponentList_var &); // copy constructor
    ~TaggedComponentList_var (void); // destructor

    TaggedComponentList_var &operator= (TaggedComponentList *);
    TaggedComponentList_var &operator= (const TaggedComponentList_var &);
    TaggedComponentList *operator-> (void);
    const TaggedComponentList *operator-> (void) const;

    operator const TaggedComponentList &() const;
    operator TaggedComponentList &();
    operator TaggedComponentList &() const;
    operator TaggedComponentList *&(); // variable-size base types only

    TaggedComponent & operator[] (CORBA::ULong index);
    const TaggedComponent & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const TaggedComponentList &in (void) const;
    TaggedComponentList &inout (void);
    TaggedComponentList *&out (void);
    TaggedComponentList *_retn (void);
    TaggedComponentList *ptr (void) const;

  private:
    TaggedComponentList *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_IOP_TAGGEDCOMPONENTLIST___OUT_CH_)
#define _IOP_TAGGEDCOMPONENTLIST___OUT_CH_

  class TAO_Export TaggedComponentList_out
  {
  public:
    TaggedComponentList_out (TaggedComponentList *&);
    TaggedComponentList_out (TaggedComponentList_var &);
    TaggedComponentList_out (const TaggedComponentList_out &);
    TaggedComponentList_out &operator= (const TaggedComponentList_out &);
    TaggedComponentList_out &operator= (TaggedComponentList *);
    operator TaggedComponentList *&();
    TaggedComponentList *&ptr (void);
    TaggedComponentList *operator-> (void);
    TaggedComponent & operator[] (CORBA::ULong index);

  private:
    TaggedComponentList *&ptr_;
    // assignment from T_var not allowed
    void operator= (const TaggedComponentList_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TaggedComponentList;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IOP_TAGGEDCOMPONENTSEQ_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IOP_TAGGEDCOMPONENTSEQ_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq (void); // Default constructor.
      _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq (CORBA::ULong maximum,
        CORBA::ULong length,
        TaggedComponent *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq (const _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq &rhs);
      _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq &operator= (const _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq &rhs);
      virtual ~_TAO_Unbounded_Sequence_IOP_TaggedComponentSeq (void); // Dtor.
      // = Accessors.
      TaggedComponent &operator[] (CORBA::ULong i);
      const TaggedComponent &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static TaggedComponent *allocbuf (CORBA::ULong size);
      static void freebuf (TaggedComponent *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      TaggedComponent *get_buffer (CORBA::Boolean orphan = 0);
      const TaggedComponent *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        TaggedComponent *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IOP_TAGGEDCOMPONENTSEQ_CH_)
#define _IOP_TAGGEDCOMPONENTSEQ_CH_

  class TaggedComponentSeq;
  class TaggedComponentSeq_var;

  // *************************************************************
  // TaggedComponentSeq
  // *************************************************************

  class TAO_Export TaggedComponentSeq : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_IOP_TaggedComponentSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<TaggedComponent>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    TaggedComponentSeq (void); // default ctor
    TaggedComponentSeq (CORBA::ULong max); // uses max size
    TaggedComponentSeq (
      CORBA::ULong max,
      CORBA::ULong length,
      TaggedComponent *buffer,
      CORBA::Boolean release = 0
    );
    TaggedComponentSeq (const TaggedComponentSeq &); // copy ctor
    ~TaggedComponentSeq (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef TaggedComponentSeq_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };

#endif /* end #if !defined */


#if !defined (_IOP_TAGGEDCOMPONENTSEQ___VAR_CH_)
#define _IOP_TAGGEDCOMPONENTSEQ___VAR_CH_

  // *************************************************************
  // class IOP::TaggedComponentSeq_var
  // *************************************************************

  class TAO_Export TaggedComponentSeq_var
  {
  public:
    TaggedComponentSeq_var (void); // default constructor
    TaggedComponentSeq_var (TaggedComponentSeq *);
    TaggedComponentSeq_var (const TaggedComponentSeq_var &); // copy constructor
    ~TaggedComponentSeq_var (void); // destructor

    TaggedComponentSeq_var &operator= (TaggedComponentSeq *);
    TaggedComponentSeq_var &operator= (const TaggedComponentSeq_var &);
    TaggedComponentSeq *operator-> (void);
    const TaggedComponentSeq *operator-> (void) const;

    operator const TaggedComponentSeq &() const;
    operator TaggedComponentSeq &();
    operator TaggedComponentSeq &() const;
    operator TaggedComponentSeq *&(); // variable-size base types only

    TaggedComponent & operator[] (CORBA::ULong index);
    const TaggedComponent & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const TaggedComponentSeq &in (void) const;
    TaggedComponentSeq &inout (void);
    TaggedComponentSeq *&out (void);
    TaggedComponentSeq *_retn (void);
    TaggedComponentSeq *ptr (void) const;

  private:
    TaggedComponentSeq *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_IOP_TAGGEDCOMPONENTSEQ___OUT_CH_)
#define _IOP_TAGGEDCOMPONENTSEQ___OUT_CH_

  class TAO_Export TaggedComponentSeq_out
  {
  public:
    TaggedComponentSeq_out (TaggedComponentSeq *&);
    TaggedComponentSeq_out (TaggedComponentSeq_var &);
    TaggedComponentSeq_out (const TaggedComponentSeq_out &);
    TaggedComponentSeq_out &operator= (const TaggedComponentSeq_out &);
    TaggedComponentSeq_out &operator= (TaggedComponentSeq *);
    operator TaggedComponentSeq *&();
    TaggedComponentSeq *&ptr (void);
    TaggedComponentSeq *operator-> (void);
    TaggedComponent & operator[] (CORBA::ULong index);

  private:
    TaggedComponentSeq *&ptr_;
    // assignment from T_var not allowed
    void operator= (const TaggedComponentSeq_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_TaggedComponentSeq;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_ORB_TYPE;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_CODE_SETS;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_POLICIES;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_ALTERNATE_IIOP_ADDRESS;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_COMPLETE_OBJECT_KEY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_ENDPOINT_ID_POSITION;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_LOCATION_POLICY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_DCE_STRING_BINDING;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_DCE_BINDING_NAME;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_DCE_NO_PIPES;

  typedef CORBA::ULong ServiceId;
  typedef CORBA::ULong_out ServiceId_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ServiceId;

  struct ServiceContext;
  class ServiceContext_var;

  struct TAO_Export ServiceContext
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ServiceContext_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (IOP, ServiceId) context_id;

#if !defined (_IOP_SERVICECONTEXT__TAO_SEQ_OCTET_CH_)
#define _IOP_SERVICECONTEXT__TAO_SEQ_OCTET_CH_

    class _tao_seq_Octet;
    class _tao_seq_Octet_var;

    // *************************************************************
    // _tao_seq_Octet
    // *************************************************************

    class TAO_Export _tao_seq_Octet : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
      TAO_Unbounded_Sequence<CORBA::Octet>
#else /* TAO_USE_SEQUENCE_TEMPLATES */
      TAO_Unbounded_Sequence<CORBA::Octet>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
    {
    public:
      _tao_seq_Octet (void); // default ctor
      _tao_seq_Octet (CORBA::ULong max); // uses max size
      _tao_seq_Octet (
        CORBA::ULong max,
        CORBA::ULong length,
        CORBA::Octet *buffer,
        CORBA::Boolean release = 0
      );
      _tao_seq_Octet (const _tao_seq_Octet &); // copy ctor
      ~_tao_seq_Octet (void);
      static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
      typedef _tao_seq_Octet_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */


#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
      _tao_seq_Octet (
          CORBA::ULong length,
          const ACE_Message_Block* mb
        )
        : TAO_Unbounded_Sequence<CORBA::Octet> (length, mb) {}
#endif /* TAO_NO_COPY_OCTET_SEQUENCE == 1 */

    };

#endif /* end #if !defined */

#if !defined (__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef _tao_seq_Octet _context_data_seq;
  #endif /* ! __GNUC__ || ACE_HAS_GNUG_PRE_2_8 */

          _tao_seq_Octet context_data;
  };

  class TAO_Export ServiceContext_var
  {
  public:
    ServiceContext_var (void); // default constructor
    ServiceContext_var (ServiceContext *);
    ServiceContext_var (const ServiceContext_var &); // copy constructor
    ~ServiceContext_var (void); // destructor

    ServiceContext_var &operator= (ServiceContext *);
    ServiceContext_var &operator= (const ServiceContext_var &);
    ServiceContext *operator-> (void);
    const ServiceContext *operator-> (void) const;

    operator const ServiceContext &() const;
    operator ServiceContext &();
    operator ServiceContext &() const;
    operator ServiceContext *&(); // variable-size types only

    // in, inout, out, _retn
    const ServiceContext &in (void) const;
    ServiceContext &inout (void);
    ServiceContext *&out (void);
    ServiceContext *_retn (void);
    ServiceContext *ptr (void) const;

  private:
    ServiceContext *ptr_;
  };

  class TAO_Export ServiceContext_out
  {
  public:
    ServiceContext_out (ServiceContext *&);
    ServiceContext_out (ServiceContext_var &);
    ServiceContext_out (const ServiceContext_out &);
    ServiceContext_out &operator= (const ServiceContext_out &);
    ServiceContext_out &operator= (ServiceContext *);
    operator ServiceContext *&();
    ServiceContext *&ptr (void);
    ServiceContext *operator-> (void);

  private:
    ServiceContext *&ptr_;
    // assignment from T_var not allowed
    void operator= (const ServiceContext_var &);
  };

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ServiceContext;


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)

#if !defined (__TAO_UNBOUNDED_SEQUENCE_IOP_SERVICECONTEXTLIST_CH_)
#define __TAO_UNBOUNDED_SEQUENCE_IOP_SERVICECONTEXTLIST_CH_

    class TAO_EXPORT_NESTED_MACRO _TAO_Unbounded_Sequence_IOP_ServiceContextList : public TAO_Unbounded_Base_Sequence
    {
    public:
      // = Initialization and termination methods.

      _TAO_Unbounded_Sequence_IOP_ServiceContextList (void); // Default constructor.
      _TAO_Unbounded_Sequence_IOP_ServiceContextList (CORBA::ULong maximum);
      _TAO_Unbounded_Sequence_IOP_ServiceContextList (CORBA::ULong maximum,
        CORBA::ULong length,
        ServiceContext *data,
        CORBA::Boolean release = 0);
      _TAO_Unbounded_Sequence_IOP_ServiceContextList (const _TAO_Unbounded_Sequence_IOP_ServiceContextList &rhs);
      _TAO_Unbounded_Sequence_IOP_ServiceContextList &operator= (const _TAO_Unbounded_Sequence_IOP_ServiceContextList &rhs);
      virtual ~_TAO_Unbounded_Sequence_IOP_ServiceContextList (void); // Dtor.
      // = Accessors.
      ServiceContext &operator[] (CORBA::ULong i);
      const ServiceContext &operator[] (CORBA::ULong i) const;
      // = Static operations.
      static ServiceContext *allocbuf (CORBA::ULong size);
      static void freebuf (ServiceContext *buffer);
      virtual void _allocate_buffer (CORBA::ULong length);
      virtual void _deallocate_buffer (void);
      // Implement the TAO_Base_Sequence methods (see Sequence.h)

      ServiceContext *get_buffer (CORBA::Boolean orphan = 0);
      const ServiceContext *get_buffer (void) const;
      void replace (CORBA::ULong max,
        CORBA::ULong length,
        ServiceContext *data,
        CORBA::Boolean release);
    };

#endif /* end #if !defined */


#endif /* !TAO_USE_SEQUENCE_TEMPLATES */

#if !defined (_IOP_SERVICECONTEXTLIST_CH_)
#define _IOP_SERVICECONTEXTLIST_CH_

  class ServiceContextList;
  class ServiceContextList_var;

  // *************************************************************
  // ServiceContextList
  // *************************************************************

  class TAO_Export ServiceContextList : public
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
    _TAO_Unbounded_Sequence_IOP_ServiceContextList
#else /* TAO_USE_SEQUENCE_TEMPLATES */
    TAO_Unbounded_Sequence<ServiceContext>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */
  {
  public:
    ServiceContextList (void); // default ctor
    ServiceContextList (CORBA::ULong max); // uses max size
    ServiceContextList (
      CORBA::ULong max,
      CORBA::ULong length,
      ServiceContext *buffer,
      CORBA::Boolean release = 0
    );
    ServiceContextList (const ServiceContextList &); // copy ctor
    ~ServiceContextList (void);
    static void _tao_any_destructor (void*);

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef ServiceContextList_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

  };

#endif /* end #if !defined */


#if !defined (_IOP_SERVICECONTEXTLIST___VAR_CH_)
#define _IOP_SERVICECONTEXTLIST___VAR_CH_

  // *************************************************************
  // class IOP::ServiceContextList_var
  // *************************************************************

  class TAO_Export ServiceContextList_var
  {
  public:
    ServiceContextList_var (void); // default constructor
    ServiceContextList_var (ServiceContextList *);
    ServiceContextList_var (const ServiceContextList_var &); // copy constructor
    ~ServiceContextList_var (void); // destructor

    ServiceContextList_var &operator= (ServiceContextList *);
    ServiceContextList_var &operator= (const ServiceContextList_var &);
    ServiceContextList *operator-> (void);
    const ServiceContextList *operator-> (void) const;

    operator const ServiceContextList &() const;
    operator ServiceContextList &();
    operator ServiceContextList &() const;
    operator ServiceContextList *&(); // variable-size base types only

    ServiceContext & operator[] (CORBA::ULong index);
    const ServiceContext & operator[] (CORBA::ULong index) const;

    // in, inout, out, _retn
    const ServiceContextList &in (void) const;
    ServiceContextList &inout (void);
    ServiceContextList *&out (void);
    ServiceContextList *_retn (void);
    ServiceContextList *ptr (void) const;

  private:
    ServiceContextList *ptr_;
  };


#endif /* end #if !defined */


#if !defined (_IOP_SERVICECONTEXTLIST___OUT_CH_)
#define _IOP_SERVICECONTEXTLIST___OUT_CH_

  class TAO_Export ServiceContextList_out
  {
  public:
    ServiceContextList_out (ServiceContextList *&);
    ServiceContextList_out (ServiceContextList_var &);
    ServiceContextList_out (const ServiceContextList_out &);
    ServiceContextList_out &operator= (const ServiceContextList_out &);
    ServiceContextList_out &operator= (ServiceContextList *);
    operator ServiceContextList *&();
    ServiceContextList *&ptr (void);
    ServiceContextList *operator-> (void);
    ServiceContext & operator[] (CORBA::ULong index);

  private:
    ServiceContextList *&ptr_;
    // assignment from T_var not allowed
    void operator= (const ServiceContextList_var &);
  };


#endif /* end #if !defined */

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_ServiceContextList;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TransactionService;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong CodeSets;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong ChainBypassCheck;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong ChainBypassInfo;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong LogicalThreadId;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong BI_DIR_IIOP;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong SendingContextRunTime;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong INVOCATION_POLICIES;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong UnknownExceptionInfo;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RTCorbaPriority;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong RTCorbaPriorityRange;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_FT_GROUP;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_FT_PRIMARY;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong TAG_FT_HEARTBEAT_ENABLED;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong FT_GROUP_VERSION;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::ULong FT_REQUEST;


#if !defined (_IOP_CODEC___PTR_CH_)
#define _IOP_CODEC___PTR_CH_

  class Codec;
  typedef Codec *Codec_ptr;

#endif /* end #if !defined */


#if !defined (_IOP_CODEC___VAR_CH_)
#define _IOP_CODEC___VAR_CH_

  class TAO_Export Codec_var : public TAO_Base_var
  {
  public:
    Codec_var (void); // default constructor
    Codec_var (Codec_ptr p) : ptr_ (p) {}
    Codec_var (const Codec_var &); // copy constructor
    ~Codec_var (void); // destructor

    Codec_var &operator= (Codec_ptr);
    Codec_var &operator= (const Codec_var &);
    Codec_ptr operator-> (void) const;

    operator const Codec_ptr &() const;
    operator Codec_ptr &();
    // in, inout, out, _retn
    Codec_ptr in (void) const;
    Codec_ptr &inout (void);
    Codec_ptr &out (void);
    Codec_ptr _retn (void);
    Codec_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static Codec_ptr tao_duplicate (Codec_ptr);
    static void tao_release (Codec_ptr);
    static Codec_ptr tao_nil (void);
    static Codec_ptr tao_narrow (CORBA::Object * TAO_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    Codec_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    Codec_var (const TAO_Base_var &rhs);
    Codec_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_IOP_CODEC___OUT_CH_)
#define _IOP_CODEC___OUT_CH_

  class TAO_Export Codec_out
  {
  public:
    Codec_out (Codec_ptr &);
    Codec_out (Codec_var &);
    Codec_out (const Codec_out &);
    Codec_out &operator= (const Codec_out &);
    Codec_out &operator= (const Codec_var &);
    Codec_out &operator= (Codec_ptr);
    operator Codec_ptr &();
    Codec_ptr &ptr (void);
    Codec_ptr operator-> (void);

  private:
    Codec_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_IOP_CODEC_CH_)
#define _IOP_CODEC_CH_

class TAO_Export Codec : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Codec_ptr _ptr_type;
    typedef Codec_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

  // the static operations
  static Codec_ptr _duplicate (Codec_ptr obj);
  static Codec_ptr _narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_WITH_DEFAULTS);

  static Codec_ptr _unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_WITH_DEFAULTS);

  static Codec_ptr _nil (void)
    {
      return (Codec_ptr)0;
    }


#if !defined (_IOP_CODEC_INVALIDTYPEFORENCODING_CH_)
#define _IOP_CODEC_INVALIDTYPEFORENCODING_CH_

    class TAO_Export InvalidTypeForEncoding : public CORBA::UserException
    {
    public:

      InvalidTypeForEncoding (void);
      // Default constructor.

      InvalidTypeForEncoding (const InvalidTypeForEncoding &);
      // Copy constructor.

      ~InvalidTypeForEncoding (void);
      // Destructor.

      InvalidTypeForEncoding &operator= (const InvalidTypeForEncoding &);

      virtual void _raise (void);

      virtual void _tao_encode (
          TAO_OutputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        ) const;

      virtual void _tao_decode (
          TAO_InputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        );

      static InvalidTypeForEncoding *_downcast (CORBA::Exception *);


      // = TAO extension.
      static CORBA::Exception *_alloc (void);
    }; // Exception IOP::Codec::InvalidTypeForEncoding.


#endif /* end #if !defined */


#if !defined (_IOP_CODEC_FORMATMISMATCH_CH_)
#define _IOP_CODEC_FORMATMISMATCH_CH_

    class TAO_Export FormatMismatch : public CORBA::UserException
    {
    public:

      FormatMismatch (void);
      // Default constructor.

      FormatMismatch (const FormatMismatch &);
      // Copy constructor.

      ~FormatMismatch (void);
      // Destructor.

      FormatMismatch &operator= (const FormatMismatch &);

      virtual void _raise (void);

      virtual void _tao_encode (
          TAO_OutputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        ) const;

      virtual void _tao_decode (
          TAO_InputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        );

      static FormatMismatch *_downcast (CORBA::Exception *);


      // = TAO extension.
      static CORBA::Exception *_alloc (void);
    }; // Exception IOP::Codec::FormatMismatch.


#endif /* end #if !defined */


#if !defined (_IOP_CODEC_TYPEMISMATCH_CH_)
#define _IOP_CODEC_TYPEMISMATCH_CH_

    class TAO_Export TypeMismatch : public CORBA::UserException
    {
    public:

      TypeMismatch (void);
      // Default constructor.

      TypeMismatch (const TypeMismatch &);
      // Copy constructor.

      ~TypeMismatch (void);
      // Destructor.

      TypeMismatch &operator= (const TypeMismatch &);

      virtual void _raise (void);

      virtual void _tao_encode (
          TAO_OutputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        ) const;

      virtual void _tao_decode (
          TAO_InputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        );

      static TypeMismatch *_downcast (CORBA::Exception *);


      // = TAO extension.
      static CORBA::Exception *_alloc (void);
    }; // Exception IOP::Codec::TypeMismatch.


#endif /* end #if !defined */

    virtual CORBA::OctetSeq * encode (
        const CORBA::Any & data
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException,
        IOP::Codec::InvalidTypeForEncoding
      )) = 0;

    virtual CORBA::Any * decode (
        const CORBA::OctetSeq & data
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException,
        IOP::Codec::FormatMismatch
      )) = 0;

    virtual CORBA::OctetSeq * encode_value (
        const CORBA::Any & data
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException,
        IOP::Codec::InvalidTypeForEncoding
      )) = 0;

    virtual CORBA::Any * decode_value (
        const CORBA::OctetSeq & data,
        CORBA::TypeCode_ptr tc
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException,
        IOP::Codec::FormatMismatch,
        IOP::Codec::TypeMismatch
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    Codec ();

    virtual ~Codec (void);
  private:
    Codec (const Codec &);
    void operator= (const Codec &);
  };


#endif /* end #if !defined */

  typedef CORBA::Short EncodingFormat;
  typedef CORBA::Short_out EncodingFormat_out;
    TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_EncodingFormat;

  TAO_NAMESPACE_STORAGE_CLASS const CORBA::Short ENCODING_CDR_ENCAPS;

  struct Encoding;
  class Encoding_var;

  struct TAO_Export Encoding
  {

#if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef Encoding_var _var_type;
#endif /* ! __GNUC__ || g++ >= 2.8 */

    static void _tao_any_destructor (void*);

    ACE_NESTED_CLASS (IOP, EncodingFormat) format;
    CORBA::Octet major_version;
    CORBA::Octet minor_version;
  };

  class TAO_Export Encoding_var
  {
  public:
    Encoding_var (void); // default constructor
    Encoding_var (Encoding *);
    Encoding_var (const Encoding_var &); // copy constructor
    Encoding_var (const Encoding &); // fixed-size types only
    ~Encoding_var (void); // destructor

    Encoding_var &operator= (Encoding *);
    Encoding_var &operator= (const Encoding_var &);
    Encoding_var &operator= (const Encoding &); // fixed-size types only
    Encoding *operator-> (void);
    const Encoding *operator-> (void) const;

    operator const Encoding &() const;
    operator Encoding &();
    operator Encoding &() const;

    // in, inout, out, _retn
    const Encoding &in (void) const;
    Encoding &inout (void);
    Encoding &out (void);
    Encoding _retn (void);
    Encoding *ptr (void) const;

  private:
    Encoding *ptr_;
  };

  typedef Encoding &Encoding_out;

  TAO_NAMESPACE_STORAGE_CLASS CORBA::TypeCode_ptr _tc_Encoding;


#if !defined (_IOP_CODECFACTORY___PTR_CH_)
#define _IOP_CODECFACTORY___PTR_CH_

  class CodecFactory;
  typedef CodecFactory *CodecFactory_ptr;

#endif /* end #if !defined */


#if !defined (_IOP_CODECFACTORY___VAR_CH_)
#define _IOP_CODECFACTORY___VAR_CH_

  class TAO_Export CodecFactory_var : public TAO_Base_var
  {
  public:
    CodecFactory_var (void); // default constructor
    CodecFactory_var (CodecFactory_ptr p) : ptr_ (p) {}
    CodecFactory_var (const CodecFactory_var &); // copy constructor
    ~CodecFactory_var (void); // destructor

    CodecFactory_var &operator= (CodecFactory_ptr);
    CodecFactory_var &operator= (const CodecFactory_var &);
    CodecFactory_ptr operator-> (void) const;

    operator const CodecFactory_ptr &() const;
    operator CodecFactory_ptr &();
    // in, inout, out, _retn
    CodecFactory_ptr in (void) const;
    CodecFactory_ptr &inout (void);
    CodecFactory_ptr &out (void);
    CodecFactory_ptr _retn (void);
    CodecFactory_ptr ptr (void) const;

    // Hooks used by template sequence and object manager classes
    // for non-defined forward declared interfaces.
    static CodecFactory_ptr tao_duplicate (CodecFactory_ptr);
    static void tao_release (CodecFactory_ptr);
    static CodecFactory_ptr tao_nil (void);
    static CodecFactory_ptr tao_narrow (CORBA::Object * TAO_ENV_ARG_DECL_NOT_USED);
    static CORBA::Object * tao_upcast (void *);

  private:
    CodecFactory_ptr ptr_;
    // Unimplemented - prevents widening assignment.
    CodecFactory_var (const TAO_Base_var &rhs);
    CodecFactory_var &operator= (const TAO_Base_var &rhs);
  };


#endif /* end #if !defined */


#if !defined (_IOP_CODECFACTORY___OUT_CH_)
#define _IOP_CODECFACTORY___OUT_CH_

  class TAO_Export CodecFactory_out
  {
  public:
    CodecFactory_out (CodecFactory_ptr &);
    CodecFactory_out (CodecFactory_var &);
    CodecFactory_out (const CodecFactory_out &);
    CodecFactory_out &operator= (const CodecFactory_out &);
    CodecFactory_out &operator= (const CodecFactory_var &);
    CodecFactory_out &operator= (CodecFactory_ptr);
    operator CodecFactory_ptr &();
    CodecFactory_ptr &ptr (void);
    CodecFactory_ptr operator-> (void);

  private:
    CodecFactory_ptr &ptr_;
  };


#endif /* end #if !defined */


#if !defined (_IOP_CODECFACTORY_CH_)
#define _IOP_CODECFACTORY_CH_

class TAO_Export CodecFactory : public virtual CORBA_Object
  {
  public:
  #if !defined(__GNUC__) || !defined (ACE_HAS_GNUG_PRE_2_8)
    typedef CodecFactory_ptr _ptr_type;
    typedef CodecFactory_var _var_type;
  #endif /* ! __GNUC__ || g++ >= 2.8 */

  static int _tao_class_id;

  // the static operations
  static CodecFactory_ptr _duplicate (CodecFactory_ptr obj);
  static CodecFactory_ptr _narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_WITH_DEFAULTS);

  static CodecFactory_ptr _unchecked_narrow (
      CORBA::Object_ptr obj
      TAO_ENV_ARG_DECL_WITH_DEFAULTS);

  static CodecFactory_ptr _nil (void)
    {
      return (CodecFactory_ptr)0;
    }


#if !defined (_IOP_CODECFACTORY_UNKNOWNENCODING_CH_)
#define _IOP_CODECFACTORY_UNKNOWNENCODING_CH_

    class TAO_Export UnknownEncoding : public CORBA::UserException
    {
    public:

      UnknownEncoding (void);
      // Default constructor.

      UnknownEncoding (const UnknownEncoding &);
      // Copy constructor.

      ~UnknownEncoding (void);
      // Destructor.

      UnknownEncoding &operator= (const UnknownEncoding &);

      virtual void _raise (void);

      virtual void _tao_encode (
          TAO_OutputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        ) const;

      virtual void _tao_decode (
          TAO_InputCDR &
          TAO_ENV_ARG_DECL_NOT_USED
        );

      static UnknownEncoding *_downcast (CORBA::Exception *);


      // = TAO extension.
      static CORBA::Exception *_alloc (void);
    }; // Exception IOP::CodecFactory::UnknownEncoding.


#endif /* end #if !defined */

    virtual IOP::Codec_ptr create_codec (
        const IOP::Encoding & enc
        TAO_ENV_ARG_DECL_WITH_DEFAULTS)

      ACE_THROW_SPEC ((
        CORBA::SystemException,
        IOP::CodecFactory::UnknownEncoding
      )) = 0;

    virtual void *_tao_QueryInterface (ptr_arith_t type);

    virtual const char* _interface_repository_id (void) const;

  protected:
    CodecFactory ();

    virtual ~CodecFactory (void);
  private:
    CodecFactory (const CodecFactory &);
    void operator= (const CodecFactory &);
  };


#endif /* end #if !defined */


}
TAO_NAMESPACE_CLOSE // module IOP

TAO_Export void operator<<= (CORBA::Any &, const IOP::TaggedProfile &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::TaggedProfile*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::TaggedProfile *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::TaggedProfile *&);
TAO_Export void operator<<= (CORBA::Any &, const IOP::IOR &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::IOR*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::IOR *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::IOR *&);
TAO_Export void operator<<= (CORBA::Any &, const IOP::TaggedComponent &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::TaggedComponent*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::TaggedComponent *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::TaggedComponent *&);
TAO_Export void operator<<= (CORBA::Any &, const IOP::MultipleComponentProfile &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::MultipleComponentProfile*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::MultipleComponentProfile *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::MultipleComponentProfile *&);
TAO_Export void operator<<= (CORBA::Any &, const IOP::TaggedComponentList &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::TaggedComponentList*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::TaggedComponentList *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::TaggedComponentList *&);
TAO_Export void operator<<= (CORBA::Any &, const IOP::TaggedComponentSeq &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::TaggedComponentSeq*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::TaggedComponentSeq *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::TaggedComponentSeq *&);
TAO_Export void operator<<= (CORBA::Any &, const IOP::ServiceContext &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::ServiceContext*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::ServiceContext *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::ServiceContext *&);
TAO_Export void operator<<= (CORBA::Any &, const IOP::ServiceContextList &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::ServiceContextList*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::ServiceContextList *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::ServiceContextList *&);
TAO_Export void operator<<= (CORBA::Any &, const IOP::Encoding &); // copying version
TAO_Export void operator<<= (CORBA::Any &, IOP::Encoding*); // noncopying version
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, IOP::Encoding *&); // deprecated
TAO_Export CORBA::Boolean operator>>= (const CORBA::Any &, const IOP::Encoding *&);

#ifndef __ACE_INLINE__

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IOP::TaggedProfile &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IOP::TaggedProfile &);

#if !defined _TAO_CDR_OP_IOP_TaggedProfile__tao_seq_Octet_H_
#define _TAO_CDR_OP_IOP_TaggedProfile__tao_seq_Octet_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IOP::TaggedProfile::_tao_seq_Octet &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IOP::TaggedProfile::_tao_seq_Octet &
  );

#endif /* _TAO_CDR_OP_IOP_TaggedProfile__tao_seq_Octet_H_ */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IOP::IOR &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IOP::IOR &);

#if !defined _TAO_CDR_OP_IOP_IOR__tao_seq_TaggedProfile_H_
#define _TAO_CDR_OP_IOP_IOR__tao_seq_TaggedProfile_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IOP::IOR::_tao_seq_TaggedProfile &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IOP::IOR::_tao_seq_TaggedProfile &
  );

#endif /* _TAO_CDR_OP_IOP_IOR__tao_seq_TaggedProfile_H_ */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IOP::TaggedComponent &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IOP::TaggedComponent &);

#if !defined _TAO_CDR_OP_IOP_TaggedComponent__tao_seq_Octet_H_
#define _TAO_CDR_OP_IOP_TaggedComponent__tao_seq_Octet_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IOP::TaggedComponent::_tao_seq_Octet &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IOP::TaggedComponent::_tao_seq_Octet &
  );

#endif /* _TAO_CDR_OP_IOP_TaggedComponent__tao_seq_Octet_H_ */


#if !defined _TAO_CDR_OP_IOP_MultipleComponentProfile_H_
#define _TAO_CDR_OP_IOP_MultipleComponentProfile_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IOP::MultipleComponentProfile &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IOP::MultipleComponentProfile &
  );

#endif /* _TAO_CDR_OP_IOP_MultipleComponentProfile_H_ */


#if !defined _TAO_CDR_OP_IOP_TaggedComponentList_H_
#define _TAO_CDR_OP_IOP_TaggedComponentList_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IOP::TaggedComponentList &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IOP::TaggedComponentList &
  );

#endif /* _TAO_CDR_OP_IOP_TaggedComponentList_H_ */


#if !defined _TAO_CDR_OP_IOP_TaggedComponentSeq_H_
#define _TAO_CDR_OP_IOP_TaggedComponentSeq_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IOP::TaggedComponentSeq &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IOP::TaggedComponentSeq &
  );

#endif /* _TAO_CDR_OP_IOP_TaggedComponentSeq_H_ */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IOP::ServiceContext &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IOP::ServiceContext &);

#if !defined _TAO_CDR_OP_IOP_ServiceContext__tao_seq_Octet_H_
#define _TAO_CDR_OP_IOP_ServiceContext__tao_seq_Octet_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IOP::ServiceContext::_tao_seq_Octet &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IOP::ServiceContext::_tao_seq_Octet &
  );

#endif /* _TAO_CDR_OP_IOP_ServiceContext__tao_seq_Octet_H_ */


#if !defined _TAO_CDR_OP_IOP_ServiceContextList_H_
#define _TAO_CDR_OP_IOP_ServiceContextList_H_

TAO_Export CORBA::Boolean operator<< (
    TAO_OutputCDR &,
    const IOP::ServiceContextList &
  );
TAO_Export CORBA::Boolean operator>> (
    TAO_InputCDR &,
    IOP::ServiceContextList &
  );

#endif /* _TAO_CDR_OP_IOP_ServiceContextList_H_ */

TAO_Export CORBA::Boolean operator<< (TAO_OutputCDR &, const IOP::Encoding &);
TAO_Export CORBA::Boolean operator>> (TAO_InputCDR &, IOP::Encoding &);

#endif /* __ACE_INLINE__ */


#if defined (__ACE_INLINE__)
#include "IOPC.i"
#endif /* defined INLINE */

#if defined(_MSC_VER) && (_MSC_VER >= 1200)
#pragma warning(pop)
#endif /* _MSC_VER */

#if defined (__BORLANDC__)
#pragma option pop
#endif /* __BORLANDC__ */

#include "ace/post.h"
#endif /* ifndef */
