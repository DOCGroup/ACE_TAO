// $Id$

#include "tao/TimeBase.pidl"
#include "tao/StringSeq.pidl"

module Monitor
{
  struct DataValue
  {
    /// The number of samples currently taken into account
    TimeBase::TimeT timestamp;
    double value;
  };

  typedef string Name;
  typedef string NameFilter;
  typedef CORBA::StringSeq NameList;
  typedef sequence<DataValue> DataValueList;
  struct Numeric
  {
    DataValueList dlist;
    unsigned long count;
    double average;
    double sum_of_squares;
    double minimum;
    double maximum;
  };
  enum DataType { DATA_NUMERIC, DATA_TEXT };
  union UData switch (DataType) {
    case DATA_NUMERIC: Numeric num;
    case DATA_TEXT: NameList list;
  };
  struct Data
  {
    Name itemname;
    UData data_union;
  };
  typedef sequence<Data> DataList;
  typedef long ConstraintId;
  typedef sequence<ConstraintId> ConstraintIdList;
  typedef string Constraint;
  struct ConstraintStruct
  {
    Name itemname;
    ConstraintId id;
  };
  typedef sequence<ConstraintStruct> ConstraintStructList;

  interface Subscriber
  {
    oneway void push (in DataList dil);
  };

  /**
   * @todo Make it possible to use then namelist as filter
   */
  interface MC
  {
    NameList get_statistic_names (in NameFilter filter);

    /**
     * Get the statistics for the given monitor points.
     * The return value only contains the values for the existing
     * monitoring points. If they don't exist they are just
     * not in the list.
     */
    DataList get_statistics (in NameList names);

    /**
     * Get and clear the statistics for the given monitor points.
     * The return value only contains the values for the existing
     * monitoring points. If they don't exist they are just
     * not in the list.
     */
    DataList get_and_clear_statistics (in NameList names);

    /**
     * Clear the statistics for the given monitor points.
     * The return value only contains the names of the cleared
     * monitoring points. If they don't exist they are just
     * not in the list.
     */
    NameList clear_statistics (in NameList names);

    /**
     * Register a constraint for the given monitoring points specified
     * by @a names. When the constraint evaluates to true the
     * @a sub is called
     * @return Returns a list with constraint id and monitor name
     */
    ConstraintStructList register_constraint (in NameList names, in Constraint cs, in Subscriber sub);

    /**
     * Unregister for certain constraints
     */
    void unregister_constraints (in ConstraintStructList constraint);
  };
};
