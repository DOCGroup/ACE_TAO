// $Id$
//
// ******  Code generated by the The ACE ORB (TAO) IDL Compiler *******
// TAO ORB and the TAO IDL Compiler have been developed by Washington
// University Computer Science's Distributed Object Computing Group.
//
// Information on TAO is available at
//                 http://www.cs.wustl.edu/~schmidt/TAO.html

// Take care: The typecodes are platform dependent, therefore
// a ifdef is needed right now. This is going to be changed in
// the future.

#include "tao/POAC.h"
#include "tao/POAS.h"
#include "tao/POA.h"
#include "tao/Typecode.h"
#include "tao/Any.h"
#include "tao/Invocation.h"
#include "tao/Stub.h"

#if !defined (__ACE_INLINE__)
#include "tao/POAC.i"
#endif // !defined INLINE

ACE_RCSID(tao, POAC, "$Id$")

#if !defined (_PORTABLESERVER__TAO_SEQ_OCTET_CS_)
#define _PORTABLESERVER__TAO_SEQ_OCTET_CS_

static const CORBA::Long _oc_PortableServer__tao_seq_Octet[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  CORBA::tk_octet,

  0,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer__tao_seq_Octet
(CORBA::tk_sequence, sizeof (_oc_PortableServer__tao_seq_Octet), (char *)
 &_oc_PortableServer__tao_seq_Octet, 0, sizeof (PortableServer::_tao_seq_Octet));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc__tao_seq_Octet, &_tc_TAO_tc_PortableServer__tao_seq_Octet)
TAO_NAMESPACE_END

#endif /* end #if !defined */

static const CORBA::Long _oc_PortableServer_ObjectId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x7449643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/ObjectId:1.0
  9, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744964), ACE_NTOHL (0x0),  // name = ObjectId
  CORBA::tk_sequence, // typecode kind
  12, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_octet,

  0,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ObjectId (CORBA::tk_alias, sizeof
                                                           (_oc_PortableServer_ObjectId),
                                                           (char *) &_oc_PortableServer_ObjectId,
                                                           0, sizeof (PortableServer::ObjectId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ObjectId, &_tc_TAO_tc_PortableServer_ObjectId)
TAO_NAMESPACE_END

#if !defined (TAO_HAS_MINIMUM_CORBA)

// default constructor
PortableServer::ForwardRequest::ForwardRequest (void)
  : CORBA_UserException (PortableServer::_tc_ForwardRequest)
{
}

// destructor - all members are of self managing types
PortableServer::ForwardRequest::~ForwardRequest (void)
{
}

// copy constructor
PortableServer::ForwardRequest::ForwardRequest (const PortableServer::ForwardRequest &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
  this->forward_reference = CORBA::Object::_duplicate (_tao_excp.forward_reference.in ());
}

// assignment operator
PortableServer::ForwardRequest&
PortableServer::ForwardRequest::operator= (const PortableServer::ForwardRequest &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->forward_reference = CORBA::Object::_duplicate (_tao_excp.forward_reference.in ());
  return *this;
}

PortableServer::ForwardRequest::ForwardRequest(
                                               const CORBA::Object_ptr  _tao_forward_reference)
  : CORBA_UserException  (PortableServer::_tc_ForwardRequest)
{
  this->forward_reference = CORBA::Object::_duplicate (_tao_forward_reference);
}

void PortableServer::ForwardRequest::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::ForwardRequest_ptr
PortableServer::ForwardRequest::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/ForwardRequest:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::ForwardRequest_ptr, exc);
  else
    return 0;
}

// = TAO extension
CORBA::Exception *PortableServer::ForwardRequest::_alloc (void)
{
  return new PortableServer::ForwardRequest;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::ForwardRequest &_tao_elem) // copying
{
  PortableServer::ForwardRequest *_tao_any_val = new PortableServer::ForwardRequest (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::_tc_ForwardRequest, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::ForwardRequest *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::_tc_ForwardRequest, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::ForwardRequest *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::_tc_ForwardRequest, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::ForwardRequest *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::ForwardRequest, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::_tc_ForwardRequest, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::_tc_ForwardRequest, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_ForwardRequest[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f46), ACE_NTOHL (0x6f727761), ACE_NTOHL (0x72645265), ACE_NTOHL (0x71756573), ACE_NTOHL (0x743a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/ForwardRequest:1.0
  15, ACE_NTOHL (0x466f7277), ACE_NTOHL (0x61726452), ACE_NTOHL (0x65717565), ACE_NTOHL (0x73740000),  // name = ForwardRequest
  1, // member count
    18, ACE_NTOHL (0x666f7277), ACE_NTOHL (0x6172645f), ACE_NTOHL (0x72656665), ACE_NTOHL (0x72656e63), ACE_NTOHL (0x65000000),  // name = forward_reference
    CORBA::tk_objref,
52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Object:1.0
    7, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63740000),  // name = Object,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ForwardRequest (CORBA::tk_except,
                                                                 sizeof (_oc_PortableServer_ForwardRequest),
                                                                 (char *) &_oc_PortableServer_ForwardRequest,
                                                                 0,
                                                                 sizeof (PortableServer::ForwardRequest));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ForwardRequest, &_tc_TAO_tc_PortableServer_ForwardRequest)
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_CORBA */

TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, THREAD_POLICY_ID, 16)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, LIFESPAN_POLICY_ID, 17)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, ID_UNIQUENESS_POLICY_ID, 18)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, ID_ASSIGNMENT_POLICY_ID, 19)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, IMPLICIT_ACTIVATION_POLICY_ID, 20)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, SERVANT_RETENTION_POLICY_ID, 21)
TAO_NAMESPACE_END
TAO_NAMESPACE_TYPE (const CORBA::ULong)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (const CORBA::ULong, REQUEST_PROCESSING_POLICY_ID, 22)
TAO_NAMESPACE_END

#if !defined (TAO_HAS_MINIMUM_CORBA)

static const CORBA::Long _oc_PortableServer_ThreadPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f54), ACE_NTOHL (0x68726561), ACE_NTOHL (0x64506f6c), ACE_NTOHL (0x69637956), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/ThreadPolicyValue:1.0
  18, ACE_NTOHL (0x54687265), ACE_NTOHL (0x6164506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65000000),  // name = ThreadPolicyValue
  2, // member count
    15, ACE_NTOHL (0x4f52425f), ACE_NTOHL (0x4354524c), ACE_NTOHL (0x5f4d4f44), ACE_NTOHL (0x454c0000),  // name = ORB_CTRL_MODEL
    20, ACE_NTOHL (0x53494e47), ACE_NTOHL (0x4c455f54), ACE_NTOHL (0x48524541), ACE_NTOHL (0x445f4d4f), ACE_NTOHL (0x44454c00),  // name = SINGLE_THREAD_MODEL
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ThreadPolicyValue (CORBA::tk_enum,
                                                                    sizeof (_oc_PortableServer_ThreadPolicyValue),
                                                                    (char *) &_oc_PortableServer_ThreadPolicyValue,
                                                                    0,
                                                                    sizeof (PortableServer::ThreadPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ThreadPolicyValue, &_tc_TAO_tc_PortableServer_ThreadPolicyValue)
TAO_NAMESPACE_END

PortableServer::ThreadPolicy_ptr PortableServer::ThreadPolicy::_duplicate (PortableServer::ThreadPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::ThreadPolicy_ptr PortableServer::ThreadPolicy::_narrow (
                                                                        CORBA::Object_ptr obj,
                                                                        CORBA::Environment &ACE_TRY_ENV
                                                                        )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ThreadPolicy::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/ThreadPolicy:1.0", ACE_TRY_ENV))
    return PortableServer::ThreadPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:omg.org/PortableServer/ThreadPolicy:1.0");
#if defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  else
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::ThreadPolicy::_nil ());
#else
  if (servant == 0)
    return new PortableServer::ThreadPolicy(stub);
#endif /* TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
  return new POA_PortableServer::_tao_collocated_ThreadPolicy(
      ACE_reinterpret_cast(POA_PortableServer::ThreadPolicy_ptr, servant),
      stub
    );
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
PortableServer::ThreadPolicyValue PortableServer::ThreadPolicy::value(CORBA::Environment &ACE_TRY_ENV)
{
    PortableServer::ThreadPolicyValue _tao_retval = (PortableServer::ThreadPolicyValue)0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (! (_tao_in >> _tao_retval))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean PortableServer::ThreadPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ThreadPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::ThreadPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ThreadPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_ThreadPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f54), ACE_NTOHL (0x68726561), ACE_NTOHL (0x64506f6c), ACE_NTOHL (0x6963793a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/ThreadPolicy:1.0
  13, ACE_NTOHL (0x54687265), ACE_NTOHL (0x6164506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = ThreadPolicy,
};

static CORBA::TypeCode _tc_TAO_tc_PortableServer_ThreadPolicy (CORBA::tk_objref,
                                                               sizeof (_oc_PortableServer_ThreadPolicy),
                                                               (char *) &_oc_PortableServer_ThreadPolicy,
                                                               0,
                                                               sizeof (PortableServer::ThreadPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ThreadPolicy, &_tc_TAO_tc_PortableServer_ThreadPolicy)
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_CORBA */

static const CORBA::Long _oc_PortableServer_LifespanPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f4c), ACE_NTOHL (0x69666573), ACE_NTOHL (0x70616e50), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x7956616c), ACE_NTOHL (0x75653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/LifespanPolicyValue:1.0
  20, ACE_NTOHL (0x4c696665), ACE_NTOHL (0x7370616e), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756500),  // name = LifespanPolicyValue
  2, // member count
    10, ACE_NTOHL (0x5452414e), ACE_NTOHL (0x5349454e), ACE_NTOHL (0x54000000),  // name = TRANSIENT
    11, ACE_NTOHL (0x50455253), ACE_NTOHL (0x49535445), ACE_NTOHL (0x4e540000),  // name = PERSISTENT
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_LifespanPolicyValue (CORBA::tk_enum,
                                                                      sizeof (_oc_PortableServer_LifespanPolicyValue),
                                                                      (char *) &_oc_PortableServer_LifespanPolicyValue,
                                                                      0,
                                                                      sizeof (PortableServer::LifespanPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_LifespanPolicyValue, &_tc_TAO_tc_PortableServer_LifespanPolicyValue)
TAO_NAMESPACE_END

PortableServer::LifespanPolicy_ptr PortableServer::LifespanPolicy::_duplicate (PortableServer::LifespanPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::LifespanPolicy_ptr PortableServer::LifespanPolicy::_narrow (
                                                                            CORBA::Object_ptr obj,
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  if (CORBA::is_nil (obj))
    return PortableServer::LifespanPolicy::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/LifespanPolicy:1.0", ACE_TRY_ENV))
    return PortableServer::LifespanPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:omg.org/PortableServer/LifespanPolicy:1.0");
#if defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  else
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::LifespanPolicy::_nil ());
#else
  if (servant == 0)
    return new PortableServer::LifespanPolicy(stub);
#endif /* TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
  return new POA_PortableServer::_tao_collocated_LifespanPolicy(
      ACE_reinterpret_cast(POA_PortableServer::LifespanPolicy_ptr, servant),
      stub
    );
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
PortableServer::LifespanPolicyValue PortableServer::LifespanPolicy::value(CORBA::Environment &ACE_TRY_ENV)
{
    PortableServer::LifespanPolicyValue _tao_retval = (PortableServer::LifespanPolicyValue)0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean PortableServer::LifespanPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/LifespanPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::LifespanPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/LifespanPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_LifespanPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f4c), ACE_NTOHL (0x69666573), ACE_NTOHL (0x70616e50), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/LifespanPolicy:1.0
  15, ACE_NTOHL (0x4c696665), ACE_NTOHL (0x7370616e), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = LifespanPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_LifespanPolicy (CORBA::tk_objref,
                                                                 sizeof (_oc_PortableServer_LifespanPolicy),
                                                                 (char *) &_oc_PortableServer_LifespanPolicy,
                                                                 0,
                                                                 sizeof (PortableServer::LifespanPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_LifespanPolicy, &_tc_TAO_tc_PortableServer_LifespanPolicy)
TAO_NAMESPACE_END


static const CORBA::Long _oc_PortableServer_IdUniquenessPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f49), ACE_NTOHL (0x64556e69), ACE_NTOHL (0x7175656e), ACE_NTOHL (0x65737350), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x7956616c), ACE_NTOHL (0x75653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/IdUniquenessPolicyValue:1.0
  24, ACE_NTOHL (0x4964556e), ACE_NTOHL (0x69717565), ACE_NTOHL (0x6e657373), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756500),  // name = IdUniquenessPolicyValue
  2, // member count
    10, ACE_NTOHL (0x554e4951), ACE_NTOHL (0x55455f49), ACE_NTOHL (0x44000000),  // name = UNIQUE_ID
    12, ACE_NTOHL (0x4d554c54), ACE_NTOHL (0x49504c45), ACE_NTOHL (0x5f494400),  // name = MULTIPLE_ID
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdUniquenessPolicyValue (CORBA::tk_enum,
                                                                          sizeof (_oc_PortableServer_IdUniquenessPolicyValue),
                                                                          (char *) &_oc_PortableServer_IdUniquenessPolicyValue,
                                                                          0,
                                                                          sizeof (PortableServer::IdUniquenessPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IdUniquenessPolicyValue, &_tc_TAO_tc_PortableServer_IdUniquenessPolicyValue)
TAO_NAMESPACE_END

PortableServer::IdUniquenessPolicy_ptr PortableServer::IdUniquenessPolicy::_duplicate (PortableServer::IdUniquenessPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::IdUniquenessPolicy_ptr PortableServer::IdUniquenessPolicy::_narrow (
                                                                                    CORBA::Object_ptr obj,
                                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                                    )
{
  if (CORBA::is_nil (obj))
    return PortableServer::IdUniquenessPolicy::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0", ACE_TRY_ENV))
    return PortableServer::IdUniquenessPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0");
#if defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  else
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::IdUniquenessPolicy::_nil ());
#else
  if (servant == 0)
    return new PortableServer::IdUniquenessPolicy(stub);
#endif /* TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
  return new POA_PortableServer::_tao_collocated_IdUniquenessPolicy(
      ACE_reinterpret_cast(POA_PortableServer::IdUniquenessPolicy_ptr, servant),
      stub
    );
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
PortableServer::IdUniquenessPolicyValue PortableServer::IdUniquenessPolicy::value(CORBA::Environment &ACE_TRY_ENV)
{
    PortableServer::IdUniquenessPolicyValue _tao_retval = (PortableServer::IdUniquenessPolicyValue)0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean PortableServer::IdUniquenessPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::IdUniquenessPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_IdUniquenessPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f49), ACE_NTOHL (0x64556e69), ACE_NTOHL (0x7175656e), ACE_NTOHL (0x65737350), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/IdUniquenessPolicy:1.0
  19, ACE_NTOHL (0x4964556e), ACE_NTOHL (0x69717565), ACE_NTOHL (0x6e657373), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = IdUniquenessPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdUniquenessPolicy (CORBA::tk_objref,
                                                                     sizeof (_oc_PortableServer_IdUniquenessPolicy),
                                                                     (char *) &_oc_PortableServer_IdUniquenessPolicy,
                                                                     0,
                                                                     sizeof (PortableServer::IdUniquenessPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IdUniquenessPolicy, &_tc_TAO_tc_PortableServer_IdUniquenessPolicy)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableServer_IdAssignmentPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f49), ACE_NTOHL (0x64417373), ACE_NTOHL (0x69676e6d), ACE_NTOHL (0x656e7450), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x7956616c), ACE_NTOHL (0x75653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/IdAssignmentPolicyValue:1.0
  24, ACE_NTOHL (0x49644173), ACE_NTOHL (0x7369676e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756500),  // name = IdAssignmentPolicyValue
  2, // member count
    8, ACE_NTOHL (0x55534552), ACE_NTOHL (0x5f494400),  // name = USER_ID
    10, ACE_NTOHL (0x53595354), ACE_NTOHL (0x454d5f49), ACE_NTOHL (0x44000000),  // name = SYSTEM_ID
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdAssignmentPolicyValue (CORBA::tk_enum,
                                                                          sizeof (_oc_PortableServer_IdAssignmentPolicyValue),
                                                                          (char *) &_oc_PortableServer_IdAssignmentPolicyValue,
                                                                          0,
                                                                          sizeof (PortableServer::IdAssignmentPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IdAssignmentPolicyValue, &_tc_TAO_tc_PortableServer_IdAssignmentPolicyValue)
TAO_NAMESPACE_END

PortableServer::IdAssignmentPolicy_ptr PortableServer::IdAssignmentPolicy::_duplicate (PortableServer::IdAssignmentPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::IdAssignmentPolicy_ptr PortableServer::IdAssignmentPolicy::_narrow (
                                                                                    CORBA::Object_ptr obj,
                                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                                    )
{
  if (CORBA::is_nil (obj))
    return PortableServer::IdAssignmentPolicy::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0", ACE_TRY_ENV))
    return PortableServer::IdAssignmentPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0");
#if defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  else
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::IdAssignmentPolicy::_nil ());
#else
  if (servant == 0)
    return new PortableServer::IdAssignmentPolicy(stub);
#endif /* TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
  return new POA_PortableServer::_tao_collocated_IdAssignmentPolicy(
      ACE_reinterpret_cast(POA_PortableServer::IdAssignmentPolicy_ptr, servant),
      stub
    );
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
PortableServer::IdAssignmentPolicyValue PortableServer::IdAssignmentPolicy::value(CORBA::Environment &ACE_TRY_ENV)
{
    PortableServer::IdAssignmentPolicyValue _tao_retval = (PortableServer::IdAssignmentPolicyValue)0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean PortableServer::IdAssignmentPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::IdAssignmentPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_IdAssignmentPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  50, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f49), ACE_NTOHL (0x64417373), ACE_NTOHL (0x69676e6d), ACE_NTOHL (0x656e7450), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/IdAssignmentPolicy:1.0
  19, ACE_NTOHL (0x49644173), ACE_NTOHL (0x7369676e), ACE_NTOHL (0x6d656e74), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = IdAssignmentPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_IdAssignmentPolicy (CORBA::tk_objref,
                                                                     sizeof (_oc_PortableServer_IdAssignmentPolicy),
                                                                     (char *) &_oc_PortableServer_IdAssignmentPolicy,
                                                                     0,
                                                                     sizeof (PortableServer::IdAssignmentPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IdAssignmentPolicy, &_tc_TAO_tc_PortableServer_IdAssignmentPolicy)
TAO_NAMESPACE_END


#if !defined (TAO_HAS_MINIMUM_CORBA)

static const CORBA::Long _oc_PortableServer_ImplicitActivationPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  61, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f49), ACE_NTOHL (0x6d706c69), ACE_NTOHL (0x63697441), ACE_NTOHL (0x63746976), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e506f6c), ACE_NTOHL (0x69637956), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/ImplicitActivationPolicyValue:1.0
  30, ACE_NTOHL (0x496d706c), ACE_NTOHL (0x69636974), ACE_NTOHL (0x41637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65000000),  // name = ImplicitActivationPolicyValue
  2, // member count
    20, ACE_NTOHL (0x494d504c), ACE_NTOHL (0x49434954), ACE_NTOHL (0x5f414354), ACE_NTOHL (0x49564154), ACE_NTOHL (0x494f4e00),  // name = IMPLICIT_ACTIVATION
    23, ACE_NTOHL (0x4e4f5f49), ACE_NTOHL (0x4d504c49), ACE_NTOHL (0x4349545f), ACE_NTOHL (0x41435449), ACE_NTOHL (0x56415449), ACE_NTOHL (0x4f4e0000),  // name = NO_IMPLICIT_ACTIVATION
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ImplicitActivationPolicyValue (CORBA::tk_enum,
                                                                                sizeof (_oc_PortableServer_ImplicitActivationPolicyValue),
                                                                                (char *) &_oc_PortableServer_ImplicitActivationPolicyValue,
                                                                                0,
                                                                                sizeof (PortableServer::ImplicitActivationPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ImplicitActivationPolicyValue, &_tc_TAO_tc_PortableServer_ImplicitActivationPolicyValue)
TAO_NAMESPACE_END

PortableServer::ImplicitActivationPolicy_ptr PortableServer::ImplicitActivationPolicy::_duplicate (PortableServer::ImplicitActivationPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::ImplicitActivationPolicy_ptr PortableServer::ImplicitActivationPolicy::_narrow (
                                                                                                CORBA::Object_ptr obj,
                                                                                                CORBA::Environment &ACE_TRY_ENV
                                                                                                )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ImplicitActivationPolicy::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0", ACE_TRY_ENV))
    return PortableServer::ImplicitActivationPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0");
#if defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  else
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::ImplicitActivationPolicy::_nil ());
#else
  if (servant == 0)
    return new PortableServer::ImplicitActivationPolicy(stub);
#endif /* TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
  return new POA_PortableServer::_tao_collocated_ImplicitActivationPolicy(
      ACE_reinterpret_cast(POA_PortableServer::ImplicitActivationPolicy_ptr, servant),
      stub
    );
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
PortableServer::ImplicitActivationPolicyValue PortableServer::ImplicitActivationPolicy::value(CORBA::Environment &ACE_TRY_ENV)
{
    PortableServer::ImplicitActivationPolicyValue _tao_retval = (PortableServer::ImplicitActivationPolicyValue)0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean PortableServer::ImplicitActivationPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::ImplicitActivationPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_ImplicitActivationPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  56, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f49), ACE_NTOHL (0x6d706c69), ACE_NTOHL (0x63697441), ACE_NTOHL (0x63746976), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e506f6c), ACE_NTOHL (0x6963793a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/ImplicitActivationPolicy:1.0
  25, ACE_NTOHL (0x496d706c), ACE_NTOHL (0x69636974), ACE_NTOHL (0x41637469), ACE_NTOHL (0x76617469), ACE_NTOHL (0x6f6e506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x0),  // name = ImplicitActivationPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ImplicitActivationPolicy (CORBA::tk_objref,
                                                                           sizeof (_oc_PortableServer_ImplicitActivationPolicy),
                                                                           (char *) &_oc_PortableServer_ImplicitActivationPolicy,
                                                                           0,
                                                                           sizeof (PortableServer::ImplicitActivationPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ImplicitActivationPolicy, &_tc_TAO_tc_PortableServer_ImplicitActivationPolicy)
TAO_NAMESPACE_END


static const CORBA::Long _oc_PortableServer_ServantRetentionPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  59, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f53), ACE_NTOHL (0x65727661), ACE_NTOHL (0x6e745265), ACE_NTOHL (0x74656e74), ACE_NTOHL (0x696f6e50), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x7956616c), ACE_NTOHL (0x75653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/ServantRetentionPolicyValue:1.0
  28, ACE_NTOHL (0x53657276), ACE_NTOHL (0x616e7452), ACE_NTOHL (0x6574656e), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c756500),  // name = ServantRetentionPolicyValue
  2, // member count
    7, ACE_NTOHL (0x52455441), ACE_NTOHL (0x494e0000),  // name = RETAIN
    11, ACE_NTOHL (0x4e4f4e5f), ACE_NTOHL (0x52455441), ACE_NTOHL (0x494e0000),  // name = NON_RETAIN
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantRetentionPolicyValue (CORBA::tk_enum,
                                                                              sizeof (_oc_PortableServer_ServantRetentionPolicyValue),
                                                                              (char *) &_oc_PortableServer_ServantRetentionPolicyValue,
                                                                              0,
                                                                              sizeof (PortableServer::ServantRetentionPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServantRetentionPolicyValue, &_tc_TAO_tc_PortableServer_ServantRetentionPolicyValue)
TAO_NAMESPACE_END

PortableServer::ServantRetentionPolicy_ptr PortableServer::ServantRetentionPolicy::_duplicate (PortableServer::ServantRetentionPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::ServantRetentionPolicy_ptr PortableServer::ServantRetentionPolicy::_narrow (
                                                                                            CORBA::Object_ptr obj,
                                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                                            )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ServantRetentionPolicy::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0", ACE_TRY_ENV))
    return PortableServer::ServantRetentionPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0");
#if defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  else
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::ServantRetentionPolicy::_nil ());
#else
  if (servant == 0)
    return new PortableServer::ServantRetentionPolicy(stub);
#endif /* TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
  return new POA_PortableServer::_tao_collocated_ServantRetentionPolicy(
      ACE_reinterpret_cast(POA_PortableServer::ServantRetentionPolicy_ptr, servant),
      stub
    );
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
PortableServer::ServantRetentionPolicyValue PortableServer::ServantRetentionPolicy::value(CORBA::Environment &ACE_TRY_ENV)
{
    PortableServer::ServantRetentionPolicyValue _tao_retval = (PortableServer::ServantRetentionPolicyValue)0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean PortableServer::ServantRetentionPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::ServantRetentionPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_ServantRetentionPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f53), ACE_NTOHL (0x65727661), ACE_NTOHL (0x6e745265), ACE_NTOHL (0x74656e74), ACE_NTOHL (0x696f6e50), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/ServantRetentionPolicy:1.0
  23, ACE_NTOHL (0x53657276), ACE_NTOHL (0x616e7452), ACE_NTOHL (0x6574656e), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63790000),  // name = ServantRetentionPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantRetentionPolicy (CORBA::tk_objref,
                                                                         sizeof (_oc_PortableServer_ServantRetentionPolicy),
                                                                         (char *) &_oc_PortableServer_ServantRetentionPolicy,
                                                                         0,
                                                                         sizeof (PortableServer::ServantRetentionPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServantRetentionPolicy, &_tc_TAO_tc_PortableServer_ServantRetentionPolicy)
TAO_NAMESPACE_END

static const CORBA::Long _oc_PortableServer_RequestProcessingPolicyValue[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  60, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f52), ACE_NTOHL (0x65717565), ACE_NTOHL (0x73745072), ACE_NTOHL (0x6f636573), ACE_NTOHL (0x73696e67), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63795661), ACE_NTOHL (0x6c75653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/RequestProcessingPolicyValue:1.0
  29, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737450), ACE_NTOHL (0x726f6365), ACE_NTOHL (0x7373696e), ACE_NTOHL (0x67506f6c), ACE_NTOHL (0x69637956), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = RequestProcessingPolicyValue
  3, // member count
    27, ACE_NTOHL (0x5553455f), ACE_NTOHL (0x41435449), ACE_NTOHL (0x56455f4f), ACE_NTOHL (0x424a4543), ACE_NTOHL (0x545f4d41), ACE_NTOHL (0x505f4f4e), ACE_NTOHL (0x4c590000),  // name = USE_ACTIVE_OBJECT_MAP_ONLY
    20, ACE_NTOHL (0x5553455f), ACE_NTOHL (0x44454641), ACE_NTOHL (0x554c545f), ACE_NTOHL (0x53455256), ACE_NTOHL (0x414e5400),  // name = USE_DEFAULT_SERVANT
    20, ACE_NTOHL (0x5553455f), ACE_NTOHL (0x53455256), ACE_NTOHL (0x414e545f), ACE_NTOHL (0x4d414e41), ACE_NTOHL (0x47455200),  // name = USE_SERVANT_MANAGER
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_RequestProcessingPolicyValue (CORBA::tk_enum,
                                                                               sizeof (_oc_PortableServer_RequestProcessingPolicyValue),
                                                                               (char *) &_oc_PortableServer_RequestProcessingPolicyValue,
                                                                               0,
                                                                               sizeof (PortableServer::RequestProcessingPolicyValue));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestProcessingPolicyValue, &_tc_TAO_tc_PortableServer_RequestProcessingPolicyValue)
TAO_NAMESPACE_END

PortableServer::RequestProcessingPolicy_ptr PortableServer::RequestProcessingPolicy::_duplicate (PortableServer::RequestProcessingPolicy_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::RequestProcessingPolicy_ptr PortableServer::RequestProcessingPolicy::_narrow (
                                                                                              CORBA::Object_ptr obj,
                                                                                              CORBA::Environment &ACE_TRY_ENV
                                                                                              )
{
  if (CORBA::is_nil (obj))
    return PortableServer::RequestProcessingPolicy::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0", ACE_TRY_ENV))
    return PortableServer::RequestProcessingPolicy::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0");
#if defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
  else
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::RequestProcessingPolicy::_nil ());
#else
  if (servant == 0)
    return new PortableServer::RequestProcessingPolicy(stub);
#endif /* TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */
  return new POA_PortableServer::_tao_collocated_RequestProcessingPolicy(
      ACE_reinterpret_cast(POA_PortableServer::RequestProcessingPolicy_ptr, servant),
      stub
    );
}

#if !defined (TAO_HAS_LOCALITY_CONSTRAINT_POLICIES)
PortableServer::RequestProcessingPolicyValue PortableServer::RequestProcessingPolicy::value(CORBA::Environment &ACE_TRY_ENV)
{
    PortableServer::RequestProcessingPolicyValue _tao_retval = (PortableServer::RequestProcessingPolicyValue)0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (), _tao_retval);


  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_""value",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (0, 0, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> _tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}
#endif /* !TAO_HAS_LOCALITY_CONSTRAINT_POLICIES */

CORBA::Boolean PortableServer::RequestProcessingPolicy::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Policy:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::RequestProcessingPolicy::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0";
}

static const CORBA::Long _oc_PortableServer_RequestProcessingPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f52), ACE_NTOHL (0x65717565), ACE_NTOHL (0x73745072), ACE_NTOHL (0x6f636573), ACE_NTOHL (0x73696e67), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/RequestProcessingPolicy:1.0
  24, ACE_NTOHL (0x52657175), ACE_NTOHL (0x65737450), ACE_NTOHL (0x726f6365), ACE_NTOHL (0x7373696e), ACE_NTOHL (0x67506f6c), ACE_NTOHL (0x69637900),  // name = RequestProcessingPolicy,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_RequestProcessingPolicy (CORBA::tk_objref,
                                                                          sizeof (_oc_PortableServer_RequestProcessingPolicy),
                                                                          (char *) &_oc_PortableServer_RequestProcessingPolicy,
                                                                          0,
                                                                          sizeof (PortableServer::RequestProcessingPolicy));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RequestProcessingPolicy, &_tc_TAO_tc_PortableServer_RequestProcessingPolicy)
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_CORBA */

PortableServer::POAManager_ptr PortableServer::POAManager::_duplicate (PortableServer::POAManager_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::POAManager_ptr PortableServer::POAManager::_narrow (
                                                                    CORBA::Object_ptr obj,
                                                                    CORBA::Environment &ACE_TRY_ENV
                                                                    )
{
  if (CORBA::is_nil (obj))
    return PortableServer::POAManager::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/POAManager:1.0", ACE_TRY_ENV))
    return PortableServer::POAManager::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
      // This can only be colocated
      ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::POAManager::_nil ());

  TAO_Stub *stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = obj->_servant ()->_downcast ("IDL:omg.org/PortableServer/POAManager:1.0");
  return new POA_PortableServer::_tao_collocated_POAManager(
                                                            ACE_reinterpret_cast(POA_PortableServer::POAManager_ptr, servant),
                                                            stub
                                                            );
}

// default constructor
PortableServer::POAManager::AdapterInactive::AdapterInactive (void)
  : CORBA_UserException (PortableServer::POAManager::_tc_AdapterInactive)
{
}

// destructor - all members are of self managing types
PortableServer::POAManager::AdapterInactive::~AdapterInactive (void)
{
}

// copy constructor
PortableServer::POAManager::AdapterInactive::AdapterInactive (const PortableServer::POAManager::AdapterInactive &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POAManager::AdapterInactive&
PortableServer::POAManager::AdapterInactive::operator= (const PortableServer::POAManager::AdapterInactive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POAManager::AdapterInactive::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POAManager::AdapterInactive_ptr
PortableServer::POAManager::AdapterInactive::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POAManager/AdapterInactive:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POAManager::AdapterInactive_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POAManager::AdapterInactive::_alloc (void)
{
  return new PortableServer::POAManager::AdapterInactive;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POAManager::AdapterInactive &_tao_elem) // copying
{
  PortableServer::POAManager::AdapterInactive *_tao_any_val = new PortableServer::POAManager::AdapterInactive (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POAManager::_tc_AdapterInactive, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POAManager::AdapterInactive *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POAManager::_tc_AdapterInactive, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POAManager::AdapterInactive *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POAManager::_tc_AdapterInactive, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POAManager::AdapterInactive *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POAManager::AdapterInactive, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POAManager::_tc_AdapterInactive, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POAManager::_tc_AdapterInactive, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POAManager_AdapterInactive[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  58, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f414d61), ACE_NTOHL (0x6e616765), ACE_NTOHL (0x722f4164), ACE_NTOHL (0x61707465), ACE_NTOHL (0x72496e61), ACE_NTOHL (0x63746976), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/POAManager/AdapterInactive:1.0
  16, ACE_NTOHL (0x41646170), ACE_NTOHL (0x74657249), ACE_NTOHL (0x6e616374), ACE_NTOHL (0x69766500),  // name = AdapterInactive
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POAManager_AdapterInactive
(CORBA::tk_except, sizeof (_oc_PortableServer_POAManager_AdapterInactive),
 (char *) &_oc_PortableServer_POAManager_AdapterInactive, 0, sizeof
 (PortableServer::POAManager::AdapterInactive));
CORBA::TypeCode_ptr PortableServer::POAManager::_tc_AdapterInactive = &_tc_TAO_tc_PortableServer_POAManager_AdapterInactive;

CORBA::Boolean PortableServer::POAManager::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/POAManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::POAManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/POAManager:1.0";
}

static const CORBA::Long _oc_PortableServer_POAManager[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  42, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f414d61), ACE_NTOHL (0x6e616765), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/POAManager:1.0
  11, ACE_NTOHL (0x504f414d), ACE_NTOHL (0x616e6167), ACE_NTOHL (0x65720000),  // name = POAManager,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POAManager (CORBA::tk_objref,
                                                             sizeof (_oc_PortableServer_POAManager),
                                                             (char *) &_oc_PortableServer_POAManager,
                                                             0,
                                                             sizeof (PortableServer::POAManager));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_POAManager, &_tc_TAO_tc_PortableServer_POAManager)
TAO_NAMESPACE_END

#if !defined (TAO_HAS_MINIMUM_CORBA)

PortableServer::AdapterActivator_ptr PortableServer::AdapterActivator::_duplicate (PortableServer::AdapterActivator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::AdapterActivator_ptr PortableServer::AdapterActivator::_narrow (
                                                                                CORBA::Object_ptr obj,
                                                                                CORBA::Environment &ACE_TRY_ENV
                                                                                )
{
  if (CORBA::is_nil (obj))
    return PortableServer::AdapterActivator::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/AdapterActivator:1.0", ACE_TRY_ENV))
    return PortableServer::AdapterActivator::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
      // This can only be colocated
      ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::AdapterActivator::_nil ());

  TAO_Stub *stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = obj->_servant ()->_downcast ("IDL:omg.org/PortableServer/AdapterActivator:1.0");
  return new POA_PortableServer::_tao_collocated_AdapterActivator(
                                                                  ACE_reinterpret_cast(POA_PortableServer::AdapterActivator_ptr, servant),
                                                                  stub
                                                                  );
}

CORBA::Boolean PortableServer::AdapterActivator::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/AdapterActivator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::AdapterActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/AdapterActivator:1.0";
}

static const CORBA::Long _oc_PortableServer_AdapterActivator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f41), ACE_NTOHL (0x64617074), ACE_NTOHL (0x65724163), ACE_NTOHL (0x74697661), ACE_NTOHL (0x746f723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/AdapterActivator:1.0
  17, ACE_NTOHL (0x41646170), ACE_NTOHL (0x74657241), ACE_NTOHL (0x63746976), ACE_NTOHL (0x61746f72), ACE_NTOHL (0x0),  // name = AdapterActivator,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_AdapterActivator (CORBA::tk_objref,
                                                                   sizeof (_oc_PortableServer_AdapterActivator),
                                                                   (char *) &_oc_PortableServer_AdapterActivator,
                                                                   0,
                                                                   sizeof (PortableServer::AdapterActivator));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AdapterActivator, &_tc_TAO_tc_PortableServer_AdapterActivator)
TAO_NAMESPACE_END

PortableServer::ServantManager_ptr PortableServer::ServantManager::_duplicate (PortableServer::ServantManager_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::ServantManager_ptr PortableServer::ServantManager::_narrow (
                                                                            CORBA::Object_ptr obj,
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ServantManager::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/ServantManager:1.0", ACE_TRY_ENV))
    return PortableServer::ServantManager::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
    // This can only be colocated
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::ServantManager::_nil ());

  TAO_Stub *stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = obj->_servant ()->_downcast ("IDL:omg.org/PortableServer/ServantManager:1.0");
  return new POA_PortableServer::_tao_collocated_ServantManager(
                                                                ACE_reinterpret_cast(POA_PortableServer::ServantManager_ptr, servant),
                                                                stub
                                                                );
}

CORBA::Boolean PortableServer::ServantManager::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::ServantManager::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantManager:1.0";
}

static const CORBA::Long _oc_PortableServer_ServantManager[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f53), ACE_NTOHL (0x65727661), ACE_NTOHL (0x6e744d61), ACE_NTOHL (0x6e616765), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/ServantManager:1.0
  15, ACE_NTOHL (0x53657276), ACE_NTOHL (0x616e744d), ACE_NTOHL (0x616e6167), ACE_NTOHL (0x65720000),  // name = ServantManager,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantManager (CORBA::tk_objref,
                                                                 sizeof (_oc_PortableServer_ServantManager),
                                                                 (char *) &_oc_PortableServer_ServantManager,
                                                                 0,
                                                                 sizeof (PortableServer::ServantManager));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServantManager, &_tc_TAO_tc_PortableServer_ServantManager)
TAO_NAMESPACE_END

PortableServer::ServantActivator_ptr PortableServer::ServantActivator::_duplicate (PortableServer::ServantActivator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::ServantActivator_ptr PortableServer::ServantActivator::_narrow (
                                                                                CORBA::Object_ptr obj,
                                                                                CORBA::Environment &ACE_TRY_ENV
                                                                                )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ServantActivator::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/ServantActivator:1.0", ACE_TRY_ENV))
    return PortableServer::ServantActivator::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
      // This can only be colocated
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::ServantActivator::_nil ());

  TAO_Stub *stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = obj->_servant ()->_downcast ("IDL:omg.org/PortableServer/ServantActivator:1.0");
  return new POA_PortableServer::_tao_collocated_ServantActivator(
                                                                  ACE_reinterpret_cast(POA_PortableServer::ServantActivator_ptr, servant),
                                                                  stub
                                                                  );
}

CORBA::Boolean PortableServer::ServantActivator::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantActivator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::ServantActivator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantActivator:1.0";
}

static const CORBA::Long _oc_PortableServer_ServantActivator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f53), ACE_NTOHL (0x65727661), ACE_NTOHL (0x6e744163), ACE_NTOHL (0x74697661), ACE_NTOHL (0x746f723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/ServantActivator:1.0
  17, ACE_NTOHL (0x53657276), ACE_NTOHL (0x616e7441), ACE_NTOHL (0x63746976), ACE_NTOHL (0x61746f72), ACE_NTOHL (0x0),  // name = ServantActivator,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantActivator (CORBA::tk_objref,
                                                                   sizeof (_oc_PortableServer_ServantActivator),
                                                                   (char *) &_oc_PortableServer_ServantActivator,
                                                                   0,
                                                                   sizeof (PortableServer::ServantActivator));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServantActivator, &_tc_TAO_tc_PortableServer_ServantActivator)
TAO_NAMESPACE_END

PortableServer::ServantLocator_ptr PortableServer::ServantLocator::_duplicate (PortableServer::ServantLocator_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::ServantLocator_ptr PortableServer::ServantLocator::_narrow (
                                                                            CORBA::Object_ptr obj,
                                                                            CORBA::Environment &ACE_TRY_ENV
                                                                            )
{
  if (CORBA::is_nil (obj))
    return PortableServer::ServantLocator::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/ServantLocator:1.0", ACE_TRY_ENV))
    return PortableServer::ServantLocator::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
    // This can only be colocated
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::ServantLocator::_nil ());

  TAO_Stub *stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = obj->_servant ()->_downcast ("IDL:omg.org/PortableServer/ServantLocator:1.0");
  return new POA_PortableServer::_tao_collocated_ServantLocator(
                                                                ACE_reinterpret_cast(POA_PortableServer::ServantLocator_ptr, servant),
                                                                stub
                                                                );
}

CORBA::Boolean PortableServer::ServantLocator::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantLocator:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/ServantManager:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::ServantLocator::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/ServantLocator:1.0";
}

static const CORBA::Long _oc_PortableServer_ServantLocator[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  46, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f53), ACE_NTOHL (0x65727661), ACE_NTOHL (0x6e744c6f), ACE_NTOHL (0x6361746f), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/ServantLocator:1.0
  15, ACE_NTOHL (0x53657276), ACE_NTOHL (0x616e744c), ACE_NTOHL (0x6f636174), ACE_NTOHL (0x6f720000),  // name = ServantLocator,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_ServantLocator (CORBA::tk_objref,
                                                                 sizeof (_oc_PortableServer_ServantLocator),
                                                                 (char *) &_oc_PortableServer_ServantLocator,
                                                                 0,
                                                                 sizeof (PortableServer::ServantLocator));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ServantLocator, &_tc_TAO_tc_PortableServer_ServantLocator)
TAO_NAMESPACE_END

#endif /* TAO_HAS_MINIMUM_CORBA */

PortableServer::POA_ptr PortableServer::POA::_duplicate (PortableServer::POA_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::POA_ptr PortableServer::POA::_narrow (
                                                      CORBA::Object_ptr obj,
                                                      CORBA::Environment &ACE_TRY_ENV
                                                      )
{
  if (CORBA::is_nil (obj))
    return PortableServer::POA::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/POA:1.0", ACE_TRY_ENV))
    return PortableServer::POA::_nil ();
  if (!obj->_is_collocated () || !obj->_servant())
    // This can only be colocated
    ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::POA::_nil ());

  TAO_Stub *stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = obj->_servant ()->_downcast ("IDL:omg.org/PortableServer/POA:1.0");
  return new POA_PortableServer::_tao_collocated_POA(
                                                     ACE_reinterpret_cast(POA_PortableServer::POA_ptr, servant),
                                                     stub
                                                     );
}

// default constructor
PortableServer::POA::AdapterAlreadyExists::AdapterAlreadyExists (void)
  : CORBA_UserException (PortableServer::POA::_tc_AdapterAlreadyExists)
{
}

// destructor - all members are of self managing types
PortableServer::POA::AdapterAlreadyExists::~AdapterAlreadyExists (void)
{
}

// copy constructor
PortableServer::POA::AdapterAlreadyExists::AdapterAlreadyExists (const PortableServer::POA::AdapterAlreadyExists &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::AdapterAlreadyExists&
PortableServer::POA::AdapterAlreadyExists::operator= (const PortableServer::POA::AdapterAlreadyExists &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::AdapterAlreadyExists::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::AdapterAlreadyExists_ptr
PortableServer::POA::AdapterAlreadyExists::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/AdapterAlreadyExists:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::AdapterAlreadyExists_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::AdapterAlreadyExists::_alloc (void)
{
  return new PortableServer::POA::AdapterAlreadyExists;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::AdapterAlreadyExists &_tao_elem) // copying
{
  PortableServer::POA::AdapterAlreadyExists *_tao_any_val = new PortableServer::POA::AdapterAlreadyExists (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_AdapterAlreadyExists, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::AdapterAlreadyExists *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_AdapterAlreadyExists, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::AdapterAlreadyExists *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_AdapterAlreadyExists, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::AdapterAlreadyExists *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::AdapterAlreadyExists, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_AdapterAlreadyExists, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_AdapterAlreadyExists, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_AdapterAlreadyExists[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  56, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f41), ACE_NTOHL (0x64617074), ACE_NTOHL (0x6572416c), ACE_NTOHL (0x72656164), ACE_NTOHL (0x79457869), ACE_NTOHL (0x7374733a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/POA/AdapterAlreadyExists:1.0
  21, ACE_NTOHL (0x41646170), ACE_NTOHL (0x74657241), ACE_NTOHL (0x6c726561), ACE_NTOHL (0x64794578), ACE_NTOHL (0x69737473), ACE_NTOHL (0x0),  // name = AdapterAlreadyExists
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_AdapterAlreadyExists
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_AdapterAlreadyExists),
 (char *) &_oc_PortableServer_POA_AdapterAlreadyExists, 0, sizeof
 (PortableServer::POA::AdapterAlreadyExists));
CORBA::TypeCode_ptr PortableServer::POA::_tc_AdapterAlreadyExists = &_tc_TAO_tc_PortableServer_POA_AdapterAlreadyExists;

#if !defined (TAO_HAS_MINIMUM_CORBA)

// default constructor
PortableServer::POA::AdapterInactive::AdapterInactive (void)
  : CORBA_UserException (PortableServer::POA::_tc_AdapterInactive)
{
}

// destructor - all members are of self managing types
PortableServer::POA::AdapterInactive::~AdapterInactive (void)
{
}

// copy constructor
PortableServer::POA::AdapterInactive::AdapterInactive (const PortableServer::POA::AdapterInactive &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::AdapterInactive&
PortableServer::POA::AdapterInactive::operator= (const PortableServer::POA::AdapterInactive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::AdapterInactive::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::AdapterInactive_ptr
PortableServer::POA::AdapterInactive::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/AdapterInactive:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::AdapterInactive_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::AdapterInactive::_alloc (void)
{
  return new PortableServer::POA::AdapterInactive;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::AdapterInactive &_tao_elem) // copying
{
  PortableServer::POA::AdapterInactive *_tao_any_val = new PortableServer::POA::AdapterInactive (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_AdapterInactive, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::AdapterInactive *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_AdapterInactive, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::AdapterInactive *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_AdapterInactive, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::AdapterInactive *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::AdapterInactive, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_AdapterInactive, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_AdapterInactive, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_AdapterInactive[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f41), ACE_NTOHL (0x64617074), ACE_NTOHL (0x6572496e), ACE_NTOHL (0x61637469), ACE_NTOHL (0x76653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/POA/AdapterInactive:1.0
  16, ACE_NTOHL (0x41646170), ACE_NTOHL (0x74657249), ACE_NTOHL (0x6e616374), ACE_NTOHL (0x69766500),  // name = AdapterInactive
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_AdapterInactive
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_AdapterInactive), (char *)
 &_oc_PortableServer_POA_AdapterInactive, 0, sizeof
 (PortableServer::POA::AdapterInactive));
CORBA::TypeCode_ptr PortableServer::POA::_tc_AdapterInactive = &_tc_TAO_tc_PortableServer_POA_AdapterInactive;

#endif /* TAO_HAS_MINIMUM_CORBA */

// default constructor
PortableServer::POA::AdapterNonExistent::AdapterNonExistent (void)
  : CORBA_UserException (PortableServer::POA::_tc_AdapterNonExistent)
{
}

// destructor - all members are of self managing types
PortableServer::POA::AdapterNonExistent::~AdapterNonExistent (void)
{
}

// copy constructor
PortableServer::POA::AdapterNonExistent::AdapterNonExistent (const PortableServer::POA::AdapterNonExistent &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::AdapterNonExistent&
PortableServer::POA::AdapterNonExistent::operator= (const PortableServer::POA::AdapterNonExistent &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::AdapterNonExistent::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::AdapterNonExistent_ptr
PortableServer::POA::AdapterNonExistent::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/AdapterNonExistent:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::AdapterNonExistent_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::AdapterNonExistent::_alloc (void)
{
  return new PortableServer::POA::AdapterNonExistent;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::AdapterNonExistent &_tao_elem) // copying
{
  PortableServer::POA::AdapterNonExistent *_tao_any_val = new PortableServer::POA::AdapterNonExistent (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_AdapterNonExistent, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::AdapterNonExistent *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_AdapterNonExistent, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::AdapterNonExistent *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_AdapterNonExistent, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::AdapterNonExistent *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::AdapterNonExistent, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_AdapterNonExistent, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_AdapterNonExistent, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_AdapterNonExistent[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  54, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f41), ACE_NTOHL (0x64617074), ACE_NTOHL (0x65724e6f), ACE_NTOHL (0x6e457869), ACE_NTOHL (0x7374656e), ACE_NTOHL (0x743a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/PortableServer/POA/AdapterNonExistent:1.0
  19, ACE_NTOHL (0x41646170), ACE_NTOHL (0x7465724e), ACE_NTOHL (0x6f6e4578), ACE_NTOHL (0x69737465), ACE_NTOHL (0x6e740000),  // name = AdapterNonExistent
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_AdapterNonExistent
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_AdapterNonExistent), (char *)
 &_oc_PortableServer_POA_AdapterNonExistent, 0, sizeof
 (PortableServer::POA::AdapterNonExistent));
CORBA::TypeCode_ptr PortableServer::POA::_tc_AdapterNonExistent = &_tc_TAO_tc_PortableServer_POA_AdapterNonExistent;

// default constructor
PortableServer::POA::InvalidPolicy::InvalidPolicy (void)
  : CORBA_UserException (PortableServer::POA::_tc_InvalidPolicy)
{
}

// destructor - all members are of self managing types
PortableServer::POA::InvalidPolicy::~InvalidPolicy (void)
{
}

// copy constructor
PortableServer::POA::InvalidPolicy::InvalidPolicy (const PortableServer::POA::InvalidPolicy &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
  this->index = _tao_excp.index;
}

// assignment operator
PortableServer::POA::InvalidPolicy&
PortableServer::POA::InvalidPolicy::operator= (const PortableServer::POA::InvalidPolicy &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  this->index = _tao_excp.index;
  return *this;
}

PortableServer::POA::InvalidPolicy::InvalidPolicy(
                                                  CORBA::UShort _tao_index)
  : CORBA_UserException  (PortableServer::POA::_tc_InvalidPolicy)
{
  this->index = _tao_index;
}

void PortableServer::POA::InvalidPolicy::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::InvalidPolicy_ptr
PortableServer::POA::InvalidPolicy::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/InvalidPolicy:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::InvalidPolicy_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::InvalidPolicy::_alloc (void)
{
  return new PortableServer::POA::InvalidPolicy;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::InvalidPolicy &_tao_elem) // copying
{
  PortableServer::POA::InvalidPolicy *_tao_any_val = new PortableServer::POA::InvalidPolicy (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_InvalidPolicy, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::InvalidPolicy *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_InvalidPolicy, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::InvalidPolicy *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_InvalidPolicy, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::InvalidPolicy *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::InvalidPolicy, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_InvalidPolicy, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_InvalidPolicy, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_InvalidPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f49), ACE_NTOHL (0x6e76616c), ACE_NTOHL (0x6964506f), ACE_NTOHL (0x6c696379), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/POA/InvalidPolicy:1.0
  14, ACE_NTOHL (0x496e7661), ACE_NTOHL (0x6c696450), ACE_NTOHL (0x6f6c6963), ACE_NTOHL (0x79000000),  // name = InvalidPolicy
  1, // member count
    6, ACE_NTOHL (0x696e6465), ACE_NTOHL (0x78000000),  // name = index
    CORBA::tk_ushort,

};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_InvalidPolicy
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_InvalidPolicy), (char *)
 &_oc_PortableServer_POA_InvalidPolicy, 0, sizeof
 (PortableServer::POA::InvalidPolicy));
CORBA::TypeCode_ptr PortableServer::POA::_tc_InvalidPolicy = &_tc_TAO_tc_PortableServer_POA_InvalidPolicy;

#if !defined (TAO_HAS_MINIMUM_CORBA)

// default constructor
PortableServer::POA::NoServant::NoServant (void)
  : CORBA_UserException (PortableServer::POA::_tc_NoServant)
{
}

// destructor - all members are of self managing types
PortableServer::POA::NoServant::~NoServant (void)
{
}

// copy constructor
PortableServer::POA::NoServant::NoServant (const PortableServer::POA::NoServant &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::NoServant&
PortableServer::POA::NoServant::operator= (const PortableServer::POA::NoServant &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::NoServant::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::NoServant_ptr
PortableServer::POA::NoServant::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/NoServant:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::NoServant_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::NoServant::_alloc (void)
{
  return new PortableServer::POA::NoServant;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::NoServant &_tao_elem) // copying
{
  PortableServer::POA::NoServant *_tao_any_val = new PortableServer::POA::NoServant (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_NoServant, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::NoServant *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_NoServant, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::NoServant *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_NoServant, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::NoServant *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::NoServant, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_NoServant, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_NoServant, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_NoServant[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  45, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f4e), ACE_NTOHL (0x6f536572), ACE_NTOHL (0x76616e74), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/POA/NoServant:1.0
  10, ACE_NTOHL (0x4e6f5365), ACE_NTOHL (0x7276616e), ACE_NTOHL (0x74000000),  // name = NoServant
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_NoServant (CORBA::tk_except,
                                                             sizeof
                                                             (_oc_PortableServer_POA_NoServant),
                                                             (char *)
                                                             &_oc_PortableServer_POA_NoServant, 0,
                                                             sizeof (PortableServer::POA::NoServant));
CORBA::TypeCode_ptr PortableServer::POA::_tc_NoServant = &_tc_TAO_tc_PortableServer_POA_NoServant;

#endif /* TAO_HAS_MINIMUM_CORBA */

// default constructor
PortableServer::POA::ObjectAlreadyActive::ObjectAlreadyActive (void)
  : CORBA_UserException (PortableServer::POA::_tc_ObjectAlreadyActive)
{
}

// destructor - all members are of self managing types
PortableServer::POA::ObjectAlreadyActive::~ObjectAlreadyActive (void)
{
}

// copy constructor
PortableServer::POA::ObjectAlreadyActive::ObjectAlreadyActive (const PortableServer::POA::ObjectAlreadyActive &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::ObjectAlreadyActive&
PortableServer::POA::ObjectAlreadyActive::operator= (const PortableServer::POA::ObjectAlreadyActive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::ObjectAlreadyActive::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::ObjectAlreadyActive_ptr
PortableServer::POA::ObjectAlreadyActive::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ObjectAlreadyActive:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::ObjectAlreadyActive_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::ObjectAlreadyActive::_alloc (void)
{
  return new PortableServer::POA::ObjectAlreadyActive;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::ObjectAlreadyActive &_tao_elem) // copying
{
  PortableServer::POA::ObjectAlreadyActive *_tao_any_val = new PortableServer::POA::ObjectAlreadyActive (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_ObjectAlreadyActive, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::ObjectAlreadyActive *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_ObjectAlreadyActive, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::ObjectAlreadyActive *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_ObjectAlreadyActive, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::ObjectAlreadyActive *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::ObjectAlreadyActive, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_ObjectAlreadyActive, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_ObjectAlreadyActive, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_ObjectAlreadyActive[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  55, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x74416c72), ACE_NTOHL (0x65616479), ACE_NTOHL (0x41637469), ACE_NTOHL (0x76653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/POA/ObjectAlreadyActive:1.0
  20, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x6374416c), ACE_NTOHL (0x72656164), ACE_NTOHL (0x79416374), ACE_NTOHL (0x69766500),  // name = ObjectAlreadyActive
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_ObjectAlreadyActive
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_ObjectAlreadyActive),
 (char *) &_oc_PortableServer_POA_ObjectAlreadyActive, 0, sizeof
 (PortableServer::POA::ObjectAlreadyActive));
CORBA::TypeCode_ptr PortableServer::POA::_tc_ObjectAlreadyActive = &_tc_TAO_tc_PortableServer_POA_ObjectAlreadyActive;

// default constructor
PortableServer::POA::ObjectNotActive::ObjectNotActive (void)
  : CORBA_UserException (PortableServer::POA::_tc_ObjectNotActive)
{
}

// destructor - all members are of self managing types
PortableServer::POA::ObjectNotActive::~ObjectNotActive (void)
{
}

// copy constructor
PortableServer::POA::ObjectNotActive::ObjectNotActive (const PortableServer::POA::ObjectNotActive &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::ObjectNotActive&
PortableServer::POA::ObjectNotActive::operator= (const PortableServer::POA::ObjectNotActive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::ObjectNotActive::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::ObjectNotActive_ptr
PortableServer::POA::ObjectNotActive::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ObjectNotActive:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::ObjectNotActive_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::ObjectNotActive::_alloc (void)
{
  return new PortableServer::POA::ObjectNotActive;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::ObjectNotActive &_tao_elem) // copying
{
  PortableServer::POA::ObjectNotActive *_tao_any_val = new PortableServer::POA::ObjectNotActive (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_ObjectNotActive, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::ObjectNotActive *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_ObjectNotActive, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::ObjectNotActive *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_ObjectNotActive, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::ObjectNotActive *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::ObjectNotActive, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_ObjectNotActive, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_ObjectNotActive, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_ObjectNotActive[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  51, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f4f), ACE_NTOHL (0x626a6563), ACE_NTOHL (0x744e6f74), ACE_NTOHL (0x41637469), ACE_NTOHL (0x76653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/POA/ObjectNotActive:1.0
  16, ACE_NTOHL (0x4f626a65), ACE_NTOHL (0x63744e6f), ACE_NTOHL (0x74416374), ACE_NTOHL (0x69766500),  // name = ObjectNotActive
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_ObjectNotActive
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_ObjectNotActive), (char *)
 &_oc_PortableServer_POA_ObjectNotActive, 0, sizeof
 (PortableServer::POA::ObjectNotActive));
CORBA::TypeCode_ptr PortableServer::POA::_tc_ObjectNotActive = &_tc_TAO_tc_PortableServer_POA_ObjectNotActive;

// default constructor
PortableServer::POA::ServantAlreadyActive::ServantAlreadyActive (void)
  : CORBA_UserException (PortableServer::POA::_tc_ServantAlreadyActive)
{
}

// destructor - all members are of self managing types
PortableServer::POA::ServantAlreadyActive::~ServantAlreadyActive (void)
{
}

// copy constructor
PortableServer::POA::ServantAlreadyActive::ServantAlreadyActive (const PortableServer::POA::ServantAlreadyActive &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::ServantAlreadyActive&
PortableServer::POA::ServantAlreadyActive::operator= (const PortableServer::POA::ServantAlreadyActive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::ServantAlreadyActive::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::ServantAlreadyActive_ptr
PortableServer::POA::ServantAlreadyActive::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ServantAlreadyActive:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::ServantAlreadyActive_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::ServantAlreadyActive::_alloc (void)
{
  return new PortableServer::POA::ServantAlreadyActive;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::ServantAlreadyActive &_tao_elem) // copying
{
  PortableServer::POA::ServantAlreadyActive *_tao_any_val = new PortableServer::POA::ServantAlreadyActive (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_ServantAlreadyActive, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::ServantAlreadyActive *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_ServantAlreadyActive, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::ServantAlreadyActive *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_ServantAlreadyActive, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::ServantAlreadyActive *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::ServantAlreadyActive, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_ServantAlreadyActive, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_ServantAlreadyActive, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_ServantAlreadyActive[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  56, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f53), ACE_NTOHL (0x65727661), ACE_NTOHL (0x6e74416c), ACE_NTOHL (0x72656164), ACE_NTOHL (0x79416374), ACE_NTOHL (0x6976653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/POA/ServantAlreadyActive:1.0
  21, ACE_NTOHL (0x53657276), ACE_NTOHL (0x616e7441), ACE_NTOHL (0x6c726561), ACE_NTOHL (0x64794163), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = ServantAlreadyActive
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_ServantAlreadyActive
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_ServantAlreadyActive),
 (char *) &_oc_PortableServer_POA_ServantAlreadyActive, 0, sizeof
 (PortableServer::POA::ServantAlreadyActive));
CORBA::TypeCode_ptr PortableServer::POA::_tc_ServantAlreadyActive = &_tc_TAO_tc_PortableServer_POA_ServantAlreadyActive;

// default constructor
PortableServer::POA::ServantNotActive::ServantNotActive (void)
  : CORBA_UserException (PortableServer::POA::_tc_ServantNotActive)
{
}

// destructor - all members are of self managing types
PortableServer::POA::ServantNotActive::~ServantNotActive (void)
{
}

// copy constructor
PortableServer::POA::ServantNotActive::ServantNotActive (const PortableServer::POA::ServantNotActive &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::ServantNotActive&
PortableServer::POA::ServantNotActive::operator= (const PortableServer::POA::ServantNotActive &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::ServantNotActive::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::ServantNotActive_ptr
PortableServer::POA::ServantNotActive::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/ServantNotActive:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::ServantNotActive_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::ServantNotActive::_alloc (void)
{
  return new PortableServer::POA::ServantNotActive;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::ServantNotActive &_tao_elem) // copying
{
  PortableServer::POA::ServantNotActive *_tao_any_val = new PortableServer::POA::ServantNotActive (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_ServantNotActive, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::ServantNotActive *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_ServantNotActive, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::ServantNotActive *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_ServantNotActive, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::ServantNotActive *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::ServantNotActive, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_ServantNotActive, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_ServantNotActive, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_ServantNotActive[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  52, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f53), ACE_NTOHL (0x65727661), ACE_NTOHL (0x6e744e6f), ACE_NTOHL (0x74416374), ACE_NTOHL (0x6976653a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/POA/ServantNotActive:1.0
  17, ACE_NTOHL (0x53657276), ACE_NTOHL (0x616e744e), ACE_NTOHL (0x6f744163), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = ServantNotActive
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_ServantNotActive
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_ServantNotActive), (char *)
 &_oc_PortableServer_POA_ServantNotActive, 0, sizeof
 (PortableServer::POA::ServantNotActive));
CORBA::TypeCode_ptr PortableServer::POA::_tc_ServantNotActive = &_tc_TAO_tc_PortableServer_POA_ServantNotActive;

// default constructor
PortableServer::POA::WrongAdapter::WrongAdapter (void)
  : CORBA_UserException (PortableServer::POA::_tc_WrongAdapter)
{
}

// destructor - all members are of self managing types
PortableServer::POA::WrongAdapter::~WrongAdapter (void)
{
}

// copy constructor
PortableServer::POA::WrongAdapter::WrongAdapter (const PortableServer::POA::WrongAdapter &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::WrongAdapter&
PortableServer::POA::WrongAdapter::operator= (const PortableServer::POA::WrongAdapter &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::WrongAdapter::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::WrongAdapter_ptr
PortableServer::POA::WrongAdapter::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/WrongAdapter:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::WrongAdapter_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::WrongAdapter::_alloc (void)
{
  return new PortableServer::POA::WrongAdapter;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::WrongAdapter &_tao_elem) // copying
{
  PortableServer::POA::WrongAdapter *_tao_any_val = new PortableServer::POA::WrongAdapter (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_WrongAdapter, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::WrongAdapter *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_WrongAdapter, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::WrongAdapter *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_WrongAdapter, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::WrongAdapter *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::WrongAdapter, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_WrongAdapter, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_WrongAdapter, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_WrongAdapter[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  48, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f57), ACE_NTOHL (0x726f6e67), ACE_NTOHL (0x41646170), ACE_NTOHL (0x7465723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/PortableServer/POA/WrongAdapter:1.0
  13, ACE_NTOHL (0x57726f6e), ACE_NTOHL (0x67416461), ACE_NTOHL (0x70746572), ACE_NTOHL (0x0),  // name = WrongAdapter
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_WrongAdapter
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_WrongAdapter), (char *)
 &_oc_PortableServer_POA_WrongAdapter, 0, sizeof
 (PortableServer::POA::WrongAdapter));
CORBA::TypeCode_ptr PortableServer::POA::_tc_WrongAdapter = &_tc_TAO_tc_PortableServer_POA_WrongAdapter;

// default constructor
PortableServer::POA::WrongPolicy::WrongPolicy (void)
  : CORBA_UserException (PortableServer::POA::_tc_WrongPolicy)
{
}

// destructor - all members are of self managing types
PortableServer::POA::WrongPolicy::~WrongPolicy (void)
{
}

// copy constructor
PortableServer::POA::WrongPolicy::WrongPolicy (const PortableServer::POA::WrongPolicy &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::POA::WrongPolicy&
PortableServer::POA::WrongPolicy::operator= (const PortableServer::POA::WrongPolicy &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::POA::WrongPolicy::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::POA::WrongPolicy_ptr
PortableServer::POA::WrongPolicy::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/POA/WrongPolicy:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::POA::WrongPolicy_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::POA::WrongPolicy::_alloc (void)
{
  return new PortableServer::POA::WrongPolicy;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::POA::WrongPolicy &_tao_elem) // copying
{
  PortableServer::POA::WrongPolicy *_tao_any_val = new PortableServer::POA::WrongPolicy (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_WrongPolicy, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::POA::WrongPolicy *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::POA::_tc_WrongPolicy, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::POA::WrongPolicy *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::POA::_tc_WrongPolicy, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::POA::WrongPolicy *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::POA::WrongPolicy, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::POA::_tc_WrongPolicy, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::POA::_tc_WrongPolicy, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_POA_WrongPolicy[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  47, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f412f57), ACE_NTOHL (0x726f6e67), ACE_NTOHL (0x506f6c69), ACE_NTOHL (0x63793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/POA/WrongPolicy:1.0
  12, ACE_NTOHL (0x57726f6e), ACE_NTOHL (0x67506f6c), ACE_NTOHL (0x69637900),  // name = WrongPolicy
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA_WrongPolicy
(CORBA::tk_except, sizeof (_oc_PortableServer_POA_WrongPolicy), (char *)
 &_oc_PortableServer_POA_WrongPolicy, 0, sizeof
 (PortableServer::POA::WrongPolicy));
CORBA::TypeCode_ptr PortableServer::POA::_tc_WrongPolicy = &_tc_TAO_tc_PortableServer_POA_WrongPolicy;

CORBA::Boolean PortableServer::POA::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/POA:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::POA::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/POA:1.0";
}

static const CORBA::Long _oc_PortableServer_POA[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f50), ACE_NTOHL (0x4f413a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/PortableServer/POA:1.0
  4, ACE_NTOHL (0x504f4100),  // name = POA,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_POA (CORBA::tk_objref,
                                                      sizeof (_oc_PortableServer_POA),
                                                      (char *) &_oc_PortableServer_POA,
                                                      0,
                                                      sizeof (PortableServer::POA));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (PortableServer)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_POA, &_tc_TAO_tc_PortableServer_POA)
TAO_NAMESPACE_END

PortableServer::Current_ptr PortableServer::Current::_duplicate (PortableServer::Current_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_incr_refcnt ();

  return obj;
} // end of _duplicate

PortableServer::Current_ptr PortableServer::Current::_narrow (
                                                              CORBA::Object_ptr obj,
                                                              CORBA::Environment &env
                                                              )
{
  if (CORBA::is_nil (obj))
    return PortableServer::Current::_nil ();
  if (!obj->_is_a ("IDL:omg.org/PortableServer/Current:1.0", env))
    return PortableServer::Current::_nil ();
  TAO_Stub* stub = obj->_stubobj ();
  stub->_incr_refcnt ();
  void* servant = 0;
  if (obj->_is_collocated () && obj->_servant() != 0)
    servant = obj->_servant()->_downcast ("IDL:omg.org/PortableServer/Current:1.0");
  if (servant == 0)
    return new PortableServer::Current(stub);
  return new POA_PortableServer::_tao_collocated_Current(
      ACE_reinterpret_cast(POA_PortableServer::Current_ptr, servant),
      stub
    );
}

// default constructor
PortableServer::Current::NoContext::NoContext (void)
  : CORBA_UserException (PortableServer::Current::_tc_NoContext)
{
}

// destructor - all members are of self managing types
PortableServer::Current::NoContext::~NoContext (void)
{
}

// copy constructor
PortableServer::Current::NoContext::NoContext (const PortableServer::Current::NoContext &_tao_excp)
  : CORBA_UserException (_tao_excp._type ())
{
}

// assignment operator
PortableServer::Current::NoContext&
PortableServer::Current::NoContext::operator= (const PortableServer::Current::NoContext &_tao_excp)
{
  this->CORBA_UserException::operator= (_tao_excp);
  return *this;
}

void PortableServer::Current::NoContext::_raise (void)
{
  TAO_RAISE(*this);
}

// narrow
PortableServer::Current::NoContext_ptr
PortableServer::Current::NoContext::_narrow (CORBA::Exception *exc)
{
  if (!ACE_OS::strcmp ("IDL:omg.org/PortableServer/Current/NoContext:1.0", exc->_id ())) // same type
    return ACE_dynamic_cast (PortableServer::Current::NoContext_ptr, exc);
  else
    return 0;
}

// TAO extension - the _alloc method
CORBA::Exception *PortableServer::Current::NoContext::_alloc (void)
{
  return new PortableServer::Current::NoContext;
}

void operator<<= (CORBA::Any &_tao_any, const PortableServer::Current::NoContext &_tao_elem) // copying
{
  PortableServer::Current::NoContext *_tao_any_val = new PortableServer::Current::NoContext (_tao_elem);
  if (!_tao_any_val) return;
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::Current::_tc_NoContext, _tao_any_val, 1, ACE_TRY_ENV);
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY
  {
    delete _tao_any_val;
  }
  ACE_ENDTRY;
}

void operator<<= (CORBA::Any &_tao_any, PortableServer::Current::NoContext *_tao_elem) // non copying
{
  ACE_TRY_NEW_ENV
  {
    _tao_any.replace (PortableServer::Current::_tc_NoContext, _tao_elem, 1, ACE_TRY_ENV); // consume it
    ACE_TRY_CHECK;
  }
  ACE_CATCHANY {}
  ACE_ENDTRY;
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, PortableServer::Current::NoContext *&_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equal (PortableServer::Current::_tc_NoContext, ACE_TRY_ENV)) return 0; // not equal
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = (PortableServer::Current::NoContext *)_tao_any.value ();
      return 1;
    }
    else
    {
      ACE_NEW_RETURN (_tao_elem, PortableServer::Current::NoContext, 0);
      TAO_InputCDR stream (_tao_any._tao_get_cdr ());
      if (stream.decode (PortableServer::Current::_tc_NoContext, _tao_elem, 0, ACE_TRY_ENV)
        == CORBA::TypeCode::TRAVERSE_CONTINUE)
      {
        ((CORBA::Any *)&_tao_any)->replace (PortableServer::Current::_tc_NoContext, _tao_elem, 1, ACE_TRY_ENV);
        ACE_TRY_CHECK;
        return 1;
      }
      else
      {
        delete _tao_elem;
      }
    }
  }
  ACE_CATCHANY
  {
    delete _tao_elem;
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

static const CORBA::Long _oc_PortableServer_Current_NoContext[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  49, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f43), ACE_NTOHL (0x75727265), ACE_NTOHL (0x6e742f4e), ACE_NTOHL (0x6f436f6e), ACE_NTOHL (0x74657874), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/PortableServer/Current/NoContext:1.0
  10, ACE_NTOHL (0x4e6f436f), ACE_NTOHL (0x6e746578), ACE_NTOHL (0x74000000),  // name = NoContext
  0, // member count
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_Current_NoContext
(CORBA::tk_except, sizeof (_oc_PortableServer_Current_NoContext), (char *)
 &_oc_PortableServer_Current_NoContext, 0, sizeof
 (PortableServer::Current::NoContext));
CORBA::TypeCode_ptr PortableServer::Current::_tc_NoContext = &_tc_TAO_tc_PortableServer_Current_NoContext;

PortableServer::POA_ptr  PortableServer::Current::get_POA (CORBA::Environment &ACE_TRY_ENV)
{
  ACE_THROW_RETURN (CORBA::MARSHAL (), PortableServer::POA::_nil ());
}

PortableServer::ObjectId * PortableServer::Current::get_object_id (CORBA::Environment &ACE_TRY_ENV)
{
    static TAO_Exception_Data _tao_PortableServer_Current_get_object_id_exceptiondata [] =
  {
    {PortableServer::Current::_tc_NoContext, PortableServer::Current::NoContext::_alloc}
  };

  PortableServer::ObjectId *_tao_retval = 0;

  TAO_Stub *istub = this->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INV_OBJREF (), _tao_retval);


  ACE_NEW_RETURN (_tao_retval, PortableServer::ObjectId, _tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_object_id",
      istub->orb_core ()
    );


  for (;;)
  {
    ACE_TRY_ENV.clear ();
    _tao_call.start (ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    int _invoke_status =
      _tao_call.invoke (_tao_PortableServer_Current_get_object_id_exceptiondata, 1, ACE_TRY_ENV);
        ACE_CHECK_RETURN (_tao_retval);

    if (_invoke_status == TAO_INVOKE_RESTART)
      continue;
    // if (_invoke_status == TAO_INVOKE_EXCEPTION)
      // cannot happen
    if (_invoke_status != TAO_INVOKE_OK)
    {
      ACE_THROW_RETURN (CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);

    }
    break;

  }
  TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
  if (!(
        (_tao_in >> *_tao_retval)
    ))
    ACE_THROW_RETURN (CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES), _tao_retval);
  return _tao_retval;
}

CORBA::Boolean PortableServer::Current::_is_a (const CORBA::Char *value, CORBA::Environment &_tao_environment)
{
  if (
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/PortableServer/Current:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Current:1.0")) ||
      (!ACE_OS::strcmp ((char *)value, CORBA::_tc_Object->id (_tao_environment))))
    return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, _tao_environment); // remote call
}

const char* PortableServer::Current::_interface_repository_id (void) const
{
  return "IDL:omg.org/PortableServer/Current:1.0";
}

static const CORBA::Long _oc_PortableServer_Current[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x506f7274), ACE_NTOHL (0x61626c65), ACE_NTOHL (0x53657276), ACE_NTOHL (0x65722f43), ACE_NTOHL (0x75727265), ACE_NTOHL (0x6e743a31), ACE_NTOHL (0x2e3000fd),  // repository ID = IDL:PortableServer/Current:1.0
  8, ACE_NTOHL (0x43757272), ACE_NTOHL (0x656e7400),  // name = Current,
};
static CORBA::TypeCode _tc_TAO_tc_PortableServer_Current (CORBA::tk_objref, sizeof
                                                       (_oc_PortableServer_Current), (char *) &_oc_PortableServer_Current,
                                                       0,
                                                       sizeof (PortableServer::Current));
CORBA::TypeCode_ptr PortableServer::_tc_Current = &_tc_TAO_tc_PortableServer_Current;

char *
PortableServer::ObjectId_to_string (const PortableServer::ObjectId &id)
{
  return TAO_POA::ObjectId_to_string (id);
}

CORBA::WChar *
PortableServer::ObjectId_to_wstring (const PortableServer::ObjectId &id)
{
  return TAO_POA::ObjectId_to_wstring (id);
}

PortableServer::ObjectId *
PortableServer::string_to_ObjectId (const char *id)
{
  return TAO_POA::string_to_ObjectId (id);
}

PortableServer::ObjectId *
PortableServer::wstring_to_ObjectId (const CORBA::WChar *id)
{
  return TAO_POA::wstring_to_ObjectId (id);
}
