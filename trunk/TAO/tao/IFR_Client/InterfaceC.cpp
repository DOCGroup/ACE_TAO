// -*- C++ -*-
//
/* $Id$ */

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

#include "InterfaceC.h"
#include "tao/Stub.h"
#include "tao/Invocation.h"

// The Following header must remain visible since it contains the
// "TAO_INTERCEPTOR" macros.  Note that this won't cause problems when
// portable interceptor support is disabled since those macros are
// always visible, too.
#include "tao/PortableInterceptor.h"

#if TAO_HAS_INTERCEPTORS == 1
#include "tao/RequestInfo_Util.h"
#endif  /* TAO_HAS_INTERCEPTORS == 1 */

#if defined (__BORLANDC__)
#pragma option -w-rvl -w-rch -w-ccc -w-aus
#endif /* __BORLANDC__ */

#if !defined (__ACE_INLINE__)
#include "InterfaceC.i"
#endif /* !defined INLINE */

static const CORBA::Long _oc_IR_DefinitionKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f44), ACE_NTOHL (0x6566696e), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e4b696e), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/DefinitionKind:1.0
  15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
  34, // member count
  8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
  7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
  13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
  12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
  13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
  13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
  10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
  13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
  11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
  9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
  10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
  9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
  8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
  13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
  10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
  12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
  9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
  14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
  11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
  9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
  9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
  12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
  15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
  10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
  13, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = dk_Component
  8, ACE_NTOHL (0x646b5f48), ACE_NTOHL (0x6f6d6500),  // name = dk_Home
  11, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72790000),  // name = dk_Factory
  10, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72000000),  // name = dk_Finder
  14, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79000000),  // name = dk_PrimaryKey
  9, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x0),  // name = dk_Emits
  13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x0),  // name = dk_Publishes
  12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657300),  // name = dk_Consumes
  12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
  8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses
};
static CORBA::TypeCode _tc_TAO_tc_IR_DefinitionKind (CORBA::tk_enum, sizeof (_oc_IR_DefinitionKind), (char *) &_oc_IR_DefinitionKind, 0, sizeof (IR_DefinitionKind));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_DefinitionKind, &_tc_TAO_tc_IR_DefinitionKind)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_IRObject_Proxy_Impl::_TAO_IRObject_Proxy_Impl (void)
{}

_TAO_IRObject_Remote_Proxy_Impl::_TAO_IRObject_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_DefinitionKind _TAO_IRObject_Remote_Proxy_Impl::def_kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_DefinitionKind _tao_retval = (IR_DefinitionKind)0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_def_kind",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_DefinitionKind  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_IRObject_Remote_Proxy_Impl::destroy (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "destroy",
      7,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_IRObject_Proxy_Broker::_TAO_IRObject_Proxy_Broker (void)
{
}

_TAO_IRObject_Proxy_Broker::~_TAO_IRObject_Proxy_Broker (void)
{
}

_TAO_IRObject_Proxy_Broker * (*_TAO_IRObject_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_IRObject_Remote_Proxy_Broker *
_TAO_IRObject_Remote_Proxy_Broker::the_TAO_IRObject_Remote_Proxy_Broker (void)
{
  static ::_TAO_IRObject_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}
_TAO_IRObject_Remote_Proxy_Broker::_TAO_IRObject_Remote_Proxy_Broker (void)
{
}

_TAO_IRObject_Remote_Proxy_Broker::~_TAO_IRObject_Remote_Proxy_Broker (void)
{
}

_TAO_IRObject_Proxy_Impl&
_TAO_IRObject_Remote_Proxy_Broker::select_proxy (
  CORBA_IRObject *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
CORBA_IRObject::CORBA_IRObject (int collocated)
{
  this->CORBA_IRObject_setup_collocation (collocated);
}

// destructor
CORBA_IRObject::~CORBA_IRObject (void)
{}

void
CORBA_IRObject::CORBA_IRObject_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_IRObject_Proxy_Broker_ =
      _TAO_IRObject_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_IRObject_Proxy_Broker_ =
      _TAO_IRObject_Remote_Proxy_Broker::the_TAO_IRObject_Remote_Proxy_Broker ();    
}

void CORBA_IRObject::_tao_any_destructor (void *x)
{
  CORBA_IRObject *tmp = ACE_static_cast (CORBA_IRObject*,x);
  CORBA::release (tmp);
}

CORBA_IRObject_ptr CORBA_IRObject::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_IRObject::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/CORBA/IRObject:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (CORBA_IRObject::_nil ());
      if (is_a == 0)
        return CORBA_IRObject::_nil ();
    }
  return CORBA_IRObject::_unchecked_narrow (obj, ACE_TRY_ENV);
}

CORBA_IRObject_ptr CORBA_IRObject::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return CORBA_IRObject::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      CORBA_IRObject_ptr default_proxy = CORBA_IRObject::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () && _TAO_IRObject_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          CORBA_IRObject (
            stub,
            1,
            obj->_servant ()),
            
          CORBA_IRObject::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, CORBA_IRObject (stub, 0, obj->_servant ()), CORBA_IRObject::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            CORBA_IRObject_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &CORBA_IRObject::_narrow
                    )
                )
          );
}

CORBA_IRObject_ptr
CORBA_IRObject::_duplicate (CORBA_IRObject_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean CORBA_IRObject::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *CORBA_IRObject::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* CORBA_IRObject::_interface_repository_id (void) const
{
  return "IDL:omg.org/CORBA/IRObject:1.0";
}

IR_DefinitionKind CORBA_IRObject::def_kind (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_IRObject_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).def_kind (
      this,
      ACE_TRY_ENV
    );
}

void CORBA_IRObject::destroy (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_IRObject_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).destroy (
      this,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_def_kind_get::result (IR_DefinitionKind result)
{
  // update the result 
  this->_result = result;
}

CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy::TAO_ClientRequestInfo_CORBA_IRObject_destroy (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
CORBA_IRObject::TAO_ClientRequestInfo_CORBA_IRObject_destroy::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_Identifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
  11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f4964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string,
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_Identifier (CORBA::tk_alias, sizeof (_oc_IR_Identifier), (char *) &_oc_IR_Identifier, 0, sizeof (IR::Identifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Identifier, &_tc_TAO_tc_IR_Identifier)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ScopedName[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x636f7065), ACE_NTOHL (0x644e616d), ACE_NTOHL (0x653a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ScopedName:1.0
  11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5363), ACE_NTOHL (0x6f706564), ACE_NTOHL (0x4e616d65), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/ScopedName:1.0
    11, ACE_NTOHL (0x53636f70), ACE_NTOHL (0x65644e61), ACE_NTOHL (0x6d650000),  // name = ScopedName
    CORBA::tk_string,
    0U, // string length

};

static CORBA::TypeCode _tc_TAO_tc_IR_ScopedName (CORBA::tk_alias, sizeof (_oc_IR_ScopedName), (char *) &_oc_IR_ScopedName, 0, sizeof (IR::ScopedName));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ScopedName, &_tc_TAO_tc_IR_ScopedName)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_RepositoryId[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
  13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = IR_RepositoryId
  CORBA::tk_alias, // typecode kind for typedefs
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5265), ACE_NTOHL (0x706f7369), ACE_NTOHL (0x746f7279), ACE_NTOHL (0x49643a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/CORBA/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = IR_RepositoryId
    CORBA::tk_string,
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryId (CORBA::tk_alias, sizeof (_oc_IR_RepositoryId), (char *) &_oc_IR_RepositoryId, 0, sizeof (IR::RepositoryId));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryId, &_tc_TAO_tc_IR_RepositoryId)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_VersionSpec[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
  12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
  CORBA::tk_string, 
  0U, // string length
};
static CORBA::TypeCode _tc_TAO_tc_IR_VersionSpec (CORBA::tk_alias, sizeof (_oc_IR_VersionSpec), (char *) &_oc_IR_VersionSpec, 0, sizeof (IR::VersionSpec));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_VersionSpec, &_tc_TAO_tc_IR_VersionSpec)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_Contained_Proxy_Impl::_TAO_Contained_Proxy_Impl (void)
{}

_TAO_Contained_Remote_Proxy_Impl::_TAO_Contained_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

char * _TAO_Contained_Remote_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_id",
      7,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              char * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_Contained_Remote_Proxy_Impl::id (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_id",
      7,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_set ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

char * _TAO_Contained_Remote_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  CORBA::String_var _tao_safe_retval;
    
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_name",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              char * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_Contained_Remote_Proxy_Impl::name (
    CORBA_Object *_collocated_tao_target_,
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_name",
      9,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_set ri (
        &_tao_call,
        _collocated_tao_target_,
        name,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << name)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

char * _TAO_Contained_Remote_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
   CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::String_var _tao_safe_retval;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_version",
      12,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              char * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_Contained_Remote_Proxy_Impl::version (
    CORBA_Object *_collocated_tao_target_,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{ 
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_version",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_set ri (
        &_tao_call,
        _collocated_tao_target_,
        version,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << version)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_Container_ptr _TAO_Contained_Remote_Proxy_Impl::defined_in (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  IR_Container_ptr _tao_retval = IR_Container::_nil ();
  IR_Container_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_defined_in",
      15,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_Container_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

char * _TAO_Contained_Remote_Proxy_Impl::absolute_name (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  CORBA::String_var _tao_safe_retval;
    
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_absolute_name",
      18,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              char * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_Repository_ptr _TAO_Contained_Remote_Proxy_Impl::containing_repository (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{ 
  IR_Repository_ptr _tao_retval = IR_Repository::_nil ();
  IR_Repository_var _tao_safe_retval (_tao_retval);
    
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_containing_repository",
      26,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_Repository_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_Contained::Description * _TAO_Contained_Remote_Proxy_Impl::describe (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  IR_Contained::Description *_tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  ACE_NEW_RETURN (_tao_retval, IR_Contained::Description, _tao_retval);
  IR_Contained::Description_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe",
      8,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_describe ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_Contained::Description * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_Contained_Remote_Proxy_Impl::move (
    CORBA_Object *_collocated_tao_target_,
    IR_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());
 
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "move",
      4,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Contained::TAO_ClientRequestInfo_IR_Contained_move ri (
        &_tao_call,
        _collocated_tao_target_,
        new_container,
        new_name,
        new_version,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << new_container) &&
              (_tao_out << new_name) &&
              (_tao_out << new_version)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_Contained_Proxy_Broker::_TAO_Contained_Proxy_Broker (void)
{
}

_TAO_Contained_Proxy_Broker::~_TAO_Contained_Proxy_Broker (void)
{
}

_TAO_Contained_Proxy_Broker * (*_TAO_Contained_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_Contained_Remote_Proxy_Broker *
_TAO_Contained_Remote_Proxy_Broker::the_TAO_Contained_Remote_Proxy_Broker (void)
{
  static ::_TAO_Contained_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_Contained_Remote_Proxy_Broker::_TAO_Contained_Remote_Proxy_Broker (void)
{
}

_TAO_Contained_Remote_Proxy_Broker::~_TAO_Contained_Remote_Proxy_Broker (void)
{
}

_TAO_Contained_Proxy_Impl&
_TAO_Contained_Remote_Proxy_Broker::select_proxy (
  IR_Contained *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_Contained::IR_Contained (int collocated)
{
  this->IR_Contained_setup_collocation (collocated);
}

// destructor
IR_Contained::~IR_Contained (void)
{}

void
IR_Contained::IR_Contained_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Contained_Proxy_Broker_ =
      _TAO_Contained_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Contained_Proxy_Broker_ =
      _TAO_Contained_Remote_Proxy_Broker::the_TAO_Contained_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
}

void IR_Contained::_tao_any_destructor (void *x)
{
  IR_Contained *tmp = ACE_static_cast (IR_Contained*,x);
  CORBA::release (tmp);
}

IR_Contained_ptr IR_Contained::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_Contained::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Contained:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_Contained::_nil ());
      if (is_a == 0)
        return IR_Contained::_nil ();
    }
  return IR_Contained::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_Contained_ptr IR_Contained::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_Contained::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_Contained_ptr default_proxy = IR_Contained::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_Contained_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          IR_Contained (
            stub,
            1,
            obj->_servant ()),
            
          IR_Contained::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, IR_Contained (stub, 0, obj->_servant ()), IR_Contained::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_Contained_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_Contained::_narrow
                    )
                )
          );
}

IR_Contained_ptr
IR_Contained::_duplicate (IR_Contained_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_Contained::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_Contained::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_Contained::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Contained:1.0";
}

char * IR_Contained::id (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).id (
      this,
      ACE_TRY_ENV
    );
}

void IR_Contained::id (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).id (
      this,
      id,
      ACE_TRY_ENV
    );
}

char * IR_Contained::name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).name (
      this,
      ACE_TRY_ENV
    );
}

void IR_Contained::name (
    const char * name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).name (
      this,
      name,
      ACE_TRY_ENV
    );
}

char * IR_Contained::version (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).version (
      this,
      ACE_TRY_ENV
    );
}

void IR_Contained::version (
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).version (
      this,
      version,
      ACE_TRY_ENV
    );
}

IR_Container_ptr IR_Contained::defined_in (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).defined_in (
      this,
      ACE_TRY_ENV
    );
}

char * IR_Contained::absolute_name (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).absolute_name (
      this,
      ACE_TRY_ENV
    );
}

IR_Repository_ptr IR_Contained::containing_repository (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).containing_repository (
      this,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_Contained_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x2f446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained/Description:1.0
  12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
  2, // member count
  5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  632, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f44), ACE_NTOHL (0x6566696e), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e4b696e), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/DefinitionKind:1.0
    15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    34, // member count
    8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
    13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
    10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
    13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
    11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
    9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
    8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
    12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
    14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
    11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
    9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
    12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
    13, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = dk_Component
    8, ACE_NTOHL (0x646b5f48), ACE_NTOHL (0x6f6d6500),  // name = dk_Home
    11, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72790000),  // name = dk_Factory
    10, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72000000),  // name = dk_Finder
    14, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79000000),  // name = dk_PrimaryKey
    9, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x0),  // name = dk_Emits
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x0),  // name = dk_Publishes
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657300),  // name = dk_Consumes
    12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
    8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_IR_Contained_Description (CORBA::tk_struct, sizeof (_oc_IR_Contained_Description), (char *) &_oc_IR_Contained_Description, 0, sizeof (IR_Contained::Description));
CORBA::TypeCode_ptr IR_Contained::_tc_Description = &_tc_TAO_tc_IR_Contained_Description;

void IR_Contained::Description::_tao_any_destructor (void *x)
{
  Description *tmp = ACE_static_cast (Description*,x);
  delete tmp;
}

IR_Contained::Description * IR_Contained::describe (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  return this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).describe (
      this,
      ACE_TRY_ENV
    );
}

void IR_Contained::move (
    IR_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  this->the_TAO_Contained_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).move (
      this,
      new_container,
      new_name,
      new_version,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_get::TAO_ClientRequestInfo_IR_Contained_id_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_get::result (char * result)
{
  // update the result 
  this->_result = result;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_set::TAO_ClientRequestInfo_IR_Contained_id_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_id_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_get::TAO_ClientRequestInfo_IR_Contained_name_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_get::result (char * result)
{
  // update the result 
  this->_result = result;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_set::TAO_ClientRequestInfo_IR_Contained_name_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * name,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    name_ (name)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_name_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_get::TAO_ClientRequestInfo_IR_Contained_version_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_get::result (char * result)
{
  // update the result 
  this->_result = result;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_set::TAO_ClientRequestInfo_IR_Contained_version_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * version,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    version_ (version)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_version_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::TAO_ClientRequestInfo_IR_Contained_defined_in_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_defined_in_get::result (IR_Container_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::TAO_ClientRequestInfo_IR_Contained_absolute_name_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_absolute_name_get::result (char * result)
{
  // update the result 
  this->_result = result;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::TAO_ClientRequestInfo_IR_Contained_containing_repository_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_containing_repository_get::result (IR_Repository_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_describe::TAO_ClientRequestInfo_IR_Contained_describe (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_describe::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_describe::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_describe::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_describe::result (ACE_NESTED_CLASS (IR_Contained,Description) * result)
{
  // update the result 
  this->_result = result;
}

IR_Contained::TAO_ClientRequestInfo_IR_Contained_move::TAO_ClientRequestInfo_IR_Contained_move (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_Container_ptr new_container,
    const char * new_name,
    const char * new_version,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    new_container_ (new_container),
    new_name_ (new_name),
    new_version_ (new_version)
{}

Dynamic::ParameterList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_move::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_new_container = parameter_list->length ();
  parameter_list->length (length_new_container + 1);
  (*parameter_list)[length_new_container].argument <<=  this->new_container_;
  
  (*parameter_list)[length_new_container].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_new_name = parameter_list->length ();
  parameter_list->length (length_new_name + 1);
  (*parameter_list)[length_new_name].argument <<= new_name_;
  (*parameter_list)[length_new_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_new_version = parameter_list->length ();
  parameter_list->length (length_new_version + 1);
  (*parameter_list)[length_new_version].argument <<= new_version_;
  (*parameter_list)[length_new_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Contained::TAO_ClientRequestInfo_IR_Contained_move::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Contained::TAO_ClientRequestInfo_IR_Contained_move::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_Contained[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = IR_Contained
};
static CORBA::TypeCode _tc_TAO_tc_IR_Contained (CORBA::tk_objref, sizeof (_oc_IR_Contained), (char *) &_oc_IR_Contained, 0, sizeof (IR_Contained));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Contained, &_tc_TAO_tc_IR_Contained)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_InterfaceDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_InterfaceDef **old = ACE_reinterpret_cast (IR_InterfaceDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_InterfaceDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_InterfaceDef **tmp = ACE_reinterpret_cast (IR_InterfaceDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_InterfaceDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::~_TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_InterfaceDef **tmp = ACE_reinterpret_cast (IR_InterfaceDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_InterfaceDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_InterfaceDef **tmp = ACE_static_cast (IR_InterfaceDef**, target);
    *tmp = IR_InterfaceDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq::_upcast (void *src) const
  {
    IR_InterfaceDef **tmp = ACE_static_cast (IR_InterfaceDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_InterfaceDefSeq
// *************************************************************

IR_InterfaceDefSeq::IR_InterfaceDefSeq (void)
{}
IR_InterfaceDefSeq::IR_InterfaceDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_InterfaceDef,IR_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_InterfaceDefSeq::IR_InterfaceDefSeq (CORBA::ULong max, CORBA::ULong length, IR_InterfaceDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_InterfaceDef,IR_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_InterfaceDefSeq::IR_InterfaceDefSeq (const IR_InterfaceDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_InterfaceDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_InterfaceDef,IR_InterfaceDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_InterfaceDefSeq::~IR_InterfaceDefSeq (void) // dtor
{}
void IR_InterfaceDefSeq::_tao_any_destructor (void *x)
{
  IR_InterfaceDefSeq *tmp = ACE_static_cast (IR_InterfaceDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_InterfaceDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/InterfaceDefSeq:1.0
  16, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = IR_InterfaceDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
      13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDefSeq (CORBA::tk_alias, sizeof (_oc_IR_InterfaceDefSeq), (char *) &_oc_IR_InterfaceDefSeq, 0, sizeof (IR_InterfaceDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDefSeq, &_tc_TAO_tc_IR_InterfaceDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ValueDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ValueDef **old = ACE_reinterpret_cast (IR_ValueDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_ValueDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_ValueDef **tmp = ACE_reinterpret_cast (IR_ValueDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ValueDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ValueDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_ValueDef **tmp = ACE_reinterpret_cast (IR_ValueDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ValueDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_ValueDef **tmp = ACE_static_cast (IR_ValueDef**, target);
    *tmp = IR_ValueDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq::_upcast (void *src) const
  {
    IR_ValueDef **tmp = ACE_static_cast (IR_ValueDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ValueDefSeq
// *************************************************************

IR_ValueDefSeq::IR_ValueDefSeq (void)
{}
IR_ValueDefSeq::IR_ValueDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ValueDef,IR_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ValueDefSeq::IR_ValueDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ValueDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ValueDef,IR_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ValueDefSeq::IR_ValueDefSeq (const IR_ValueDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ValueDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ValueDef,IR_ValueDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ValueDefSeq::~IR_ValueDefSeq (void) // dtor
{}
void IR_ValueDefSeq::_tao_any_destructor (void *x)
{
  IR_ValueDefSeq *tmp = ACE_static_cast (IR_ValueDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ValueDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueDefSeq:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x53657100),  // name = IR_ValueDefSeq
  CORBA::tk_sequence, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
      9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_ValueDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ValueDefSeq), (char *) &_oc_IR_ValueDefSeq, 0, sizeof (IR_ValueDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDefSeq, &_tc_TAO_tc_IR_ValueDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ComponentDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ComponentDef **old = ACE_reinterpret_cast (IR_ComponentDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_ComponentDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_ComponentDef **tmp = ACE_reinterpret_cast (IR_ComponentDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ComponentDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_ComponentDef **tmp = ACE_reinterpret_cast (IR_ComponentDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ComponentDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_ComponentDef **tmp = ACE_static_cast (IR_ComponentDef**, target);
    *tmp = IR_ComponentDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq::_upcast (void *src) const
  {
    IR_ComponentDef **tmp = ACE_static_cast (IR_ComponentDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ComponentDefSeq
// *************************************************************

IR_ComponentDefSeq::IR_ComponentDefSeq (void)
{}
IR_ComponentDefSeq::IR_ComponentDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ComponentDef,IR_ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ComponentDefSeq::IR_ComponentDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ComponentDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ComponentDef,IR_ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ComponentDefSeq::IR_ComponentDefSeq (const IR_ComponentDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ComponentDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ComponentDef,IR_ComponentDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ComponentDefSeq::~IR_ComponentDefSeq (void) // dtor
{}
void IR_ComponentDefSeq::_tao_any_destructor (void *x)
{
  IR_ComponentDefSeq *tmp = ACE_static_cast (IR_ComponentDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ComponentDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentDefSeq:1.0
  16, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x53657100),  // name = IR_ComponentDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
      13, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = IR_ComponentDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ComponentDefSeq), (char *) &_oc_IR_ComponentDefSeq, 0, sizeof (IR_ComponentDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDefSeq, &_tc_TAO_tc_IR_ComponentDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ProvidesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ProvidesDef **old = ACE_reinterpret_cast (IR_ProvidesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_ProvidesDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_ProvidesDef **tmp = ACE_reinterpret_cast (IR_ProvidesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ProvidesDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_ProvidesDef **tmp = ACE_reinterpret_cast (IR_ProvidesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ProvidesDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_ProvidesDef **tmp = ACE_static_cast (IR_ProvidesDef**, target);
    *tmp = IR_ProvidesDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq::_upcast (void *src) const
  {
    IR_ProvidesDef **tmp = ACE_static_cast (IR_ProvidesDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ProvidesDefSeq
// *************************************************************

IR_ProvidesDefSeq::IR_ProvidesDefSeq (void)
{}
IR_ProvidesDefSeq::IR_ProvidesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ProvidesDef,IR_ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ProvidesDefSeq::IR_ProvidesDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ProvidesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ProvidesDef,IR_ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ProvidesDefSeq::IR_ProvidesDefSeq (const IR_ProvidesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ProvidesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ProvidesDef,IR_ProvidesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ProvidesDefSeq::~IR_ProvidesDefSeq (void) // dtor
{}
void IR_ProvidesDefSeq::_tao_any_destructor (void *x)
{
  IR_ProvidesDefSeq *tmp = ACE_static_cast (IR_ProvidesDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ProvidesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
  15, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_ProvidesDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
      12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = IR_ProvidesDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ProvidesDefSeq), (char *) &_oc_IR_ProvidesDefSeq, 0, sizeof (IR_ProvidesDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDefSeq, &_tc_TAO_tc_IR_ProvidesDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_UsesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_UsesDef **old = ACE_reinterpret_cast (IR_UsesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_UsesDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_UsesDef **tmp = ACE_reinterpret_cast (IR_UsesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_UsesDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_UsesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_UsesDef **tmp = ACE_reinterpret_cast (IR_UsesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_UsesDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_UsesDef **tmp = ACE_static_cast (IR_UsesDef**, target);
    *tmp = IR_UsesDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq::_upcast (void *src) const
  {
    IR_UsesDef **tmp = ACE_static_cast (IR_UsesDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_UsesDefSeq
// *************************************************************

IR_UsesDefSeq::IR_UsesDefSeq (void)
{}
IR_UsesDefSeq::IR_UsesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_UsesDef,IR_UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_UsesDefSeq::IR_UsesDefSeq (CORBA::ULong max, CORBA::ULong length, IR_UsesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_UsesDef,IR_UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_UsesDefSeq::IR_UsesDefSeq (const IR_UsesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_UsesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_UsesDef,IR_UsesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_UsesDefSeq::~IR_UsesDefSeq (void) // dtor
{}
void IR_UsesDefSeq::_tao_any_destructor (void *x)
{
  IR_UsesDefSeq *tmp = ACE_static_cast (IR_UsesDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_UsesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
  11, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_UsesDefSeq
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
      8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = IR_UsesDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_UsesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_UsesDefSeq), (char *) &_oc_IR_UsesDefSeq, 0, sizeof (IR_UsesDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDefSeq, &_tc_TAO_tc_IR_UsesDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_HomeDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_HomeDef **old = ACE_reinterpret_cast (IR_HomeDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_HomeDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_HomeDef **tmp = ACE_reinterpret_cast (IR_HomeDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_HomeDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::~_TAO_Unbounded_Object_Sequence_IR_HomeDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_HomeDef **tmp = ACE_reinterpret_cast (IR_HomeDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_HomeDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_HomeDef **tmp = ACE_static_cast (IR_HomeDef**, target);
    *tmp = IR_HomeDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq::_upcast (void *src) const
  {
    IR_HomeDef **tmp = ACE_static_cast (IR_HomeDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_HomeDefSeq
// *************************************************************

IR_HomeDefSeq::IR_HomeDefSeq (void)
{}
IR_HomeDefSeq::IR_HomeDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_HomeDef,IR_HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_HomeDefSeq::IR_HomeDefSeq (CORBA::ULong max, CORBA::ULong length, IR_HomeDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_HomeDef,IR_HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_HomeDefSeq::IR_HomeDefSeq (const IR_HomeDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_HomeDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_HomeDef,IR_HomeDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_HomeDefSeq::~IR_HomeDefSeq (void) // dtor
{}
void IR_HomeDefSeq::_tao_any_destructor (void *x)
{
  IR_HomeDefSeq *tmp = ACE_static_cast (IR_HomeDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_HomeDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/HomeDefSeq:1.0
  11, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_HomeDefSeq
  CORBA::tk_sequence, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    48, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
      8, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656600),  // name = IR_HomeDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_HomeDefSeq (CORBA::tk_alias, sizeof (_oc_IR_HomeDefSeq), (char *) &_oc_IR_HomeDefSeq, 0, sizeof (IR_HomeDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDefSeq, &_tc_TAO_tc_IR_HomeDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_EmitsDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_EmitsDef **old = ACE_reinterpret_cast (IR_EmitsDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_EmitsDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_EmitsDef **tmp = ACE_reinterpret_cast (IR_EmitsDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_EmitsDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::~_TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_EmitsDef **tmp = ACE_reinterpret_cast (IR_EmitsDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_EmitsDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_EmitsDef **tmp = ACE_static_cast (IR_EmitsDef**, target);
    *tmp = IR_EmitsDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq::_upcast (void *src) const
  {
    IR_EmitsDef **tmp = ACE_static_cast (IR_EmitsDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_EmitsDefSeq
// *************************************************************

IR_EmitsDefSeq::IR_EmitsDefSeq (void)
{}
IR_EmitsDefSeq::IR_EmitsDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_EmitsDef,IR_EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_EmitsDefSeq::IR_EmitsDefSeq (CORBA::ULong max, CORBA::ULong length, IR_EmitsDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_EmitsDef,IR_EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_EmitsDefSeq::IR_EmitsDefSeq (const IR_EmitsDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_EmitsDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_EmitsDef,IR_EmitsDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_EmitsDefSeq::~IR_EmitsDefSeq (void) // dtor
{}
void IR_EmitsDefSeq::_tao_any_destructor (void *x)
{
  IR_EmitsDefSeq *tmp = ACE_static_cast (IR_EmitsDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_EmitsDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
  12, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = IR_EmitsDefSeq
  CORBA::tk_sequence, // typecode kind
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    52, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
      9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_EmitsDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDefSeq (CORBA::tk_alias, sizeof (_oc_IR_EmitsDefSeq), (char *) &_oc_IR_EmitsDefSeq, 0, sizeof (IR_EmitsDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDefSeq, &_tc_TAO_tc_IR_EmitsDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_PublishesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_PublishesDef **old = ACE_reinterpret_cast (IR_PublishesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_PublishesDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_PublishesDef **tmp = ACE_reinterpret_cast (IR_PublishesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_PublishesDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_PublishesDef **tmp = ACE_reinterpret_cast (IR_PublishesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_PublishesDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_PublishesDef **tmp = ACE_static_cast (IR_PublishesDef**, target);
    *tmp = IR_PublishesDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq::_upcast (void *src) const
  {
    IR_PublishesDef **tmp = ACE_static_cast (IR_PublishesDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_PublishesDefSeq
// *************************************************************

IR_PublishesDefSeq::IR_PublishesDefSeq (void)
{}
IR_PublishesDefSeq::IR_PublishesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_PublishesDef,IR_PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_PublishesDefSeq::IR_PublishesDefSeq (CORBA::ULong max, CORBA::ULong length, IR_PublishesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_PublishesDef,IR_PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_PublishesDefSeq::IR_PublishesDefSeq (const IR_PublishesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_PublishesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_PublishesDef,IR_PublishesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_PublishesDefSeq::~IR_PublishesDefSeq (void) // dtor
{}
void IR_PublishesDefSeq::_tao_any_destructor (void *x)
{
  IR_PublishesDefSeq *tmp = ACE_static_cast (IR_PublishesDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_PublishesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
  16, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = IR_PublishesDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
      13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_PublishesDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_PublishesDefSeq), (char *) &_oc_IR_PublishesDefSeq, 0, sizeof (IR_PublishesDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDefSeq, &_tc_TAO_tc_IR_PublishesDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ConsumesDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ConsumesDef **old = ACE_reinterpret_cast (IR_ConsumesDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_ConsumesDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_ConsumesDef **tmp = ACE_reinterpret_cast (IR_ConsumesDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ConsumesDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_ConsumesDef **tmp = ACE_reinterpret_cast (IR_ConsumesDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ConsumesDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_ConsumesDef **tmp = ACE_static_cast (IR_ConsumesDef**, target);
    *tmp = IR_ConsumesDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq::_upcast (void *src) const
  {
    IR_ConsumesDef **tmp = ACE_static_cast (IR_ConsumesDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ConsumesDefSeq
// *************************************************************

IR_ConsumesDefSeq::IR_ConsumesDefSeq (void)
{}
IR_ConsumesDefSeq::IR_ConsumesDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ConsumesDef,IR_ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ConsumesDefSeq::IR_ConsumesDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ConsumesDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ConsumesDef,IR_ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ConsumesDefSeq::IR_ConsumesDefSeq (const IR_ConsumesDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ConsumesDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ConsumesDef,IR_ConsumesDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ConsumesDefSeq::~IR_ConsumesDefSeq (void) // dtor
{}
void IR_ConsumesDefSeq::_tao_any_destructor (void *x)
{
  IR_ConsumesDefSeq *tmp = ACE_static_cast (IR_ConsumesDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ConsumesDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
  15, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_ConsumesDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
      12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = IR_ConsumesDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ConsumesDefSeq), (char *) &_oc_IR_ConsumesDefSeq, 0, sizeof (IR_ConsumesDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDefSeq, &_tc_TAO_tc_IR_ConsumesDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_FactoryDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_FactoryDef **old = ACE_reinterpret_cast (IR_FactoryDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_FactoryDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_FactoryDef **tmp = ACE_reinterpret_cast (IR_FactoryDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_FactoryDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_FactoryDef **tmp = ACE_reinterpret_cast (IR_FactoryDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_FactoryDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_FactoryDef **tmp = ACE_static_cast (IR_FactoryDef**, target);
    *tmp = IR_FactoryDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq::_upcast (void *src) const
  {
    IR_FactoryDef **tmp = ACE_static_cast (IR_FactoryDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_FactoryDefSeq
// *************************************************************

IR_FactoryDefSeq::IR_FactoryDefSeq (void)
{}
IR_FactoryDefSeq::IR_FactoryDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_FactoryDef,IR_FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_FactoryDefSeq::IR_FactoryDefSeq (CORBA::ULong max, CORBA::ULong length, IR_FactoryDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_FactoryDef,IR_FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_FactoryDefSeq::IR_FactoryDefSeq (const IR_FactoryDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FactoryDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_FactoryDef,IR_FactoryDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_FactoryDefSeq::~IR_FactoryDefSeq (void) // dtor
{}
void IR_FactoryDefSeq::_tao_any_destructor (void *x)
{
  IR_FactoryDefSeq *tmp = ACE_static_cast (IR_FactoryDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_FactoryDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
  14, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65665365), ACE_NTOHL (0x71000000),  // name = IR_FactoryDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
      11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = IR_FactoryDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDefSeq (CORBA::tk_alias, sizeof (_oc_IR_FactoryDefSeq), (char *) &_oc_IR_FactoryDefSeq, 0, sizeof (IR_FactoryDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDefSeq, &_tc_TAO_tc_IR_FactoryDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_FinderDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_FinderDef **old = ACE_reinterpret_cast (IR_FinderDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_FinderDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_FinderDef **tmp = ACE_reinterpret_cast (IR_FinderDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_FinderDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::~_TAO_Unbounded_Object_Sequence_IR_FinderDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_FinderDef **tmp = ACE_reinterpret_cast (IR_FinderDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_FinderDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_FinderDef **tmp = ACE_static_cast (IR_FinderDef**, target);
    *tmp = IR_FinderDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq::_upcast (void *src) const
  {
    IR_FinderDef **tmp = ACE_static_cast (IR_FinderDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_FinderDefSeq
// *************************************************************

IR_FinderDefSeq::IR_FinderDefSeq (void)
{}
IR_FinderDefSeq::IR_FinderDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_FinderDef,IR_FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_FinderDefSeq::IR_FinderDefSeq (CORBA::ULong max, CORBA::ULong length, IR_FinderDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_FinderDef,IR_FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_FinderDefSeq::IR_FinderDefSeq (const IR_FinderDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_FinderDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_FinderDef,IR_FinderDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_FinderDefSeq::~IR_FinderDefSeq (void) // dtor
{}
void IR_FinderDefSeq::_tao_any_destructor (void *x)
{
  IR_FinderDefSeq *tmp = ACE_static_cast (IR_FinderDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_FinderDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
  13, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x0),  // name = IR_FinderDefSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
      10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = IR_FinderDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_FinderDefSeq (CORBA::tk_alias, sizeof (_oc_IR_FinderDefSeq), (char *) &_oc_IR_FinderDefSeq, 0, sizeof (IR_FinderDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDefSeq, &_tc_TAO_tc_IR_FinderDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_Contained **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_Contained **old = ACE_reinterpret_cast (IR_Contained**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_Contained::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_Contained **tmp = ACE_reinterpret_cast (IR_Contained**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_Contained::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::~_TAO_Unbounded_Object_Sequence_IR_ContainedSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_Contained **tmp = ACE_reinterpret_cast (IR_Contained**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_Contained::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_Contained **tmp = ACE_static_cast (IR_Contained**, target);
    *tmp = IR_Contained::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq::_upcast (void *src) const
  {
    IR_Contained **tmp = ACE_static_cast (IR_Contained**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ContainedSeq
// *************************************************************

IR_ContainedSeq::IR_ContainedSeq (void)
{}
IR_ContainedSeq::IR_ContainedSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_Contained,IR_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ContainedSeq::IR_ContainedSeq (CORBA::ULong max, CORBA::ULong length, IR_Contained_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_Contained,IR_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ContainedSeq::IR_ContainedSeq (const IR_ContainedSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ContainedSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_Contained,IR_Contained_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ContainedSeq::~IR_ContainedSeq (void) // dtor
{}
void IR_ContainedSeq::_tao_any_destructor (void *x)
{
  IR_ContainedSeq *tmp = ACE_static_cast (IR_ContainedSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ContainedSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContainedSeq:1.0
  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = IR_ContainedSeq
  CORBA::tk_sequence, // typecode kind
  72, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    56, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
      10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = IR_Contained

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ContainedSeq (CORBA::tk_alias, sizeof (_oc_IR_ContainedSeq), (char *) &_oc_IR_ContainedSeq, 0, sizeof (IR_ContainedSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContainedSeq, &_tc_TAO_tc_IR_ContainedSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_StructMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
  13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
  3, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  48, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

};
static CORBA::TypeCode _tc_TAO_tc_IR_StructMember (CORBA::tk_struct, sizeof (_oc_IR_StructMember), (char *) &_oc_IR_StructMember, 0, sizeof (IR_StructMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMember, &_tc_TAO_tc_IR_StructMember)
TAO_NAMESPACE_END

void IR_StructMember::_tao_any_destructor (void *x)
{
  IR_StructMember *tmp = ACE_static_cast (IR_StructMember*,x);
  delete tmp;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_StructMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_StructMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_StructMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_StructMember *old = ACE_reinterpret_cast (IR_StructMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_StructMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_StructMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_StructMember *tmp = ACE_reinterpret_cast (IR_StructMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_StructMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_StructMemberSeq::~_TAO_Unbounded_Sequence_IR_StructMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_StructMemberSeq
// *************************************************************

IR_StructMemberSeq::IR_StructMemberSeq (void)
{}
IR_StructMemberSeq::IR_StructMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_StructMemberSeq::IR_StructMemberSeq (CORBA::ULong max, CORBA::ULong length, IR_StructMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_StructMemberSeq::IR_StructMemberSeq (const IR_StructMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_StructMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_StructMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_StructMemberSeq::~IR_StructMemberSeq (void) // dtor
{}
void IR_StructMemberSeq::_tao_any_destructor (void *x)
{
  IR_StructMemberSeq *tmp = ACE_static_cast (IR_StructMemberSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_StructMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
  16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = IR_StructMemberSeq
  CORBA::tk_sequence, // typecode kind
  252, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    236, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
      13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
      3, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_StructMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_StructMemberSeq), (char *) &_oc_IR_StructMemberSeq, 0, sizeof (IR_StructMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructMemberSeq, &_tc_TAO_tc_IR_StructMemberSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_Initializer[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
  12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = IR_Initializer
  2, // member count
  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  324, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
    16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = IR_StructMemberSeq
    CORBA::tk_sequence, // typecode kind
    252, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      236, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
        13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
        3, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        48, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType


      0U,


  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_Initializer (CORBA::tk_struct, sizeof (_oc_IR_Initializer), (char *) &_oc_IR_Initializer, 0, sizeof (IR_Initializer));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Initializer, &_tc_TAO_tc_IR_Initializer)
TAO_NAMESPACE_END

void IR_Initializer::_tao_any_destructor (void *x)
{
  IR_Initializer *tmp = ACE_static_cast (IR_Initializer*,x);
  delete tmp;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_InitializerSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_Initializer* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_InitializerSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_Initializer *old = ACE_reinterpret_cast (IR_Initializer *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_InitializerSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_InitializerSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_Initializer *tmp = ACE_reinterpret_cast (IR_Initializer *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_InitializerSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_InitializerSeq::~_TAO_Unbounded_Sequence_IR_InitializerSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_InitializerSeq
// *************************************************************

IR_InitializerSeq::IR_InitializerSeq (void)
{}
IR_InitializerSeq::IR_InitializerSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_InitializerSeq::IR_InitializerSeq (CORBA::ULong max, CORBA::ULong length, IR_Initializer *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_InitializerSeq::IR_InitializerSeq (const IR_InitializerSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_InitializerSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_Initializer>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_InitializerSeq::~IR_InitializerSeq (void) // dtor
{}
void IR_InitializerSeq::_tao_any_destructor (void *x)
{
  IR_InitializerSeq *tmp = ACE_static_cast (IR_InitializerSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_InitializerSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/InitializerSeq:1.0
  15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = IR_InitializerSeq
  CORBA::tk_sequence, // typecode kind
  504, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    488, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
      12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = IR_Initializer
      2, // member count
      8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
      CORBA::tk_alias, // typecode kind for typedefs
      324, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
        16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = IR_StructMemberSeq
        CORBA::tk_sequence, // typecode kind
        252, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          236, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
            13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
            3, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            48, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType


          0U,


      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_InitializerSeq (CORBA::tk_alias, sizeof (_oc_IR_InitializerSeq), (char *) &_oc_IR_InitializerSeq, 0, sizeof (IR_InitializerSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InitializerSeq, &_tc_TAO_tc_IR_InitializerSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_UnionMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UnionMember:1.0
  12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = IR_UnionMember
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  6, ACE_NTOHL (0x6c616265), ACE_NTOHL (0x6c000000),  // name = label
  CORBA::tk_any,

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  48, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

};
static CORBA::TypeCode _tc_TAO_tc_IR_UnionMember (CORBA::tk_struct, sizeof (_oc_IR_UnionMember), (char *) &_oc_IR_UnionMember, 0, sizeof (IR_UnionMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMember, &_tc_TAO_tc_IR_UnionMember)
TAO_NAMESPACE_END

void IR_UnionMember::_tao_any_destructor (void *x)
{
  IR_UnionMember *tmp = ACE_static_cast (IR_UnionMember*,x);
  delete tmp;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_UnionMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_UnionMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_UnionMember *old = ACE_reinterpret_cast (IR_UnionMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_UnionMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_UnionMember *tmp = ACE_reinterpret_cast (IR_UnionMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_UnionMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq::~_TAO_Unbounded_Sequence_IR_UnionMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_UnionMemberSeq
// *************************************************************

IR_UnionMemberSeq::IR_UnionMemberSeq (void)
{}
IR_UnionMemberSeq::IR_UnionMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_UnionMemberSeq::IR_UnionMemberSeq (CORBA::ULong max, CORBA::ULong length, IR_UnionMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_UnionMemberSeq::IR_UnionMemberSeq (const IR_UnionMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UnionMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_UnionMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_UnionMemberSeq::~IR_UnionMemberSeq (void) // dtor
{}
void IR_UnionMemberSeq::_tao_any_destructor (void *x)
{
  IR_UnionMemberSeq *tmp = ACE_static_cast (IR_UnionMemberSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_UnionMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UnionMemberSeq:1.0
  15, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = IR_UnionMemberSeq
  CORBA::tk_sequence, // typecode kind
  264, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    248, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UnionMember:1.0
      12, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e4d656d), ACE_NTOHL (0x62657200),  // name = IR_UnionMember
      4, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      6, ACE_NTOHL (0x6c616265), ACE_NTOHL (0x6c000000),  // name = label
      CORBA::tk_any,

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_UnionMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_UnionMemberSeq), (char *) &_oc_IR_UnionMemberSeq, 0, sizeof (IR_UnionMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionMemberSeq, &_tc_TAO_tc_IR_UnionMemberSeq)
TAO_NAMESPACE_END

// *************************************************************
// IR_EnumMemberSeq
// *************************************************************

IR_EnumMemberSeq::IR_EnumMemberSeq (void)
{}
IR_EnumMemberSeq::IR_EnumMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_EnumMemberSeq::IR_EnumMemberSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_EnumMemberSeq::IR_EnumMemberSeq (const IR_EnumMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_EnumMemberSeq::~IR_EnumMemberSeq (void) // dtor
{}
void IR_EnumMemberSeq::_tao_any_destructor (void *x)
{
  IR_EnumMemberSeq *tmp = ACE_static_cast (IR_EnumMemberSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_EnumMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6e756d4d), ACE_NTOHL (0x656d6265), ACE_NTOHL (0x72536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/EnumMemberSeq:1.0
  14, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x71000000),  // name = IR_EnumMemberSeq
  CORBA::tk_sequence, // typecode kind
  80, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
      11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
      CORBA::tk_string, 
      0U, // string length

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_EnumMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_EnumMemberSeq), (char *) &_oc_IR_EnumMemberSeq, 0, sizeof (IR_EnumMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumMemberSeq, &_tc_TAO_tc_IR_EnumMemberSeq)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_Container_Proxy_Impl::_TAO_Container_Proxy_Impl (void)
{}

_TAO_Container_Remote_Proxy_Impl::_TAO_Container_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_Contained_ptr _TAO_Container_Remote_Proxy_Impl::lookup (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{ 
  IR_Contained_ptr _tao_retval = IR_Contained::_nil ();
  IR_Contained_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup",
      6,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_lookup ri (
        &_tao_call,
        _collocated_tao_target_,
        search_name,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << search_name)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_Contained_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ContainedSeq * _TAO_Container_Remote_Proxy_Impl::contents (
    CORBA_Object *_collocated_tao_target_,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{ 
  IR_ContainedSeq *_tao_retval = 0;
   
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  ACE_NEW_RETURN (_tao_retval, IR_ContainedSeq, _tao_retval);
  IR_ContainedSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "contents",
      8,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_contents ri (
        &_tao_call,
        _collocated_tao_target_,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ContainedSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ContainedSeq * _TAO_Container_Remote_Proxy_Impl::lookup_name (
    CORBA_Object *_collocated_tao_target_,
    const char * search_name,
    CORBA::Long levels_to_search,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{ 
  IR_ContainedSeq *_tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  ACE_NEW_RETURN (_tao_retval, IR_ContainedSeq, _tao_retval);
  IR_ContainedSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_name",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_lookup_name ri (
        &_tao_call,
        _collocated_tao_target_,
        search_name,
        levels_to_search,
        limit_type,
        exclude_inherited,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << search_name) &&
              (_tao_out << levels_to_search) &&
              (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited))
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ContainedSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_Container::DescriptionSeq * _TAO_Container_Remote_Proxy_Impl::describe_contents (
    CORBA_Object *_collocated_tao_target_,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_Container::DescriptionSeq *_tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  ACE_NEW_RETURN (_tao_retval, IR_Container::DescriptionSeq, _tao_retval);
  IR_Container::DescriptionSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "describe_contents",
      17,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_describe_contents ri (
        &_tao_call,
        _collocated_tao_target_,
        limit_type,
        exclude_inherited,
        max_returned_objs,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << limit_type) &&
              (_tao_out << CORBA::Any::from_boolean (exclude_inherited)) &&
              (_tao_out << max_returned_objs)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_Container::DescriptionSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ModuleDef_ptr _TAO_Container_Remote_Proxy_Impl::create_module (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_ModuleDef_ptr _tao_retval = IR_ModuleDef::_nil ();
  IR_ModuleDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_module",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_module ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ModuleDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ConstantDef_ptr _TAO_Container_Remote_Proxy_Impl::create_constant (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_ConstantDef_ptr _tao_retval = IR_ConstantDef::_nil ();
  IR_ConstantDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_constant",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_constant ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        type,
        value,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ConstantDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_StructDef_ptr _TAO_Container_Remote_Proxy_Impl::create_struct (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_StructDef_ptr _tao_retval = IR_StructDef::_nil ();
  IR_StructDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_struct",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_struct ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_StructDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_UnionDef_ptr _TAO_Container_Remote_Proxy_Impl::create_union (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr discriminator_type,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_UnionDef_ptr _tao_retval = IR_UnionDef::_nil ();
  IR_UnionDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_union",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_union ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        discriminator_type,
        members,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << discriminator_type) &&
              (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_UnionDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_EnumDef_ptr _TAO_Container_Remote_Proxy_Impl::create_enum (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_EnumDef_ptr _tao_retval = IR_EnumDef::_nil ();
  IR_EnumDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_enum",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_enum ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_EnumDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_AliasDef_ptr _TAO_Container_Remote_Proxy_Impl::create_alias (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_AliasDef_ptr _tao_retval = IR_AliasDef::_nil ();
  IR_AliasDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_alias",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_alias ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        original_type,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << original_type)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_AliasDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_InterfaceDef_ptr _TAO_Container_Remote_Proxy_Impl::create_interface (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Boolean is_abstract,
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_InterfaceDef_ptr _tao_retval = IR_InterfaceDef::_nil ();
  IR_InterfaceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_interface",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_interface ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        base_interfaces,
        is_abstract,
        is_local,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_interfaces) &&
              (_tao_out << CORBA::Any::from_boolean (is_abstract)) &&
              (_tao_out << CORBA::Any::from_boolean (is_local))
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ValueDef_ptr _TAO_Container_Remote_Proxy_Impl::create_value (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    IR_ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const IR_ValueDefSeq & abstract_base_values,
    const IR_InterfaceDefSeq & supported_interfaces,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_ValueDef_ptr _tao_retval = IR_ValueDef::_nil ();
  IR_ValueDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_value ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        is_custom,
        is_abstract,
        base_value,
        is_truncatable,
        abstract_base_values,
        supported_interfaces,
        initializers,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << CORBA::Any::from_boolean (is_custom)) &&
              (_tao_out << CORBA::Any::from_boolean (is_abstract)) &&
              (_tao_out << base_value) &&
              (_tao_out << CORBA::Any::from_boolean (is_truncatable)) &&
              (_tao_out << abstract_base_values) &&
              (_tao_out << supported_interfaces) &&
              (_tao_out << initializers)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ValueBoxDef_ptr _TAO_Container_Remote_Proxy_Impl::create_value_box (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_ValueBoxDef_ptr _tao_retval = IR_ValueBoxDef::_nil ();
  IR_ValueBoxDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_box",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_value_box ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        original_type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << original_type_def)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ValueBoxDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ExceptionDef_ptr _TAO_Container_Remote_Proxy_Impl::create_exception (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_ExceptionDef_ptr _tao_retval = IR_ExceptionDef::_nil ();
  IR_ExceptionDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_exception",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_exception ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        members,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ExceptionDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_NativeDef_ptr _TAO_Container_Remote_Proxy_Impl::create_native (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_NativeDef_ptr _tao_retval = IR_NativeDef::_nil ();
  IR_NativeDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_native",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Container::TAO_ClientRequestInfo_IR_Container_create_native ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_NativeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_Container_Proxy_Broker::_TAO_Container_Proxy_Broker (void)
{
}

_TAO_Container_Proxy_Broker::~_TAO_Container_Proxy_Broker (void)
{
}

_TAO_Container_Proxy_Broker * (*_TAO_Container_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_Container_Remote_Proxy_Broker *
_TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker (void)
{
  static ::_TAO_Container_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_Container_Remote_Proxy_Broker::_TAO_Container_Remote_Proxy_Broker (void)
{
}

_TAO_Container_Remote_Proxy_Broker::~_TAO_Container_Remote_Proxy_Broker (void)
{
}

_TAO_Container_Proxy_Impl&
_TAO_Container_Remote_Proxy_Broker::select_proxy (
  ::IR_Container *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_Container::IR_Container (int collocated)
{
  this->IR_Container_setup_collocation (collocated);
}

// destructor
IR_Container::~IR_Container (void)
{}

void
IR_Container::IR_Container_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Container_Proxy_Broker_ =
      _TAO_Container_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Container_Proxy_Broker_ =
      _TAO_Container_Remote_Proxy_Broker::the_TAO_Container_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
  
}

void IR_Container::_tao_any_destructor (void *x)
{
  IR_Container *tmp = ACE_static_cast (IR_Container*,x);
  CORBA::release (tmp);
}

IR_Container_ptr IR_Container::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_Container::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Container:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_Container::_nil ());
      if (is_a == 0)
        return IR_Container::_nil ();
    }
  return IR_Container::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_Container_ptr IR_Container::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_Container::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_Container_ptr default_proxy = IR_Container::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_Container_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_Container (
            stub,
            1,
            obj->_servant ()),
            
          IR_Container::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_Container (stub, 0, obj->_servant ()), IR_Container::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_Container_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_Container::_narrow
                    )
                )
          );
}

IR_Container_ptr
IR_Container::_duplicate (IR_Container_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_Container::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_Container::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_Container::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Container:1.0";
}

IR_Contained_ptr IR_Container::lookup (
    const char * search_name,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{ 
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).lookup (
      this,
      search_name,
      ACE_TRY_ENV
    );
}

IR_ContainedSeq * IR_Container::contents (
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).contents (
      this,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );
}

IR_ContainedSeq * IR_Container::lookup_name (
    const char * search_name,
    CORBA::Long levels_to_search,
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).lookup_name (
      this,
      search_name,
      levels_to_search,
      limit_type,
      exclude_inherited,
      ACE_TRY_ENV
    );
}

static const CORBA::Long _oc_IR_Container_Description[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x2f446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Container/Description:1.0
  12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
  3, // member count
  17, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x645f6f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = contained_object
  CORBA::tk_objref, // typecode kind
  56, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
    10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = IR_Contained

  5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
  CORBA::tk_enum, // typecode kind
  632, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f44), ACE_NTOHL (0x6566696e), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e4b696e), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/DefinitionKind:1.0
    15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
    34, // member count
    8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
    7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
    13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
    13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
    13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
    10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
    13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
    11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
    9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
    8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
    10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
    12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
    9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
    14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
    11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
    9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
    9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
    12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
    15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
    10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
    13, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = dk_Component
    8, ACE_NTOHL (0x646b5f48), ACE_NTOHL (0x6f6d6500),  // name = dk_Home
    11, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72790000),  // name = dk_Factory
    10, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72000000),  // name = dk_Finder
    14, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79000000),  // name = dk_PrimaryKey
    9, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x0),  // name = dk_Emits
    13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x0),  // name = dk_Publishes
    12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657300),  // name = dk_Consumes
    12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
    8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_IR_Container_Description (CORBA::tk_struct, sizeof (_oc_IR_Container_Description), (char *) &_oc_IR_Container_Description, 0, sizeof (IR_Container::Description));
CORBA::TypeCode_ptr IR_Container::_tc_Description = &_tc_TAO_tc_IR_Container_Description;

void IR_Container::Description::_tao_any_destructor (void *x)
{
  Description *tmp = ACE_static_cast (Description*,x);
  delete tmp;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_Container::Description* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_Container::Description *old = ACE_reinterpret_cast (IR_Container::Description *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_Container::Description *tmp = ACE_reinterpret_cast (IR_Container::Description *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  IR_Container::_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq::~_TAO_Unbounded_Sequence_IR_Container_DescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_Container::DescriptionSeq
// *************************************************************

IR_Container::DescriptionSeq::DescriptionSeq (void)
{}
IR_Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_Container::DescriptionSeq::DescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_Container::Description *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_Container::DescriptionSeq::DescriptionSeq (const DescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_Container_DescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_Container::Description>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_Container::DescriptionSeq::~DescriptionSeq (void) // dtor
{}
void IR_Container::DescriptionSeq::_tao_any_destructor (void *x)
{
  DescriptionSeq *tmp = ACE_static_cast (DescriptionSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_Container_DescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  44, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x2f446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/Container/DescriptionSeq:1.0
  15, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = DescriptionSeq
  CORBA::tk_sequence, // typecode kind
  844, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    828, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x2f446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Container/Description:1.0
      12, ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = Description
      3, // member count
      17, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x645f6f62), ACE_NTOHL (0x6a656374), ACE_NTOHL (0x0),  // name = contained_object
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6564), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Contained:1.0
        10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x64000000),  // name = IR_Contained

      5, ACE_NTOHL (0x6b696e64), ACE_NTOHL (0x0),  // name = kind
      CORBA::tk_enum, // typecode kind
      632, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f44), ACE_NTOHL (0x6566696e), ACE_NTOHL (0x6974696f), ACE_NTOHL (0x6e4b696e), ACE_NTOHL (0x643a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/DefinitionKind:1.0
        15, ACE_NTOHL (0x44656669), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x6f6e4b69), ACE_NTOHL (0x6e640000),  // name = DefinitionKind
        34, // member count
        8, ACE_NTOHL (0x646b5f6e), ACE_NTOHL (0x6f6e6500),  // name = dk_none
        7, ACE_NTOHL (0x646b5f61), ACE_NTOHL (0x6c6c0000),  // name = dk_all
        13, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x0),  // name = dk_Attribute
        12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7400),  // name = dk_Constant
        13, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Exception
        13, ACE_NTOHL (0x646b5f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x0),  // name = dk_Interface
        10, ACE_NTOHL (0x646b5f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65000000),  // name = dk_Module
        13, ACE_NTOHL (0x646b5f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = dk_Operation
        11, ACE_NTOHL (0x646b5f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65660000),  // name = dk_Typedef
        9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x0),  // name = dk_Alias
        10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74000000),  // name = dk_Struct
        9, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x0),  // name = dk_Union
        8, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6e756d00),  // name = dk_Enum
        13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x0),  // name = dk_Primitive
        10, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = dk_String
        12, ACE_NTOHL (0x646b5f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636500),  // name = dk_Sequence
        9, ACE_NTOHL (0x646b5f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x0),  // name = dk_Array
        14, ACE_NTOHL (0x646b5f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79000000),  // name = dk_Repository
        11, ACE_NTOHL (0x646b5f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = dk_Wstring
        9, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x0),  // name = dk_Fixed
        9, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x0),  // name = dk_Value
        12, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7800),  // name = dk_ValueBox
        15, ACE_NTOHL (0x646b5f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65720000),  // name = dk_ValueMember
        10, ACE_NTOHL (0x646b5f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65000000),  // name = dk_Native
        13, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x0),  // name = dk_Component
        8, ACE_NTOHL (0x646b5f48), ACE_NTOHL (0x6f6d6500),  // name = dk_Home
        11, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72790000),  // name = dk_Factory
        10, ACE_NTOHL (0x646b5f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72000000),  // name = dk_Finder
        14, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79000000),  // name = dk_PrimaryKey
        9, ACE_NTOHL (0x646b5f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x0),  // name = dk_Emits
        13, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x0),  // name = dk_Publishes
        12, ACE_NTOHL (0x646b5f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657300),  // name = dk_Consumes
        12, ACE_NTOHL (0x646b5f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657300),  // name = dk_Provides
        8, ACE_NTOHL (0x646b5f55), ACE_NTOHL (0x73657300),  // name = dk_Uses

      6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
      CORBA::tk_any,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_Container_DescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_Container_DescriptionSeq), (char *) &_oc_IR_Container_DescriptionSeq, 0, sizeof (IR_Container::DescriptionSeq));
CORBA::TypeCode_ptr IR_Container::_tc_DescriptionSeq = &_tc_TAO_tc_IR_Container_DescriptionSeq;

IR_Container::DescriptionSeq * IR_Container::describe_contents (
    IR_DefinitionKind limit_type,
    CORBA::Boolean exclude_inherited,
    CORBA::Long max_returned_objs,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).describe_contents (
      this,
      limit_type,
      exclude_inherited,
      max_returned_objs,
      ACE_TRY_ENV
    );
}

IR_ModuleDef_ptr IR_Container::create_module (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_module (
      this,
      id,
      name,
      version,
      ACE_TRY_ENV
    );
}

IR_ConstantDef_ptr IR_Container::create_constant (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_constant (
      this,
      id,
      name,
      version,
      type,
      value,
      ACE_TRY_ENV
    );
}

IR_StructDef_ptr IR_Container::create_struct (
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_struct (
      this,
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );
}

IR_UnionDef_ptr IR_Container::create_union (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr discriminator_type,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_union (
      this,
      id,
      name,
      version,
      discriminator_type,
      members,
      ACE_TRY_ENV
    );
}

IR_EnumDef_ptr IR_Container::create_enum (
    const char * id,
    const char * name,
    const char * version,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_enum (
      this,
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );
}

IR_AliasDef_ptr IR_Container::create_alias (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_alias (
      this,
      id,
      name,
      version,
      original_type,
      ACE_TRY_ENV
    );
}

IR_InterfaceDef_ptr IR_Container::create_interface (
    const char * id,
    const char * name,
    const char * version,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Boolean is_abstract,
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_interface (
      this,
      id,
      name,
      version,
      base_interfaces,
      is_abstract,
      is_local,
      ACE_TRY_ENV
    );
}

IR_ValueDef_ptr IR_Container::create_value (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Boolean is_custom,
    CORBA::Boolean is_abstract,
    IR_ValueDef_ptr base_value,
    CORBA::Boolean is_truncatable,
    const IR_ValueDefSeq & abstract_base_values,
    const IR_InterfaceDefSeq & supported_interfaces,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_value (
      this,
      id,
      name,
      version,
      is_custom,
      is_abstract,
      base_value,
      is_truncatable,
      abstract_base_values,
      supported_interfaces,
      initializers,
      ACE_TRY_ENV
    );
}

IR_ValueBoxDef_ptr IR_Container::create_value_box (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_value_box (
      this,
      id,
      name,
      version,
      original_type_def,
      ACE_TRY_ENV
    );
}

IR_ExceptionDef_ptr IR_Container::create_exception (
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_exception (
      this,
      id,
      name,
      version,
      members,
      ACE_TRY_ENV
    );
}

IR_NativeDef_ptr IR_Container::create_native (
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Container_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_native (
      this,
      id,
      name,
      version,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup::TAO_ClientRequestInfo_IR_Container_lookup (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * search_name,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    search_name_ (search_name)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup::result (IR_Contained_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_contents::TAO_ClientRequestInfo_IR_Container_contents (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_contents::result (IR_ContainedSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_lookup_name::TAO_ClientRequestInfo_IR_Container_lookup_name (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * search_name,
    const CORBA::Long & levels_to_search,
    IR_DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    search_name_ (search_name),
    levels_to_search_ (levels_to_search),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup_name::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_name = parameter_list->length ();
  parameter_list->length (length_search_name + 1);
  (*parameter_list)[length_search_name].argument <<= search_name_;
  (*parameter_list)[length_search_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_levels_to_search = parameter_list->length ();
  parameter_list->length (length_levels_to_search + 1);
  (*parameter_list)[length_levels_to_search].argument <<= levels_to_search_;
  (*parameter_list)[length_levels_to_search].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup_name::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup_name::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_lookup_name::result (IR_ContainedSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_describe_contents::TAO_ClientRequestInfo_IR_Container_describe_contents (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_DefinitionKind & limit_type,
    const CORBA::Boolean & exclude_inherited,
    const CORBA::Long & max_returned_objs,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    limit_type_ (limit_type),
    exclude_inherited_ (exclude_inherited),
    max_returned_objs_ (max_returned_objs)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_describe_contents::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_limit_type = parameter_list->length ();
  parameter_list->length (length_limit_type + 1);
  (*parameter_list)[length_limit_type].argument <<=  this->limit_type_;
  
  (*parameter_list)[length_limit_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exclude_inherited = parameter_list->length ();
  parameter_list->length (length_exclude_inherited + 1);
  (*parameter_list)[length_exclude_inherited].argument <<= CORBA::Any::from_boolean (this->exclude_inherited_);
  (*parameter_list)[length_exclude_inherited].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_max_returned_objs = parameter_list->length ();
  parameter_list->length (length_max_returned_objs + 1);
  (*parameter_list)[length_max_returned_objs].argument <<= max_returned_objs_;
  (*parameter_list)[length_max_returned_objs].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_describe_contents::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_describe_contents::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_describe_contents::result (ACE_NESTED_CLASS (IR_Container,DescriptionSeq) * result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_module::TAO_ClientRequestInfo_IR_Container_create_module (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_module::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_module::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_module::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_module::result (IR_ModuleDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_constant::TAO_ClientRequestInfo_IR_Container_create_constant (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    const CORBA::Any & value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    value_ (value)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_constant::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<= value_;
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_constant::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_constant::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_constant::result (IR_ConstantDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_struct::TAO_ClientRequestInfo_IR_Container_create_struct (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_struct::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_struct::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_struct::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_struct::result (IR_StructDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_union::TAO_ClientRequestInfo_IR_Container_create_union (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr discriminator_type,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    discriminator_type_ (discriminator_type),
    members_ (members)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_union::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_discriminator_type = parameter_list->length ();
  parameter_list->length (length_discriminator_type + 1);
  (*parameter_list)[length_discriminator_type].argument <<=  this->discriminator_type_;
  
  (*parameter_list)[length_discriminator_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_union::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_union::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_union::result (IR_UnionDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_enum::TAO_ClientRequestInfo_IR_Container_create_enum (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_enum::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_enum::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_enum::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_enum::result (IR_EnumDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_alias::TAO_ClientRequestInfo_IR_Container_create_alias (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_ (original_type)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_alias::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_original_type = parameter_list->length ();
  parameter_list->length (length_original_type + 1);
  (*parameter_list)[length_original_type].argument <<=  this->original_type_;
  
  (*parameter_list)[length_original_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_alias::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_alias::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_alias::result (IR_AliasDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_interface::TAO_ClientRequestInfo_IR_Container_create_interface (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const IR_InterfaceDefSeq & base_interfaces,
    const CORBA::Boolean & is_abstract,
    const CORBA::Boolean & is_local,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_interfaces_ (base_interfaces),
    is_abstract_ (is_abstract),
    is_local_ (is_local)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_interface::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
  
  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_local = parameter_list->length ();
  parameter_list->length (length_is_local + 1);
  (*parameter_list)[length_is_local].argument <<= CORBA::Any::from_boolean (this->is_local_);
  (*parameter_list)[length_is_local].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_interface::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_interface::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_interface::result (IR_InterfaceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_value::TAO_ClientRequestInfo_IR_Container_create_value (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const CORBA::Boolean & is_custom,
    const CORBA::Boolean & is_abstract,
    IR_ValueDef_ptr base_value,
    const CORBA::Boolean & is_truncatable,
    const IR_ValueDefSeq & abstract_base_values,
    const IR_InterfaceDefSeq & supported_interfaces,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    is_custom_ (is_custom),
    is_abstract_ (is_abstract),
    base_value_ (base_value),
    is_truncatable_ (is_truncatable),
    abstract_base_values_ (abstract_base_values),
    supported_interfaces_ (supported_interfaces),
    initializers_ (initializers)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_value::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_custom = parameter_list->length ();
  parameter_list->length (length_is_custom + 1);
  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_value = parameter_list->length ();
  parameter_list->length (length_base_value + 1);
  (*parameter_list)[length_base_value].argument <<=  this->base_value_;
  
  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_truncatable = parameter_list->length ();
  parameter_list->length (length_is_truncatable + 1);
  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_abstract_base_values = parameter_list->length ();
  parameter_list->length (length_abstract_base_values + 1);
  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;
  
  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
  
  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_initializers = parameter_list->length ();
  parameter_list->length (length_initializers + 1);
  (*parameter_list)[length_initializers].argument <<=  this->initializers_;
  
  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_value::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_value::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_value::result (IR_ValueDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_value_box::TAO_ClientRequestInfo_IR_Container_create_value_box (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_value_box::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
  
  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_value_box::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_value_box::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_value_box::result (IR_ValueBoxDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_exception::TAO_ClientRequestInfo_IR_Container_create_exception (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const IR_StructMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    members_ (members)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_exception::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_exception::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_exception::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_exception::result (IR_ExceptionDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Container::TAO_ClientRequestInfo_IR_Container_create_native::TAO_ClientRequestInfo_IR_Container_create_native (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version)
{}

Dynamic::ParameterList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_native::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Container::TAO_ClientRequestInfo_IR_Container_create_native::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_native::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Container::TAO_ClientRequestInfo_IR_Container_create_native::result (IR_NativeDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_Container[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7461), ACE_NTOHL (0x696e6572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/Container:1.0
  10, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x61696e65), ACE_NTOHL (0x72000000),  // name = IR_Container
};
static CORBA::TypeCode _tc_TAO_tc_IR_Container (CORBA::tk_objref, sizeof (_oc_IR_Container), (char *) &_oc_IR_Container, 0, sizeof (IR_Container));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Container, &_tc_TAO_tc_IR_Container)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_IDLType_Proxy_Impl::_TAO_IDLType_Proxy_Impl (void)
{}

_TAO_IDLType_Remote_Proxy_Impl::_TAO_IDLType_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_IDLType_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
        CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_IDLType_Proxy_Broker::_TAO_IDLType_Proxy_Broker (void)
{
}

_TAO_IDLType_Proxy_Broker::~_TAO_IDLType_Proxy_Broker (void)
{
}

_TAO_IDLType_Proxy_Broker * (*_TAO_IDLType_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_IDLType_Remote_Proxy_Broker *
_TAO_IDLType_Remote_Proxy_Broker::the_TAO_IDLType_Remote_Proxy_Broker (void)
{
  static ::_TAO_IDLType_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_IDLType_Remote_Proxy_Broker::_TAO_IDLType_Remote_Proxy_Broker (void)
{
}

_TAO_IDLType_Remote_Proxy_Broker::~_TAO_IDLType_Remote_Proxy_Broker (void)
{
}

_TAO_IDLType_Proxy_Impl&
_TAO_IDLType_Remote_Proxy_Broker::select_proxy (
  ::IR_IDLType *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_IDLType::IR_IDLType (int collocated)
{
  this->IR_IDLType_setup_collocation (collocated);
}

// destructor
IR_IDLType::~IR_IDLType (void)
{}

void
IR_IDLType::IR_IDLType_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_IDLType_Proxy_Broker_ =
      _TAO_IDLType_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_IDLType_Proxy_Broker_ =
      ::_TAO_IDLType_Remote_Proxy_Broker::the_TAO_IDLType_Remote_Proxy_Broker ();
  
  this->CORBA_IRObject_setup_collocation (collocated);
  
}

void IR_IDLType::_tao_any_destructor (void *x)
{
  IR_IDLType *tmp = ACE_static_cast (IR_IDLType*,x);
  CORBA::release (tmp);
}

IR_IDLType_ptr IR_IDLType::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_IDLType::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/IDLType:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_IDLType::_nil ());
      if (is_a == 0)
        return IR_IDLType::_nil ();
    }
  return IR_IDLType::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_IDLType_ptr IR_IDLType::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_IDLType::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_IDLType_ptr default_proxy = IR_IDLType::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_IDLType_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_IDLType (
            stub,
            1,
            obj->_servant ()),
            
          IR_IDLType::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_IDLType (stub, 0, obj->_servant ()), IR_IDLType::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_IDLType_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_IDLType::_narrow
                    )
                )
          );
}

IR_IDLType_ptr
IR_IDLType::_duplicate (IR_IDLType_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_IDLType::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_IDLType::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_IDLType::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/IDLType:1.0";
}

CORBA::TypeCode_ptr IR_IDLType::type (
            CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_IDLType_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
      this,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::TAO_ClientRequestInfo_IR_IDLType_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_IDLType::TAO_ClientRequestInfo_IR_IDLType_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_IDLType[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
  8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType
};
static CORBA::TypeCode _tc_TAO_tc_IR_IDLType (CORBA::tk_objref, sizeof (_oc_IR_IDLType), (char *) &_oc_IR_IDLType, 0, sizeof (IR_IDLType));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_IDLType, &_tc_TAO_tc_IR_IDLType)
TAO_NAMESPACE_END
static const CORBA::Long _oc_IR_PrimitiveKind[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x4b696e64), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimitiveKind:1.0
  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x654b696e), ACE_NTOHL (0x64000000),  // name = PrimitiveKind
  22, // member count
  8, ACE_NTOHL (0x706b5f6e), ACE_NTOHL (0x756c6c00),  // name = pk_null
  8, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x6f696400),  // name = pk_void
  9, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x686f7274), ACE_NTOHL (0x0),  // name = pk_short
  8, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6700),  // name = pk_long
  10, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x73686f72), ACE_NTOHL (0x74000000),  // name = pk_ushort
  9, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulong
  9, ACE_NTOHL (0x706b5f66), ACE_NTOHL (0x6c6f6174), ACE_NTOHL (0x0),  // name = pk_float
  10, ACE_NTOHL (0x706b5f64), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_double
  11, ACE_NTOHL (0x706b5f62), ACE_NTOHL (0x6f6f6c65), ACE_NTOHL (0x616e0000),  // name = pk_boolean
  8, ACE_NTOHL (0x706b5f63), ACE_NTOHL (0x68617200),  // name = pk_char
  9, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x63746574), ACE_NTOHL (0x0),  // name = pk_octet
  7, ACE_NTOHL (0x706b5f61), ACE_NTOHL (0x6e790000),  // name = pk_any
  12, ACE_NTOHL (0x706b5f54), ACE_NTOHL (0x79706543), ACE_NTOHL (0x6f646500),  // name = pk_TypeCode
  13, ACE_NTOHL (0x706b5f50), ACE_NTOHL (0x72696e63), ACE_NTOHL (0x6970616c), ACE_NTOHL (0x0),  // name = pk_Principal
  10, ACE_NTOHL (0x706b5f73), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67000000),  // name = pk_string
  10, ACE_NTOHL (0x706b5f6f), ACE_NTOHL (0x626a7265), ACE_NTOHL (0x66000000),  // name = pk_objref
  12, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e676c), ACE_NTOHL (0x6f6e6700),  // name = pk_longlong
  13, ACE_NTOHL (0x706b5f75), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x6c6f6e67), ACE_NTOHL (0x0),  // name = pk_ulonglong
  14, ACE_NTOHL (0x706b5f6c), ACE_NTOHL (0x6f6e6764), ACE_NTOHL (0x6f75626c), ACE_NTOHL (0x65000000),  // name = pk_longdouble
  9, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x63686172), ACE_NTOHL (0x0),  // name = pk_wchar
  11, ACE_NTOHL (0x706b5f77), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e670000),  // name = pk_wstring
  14, ACE_NTOHL (0x706b5f76), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x65000000),  // name = pk_value_base
};
static CORBA::TypeCode _tc_TAO_tc_IR_PrimitiveKind (CORBA::tk_enum, sizeof (_oc_IR_PrimitiveKind), (char *) &_oc_IR_PrimitiveKind, 0, sizeof (IR_PrimitiveKind));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveKind, &_tc_TAO_tc_IR_PrimitiveKind)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_Repository_Proxy_Impl::_TAO_Repository_Proxy_Impl (void)
{}

_TAO_Repository_Remote_Proxy_Impl::_TAO_Repository_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_Contained_ptr _TAO_Repository_Remote_Proxy_Impl::lookup_id (
    CORBA_Object *_collocated_tao_target_,
    const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_Contained_ptr _tao_retval = IR_Contained::_nil ();
  IR_Contained_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "lookup_id",
      9,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id ri (
        &_tao_call,
        _collocated_tao_target_,
        search_id,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << search_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_Contained_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::TypeCode_ptr _TAO_Repository_Remote_Proxy_Impl::get_canonical_typecode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_canonical_typecode",
      22,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode ri (
        &_tao_call,
        _collocated_tao_target_,
        tc,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << tc)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_PrimitiveDef_ptr _TAO_Repository_Remote_Proxy_Impl::get_primitive (
    CORBA_Object *_collocated_tao_target_,
    IR_PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_PrimitiveDef_ptr _tao_retval = IR_PrimitiveDef::_nil ();
  IR_PrimitiveDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "get_primitive",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive ri (
        &_tao_call,
        _collocated_tao_target_,
        kind,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << kind)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_PrimitiveDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_StringDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_string (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_StringDef_ptr _tao_retval = IR_StringDef::_nil ();
  IR_StringDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_string",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_string ri (
        &_tao_call,
        _collocated_tao_target_,
        bound,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_StringDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_WstringDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_wstring (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_WstringDef_ptr _tao_retval = IR_WstringDef::_nil ();
  IR_WstringDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_wstring",
      14,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring ri (
        &_tao_call,
        _collocated_tao_target_,
        bound,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_WstringDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_SequenceDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_sequence (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    IR_IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_SequenceDef_ptr _tao_retval = IR_SequenceDef::_nil ();
  IR_SequenceDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_sequence",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence ri (
        &_tao_call,
        _collocated_tao_target_,
        bound,
        element_type,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound) &&
              (_tao_out << element_type)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_SequenceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ArrayDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_array (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length,
    IR_IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_ArrayDef_ptr _tao_retval = IR_ArrayDef::_nil ();
  IR_ArrayDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_array",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_array ri (
        &_tao_call,
        _collocated_tao_target_,
        length,
        element_type,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << length) &&
              (_tao_out << element_type)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ArrayDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_FixedDef_ptr _TAO_Repository_Remote_Proxy_Impl::create_fixed (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_FixedDef_ptr _tao_retval = IR_FixedDef::_nil ();
  IR_FixedDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_fixed",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed ri (
        &_tao_call,
        _collocated_tao_target_,
        digits,
        scale,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << digits) &&
              (_tao_out << scale)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_FixedDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_Repository_Proxy_Broker::_TAO_Repository_Proxy_Broker (void)
{
}

_TAO_Repository_Proxy_Broker::~_TAO_Repository_Proxy_Broker (void)
{
}

_TAO_Repository_Proxy_Broker * (*_TAO_Repository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_Repository_Remote_Proxy_Broker *
_TAO_Repository_Remote_Proxy_Broker::the_TAO_Repository_Remote_Proxy_Broker (void)
{
  static ::_TAO_Repository_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_Repository_Remote_Proxy_Broker::_TAO_Repository_Remote_Proxy_Broker (void)
{
}

_TAO_Repository_Remote_Proxy_Broker::~_TAO_Repository_Remote_Proxy_Broker (void)
{
}

_TAO_Repository_Proxy_Impl&
_TAO_Repository_Remote_Proxy_Broker::select_proxy (
  ::IR_Repository *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_Repository::IR_Repository (int collocated)
{
  this->IR_Repository_setup_collocation (collocated);
}

// destructor
IR_Repository::~IR_Repository (void)
{}

void
IR_Repository::IR_Repository_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_Repository_Proxy_Broker_ =
      _TAO_Repository_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_Repository_Proxy_Broker_ =
      ::_TAO_Repository_Remote_Proxy_Broker::the_TAO_Repository_Remote_Proxy_Broker ();
  
  this->IR_Container_setup_collocation (collocated);
  
}

void IR_Repository::_tao_any_destructor (void *x)
{
  IR_Repository *tmp = ACE_static_cast (IR_Repository*,x);
  CORBA::release (tmp);
}

IR_Repository_ptr IR_Repository::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_Repository::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/Repository:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_Repository::_nil ());
      if (is_a == 0)
        return IR_Repository::_nil ();
    }
  return IR_Repository::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_Repository_ptr IR_Repository::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_Repository::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_Repository_ptr default_proxy = IR_Repository::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_Repository_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_Repository (
            stub,
            1,
            obj->_servant ()),
            
          IR_Repository::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_Repository (stub, 0, obj->_servant ()), IR_Repository::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_Repository_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_Repository::_narrow
                    )
                )
          );
}

IR_Repository_ptr
IR_Repository::_duplicate (IR_Repository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_Repository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_Repository::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Repository::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_Repository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/Repository:1.0";
}

IR_Contained_ptr IR_Repository::lookup_id (
   const char * search_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).lookup_id (
      this,
      search_id,
      ACE_TRY_ENV
    );
}

CORBA::TypeCode_ptr IR_Repository::get_canonical_typecode (
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).get_canonical_typecode (
      this,
      tc,
      ACE_TRY_ENV
    );
}

IR_PrimitiveDef_ptr IR_Repository::get_primitive (
    IR_PrimitiveKind kind,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).get_primitive (
      this,
      kind,
      ACE_TRY_ENV
    );
}

IR_StringDef_ptr IR_Repository::create_string (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_string (
      this,
      bound,
      ACE_TRY_ENV
    );
}

IR_WstringDef_ptr IR_Repository::create_wstring (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_wstring (
      this,
      bound,
      ACE_TRY_ENV
    );
}

IR_SequenceDef_ptr IR_Repository::create_sequence (
    CORBA::ULong bound,
    IR_IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_sequence (
      this,
      bound,
      element_type,
      ACE_TRY_ENV
    );
}

IR_ArrayDef_ptr IR_Repository::create_array (
    CORBA::ULong length,
    IR_IDLType_ptr element_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_array (
      this,
      length,
      element_type,
      ACE_TRY_ENV
    );
}

IR_FixedDef_ptr IR_Repository::create_fixed (
    CORBA::UShort digits,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_Repository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_fixed (
      this,
      digits,
      scale,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::TAO_ClientRequestInfo_IR_Repository_lookup_id (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * search_id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    search_id_ (search_id)
{}

Dynamic::ParameterList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_search_id = parameter_list->length ();
  parameter_list->length (length_search_id + 1);
  (*parameter_list)[length_search_id].argument <<= search_id_;
  (*parameter_list)[length_search_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_lookup_id::result (IR_Contained_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::TypeCode_ptr tc,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    tc_ (tc)
{}

Dynamic::ParameterList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_tc = parameter_list->length ();
  parameter_list->length (length_tc + 1);
  (*parameter_list)[length_tc].argument <<= tc_;
  (*parameter_list)[length_tc].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_canonical_typecode::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::TAO_ClientRequestInfo_IR_Repository_get_primitive (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_PrimitiveKind & kind,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    kind_ (kind)
{}

Dynamic::ParameterList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_kind = parameter_list->length ();
  parameter_list->length (length_kind + 1);
  (*parameter_list)[length_kind].argument <<=  this->kind_;
  
  (*parameter_list)[length_kind].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_get_primitive::result (IR_PrimitiveDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_string::TAO_ClientRequestInfo_IR_Repository_create_string (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_string::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_string::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_string::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_string::result (IR_StringDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::TAO_ClientRequestInfo_IR_Repository_create_wstring (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_wstring::result (IR_WstringDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::TAO_ClientRequestInfo_IR_Repository_create_sequence (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound,
    IR_IDLType_ptr element_type,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    bound_ (bound),
    element_type_ (element_type)
{}

Dynamic::ParameterList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_element_type = parameter_list->length ();
  parameter_list->length (length_element_type + 1);
  (*parameter_list)[length_element_type].argument <<=  this->element_type_;
  
  (*parameter_list)[length_element_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_sequence::result (IR_SequenceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_array::TAO_ClientRequestInfo_IR_Repository_create_array (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & length,
    IR_IDLType_ptr element_type,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    length_ (length),
    element_type_ (element_type)
{}

Dynamic::ParameterList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_array::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_length = parameter_list->length ();
  parameter_list->length (length_length + 1);
  (*parameter_list)[length_length].argument <<= length_;
  (*parameter_list)[length_length].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_element_type = parameter_list->length ();
  parameter_list->length (length_element_type + 1);
  (*parameter_list)[length_element_type].argument <<=  this->element_type_;
  
  (*parameter_list)[length_element_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_array::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_array::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_array::result (IR_ArrayDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::TAO_ClientRequestInfo_IR_Repository_create_fixed (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::UShort & digits,
    const CORBA::Short & scale,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    digits_ (digits),
    scale_ (scale)
{}

Dynamic::ParameterList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_digits = parameter_list->length ();
  parameter_list->length (length_digits + 1);
  (*parameter_list)[length_digits].argument <<= digits_;
  (*parameter_list)[length_digits].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_scale = parameter_list->length ();
  parameter_list->length (length_scale + 1);
  (*parameter_list)[length_scale].argument <<= scale_;
  (*parameter_list)[length_scale].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_Repository::TAO_ClientRequestInfo_IR_Repository_create_fixed::result (IR_FixedDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_Repository[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x793a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Repository:1.0
  11, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72790000),  // name = IR_Repository
};
static CORBA::TypeCode _tc_TAO_tc_IR_Repository (CORBA::tk_objref, sizeof (_oc_IR_Repository), (char *) &_oc_IR_Repository, 0, sizeof (IR_Repository));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_Repository, &_tc_TAO_tc_IR_Repository)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ComponentRepository_Proxy_Impl::_TAO_ComponentRepository_Proxy_Impl (void)
{}

_TAO_ComponentRepository_Remote_Proxy_Impl::_TAO_ComponentRepository_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_ComponentDef_ptr _TAO_ComponentRepository_Remote_Proxy_Impl::create_component (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ComponentDef_ptr base_component,
    const IR_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_ComponentDef_ptr _tao_retval = IR_ComponentDef::_nil ();
  IR_ComponentDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);
  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_component",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        base_component,
        supports_interfaces,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_component) &&
              (_tao_out << supports_interfaces)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_HomeDef_ptr _TAO_ComponentRepository_Remote_Proxy_Impl::create_home (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_HomeDef_ptr base_home,
    IR_ComponentDef_ptr managed_component,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_HomeDef_ptr _tao_retval = IR_HomeDef::_nil ();
  IR_HomeDef_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_home",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        base_home,
        managed_component,
        primary_key,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << base_home) &&
              (_tao_out << managed_component) &&
              (_tao_out << primary_key)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_HomeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ComponentRepository_Proxy_Broker::_TAO_ComponentRepository_Proxy_Broker (void)
{
}

_TAO_ComponentRepository_Proxy_Broker::~_TAO_ComponentRepository_Proxy_Broker (void)
{
}

_TAO_ComponentRepository_Proxy_Broker * (*_TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ComponentRepository_Remote_Proxy_Broker *
_TAO_ComponentRepository_Remote_Proxy_Broker::the_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
  static ::_TAO_ComponentRepository_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ComponentRepository_Remote_Proxy_Broker::_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
}

_TAO_ComponentRepository_Remote_Proxy_Broker::~_TAO_ComponentRepository_Remote_Proxy_Broker (void)
{
}

_TAO_ComponentRepository_Proxy_Impl&
_TAO_ComponentRepository_Remote_Proxy_Broker::select_proxy (
  ::IR_ComponentRepository *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ComponentRepository::IR_ComponentRepository (int collocated)
{
  this->IR_ComponentRepository_setup_collocation (collocated);
}

// destructor
IR_ComponentRepository::~IR_ComponentRepository (void)
{}

void
IR_ComponentRepository::IR_ComponentRepository_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentRepository_Proxy_Broker_ =
      _TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentRepository_Proxy_Broker_ =
      _TAO_ComponentRepository_Remote_Proxy_Broker::the_TAO_ComponentRepository_Remote_Proxy_Broker ();
  
  this->IR_Repository_setup_collocation (collocated);
  
}

void IR_ComponentRepository::_tao_any_destructor (void *x)
{
  IR_ComponentRepository *tmp = ACE_static_cast (IR_ComponentRepository*,x);
  CORBA::release (tmp);
}

IR_ComponentRepository_ptr IR_ComponentRepository::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ComponentRepository::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentRepository:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ComponentRepository::_nil ());
      if (is_a == 0)
        return IR_ComponentRepository::_nil ();
    }
  return IR_ComponentRepository::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ComponentRepository_ptr IR_ComponentRepository::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ComponentRepository::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ComponentRepository_ptr default_proxy = IR_ComponentRepository::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ComponentRepository_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ComponentRepository (
            stub,
            1,
            obj->_servant ()),
            
          IR_ComponentRepository::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ComponentRepository (stub, 0, obj->_servant ()), IR_ComponentRepository::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ComponentRepository_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ComponentRepository::_narrow
                    )
                )
          );
}

IR_ComponentRepository_ptr
IR_ComponentRepository::_duplicate (IR_ComponentRepository_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ComponentRepository::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentRepository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Repository:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ComponentRepository::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ComponentRepository::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Repository::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Repository_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ComponentRepository::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentRepository:1.0";
}

IR_ComponentDef_ptr IR_ComponentRepository::create_component (
    const char * id,
    const char * name,
    const char * version,
    IR_ComponentDef_ptr base_component,
    const IR_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_component (
      this,
      id,
      name,
      version,
      base_component,
      supports_interfaces,
      ACE_TRY_ENV
    );
}

IR_HomeDef_ptr IR_ComponentRepository::create_home (
    const char * id,
    const char * name,
    const char * version,
    IR_HomeDef_ptr base_home,
    IR_ComponentDef_ptr managed_component,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{ 
  return this->the_TAO_ComponentRepository_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_home (
      this,
      id,
      name,
      version,
      base_home,
      managed_component,
      primary_key,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::TAO_ClientRequestInfo_IR_ComponentRepository_create_component (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_ComponentDef_ptr base_component,
    const IR_InterfaceDefSeq & supports_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_component_ (base_component),
    supports_interfaces_ (supports_interfaces)
{}

Dynamic::ParameterList *
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_component = parameter_list->length ();
  parameter_list->length (length_base_component + 1);
  (*parameter_list)[length_base_component].argument <<=  this->base_component_;
  
  (*parameter_list)[length_base_component].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_supports_interfaces = parameter_list->length ();
  parameter_list->length (length_supports_interfaces + 1);
  (*parameter_list)[length_supports_interfaces].argument <<=  this->supports_interfaces_;
  
  (*parameter_list)[length_supports_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_component::result (IR_ComponentDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::TAO_ClientRequestInfo_IR_ComponentRepository_create_home (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_HomeDef_ptr base_home,
    IR_ComponentDef_ptr managed_component,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    base_home_ (base_home),
    managed_component_ (managed_component),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_base_home = parameter_list->length ();
  parameter_list->length (length_base_home + 1);
  (*parameter_list)[length_base_home].argument <<=  this->base_home_;
  
  (*parameter_list)[length_base_home].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_managed_component = parameter_list->length ();
  parameter_list->length (length_managed_component + 1);
  (*parameter_list)[length_managed_component].argument <<=  this->managed_component_;
  
  (*parameter_list)[length_managed_component].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_primary_key = parameter_list->length ();
  parameter_list->length (length_primary_key + 1);
  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;
  
  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentRepository::TAO_ClientRequestInfo_IR_ComponentRepository_create_home::result (IR_HomeDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ComponentRepository[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72793a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ComponentRepository:1.0
  20, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74526570), ACE_NTOHL (0x6f736974), ACE_NTOHL (0x6f727900),  // name = IR_ComponentRepository
};
static CORBA::TypeCode _tc_TAO_tc_IR_ComponentRepository (CORBA::tk_objref, sizeof (_oc_IR_ComponentRepository), (char *) &_oc_IR_ComponentRepository, 0, sizeof (IR_ComponentRepository));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentRepository, &_tc_TAO_tc_IR_ComponentRepository)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ModuleDef_Proxy_Impl::_TAO_ModuleDef_Proxy_Impl (void)
{}

_TAO_ModuleDef_Remote_Proxy_Impl::_TAO_ModuleDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ModuleDef_Proxy_Broker::_TAO_ModuleDef_Proxy_Broker (void)
{
}

_TAO_ModuleDef_Proxy_Broker::~_TAO_ModuleDef_Proxy_Broker (void)
{
}

_TAO_ModuleDef_Proxy_Broker * (*_TAO_ModuleDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ModuleDef_Remote_Proxy_Broker *
_TAO_ModuleDef_Remote_Proxy_Broker::the_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ModuleDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ModuleDef_Remote_Proxy_Broker::_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
}

_TAO_ModuleDef_Remote_Proxy_Broker::~_TAO_ModuleDef_Remote_Proxy_Broker (void)
{
}

_TAO_ModuleDef_Proxy_Impl&
_TAO_ModuleDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ModuleDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ModuleDef::IR_ModuleDef (int collocated)
{
  this->IR_ModuleDef_setup_collocation (collocated);
}

// destructor
IR_ModuleDef::~IR_ModuleDef (void)
{}

void
IR_ModuleDef::IR_ModuleDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ModuleDef_Proxy_Broker_ =
      _TAO_ModuleDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ModuleDef_Proxy_Broker_ =
      _TAO_ModuleDef_Remote_Proxy_Broker::the_TAO_ModuleDef_Remote_Proxy_Broker ();
  
  this->IR_Container_setup_collocation (collocated);
  this->IR_Contained_setup_collocation (collocated); 
}

void IR_ModuleDef::_tao_any_destructor (void *x)
{
  IR_ModuleDef *tmp = ACE_static_cast (IR_ModuleDef*,x);
  CORBA::release (tmp);
}

IR_ModuleDef_ptr IR_ModuleDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ModuleDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ModuleDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ModuleDef::_nil ());
      if (is_a == 0)
        return IR_ModuleDef::_nil ();
    }
  return IR_ModuleDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ModuleDef_ptr IR_ModuleDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ModuleDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ModuleDef_ptr default_proxy = IR_ModuleDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ModuleDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ModuleDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ModuleDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ModuleDef (stub, 0, obj->_servant ()), IR_ModuleDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ModuleDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ModuleDef::_narrow
                    )
                )
          );
}

IR_ModuleDef_ptr
IR_ModuleDef::_duplicate (IR_ModuleDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ModuleDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ModuleDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ModuleDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ModuleDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ModuleDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ModuleDef:1.0";
}

static const CORBA::Long _oc_IR_ModuleDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ModuleDef:1.0
  10, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x66000000),  // name = IR_ModuleDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ModuleDef (CORBA::tk_objref, sizeof (_oc_IR_ModuleDef), (char *) &_oc_IR_ModuleDef, 0, sizeof (IR_ModuleDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDef, &_tc_TAO_tc_IR_ModuleDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ModuleDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4d), ACE_NTOHL (0x6f64756c), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ModuleDescription:1.0
  18, ACE_NTOHL (0x4d6f6475), ACE_NTOHL (0x6c654465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e000000),  // name = ModuleDescription
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_ModuleDescription (CORBA::tk_struct, sizeof (_oc_IR_ModuleDescription), (char *) &_oc_IR_ModuleDescription, 0, sizeof (IR_ModuleDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ModuleDescription, &_tc_TAO_tc_IR_ModuleDescription)
TAO_NAMESPACE_END

void IR_ModuleDescription::_tao_any_destructor (void *x)
{
  IR_ModuleDescription *tmp = ACE_static_cast (IR_ModuleDescription*,x);
  delete tmp;
}

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ConstantDef_Proxy_Impl::_TAO_ConstantDef_Proxy_Impl (void)
{}

_TAO_ConstantDef_Remote_Proxy_Impl::_TAO_ConstantDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_ConstantDef_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_IDLType_ptr _TAO_ConstantDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ConstantDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Any * _TAO_ConstantDef_Remote_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::Any *_tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  ACE_NEW_RETURN (_tao_retval, CORBA::Any, _tao_retval);
  CORBA::Any_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_value",
      10,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Any * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ConstantDef_Remote_Proxy_Impl::value (
    CORBA_Object *_collocated_tao_target_,
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_value",
      10,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set ri (
        &_tao_call,
        _collocated_tao_target_,
        value,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ConstantDef_Proxy_Broker::_TAO_ConstantDef_Proxy_Broker (void)
{
}

_TAO_ConstantDef_Proxy_Broker::~_TAO_ConstantDef_Proxy_Broker (void)
{
}

_TAO_ConstantDef_Proxy_Broker * (*_TAO_ConstantDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ConstantDef_Remote_Proxy_Broker *
_TAO_ConstantDef_Remote_Proxy_Broker::the_TAO_ConstantDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ConstantDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ConstantDef_Remote_Proxy_Broker::_TAO_ConstantDef_Remote_Proxy_Broker (void)
{
}

_TAO_ConstantDef_Remote_Proxy_Broker::~_TAO_ConstantDef_Remote_Proxy_Broker (void)
{
}

_TAO_ConstantDef_Proxy_Impl&
_TAO_ConstantDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ConstantDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ConstantDef::IR_ConstantDef (int collocated)
{
  this->IR_ConstantDef_setup_collocation (collocated);
}

// destructor
IR_ConstantDef::~IR_ConstantDef (void)
{}

void
IR_ConstantDef::IR_ConstantDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ConstantDef_Proxy_Broker_ =
      _TAO_ConstantDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ConstantDef_Proxy_Broker_ =
      _TAO_ConstantDef_Remote_Proxy_Broker::the_TAO_ConstantDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
  
}

void IR_ConstantDef::_tao_any_destructor (void *x)
{
  IR_ConstantDef *tmp = ACE_static_cast (IR_ConstantDef*,x);
  CORBA::release (tmp);
}

IR_ConstantDef_ptr IR_ConstantDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ConstantDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConstantDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ConstantDef::_nil ());
      if (is_a == 0)
        return IR_ConstantDef::_nil ();
    }
  return IR_ConstantDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ConstantDef_ptr IR_ConstantDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ConstantDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ConstantDef_ptr default_proxy = IR_ConstantDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ConstantDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ConstantDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ConstantDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ConstantDef (stub, 0, obj->_servant ()), IR_ConstantDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ConstantDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ConstantDef::_narrow
                    )
                )
          );
}

IR_ConstantDef_ptr
IR_ConstantDef::_duplicate (IR_ConstantDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ConstantDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConstantDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ConstantDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ConstantDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ConstantDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConstantDef:1.0";
}

CORBA::TypeCode_ptr IR_ConstantDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{ 
  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
      this,
      ACE_TRY_ENV
    );
}

IR_IDLType_ptr IR_ConstantDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_ConstantDef::type_def (
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
      this,
      type_def,
      ACE_TRY_ENV
    );
}

CORBA::Any * IR_ConstantDef::value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).value (
      this,
      ACE_TRY_ENV
    );
}

void IR_ConstantDef::value (
    const CORBA::Any & value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->the_TAO_ConstantDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).value (
      this,
      value,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::TAO_ClientRequestInfo_IR_ConstantDef_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_type_def = parameter_list->length ();
  parameter_list->length (length_type_def + 1);
  (*parameter_list)[length_type_def].argument <<=  this->type_def_;
  
  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::TAO_ClientRequestInfo_IR_ConstantDef_value_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_get::result (CORBA::Any * result)
{
  // update the result 
  this->_result = result;
}

IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set::TAO_ClientRequestInfo_IR_ConstantDef_value_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Any & value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    value_ (value)
{}

Dynamic::ParameterList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<= value_;
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ConstantDef::TAO_ClientRequestInfo_IR_ConstantDef_value_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ConstantDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7444), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConstantDef:1.0
  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44656600),  // name = IR_ConstantDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ConstantDef (CORBA::tk_objref, sizeof (_oc_IR_ConstantDef), (char *) &_oc_IR_ConstantDef, 0, sizeof (IR_ConstantDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDef, &_tc_TAO_tc_IR_ConstantDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ConstantDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7374), ACE_NTOHL (0x616e7444), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConstantDescription:1.0
  20, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x74616e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ConstantDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_any,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ConstantDescription (CORBA::tk_struct, sizeof (_oc_IR_ConstantDescription), (char *) &_oc_IR_ConstantDescription, 0, sizeof (IR_ConstantDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConstantDescription, &_tc_TAO_tc_IR_ConstantDescription)
TAO_NAMESPACE_END

void IR_ConstantDescription::_tao_any_destructor (void *x)
{
  IR_ConstantDescription *tmp = ACE_static_cast (IR_ConstantDescription*,x);
  delete tmp;
}


///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_TypedefDef_Proxy_Impl::_TAO_TypedefDef_Proxy_Impl (void)
{}

_TAO_TypedefDef_Remote_Proxy_Impl::_TAO_TypedefDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_TypedefDef_Proxy_Broker::_TAO_TypedefDef_Proxy_Broker (void)
{
}

_TAO_TypedefDef_Proxy_Broker::~_TAO_TypedefDef_Proxy_Broker (void)
{
}

_TAO_TypedefDef_Proxy_Broker * (*_TAO_TypedefDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_TypedefDef_Remote_Proxy_Broker *
_TAO_TypedefDef_Remote_Proxy_Broker::the_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_TypedefDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_TypedefDef_Remote_Proxy_Broker::_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
}

_TAO_TypedefDef_Remote_Proxy_Broker::~_TAO_TypedefDef_Remote_Proxy_Broker (void)
{
}

_TAO_TypedefDef_Proxy_Impl&
_TAO_TypedefDef_Remote_Proxy_Broker::select_proxy (
  ::IR_TypedefDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_TypedefDef::IR_TypedefDef (int collocated)
{
  this->IR_TypedefDef_setup_collocation (collocated);
}

// destructor
IR_TypedefDef::~IR_TypedefDef (void)
{}

void
IR_TypedefDef::IR_TypedefDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_TypedefDef_Proxy_Broker_ =
      _TAO_TypedefDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_TypedefDef_Proxy_Broker_ =
      _TAO_TypedefDef_Remote_Proxy_Broker::the_TAO_TypedefDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
  this->IR_IDLType_setup_collocation (collocated);
  
}

void IR_TypedefDef::_tao_any_destructor (void *x)
{
  IR_TypedefDef *tmp = ACE_static_cast (IR_TypedefDef*,x);
  CORBA::release (tmp);
}

IR_TypedefDef_ptr IR_TypedefDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_TypedefDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/TypedefDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_TypedefDef::_nil ());
      if (is_a == 0)
        return IR_TypedefDef::_nil ();
    }
  return IR_TypedefDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_TypedefDef_ptr IR_TypedefDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_TypedefDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_TypedefDef_ptr default_proxy = IR_TypedefDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_TypedefDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_TypedefDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_TypedefDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_TypedefDef (stub, 0, obj->_servant ()), IR_TypedefDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_TypedefDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_TypedefDef::_narrow
                    )
                )
          );
}

IR_TypedefDef_ptr
IR_TypedefDef::_duplicate (IR_TypedefDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_TypedefDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_TypedefDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_TypedefDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_TypedefDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/TypedefDef:1.0";
}

static const CORBA::Long _oc_IR_TypedefDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f54), ACE_NTOHL (0x79706564), ACE_NTOHL (0x65664465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/TypedefDef:1.0
  11, ACE_NTOHL (0x54797065), ACE_NTOHL (0x64656644), ACE_NTOHL (0x65660000),  // name = IR_TypedefDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_TypedefDef (CORBA::tk_objref, sizeof (_oc_IR_TypedefDef), (char *) &_oc_IR_TypedefDef, 0, sizeof (IR_TypedefDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypedefDef, &_tc_TAO_tc_IR_TypedefDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_TypeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f54), ACE_NTOHL (0x79706544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/TypeDescription:1.0
  16, ACE_NTOHL (0x54797065), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = TypeDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_IR_TypeDescription (CORBA::tk_struct, sizeof (_oc_IR_TypeDescription), (char *) &_oc_IR_TypeDescription, 0, sizeof (IR_TypeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_TypeDescription, &_tc_TAO_tc_IR_TypeDescription)
TAO_NAMESPACE_END

void IR_TypeDescription::_tao_any_destructor (void *x)
{
  IR_TypeDescription *tmp = ACE_static_cast (IR_TypeDescription*,x);
  delete tmp;
}

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_StructDef_Proxy_Impl::_TAO_StructDef_Proxy_Impl (void)
{}

_TAO_StructDef_Remote_Proxy_Impl::_TAO_StructDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_StructMemberSeq * _TAO_StructDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_StructMemberSeq *_tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  ACE_NEW_RETURN (_tao_retval, IR_StructMemberSeq, _tao_retval);
  IR_StructMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_StructMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_StructDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set ri (
        &_tao_call,
        _collocated_tao_target_,
        members,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_StructDef_Proxy_Broker::_TAO_StructDef_Proxy_Broker (void)
{
}

_TAO_StructDef_Proxy_Broker::~_TAO_StructDef_Proxy_Broker (void)
{
}

_TAO_StructDef_Proxy_Broker * (*_TAO_StructDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_StructDef_Remote_Proxy_Broker *
_TAO_StructDef_Remote_Proxy_Broker::the_TAO_StructDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_StructDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_StructDef_Remote_Proxy_Broker::_TAO_StructDef_Remote_Proxy_Broker (void)
{
}

_TAO_StructDef_Remote_Proxy_Broker::~_TAO_StructDef_Remote_Proxy_Broker (void)
{
}

_TAO_StructDef_Proxy_Impl&
_TAO_StructDef_Remote_Proxy_Broker::select_proxy (
  ::IR_StructDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_StructDef::IR_StructDef (int collocated)
{
  this->IR_StructDef_setup_collocation (collocated);
}

// destructor
IR_StructDef::~IR_StructDef (void)
{}

void
IR_StructDef::IR_StructDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_StructDef_Proxy_Broker_ =
      _TAO_StructDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_StructDef_Proxy_Broker_ =
      _TAO_StructDef_Remote_Proxy_Broker::the_TAO_StructDef_Remote_Proxy_Broker ();
  
  this->IR_TypedefDef_setup_collocation (collocated);
  this->IR_Container_setup_collocation (collocated);
  
}

void IR_StructDef::_tao_any_destructor (void *x)
{
  IR_StructDef *tmp = ACE_static_cast (IR_StructDef*,x);
  CORBA::release (tmp);
}

IR_StructDef_ptr IR_StructDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_StructDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/StructDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_StructDef::_nil ());
      if (is_a == 0)
        return IR_StructDef::_nil ();
    }
  return IR_StructDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_StructDef_ptr IR_StructDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_StructDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_StructDef_ptr default_proxy = IR_StructDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_StructDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_StructDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_StructDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_StructDef (stub, 0, obj->_servant ()), IR_StructDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_StructDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_StructDef::_narrow
                    )
                )
          );
}

IR_StructDef_ptr
IR_StructDef::_duplicate (IR_StructDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_StructDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StructDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_StructDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_StructDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_TypedefDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_StructDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StructDef:1.0";
}

IR_StructMemberSeq * IR_StructDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_StructDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
      this,
      ACE_TRY_ENV
    );
}

void IR_StructDef::members (
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->the_TAO_StructDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
      this,
      members,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::TAO_ClientRequestInfo_IR_StructDef_members_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_get::result (IR_StructMemberSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set::TAO_ClientRequestInfo_IR_StructDef_members_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_StructMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    members_ (members)
{}

Dynamic::ParameterList *
IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_StructDef::TAO_ClientRequestInfo_IR_StructDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_StructDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x74446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/StructDef:1.0
  10, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744465), ACE_NTOHL (0x66000000),  // name = IR_StructDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_StructDef (CORBA::tk_objref, sizeof (_oc_IR_StructDef), (char *) &_oc_IR_StructDef, 0, sizeof (IR_StructDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StructDef, &_tc_TAO_tc_IR_StructDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_UnionDef_Proxy_Impl::_TAO_UnionDef_Proxy_Impl (void)
{}

_TAO_UnionDef_Remote_Proxy_Impl::_TAO_UnionDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_UnionDef_Remote_Proxy_Impl::discriminator_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_discriminator_type",
      23,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_IDLType_ptr _TAO_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
 
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_discriminator_type_def",
      27,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_UnionDef_Remote_Proxy_Impl::discriminator_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_discriminator_type_def",
      27,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        discriminator_type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << discriminator_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_UnionMemberSeq * _TAO_UnionDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_UnionMemberSeq *_tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  ACE_NEW_RETURN (_tao_retval, IR_UnionMemberSeq, _tao_retval);
  IR_UnionMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_UnionMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_UnionDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set ri (
        &_tao_call,
        _collocated_tao_target_,
        members,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_UnionDef_Proxy_Broker::_TAO_UnionDef_Proxy_Broker (void)
{
}

_TAO_UnionDef_Proxy_Broker::~_TAO_UnionDef_Proxy_Broker (void)
{
}

_TAO_UnionDef_Proxy_Broker * (*_TAO_UnionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_UnionDef_Remote_Proxy_Broker *
_TAO_UnionDef_Remote_Proxy_Broker::the_TAO_UnionDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_UnionDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_UnionDef_Remote_Proxy_Broker::_TAO_UnionDef_Remote_Proxy_Broker (void)
{
}

_TAO_UnionDef_Remote_Proxy_Broker::~_TAO_UnionDef_Remote_Proxy_Broker (void)
{
}

_TAO_UnionDef_Proxy_Impl&
_TAO_UnionDef_Remote_Proxy_Broker::select_proxy (
  ::IR_UnionDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_UnionDef::IR_UnionDef (int collocated)
{
  this->IR_UnionDef_setup_collocation (collocated);
}

// destructor
IR_UnionDef::~IR_UnionDef (void)
{}

void
IR_UnionDef::IR_UnionDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_UnionDef_Proxy_Broker_ =
      _TAO_UnionDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_UnionDef_Proxy_Broker_ =
      _TAO_UnionDef_Remote_Proxy_Broker::the_TAO_UnionDef_Remote_Proxy_Broker ();
  
  this->IR_TypedefDef_setup_collocation (collocated);
  this->IR_Container_setup_collocation (collocated);
}

void IR_UnionDef::_tao_any_destructor (void *x)
{
  IR_UnionDef *tmp = ACE_static_cast (IR_UnionDef*,x);
  CORBA::release (tmp);
}

IR_UnionDef_ptr IR_UnionDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_UnionDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UnionDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_UnionDef::_nil ());
      if (is_a == 0)
        return IR_UnionDef::_nil ();
    }
  return IR_UnionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_UnionDef_ptr IR_UnionDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_UnionDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_UnionDef_ptr default_proxy = IR_UnionDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_UnionDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_UnionDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_UnionDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_UnionDef (stub, 0, obj->_servant ()), IR_UnionDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_UnionDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_UnionDef::_narrow
                    )
                )
          );
}

IR_UnionDef_ptr
IR_UnionDef::_duplicate (IR_UnionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_UnionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UnionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_UnionDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_UnionDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_TypedefDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_UnionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UnionDef:1.0";
}

CORBA::TypeCode_ptr IR_UnionDef::discriminator_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type (
      this,
      ACE_TRY_ENV
    );
}

IR_IDLType_ptr IR_UnionDef::discriminator_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_UnionDef::discriminator_type_def (
    IR_IDLType_ptr discriminator_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).discriminator_type_def (
      this,
      discriminator_type_def,
      ACE_TRY_ENV
    );
}

IR_UnionMemberSeq * IR_UnionDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
      this,
      ACE_TRY_ENV
    );
}

void IR_UnionDef::members (
    const IR_UnionMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->the_TAO_UnionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
      this,
      members,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr discriminator_type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    discriminator_type_def_ (discriminator_type_def)
{}

Dynamic::ParameterList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_discriminator_type_def = parameter_list->length ();
  parameter_list->length (length_discriminator_type_def + 1);
  (*parameter_list)[length_discriminator_type_def].argument <<=  this->discriminator_type_def_;
  
  (*parameter_list)[length_discriminator_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_discriminator_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::TAO_ClientRequestInfo_IR_UnionDef_members_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_get::result (IR_UnionMemberSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set::TAO_ClientRequestInfo_IR_UnionDef_members_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_UnionMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    members_ (members)
{}

Dynamic::ParameterList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_UnionDef::TAO_ClientRequestInfo_IR_UnionDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_UnionDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x6e696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/UnionDef:1.0
  9, ACE_NTOHL (0x556e696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = IR_UnionDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_UnionDef (CORBA::tk_objref, sizeof (_oc_IR_UnionDef), (char *) &_oc_IR_UnionDef, 0, sizeof (IR_UnionDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UnionDef, &_tc_TAO_tc_IR_UnionDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_EnumDef_Proxy_Impl::_TAO_EnumDef_Proxy_Impl (void)
{}

_TAO_EnumDef_Remote_Proxy_Impl::_TAO_EnumDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_EnumMemberSeq * _TAO_EnumDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_EnumMemberSeq *_tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  ACE_NEW_RETURN (_tao_retval, IR_EnumMemberSeq, _tao_retval);
  IR_EnumMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_EnumMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_EnumDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set ri (
        &_tao_call,
        _collocated_tao_target_,
        members,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_EnumDef_Proxy_Broker::_TAO_EnumDef_Proxy_Broker (void)
{
}

_TAO_EnumDef_Proxy_Broker::~_TAO_EnumDef_Proxy_Broker (void)
{
}

_TAO_EnumDef_Proxy_Broker * (*_TAO_EnumDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_EnumDef_Remote_Proxy_Broker *
_TAO_EnumDef_Remote_Proxy_Broker::the_TAO_EnumDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_EnumDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_EnumDef_Remote_Proxy_Broker::_TAO_EnumDef_Remote_Proxy_Broker (void)
{
}

_TAO_EnumDef_Remote_Proxy_Broker::~_TAO_EnumDef_Remote_Proxy_Broker (void)
{
}

_TAO_EnumDef_Proxy_Impl&
_TAO_EnumDef_Remote_Proxy_Broker::select_proxy (
  ::IR_EnumDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_EnumDef::IR_EnumDef (int collocated)
{
  this->IR_EnumDef_setup_collocation (collocated);
}

// destructor
IR_EnumDef::~IR_EnumDef (void)
{}

void
IR_EnumDef::IR_EnumDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EnumDef_Proxy_Broker_ =
      _TAO_EnumDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EnumDef_Proxy_Broker_ =
      _TAO_EnumDef_Remote_Proxy_Broker::the_TAO_EnumDef_Remote_Proxy_Broker ();
  
  this->IR_TypedefDef_setup_collocation (collocated);
  
}

void IR_EnumDef::_tao_any_destructor (void *x)
{
  IR_EnumDef *tmp = ACE_static_cast (IR_EnumDef*,x);
  CORBA::release (tmp);
}

IR_EnumDef_ptr IR_EnumDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_EnumDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EnumDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_EnumDef::_nil ());
      if (is_a == 0)
        return IR_EnumDef::_nil ();
    }
  return IR_EnumDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_EnumDef_ptr IR_EnumDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_EnumDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_EnumDef_ptr default_proxy = IR_EnumDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_EnumDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_EnumDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_EnumDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_EnumDef (stub, 0, obj->_servant ()), IR_EnumDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_EnumDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_EnumDef::_narrow
                    )
                )
          );
}

IR_EnumDef_ptr
IR_EnumDef::_duplicate (IR_EnumDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_EnumDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EnumDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_EnumDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_EnumDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_TypedefDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_EnumDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EnumDef:1.0";
}

IR_EnumMemberSeq * IR_EnumDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_EnumDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
      this,
      ACE_TRY_ENV
    );
}

void IR_EnumDef::members (
    const IR_EnumMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->the_TAO_EnumDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
      this,
      members,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::TAO_ClientRequestInfo_IR_EnumDef_members_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_get::result (IR_EnumMemberSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set::TAO_ClientRequestInfo_IR_EnumDef_members_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_EnumMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    members_ (members)
{}

Dynamic::ParameterList *
IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_EnumDef::TAO_ClientRequestInfo_IR_EnumDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_EnumDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6e756d44), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EnumDef:1.0
  8, ACE_NTOHL (0x456e756d), ACE_NTOHL (0x44656600),  // name = IR_EnumDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_EnumDef (CORBA::tk_objref, sizeof (_oc_IR_EnumDef), (char *) &_oc_IR_EnumDef, 0, sizeof (IR_EnumDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EnumDef, &_tc_TAO_tc_IR_EnumDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_AliasDef_Proxy_Impl::_TAO_AliasDef_Proxy_Impl (void)
{}

_TAO_AliasDef_Remote_Proxy_Impl::_TAO_AliasDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_IDLType_ptr _TAO_AliasDef_Remote_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_original_type_def",
      22,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_AliasDef_Remote_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_original_type_def",
      22,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        original_type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << original_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_AliasDef_Proxy_Broker::_TAO_AliasDef_Proxy_Broker (void)
{
}

_TAO_AliasDef_Proxy_Broker::~_TAO_AliasDef_Proxy_Broker (void)
{
}

_TAO_AliasDef_Proxy_Broker * (*_TAO_AliasDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_AliasDef_Remote_Proxy_Broker *
_TAO_AliasDef_Remote_Proxy_Broker::the_TAO_AliasDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_AliasDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_AliasDef_Remote_Proxy_Broker::_TAO_AliasDef_Remote_Proxy_Broker (void)
{
}

_TAO_AliasDef_Remote_Proxy_Broker::~_TAO_AliasDef_Remote_Proxy_Broker (void)
{
}

_TAO_AliasDef_Proxy_Impl&
_TAO_AliasDef_Remote_Proxy_Broker::select_proxy (
  ::IR_AliasDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_AliasDef::IR_AliasDef (int collocated)
{
  this->IR_AliasDef_setup_collocation (collocated);
}

// destructor
IR_AliasDef::~IR_AliasDef (void)
{}

void
IR_AliasDef::IR_AliasDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_AliasDef_Proxy_Broker_ =
      _TAO_AliasDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_AliasDef_Proxy_Broker_ =
      _TAO_AliasDef_Remote_Proxy_Broker::the_TAO_AliasDef_Remote_Proxy_Broker ();
  
  this->IR_TypedefDef_setup_collocation (collocated);
  
}

void IR_AliasDef::_tao_any_destructor (void *x)
{
  IR_AliasDef *tmp = ACE_static_cast (IR_AliasDef*,x);
  CORBA::release (tmp);
}

IR_AliasDef_ptr IR_AliasDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_AliasDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/AliasDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_AliasDef::_nil ());
      if (is_a == 0)
        return IR_AliasDef::_nil ();
    }
  return IR_AliasDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_AliasDef_ptr IR_AliasDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_AliasDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_AliasDef_ptr default_proxy = IR_AliasDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_AliasDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_AliasDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_AliasDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_AliasDef (stub, 0, obj->_servant ()), IR_AliasDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_AliasDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_AliasDef::_narrow
                    )
                )
          );
}

IR_AliasDef_ptr
IR_AliasDef::_duplicate (IR_AliasDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_AliasDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AliasDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_AliasDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_AliasDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_TypedefDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_AliasDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AliasDef:1.0";
}

IR_IDLType_ptr IR_AliasDef::original_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_AliasDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_AliasDef::original_type_def (
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->the_TAO_AliasDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
      this,
      original_type_def,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
  
  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_AliasDef::TAO_ClientRequestInfo_IR_AliasDef_original_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_AliasDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x6c696173), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AliasDef:1.0
  9, ACE_NTOHL (0x416c6961), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_AliasDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_AliasDef (CORBA::tk_objref, sizeof (_oc_IR_AliasDef), (char *) &_oc_IR_AliasDef, 0, sizeof (IR_AliasDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AliasDef, &_tc_TAO_tc_IR_AliasDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_NativeDef_Proxy_Impl::_TAO_NativeDef_Proxy_Impl (void)
{}

_TAO_NativeDef_Remote_Proxy_Impl::_TAO_NativeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_NativeDef_Proxy_Broker::_TAO_NativeDef_Proxy_Broker (void)
{
}

_TAO_NativeDef_Proxy_Broker::~_TAO_NativeDef_Proxy_Broker (void)
{
}

_TAO_NativeDef_Proxy_Broker * (*_TAO_NativeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_NativeDef_Remote_Proxy_Broker *
_TAO_NativeDef_Remote_Proxy_Broker::the_TAO_NativeDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_NativeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_NativeDef_Remote_Proxy_Broker::_TAO_NativeDef_Remote_Proxy_Broker (void)
{
}

_TAO_NativeDef_Remote_Proxy_Broker::~_TAO_NativeDef_Remote_Proxy_Broker (void)
{
}

_TAO_NativeDef_Proxy_Impl&
_TAO_NativeDef_Remote_Proxy_Broker::select_proxy (
  ::IR_NativeDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_NativeDef::IR_NativeDef (int collocated)
{
  this->IR_NativeDef_setup_collocation (collocated);
}

// destructor
IR_NativeDef::~IR_NativeDef (void)
{}

void
IR_NativeDef::IR_NativeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_NativeDef_Proxy_Broker_ =
      _TAO_NativeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_NativeDef_Proxy_Broker_ =
      _TAO_NativeDef_Remote_Proxy_Broker::the_TAO_NativeDef_Remote_Proxy_Broker ();
  
  this->IR_TypedefDef_setup_collocation (collocated);
}
  
void IR_NativeDef::_tao_any_destructor (void *x)
{
  IR_NativeDef *tmp = ACE_static_cast (IR_NativeDef*,x);
  CORBA::release (tmp);
}

IR_NativeDef_ptr IR_NativeDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_NativeDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/NativeDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_NativeDef::_nil ());
      if (is_a == 0)
        return IR_NativeDef::_nil ();
    }
  return IR_NativeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_NativeDef_ptr IR_NativeDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_NativeDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_NativeDef_ptr default_proxy = IR_NativeDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_NativeDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_NativeDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_NativeDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_NativeDef (stub, 0, obj->_servant ()), IR_NativeDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_NativeDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_NativeDef::_narrow
                    )
                )
          );
}

IR_NativeDef_ptr
IR_NativeDef::_duplicate (IR_NativeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_NativeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/NativeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_NativeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_NativeDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_TypedefDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_NativeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/NativeDef:1.0";
}

static const CORBA::Long _oc_IR_NativeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4e), ACE_NTOHL (0x61746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/NativeDef:1.0
  10, ACE_NTOHL (0x4e617469), ACE_NTOHL (0x76654465), ACE_NTOHL (0x66000000),  // name = IR_NativeDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_NativeDef (CORBA::tk_objref, sizeof (_oc_IR_NativeDef), (char *) &_oc_IR_NativeDef, 0, sizeof (IR_NativeDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_NativeDef, &_tc_TAO_tc_IR_NativeDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_PrimitiveDef_Proxy_Impl::_TAO_PrimitiveDef_Proxy_Impl (void)
{}

_TAO_PrimitiveDef_Remote_Proxy_Impl::_TAO_PrimitiveDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_PrimitiveKind _TAO_PrimitiveDef_Remote_Proxy_Impl::kind (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  IR_PrimitiveKind _tao_retval = (IR_PrimitiveKind)0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_kind",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_PrimitiveKind  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_PrimitiveDef_Proxy_Broker::_TAO_PrimitiveDef_Proxy_Broker (void)
{
}

_TAO_PrimitiveDef_Proxy_Broker::~_TAO_PrimitiveDef_Proxy_Broker (void)
{
}

_TAO_PrimitiveDef_Proxy_Broker * (*_TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_PrimitiveDef_Remote_Proxy_Broker *
_TAO_PrimitiveDef_Remote_Proxy_Broker::the_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_PrimitiveDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_PrimitiveDef_Remote_Proxy_Broker::_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
{
}

_TAO_PrimitiveDef_Remote_Proxy_Broker::~_TAO_PrimitiveDef_Remote_Proxy_Broker (void)
{
}

_TAO_PrimitiveDef_Proxy_Impl&
_TAO_PrimitiveDef_Remote_Proxy_Broker::select_proxy (
  ::IR_PrimitiveDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_PrimitiveDef::IR_PrimitiveDef (int collocated)
{
  this->IR_PrimitiveDef_setup_collocation (collocated);
}

// destructor
IR_PrimitiveDef::~IR_PrimitiveDef (void)
{}

void
IR_PrimitiveDef::IR_PrimitiveDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PrimitiveDef_Proxy_Broker_ =
      _TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PrimitiveDef_Proxy_Broker_ =
      _TAO_PrimitiveDef_Remote_Proxy_Broker::the_TAO_PrimitiveDef_Remote_Proxy_Broker ();
  
  this->IR_IDLType_setup_collocation (collocated);
  
}

void IR_PrimitiveDef::_tao_any_destructor (void *x)
{
  IR_PrimitiveDef *tmp = ACE_static_cast (IR_PrimitiveDef*,x);
  CORBA::release (tmp);
}

IR_PrimitiveDef_ptr IR_PrimitiveDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_PrimitiveDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimitiveDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_PrimitiveDef::_nil ());
      if (is_a == 0)
        return IR_PrimitiveDef::_nil ();
    }
  return IR_PrimitiveDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_PrimitiveDef_ptr IR_PrimitiveDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_PrimitiveDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_PrimitiveDef_ptr default_proxy = IR_PrimitiveDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_PrimitiveDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_PrimitiveDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_PrimitiveDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_PrimitiveDef (stub, 0, obj->_servant ()), IR_PrimitiveDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_PrimitiveDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_PrimitiveDef::_narrow
                    )
                )
          );
}

IR_PrimitiveDef_ptr
IR_PrimitiveDef::_duplicate (IR_PrimitiveDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_PrimitiveDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimitiveDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_PrimitiveDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_PrimitiveDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_PrimitiveDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimitiveDef:1.0";
}

IR_PrimitiveKind IR_PrimitiveDef::kind (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_PrimitiveDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).kind (
      this,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_PrimitiveDef::TAO_ClientRequestInfo_IR_PrimitiveDef_kind_get::result (IR_PrimitiveKind result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_PrimitiveDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d69), ACE_NTOHL (0x74697665), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PrimitiveDef:1.0
  13, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x69746976), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_PrimitiveDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_PrimitiveDef (CORBA::tk_objref, sizeof (_oc_IR_PrimitiveDef), (char *) &_oc_IR_PrimitiveDef, 0, sizeof (IR_PrimitiveDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimitiveDef, &_tc_TAO_tc_IR_PrimitiveDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_StringDef_Proxy_Impl::_TAO_StringDef_Proxy_Impl (void)
{}

_TAO_StringDef_Remote_Proxy_Impl::_TAO_StringDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::ULong _TAO_StringDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::ULong  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_StringDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set ri (
        &_tao_call,
        _collocated_tao_target_,
        bound,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_StringDef_Proxy_Broker::_TAO_StringDef_Proxy_Broker (void)
{
}

_TAO_StringDef_Proxy_Broker::~_TAO_StringDef_Proxy_Broker (void)
{
}

_TAO_StringDef_Proxy_Broker * (*_TAO_StringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_StringDef_Remote_Proxy_Broker *
_TAO_StringDef_Remote_Proxy_Broker::the_TAO_StringDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_StringDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_StringDef_Remote_Proxy_Broker::_TAO_StringDef_Remote_Proxy_Broker (void)
{
}

_TAO_StringDef_Remote_Proxy_Broker::~_TAO_StringDef_Remote_Proxy_Broker (void)
{
}

_TAO_StringDef_Proxy_Impl&
_TAO_StringDef_Remote_Proxy_Broker::select_proxy (
  ::IR_StringDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_StringDef::IR_StringDef (int collocated)
{
  this->IR_StringDef_setup_collocation (collocated);
}

// destructor
IR_StringDef::~IR_StringDef (void)
{}

void
IR_StringDef::IR_StringDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_StringDef_Proxy_Broker_ =
      _TAO_StringDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_StringDef_Proxy_Broker_ =
      _TAO_StringDef_Remote_Proxy_Broker::the_TAO_StringDef_Remote_Proxy_Broker ();
  
  this->IR_IDLType_setup_collocation (collocated);
}

void IR_StringDef::_tao_any_destructor (void *x)
{
  IR_StringDef *tmp = ACE_static_cast (IR_StringDef*,x);
  CORBA::release (tmp);
}

IR_StringDef_ptr IR_StringDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_StringDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/StringDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_StringDef::_nil ());
      if (is_a == 0)
        return IR_StringDef::_nil ();
    }
  return IR_StringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_StringDef_ptr IR_StringDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_StringDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_StringDef_ptr default_proxy = IR_StringDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_StringDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_StringDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_StringDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_StringDef (stub, 0, obj->_servant ()), IR_StringDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_StringDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_StringDef::_narrow
                    )
                )
          );
}

IR_StringDef_ptr
IR_StringDef::_duplicate (IR_StringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_StringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/StringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_StringDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_StringDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_StringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/StringDef:1.0";
}

CORBA::ULong IR_StringDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  return this->the_TAO_StringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
      this,
      ACE_TRY_ENV
    );
}

void IR_StringDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  this->the_TAO_StringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
      this,
      bound,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::TAO_ClientRequestInfo_IR_StringDef_bound_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_get::result (CORBA::ULong result)
{
  // update the result 
  this->_result = result;
}

IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set::TAO_ClientRequestInfo_IR_StringDef_bound_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_StringDef::TAO_ClientRequestInfo_IR_StringDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_StringDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x7472696e), ACE_NTOHL (0x67446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/StringDef:1.0
  10, ACE_NTOHL (0x53747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x66000000),  // name = IR_StringDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_StringDef (CORBA::tk_objref, sizeof (_oc_IR_StringDef), (char *) &_oc_IR_StringDef, 0, sizeof (IR_StringDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_StringDef, &_tc_TAO_tc_IR_StringDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_WstringDef_Proxy_Impl::_TAO_WstringDef_Proxy_Impl (void)
{}

_TAO_WstringDef_Remote_Proxy_Impl::_TAO_WstringDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::ULong _TAO_WstringDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  CORBA::ULong _tao_retval = 0;
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::ULong  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_WstringDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set ri (
        &_tao_call,
        _collocated_tao_target_,
        bound,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_WstringDef_Proxy_Broker::_TAO_WstringDef_Proxy_Broker (void)
{
}

_TAO_WstringDef_Proxy_Broker::~_TAO_WstringDef_Proxy_Broker (void)
{
}

_TAO_WstringDef_Proxy_Broker * (*_TAO_WstringDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_WstringDef_Remote_Proxy_Broker *
_TAO_WstringDef_Remote_Proxy_Broker::the_TAO_WstringDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_WstringDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_WstringDef_Remote_Proxy_Broker::_TAO_WstringDef_Remote_Proxy_Broker (void)
{
}

_TAO_WstringDef_Remote_Proxy_Broker::~_TAO_WstringDef_Remote_Proxy_Broker (void)
{
}

_TAO_WstringDef_Proxy_Impl&
_TAO_WstringDef_Remote_Proxy_Broker::select_proxy (
  ::IR_WstringDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_WstringDef::IR_WstringDef (int collocated)
{
  this->IR_WstringDef_setup_collocation (collocated);
}

// destructor
IR_WstringDef::~IR_WstringDef (void)
{}

void
IR_WstringDef::IR_WstringDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_WstringDef_Proxy_Broker_ =
      _TAO_WstringDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_WstringDef_Proxy_Broker_ =
      _TAO_WstringDef_Remote_Proxy_Broker::the_TAO_WstringDef_Remote_Proxy_Broker ();
  
  this->IR_IDLType_setup_collocation (collocated);
  
}

void IR_WstringDef::_tao_any_destructor (void *x)
{
  IR_WstringDef *tmp = ACE_static_cast (IR_WstringDef*,x);
  CORBA::release (tmp);
}

IR_WstringDef_ptr IR_WstringDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_WstringDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/WstringDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_WstringDef::_nil ());
      if (is_a == 0)
        return IR_WstringDef::_nil ();
    }
  return IR_WstringDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_WstringDef_ptr IR_WstringDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_WstringDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_WstringDef_ptr default_proxy = IR_WstringDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_WstringDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_WstringDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_WstringDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_WstringDef (stub, 0, obj->_servant ()), IR_WstringDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_WstringDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_WstringDef::_narrow
                    )
                )
          );
}

IR_WstringDef_ptr
IR_WstringDef::_duplicate (IR_WstringDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_WstringDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/WstringDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_WstringDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_WstringDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_WstringDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/WstringDef:1.0";
}

CORBA::ULong IR_WstringDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_WstringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
      this,
      ACE_TRY_ENV
    );
}

void IR_WstringDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_WstringDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
      this,
      bound,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::TAO_ClientRequestInfo_IR_WstringDef_bound_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_get::result (CORBA::ULong result)
{
  // update the result 
  this->_result = result;
}

IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set::TAO_ClientRequestInfo_IR_WstringDef_bound_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_WstringDef::TAO_ClientRequestInfo_IR_WstringDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_WstringDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f57), ACE_NTOHL (0x73747269), ACE_NTOHL (0x6e674465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/WstringDef:1.0
  11, ACE_NTOHL (0x57737472), ACE_NTOHL (0x696e6744), ACE_NTOHL (0x65660000),  // name = IR_WstringDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_WstringDef (CORBA::tk_objref, sizeof (_oc_IR_WstringDef), (char *) &_oc_IR_WstringDef, 0, sizeof (IR_WstringDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_WstringDef, &_tc_TAO_tc_IR_WstringDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_FixedDef_Proxy_Impl::_TAO_FixedDef_Proxy_Impl (void)
{}

_TAO_FixedDef_Remote_Proxy_Impl::_TAO_FixedDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::UShort _TAO_FixedDef_Remote_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::UShort _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_digits",
      11,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::UShort  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_FixedDef_Remote_Proxy_Impl::digits (
    CORBA_Object *_collocated_tao_target_,
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_digits",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set ri (
        &_tao_call,
        _collocated_tao_target_,
        digits,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << digits)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Short _TAO_FixedDef_Remote_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Short _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_scale",
      10,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Short  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_FixedDef_Remote_Proxy_Impl::scale (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_scale",
      10,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set ri (
        &_tao_call,
        _collocated_tao_target_,
        scale,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << scale)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_FixedDef_Proxy_Broker::_TAO_FixedDef_Proxy_Broker (void)
{
}

_TAO_FixedDef_Proxy_Broker::~_TAO_FixedDef_Proxy_Broker (void)
{
}

_TAO_FixedDef_Proxy_Broker * (*_TAO_FixedDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_FixedDef_Remote_Proxy_Broker *
_TAO_FixedDef_Remote_Proxy_Broker::the_TAO_FixedDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_FixedDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_FixedDef_Remote_Proxy_Broker::_TAO_FixedDef_Remote_Proxy_Broker (void)
{
}

_TAO_FixedDef_Remote_Proxy_Broker::~_TAO_FixedDef_Remote_Proxy_Broker (void)
{
}

_TAO_FixedDef_Proxy_Impl&
_TAO_FixedDef_Remote_Proxy_Broker::select_proxy (
  ::IR_FixedDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_FixedDef::IR_FixedDef (int collocated)
{
  this->IR_FixedDef_setup_collocation (collocated);
}

// destructor
IR_FixedDef::~IR_FixedDef (void)
{}

void
IR_FixedDef::IR_FixedDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FixedDef_Proxy_Broker_ =
      _TAO_FixedDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FixedDef_Proxy_Broker_ =
      _TAO_FixedDef_Remote_Proxy_Broker::the_TAO_FixedDef_Remote_Proxy_Broker ();
  
  this->IR_IDLType_setup_collocation (collocated);
  
}

void IR_FixedDef::_tao_any_destructor (void *x)
{
  IR_FixedDef *tmp = ACE_static_cast (IR_FixedDef*,x);
  CORBA::release (tmp);
}

IR_FixedDef_ptr IR_FixedDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_FixedDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FixedDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_FixedDef::_nil ());
      if (is_a == 0)
        return IR_FixedDef::_nil ();
    }
  return IR_FixedDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_FixedDef_ptr IR_FixedDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_FixedDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_FixedDef_ptr default_proxy = IR_FixedDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_FixedDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_FixedDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_FixedDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_FixedDef (stub, 0, obj->_servant ()), IR_FixedDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_FixedDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_FixedDef::_narrow
                    )
                )
          );
}

IR_FixedDef_ptr
IR_FixedDef::_duplicate (IR_FixedDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_FixedDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FixedDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_FixedDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_FixedDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_FixedDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FixedDef:1.0";
}

CORBA::UShort IR_FixedDef::digits (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).digits (
      this,
      ACE_TRY_ENV
    );
}

void IR_FixedDef::digits (
    CORBA::UShort digits,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).digits (
      this,
      digits,
      ACE_TRY_ENV
    );
}

CORBA::Short IR_FixedDef::scale (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).scale (
      this,
      ACE_TRY_ENV
    );
}

void IR_FixedDef::scale (
    CORBA::Short scale,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_FixedDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).scale (
      this,
      scale,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::TAO_ClientRequestInfo_IR_FixedDef_digits_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_get::result (CORBA::UShort result)
{
  // update the result 
  this->_result = result;
}

IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set::TAO_ClientRequestInfo_IR_FixedDef_digits_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::UShort & digits,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    digits_ (digits)
{}

Dynamic::ParameterList *
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_digits = parameter_list->length ();
  parameter_list->length (length_digits + 1);
  (*parameter_list)[length_digits].argument <<= digits_;
  (*parameter_list)[length_digits].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_digits_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::TAO_ClientRequestInfo_IR_FixedDef_scale_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_get::result (CORBA::Short result)
{
  // update the result 
  this->_result = result;
}

IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set::TAO_ClientRequestInfo_IR_FixedDef_scale_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Short & scale,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    scale_ (scale)
{}

Dynamic::ParameterList *
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_scale = parameter_list->length ();
  parameter_list->length (length_scale + 1);
  (*parameter_list)[length_scale].argument <<= scale_;
  (*parameter_list)[length_scale].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_FixedDef::TAO_ClientRequestInfo_IR_FixedDef_scale_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_FixedDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x69786564), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FixedDef:1.0
  9, ACE_NTOHL (0x46697865), ACE_NTOHL (0x64446566), ACE_NTOHL (0x0),  // name = IR_FixedDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_FixedDef (CORBA::tk_objref, sizeof (_oc_IR_FixedDef), (char *) &_oc_IR_FixedDef, 0, sizeof (IR_FixedDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FixedDef, &_tc_TAO_tc_IR_FixedDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_SequenceDef_Proxy_Impl::_TAO_SequenceDef_Proxy_Impl (void)
{}

_TAO_SequenceDef_Remote_Proxy_Impl::_TAO_SequenceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::ULong _TAO_SequenceDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_bound",
      10,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::ULong  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_SequenceDef_Remote_Proxy_Impl::bound (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_bound",
      10,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set ri (
        &_tao_call,
        _collocated_tao_target_,
        bound,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << bound)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::TypeCode_ptr _TAO_SequenceDef_Remote_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type",
      17,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_IDLType_ptr _TAO_SequenceDef_Remote_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type_def",
      21,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_SequenceDef_Remote_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_element_type_def",
      21,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        element_type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << element_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_SequenceDef_Proxy_Broker::_TAO_SequenceDef_Proxy_Broker (void)
{
}

_TAO_SequenceDef_Proxy_Broker::~_TAO_SequenceDef_Proxy_Broker (void)
{
}

_TAO_SequenceDef_Proxy_Broker * (*_TAO_SequenceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_SequenceDef_Remote_Proxy_Broker *
_TAO_SequenceDef_Remote_Proxy_Broker::the_TAO_SequenceDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_SequenceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_SequenceDef_Remote_Proxy_Broker::_TAO_SequenceDef_Remote_Proxy_Broker (void)
{
}

_TAO_SequenceDef_Remote_Proxy_Broker::~_TAO_SequenceDef_Remote_Proxy_Broker (void)
{
}

_TAO_SequenceDef_Proxy_Impl&
_TAO_SequenceDef_Remote_Proxy_Broker::select_proxy (
  ::IR_SequenceDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_SequenceDef::IR_SequenceDef (int collocated)
{
  this->IR_SequenceDef_setup_collocation (collocated);
}

// destructor
IR_SequenceDef::~IR_SequenceDef (void)
{}

void
IR_SequenceDef::IR_SequenceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_SequenceDef_Proxy_Broker_ =
      _TAO_SequenceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_SequenceDef_Proxy_Broker_ =
      _TAO_SequenceDef_Remote_Proxy_Broker::the_TAO_SequenceDef_Remote_Proxy_Broker ();
  
  this->IR_IDLType_setup_collocation (collocated);
}

void IR_SequenceDef::_tao_any_destructor (void *x)
{
  IR_SequenceDef *tmp = ACE_static_cast (IR_SequenceDef*,x);
  CORBA::release (tmp);
}

IR_SequenceDef_ptr IR_SequenceDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_SequenceDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/SequenceDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_SequenceDef::_nil ());
      if (is_a == 0)
        return IR_SequenceDef::_nil ();
    }
  return IR_SequenceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_SequenceDef_ptr IR_SequenceDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_SequenceDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_SequenceDef_ptr default_proxy = IR_SequenceDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_SequenceDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_SequenceDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_SequenceDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_SequenceDef (stub, 0, obj->_servant ()), IR_SequenceDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_SequenceDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_SequenceDef::_narrow
                    )
                )
          );
}

IR_SequenceDef_ptr
IR_SequenceDef::_duplicate (IR_SequenceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_SequenceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/SequenceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_SequenceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_SequenceDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_SequenceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/SequenceDef:1.0";
}

CORBA::ULong IR_SequenceDef::bound (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
      this,
      ACE_TRY_ENV
    );
}

void IR_SequenceDef::bound (
    CORBA::ULong bound,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).bound (
      this,
      bound,
      ACE_TRY_ENV
    );
}

CORBA::TypeCode_ptr IR_SequenceDef::element_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type (
      this,
      ACE_TRY_ENV
    );
}

IR_IDLType_ptr IR_SequenceDef::element_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_SequenceDef::element_type_def (
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_SequenceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
      this,
      element_type_def,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::TAO_ClientRequestInfo_IR_SequenceDef_bound_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_get::result (CORBA::ULong result)
{
  // update the result 
  this->_result = result;
}

IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set::TAO_ClientRequestInfo_IR_SequenceDef_bound_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & bound,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    bound_ (bound)
{}

Dynamic::ParameterList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_bound = parameter_list->length ();
  parameter_list->length (length_bound + 1);
  (*parameter_list)[length_bound].argument <<= bound_;
  (*parameter_list)[length_bound].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_bound_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_element_type_def = parameter_list->length ();
  parameter_list->length (length_element_type_def + 1);
  (*parameter_list)[length_element_type_def].argument <<=  this->element_type_def_;
  
  (*parameter_list)[length_element_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_SequenceDef::TAO_ClientRequestInfo_IR_SequenceDef_element_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_SequenceDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x65717565), ACE_NTOHL (0x6e636544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/SequenceDef:1.0
  12, ACE_NTOHL (0x53657175), ACE_NTOHL (0x656e6365), ACE_NTOHL (0x44656600),  // name = IR_SequenceDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_SequenceDef (CORBA::tk_objref, sizeof (_oc_IR_SequenceDef), (char *) &_oc_IR_SequenceDef, 0, sizeof (IR_SequenceDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_SequenceDef, &_tc_TAO_tc_IR_SequenceDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ArrayDef_Proxy_Impl::_TAO_ArrayDef_Proxy_Impl (void)
{}

_TAO_ArrayDef_Remote_Proxy_Impl::_TAO_ArrayDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::ULong _TAO_ArrayDef_Remote_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::ULong _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_length",
      11,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::ULong  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_ArrayDef_Remote_Proxy_Impl::length (
    CORBA_Object *_collocated_tao_target_,
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_length",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set ri (
        &_tao_call,
        _collocated_tao_target_,
        length,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << length)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::TypeCode_ptr _TAO_ArrayDef_Remote_Proxy_Impl::element_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type",
      17,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_IDLType_ptr _TAO_ArrayDef_Remote_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_element_type_def",
      21,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ArrayDef_Remote_Proxy_Impl::element_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_element_type_def",
      21,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        element_type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << element_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ArrayDef_Proxy_Broker::_TAO_ArrayDef_Proxy_Broker (void)
{
}

_TAO_ArrayDef_Proxy_Broker::~_TAO_ArrayDef_Proxy_Broker (void)
{
}

_TAO_ArrayDef_Proxy_Broker * (*_TAO_ArrayDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ArrayDef_Remote_Proxy_Broker *
_TAO_ArrayDef_Remote_Proxy_Broker::the_TAO_ArrayDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ArrayDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ArrayDef_Remote_Proxy_Broker::_TAO_ArrayDef_Remote_Proxy_Broker (void)
{
}

_TAO_ArrayDef_Remote_Proxy_Broker::~_TAO_ArrayDef_Remote_Proxy_Broker (void)
{
}

_TAO_ArrayDef_Proxy_Impl&
_TAO_ArrayDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ArrayDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ArrayDef::IR_ArrayDef (int collocated)
{
  this->IR_ArrayDef_setup_collocation (collocated);
}

// destructor
IR_ArrayDef::~IR_ArrayDef (void)
{}

void
IR_ArrayDef::IR_ArrayDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ArrayDef_Proxy_Broker_ =
      _TAO_ArrayDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ArrayDef_Proxy_Broker_ =
      _TAO_ArrayDef_Remote_Proxy_Broker::the_TAO_ArrayDef_Remote_Proxy_Broker ();
  
  this->IR_IDLType_setup_collocation (collocated);
}

void IR_ArrayDef::_tao_any_destructor (void *x)
{
  IR_ArrayDef *tmp = ACE_static_cast (IR_ArrayDef*,x);
  CORBA::release (tmp);
}

IR_ArrayDef_ptr IR_ArrayDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ArrayDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ArrayDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ArrayDef::_nil ());
      if (is_a == 0)
        return IR_ArrayDef::_nil ();
    }
  return IR_ArrayDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ArrayDef_ptr IR_ArrayDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ArrayDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ArrayDef_ptr default_proxy = IR_ArrayDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ArrayDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ArrayDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ArrayDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ArrayDef (stub, 0, obj->_servant ()), IR_ArrayDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ArrayDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ArrayDef::_narrow
                    )
                )
          );
}

IR_ArrayDef_ptr
IR_ArrayDef::_duplicate (IR_ArrayDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ArrayDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ArrayDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ArrayDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ArrayDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ArrayDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ArrayDef:1.0";
}

CORBA::ULong IR_ArrayDef::length (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).length (
      this,
      ACE_TRY_ENV
    );
}

void IR_ArrayDef::length (
    CORBA::ULong length,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).length (
      this,
      length,
      ACE_TRY_ENV
    );
}

CORBA::TypeCode_ptr IR_ArrayDef::element_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type (
      this,
      ACE_TRY_ENV
    );
}

IR_IDLType_ptr IR_ArrayDef::element_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_ArrayDef::element_type_def (
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ArrayDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).element_type_def (
      this,
      element_type_def,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::TAO_ClientRequestInfo_IR_ArrayDef_length_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_get::result (CORBA::ULong result)
{
  // update the result 
  this->_result = result;
}

IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set::TAO_ClientRequestInfo_IR_ArrayDef_length_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::ULong & length,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    length_ (length)
{}

Dynamic::ParameterList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_length = parameter_list->length ();
  parameter_list->length (length_length + 1);
  (*parameter_list)[length_length].argument <<= length_;
  (*parameter_list)[length_length].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_length_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr element_type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    element_type_def_ (element_type_def)
{}

Dynamic::ParameterList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_element_type_def = parameter_list->length ();
  parameter_list->length (length_element_type_def + 1);
  (*parameter_list)[length_element_type_def].argument <<=  this->element_type_def_;
  
  (*parameter_list)[length_element_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ArrayDef::TAO_ClientRequestInfo_IR_ArrayDef_element_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ArrayDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x72726179), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ArrayDef:1.0
  9, ACE_NTOHL (0x41727261), ACE_NTOHL (0x79446566), ACE_NTOHL (0x0),  // name = IR_ArrayDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ArrayDef (CORBA::tk_objref, sizeof (_oc_IR_ArrayDef), (char *) &_oc_IR_ArrayDef, 0, sizeof (IR_ArrayDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ArrayDef, &_tc_TAO_tc_IR_ArrayDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ExceptionDef_Proxy_Impl::_TAO_ExceptionDef_Proxy_Impl (void)
{}

_TAO_ExceptionDef_Remote_Proxy_Impl::_TAO_ExceptionDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_ExceptionDef_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_StructMemberSeq * _TAO_ExceptionDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_StructMemberSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_StructMemberSeq, _tao_retval);
  IR_StructMemberSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_members",
      12,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_StructMemberSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ExceptionDef_Remote_Proxy_Impl::members (
    CORBA_Object *_collocated_tao_target_,
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_members",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set ri (
        &_tao_call,
        _collocated_tao_target_,
        members,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << members)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ExceptionDef_Proxy_Broker::_TAO_ExceptionDef_Proxy_Broker (void)
{
}

_TAO_ExceptionDef_Proxy_Broker::~_TAO_ExceptionDef_Proxy_Broker (void)
{
}

_TAO_ExceptionDef_Proxy_Broker * (*_TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ExceptionDef_Remote_Proxy_Broker *
_TAO_ExceptionDef_Remote_Proxy_Broker::the_TAO_ExceptionDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ExceptionDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ExceptionDef_Remote_Proxy_Broker::_TAO_ExceptionDef_Remote_Proxy_Broker (void)
{
}

_TAO_ExceptionDef_Remote_Proxy_Broker::~_TAO_ExceptionDef_Remote_Proxy_Broker (void)
{
}

_TAO_ExceptionDef_Proxy_Impl&
_TAO_ExceptionDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ExceptionDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ExceptionDef::IR_ExceptionDef (int collocated)
{
  this->IR_ExceptionDef_setup_collocation (collocated);
}

// destructor
IR_ExceptionDef::~IR_ExceptionDef (void)
{}

void
IR_ExceptionDef::IR_ExceptionDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ExceptionDef_Proxy_Broker_ =
      _TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ExceptionDef_Proxy_Broker_ =
      _TAO_ExceptionDef_Remote_Proxy_Broker::the_TAO_ExceptionDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
  this->IR_Container_setup_collocation (collocated);
}

void IR_ExceptionDef::_tao_any_destructor (void *x)
{
  IR_ExceptionDef *tmp = ACE_static_cast (IR_ExceptionDef*,x);
  CORBA::release (tmp);
}

IR_ExceptionDef_ptr IR_ExceptionDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ExceptionDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ExceptionDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ExceptionDef::_nil ());
      if (is_a == 0)
        return IR_ExceptionDef::_nil ();
    }
  return IR_ExceptionDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ExceptionDef_ptr IR_ExceptionDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ExceptionDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ExceptionDef_ptr default_proxy = IR_ExceptionDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ExceptionDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ExceptionDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ExceptionDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ExceptionDef (stub, 0, obj->_servant ()), IR_ExceptionDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ExceptionDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ExceptionDef::_narrow
                    )
                )
          );
}

IR_ExceptionDef_ptr
IR_ExceptionDef::_duplicate (IR_ExceptionDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ExceptionDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ExceptionDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ExceptionDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ExceptionDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ExceptionDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ExceptionDef:1.0";
}

CORBA::TypeCode_ptr IR_ExceptionDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
      this,
      ACE_TRY_ENV
    );
}

IR_StructMemberSeq * IR_ExceptionDef::members (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
      this,
      ACE_TRY_ENV
    );
}

void IR_ExceptionDef::members (
    const IR_StructMemberSeq & members,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ExceptionDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).members (
      this,
      members,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::TAO_ClientRequestInfo_IR_ExceptionDef_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::TAO_ClientRequestInfo_IR_ExceptionDef_members_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_get::result (IR_StructMemberSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set::TAO_ClientRequestInfo_IR_ExceptionDef_members_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_StructMemberSeq & members,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    members_ (members)
{}

Dynamic::ParameterList *
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_members = parameter_list->length ();
  parameter_list->length (length_members + 1);
  (*parameter_list)[length_members].argument <<=  this->members_;
  
  (*parameter_list)[length_members].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ExceptionDef::TAO_ClientRequestInfo_IR_ExceptionDef_members_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ExceptionDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDef:1.0
  13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = IR_ExceptionDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDef (CORBA::tk_objref, sizeof (_oc_IR_ExceptionDef), (char *) &_oc_IR_ExceptionDef, 0, sizeof (IR_ExceptionDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDef, &_tc_TAO_tc_IR_ExceptionDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ExceptionDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
  21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDescription (CORBA::tk_struct, sizeof (_oc_IR_ExceptionDescription), (char *) &_oc_IR_ExceptionDescription, 0, sizeof (IR_ExceptionDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDescription, &_tc_TAO_tc_IR_ExceptionDescription)
TAO_NAMESPACE_END

void IR_ExceptionDescription::_tao_any_destructor (void *x)
{
  IR_ExceptionDescription *tmp = ACE_static_cast (IR_ExceptionDescription*,x);
  delete tmp;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  // The Base_Sequence functions, please see tao/Sequence.h
  void
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ExceptionDef **tmp = 0;
    tmp = _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ExceptionDef **old = ACE_reinterpret_cast (IR_ExceptionDef**, this->buffer_);
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        if (!this->release_)
          tmp[i] = IR_ExceptionDef::_duplicate (old[i]);
        else
          tmp[i] = old[i];
        
      if (this->release_)
        delete[] old;
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    IR_ExceptionDef **tmp = ACE_reinterpret_cast (IR_ExceptionDef**, this->buffer_);
    for (CORBA::ULong i = 0; i < this->length_; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ExceptionDef::_nil ();
    }
    _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::freebuf (tmp);
    this->buffer_ = 0;
  }
  
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::~_TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq (void)
  {
    this->_deallocate_buffer ();
  }
  
  void
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_shrink_buffer (CORBA::ULong nl, CORBA::ULong ol)
  {
    IR_ExceptionDef **tmp = ACE_reinterpret_cast (IR_ExceptionDef**, this->buffer_);
    
    for (CORBA::ULong i = nl; i < ol; ++i)
    {
      CORBA::release (tmp[i]);
      tmp[i] = IR_ExceptionDef::_nil ();
    }
  }
  void 
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_downcast (
      void* target,
      CORBA_Object *src,
      CORBA_Environment &ACE_TRY_ENV
    )
  {
    IR_ExceptionDef **tmp = ACE_static_cast (IR_ExceptionDef**, target);
    *tmp = IR_ExceptionDef::_narrow (src, ACE_TRY_ENV);
  }

  CORBA_Object*
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq::_upcast (void *src) const
  {
    IR_ExceptionDef **tmp = ACE_static_cast (IR_ExceptionDef**, src);
    return *tmp;
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ExceptionDefSeq
// *************************************************************

IR_ExceptionDefSeq::IR_ExceptionDefSeq (void)
{}
IR_ExceptionDefSeq::IR_ExceptionDefSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ExceptionDef,IR_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ExceptionDefSeq::IR_ExceptionDefSeq (CORBA::ULong max, CORBA::ULong length, IR_ExceptionDef_ptr *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ExceptionDef,IR_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ExceptionDefSeq::IR_ExceptionDefSeq (const IR_ExceptionDefSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Object_Sequence_IR_ExceptionDefSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Object_Sequence<IR_ExceptionDef,IR_ExceptionDef_var>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ExceptionDefSeq::~IR_ExceptionDefSeq (void) // dtor
{}
void IR_ExceptionDefSeq::_tao_any_destructor (void *x)
{
  IR_ExceptionDefSeq *tmp = ACE_static_cast (IR_ExceptionDefSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ExceptionDefSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ExceptionDefSeq:1.0
  16, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x53657100),  // name = ExceptionDefSeq
  CORBA::tk_sequence, // typecode kind
  76, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_objref, // typecode kind
    60, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDef:1.0
      13, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = IR_ExceptionDef

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ExceptionDefSeq (CORBA::tk_alias, sizeof (_oc_IR_ExceptionDefSeq), (char *) &_oc_IR_ExceptionDefSeq, 0, sizeof (IR_ExceptionDefSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExceptionDefSeq, &_tc_TAO_tc_IR_ExceptionDefSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ExceptionDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ExceptionDescription *old = ACE_reinterpret_cast (IR_ExceptionDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_ExceptionDescription *tmp = ACE_reinterpret_cast (IR_ExceptionDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq::~_TAO_Unbounded_Sequence_IR_ExcDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ExcDescriptionSeq
// *************************************************************

IR_ExcDescriptionSeq::IR_ExcDescriptionSeq (void)
{}
IR_ExcDescriptionSeq::IR_ExcDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ExcDescriptionSeq::IR_ExcDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_ExceptionDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ExcDescriptionSeq::IR_ExcDescriptionSeq (const IR_ExcDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ExcDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ExceptionDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ExcDescriptionSeq::~IR_ExcDescriptionSeq (void) // dtor
{}
void IR_ExcDescriptionSeq::_tao_any_destructor (void *x)
{
  IR_ExcDescriptionSeq *tmp = ACE_static_cast (IR_ExcDescriptionSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ExcDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
  18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  456, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    440, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
      21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
      5, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ExcDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_ExcDescriptionSeq), (char *) &_oc_IR_ExcDescriptionSeq, 0, sizeof (IR_ExcDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ExcDescriptionSeq, &_tc_TAO_tc_IR_ExcDescriptionSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_AttributeMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
  14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
  2, // member count
  12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
  14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY
};
static CORBA::TypeCode _tc_TAO_tc_IR_AttributeMode (CORBA::tk_enum, sizeof (_oc_IR_AttributeMode), (char *) &_oc_IR_AttributeMode, 0, sizeof (IR_AttributeMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeMode, &_tc_TAO_tc_IR_AttributeMode)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_AttributeDef_Proxy_Impl::_TAO_AttributeDef_Proxy_Impl (void)
{}

_TAO_AttributeDef_Remote_Proxy_Impl::_TAO_AttributeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_AttributeDef_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_IDLType_ptr _TAO_AttributeDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_AttributeDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_AttributeMode _TAO_AttributeDef_Remote_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_AttributeMode _tao_retval = (IR_AttributeMode)0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_mode",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_AttributeMode  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_AttributeDef_Remote_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    IR_AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_mode",
      9,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set ri (
        &_tao_call,
        _collocated_tao_target_,
        mode,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << mode)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_AttributeDef_Proxy_Broker::_TAO_AttributeDef_Proxy_Broker (void)
{
}

_TAO_AttributeDef_Proxy_Broker::~_TAO_AttributeDef_Proxy_Broker (void)
{
}

_TAO_AttributeDef_Proxy_Broker * (*_TAO_AttributeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_AttributeDef_Remote_Proxy_Broker *
_TAO_AttributeDef_Remote_Proxy_Broker::the_TAO_AttributeDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_AttributeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_AttributeDef_Remote_Proxy_Broker::_TAO_AttributeDef_Remote_Proxy_Broker (void)
{
}

_TAO_AttributeDef_Remote_Proxy_Broker::~_TAO_AttributeDef_Remote_Proxy_Broker (void)
{
}

_TAO_AttributeDef_Proxy_Impl&
_TAO_AttributeDef_Remote_Proxy_Broker::select_proxy (
  ::IR_AttributeDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_AttributeDef::IR_AttributeDef (int collocated)
{
  this->IR_AttributeDef_setup_collocation (collocated);
}

// destructor
IR_AttributeDef::~IR_AttributeDef (void)
{}

void
IR_AttributeDef::IR_AttributeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_AttributeDef_Proxy_Broker_ =
      _TAO_AttributeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_AttributeDef_Proxy_Broker_ =
      _TAO_AttributeDef_Remote_Proxy_Broker::the_TAO_AttributeDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
}

void IR_AttributeDef::_tao_any_destructor (void *x)
{
  IR_AttributeDef *tmp = ACE_static_cast (IR_AttributeDef*,x);
  CORBA::release (tmp);
}

IR_AttributeDef_ptr IR_AttributeDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_AttributeDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/AttributeDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_AttributeDef::_nil ());
      if (is_a == 0)
        return IR_AttributeDef::_nil ();
    }
  return IR_AttributeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_AttributeDef_ptr IR_AttributeDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_AttributeDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_AttributeDef_ptr default_proxy = IR_AttributeDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_AttributeDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_AttributeDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_AttributeDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_AttributeDef (stub, 0, obj->_servant ()), IR_AttributeDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_AttributeDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_AttributeDef::_narrow
                    )
                )
          );
}

IR_AttributeDef_ptr
IR_AttributeDef::_duplicate (IR_AttributeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_AttributeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/AttributeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_AttributeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_AttributeDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_AttributeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/AttributeDef:1.0";
}

CORBA::TypeCode_ptr IR_AttributeDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
      this,
      ACE_TRY_ENV
    );
}

IR_IDLType_ptr IR_AttributeDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_AttributeDef::type_def (
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
      this,
      type_def,
      ACE_TRY_ENV
    );
}

IR_AttributeMode IR_AttributeDef::mode (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
      this,
      ACE_TRY_ENV
    );
}

void IR_AttributeDef::mode (
    IR_AttributeMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_AttributeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
      this,
      mode,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::TAO_ClientRequestInfo_IR_AttributeDef_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_type_def = parameter_list->length ();
  parameter_list->length (length_type_def + 1);
  (*parameter_list)[length_type_def].argument <<=  this->type_def_;
  
  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::TAO_ClientRequestInfo_IR_AttributeDef_mode_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_get::result (IR_AttributeMode result)
{
  // update the result 
  this->_result = result;
}

IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set::TAO_ClientRequestInfo_IR_AttributeDef_mode_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_AttributeMode & mode,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    mode_ (mode)
{}

Dynamic::ParameterList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;
  
  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_AttributeDef::TAO_ClientRequestInfo_IR_AttributeDef_mode_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_AttributeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDef:1.0
  13, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_AttributeDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_AttributeDef (CORBA::tk_objref, sizeof (_oc_IR_AttributeDef), (char *) &_oc_IR_AttributeDef, 0, sizeof (IR_AttributeDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDef, &_tc_TAO_tc_IR_AttributeDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_AttributeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
  21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
  8, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  104, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
    14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
    2, // member count
    12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
    14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

  15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
  CORBA::tk_alias, // typecode kind for typedefs
  536, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    456, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      440, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


      0U,


  15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
  CORBA::tk_alias, // typecode kind for typedefs
  536, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    456, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      440, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


      0U,


};
static CORBA::TypeCode _tc_TAO_tc_IR_AttributeDescription (CORBA::tk_struct, sizeof (_oc_IR_AttributeDescription), (char *) &_oc_IR_AttributeDescription, 0, sizeof (IR_AttributeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttributeDescription, &_tc_TAO_tc_IR_AttributeDescription)
TAO_NAMESPACE_END

void IR_AttributeDescription::_tao_any_destructor (void *x)
{
  IR_AttributeDescription *tmp = ACE_static_cast (IR_AttributeDescription*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_OperationMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
  14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
  2, // member count
  10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
  10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY
};
static CORBA::TypeCode _tc_TAO_tc_IR_OperationMode (CORBA::tk_enum, sizeof (_oc_IR_OperationMode), (char *) &_oc_IR_OperationMode, 0, sizeof (IR_OperationMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationMode, &_tc_TAO_tc_IR_OperationMode)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ParameterMode[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
  14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
  3, // member count
  9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
  10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
  12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT
};
static CORBA::TypeCode _tc_TAO_tc_IR_ParameterMode (CORBA::tk_enum, sizeof (_oc_IR_ParameterMode), (char *) &_oc_IR_ParameterMode, 0, sizeof (IR_ParameterMode));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterMode, &_tc_TAO_tc_IR_ParameterMode)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ParameterDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
  21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
  4, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  48, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  116, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
    14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
    3, // member count
    9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
    10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
    12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT

};
static CORBA::TypeCode _tc_TAO_tc_IR_ParameterDescription (CORBA::tk_struct, sizeof (_oc_IR_ParameterDescription), (char *) &_oc_IR_ParameterDescription, 0, sizeof (IR_ParameterDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParameterDescription, &_tc_TAO_tc_IR_ParameterDescription)
TAO_NAMESPACE_END

void IR_ParameterDescription::_tao_any_destructor (void *x)
{
  IR_ParameterDescription *tmp = ACE_static_cast (IR_ParameterDescription*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ParameterDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ParameterDescription *old = ACE_reinterpret_cast (IR_ParameterDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_ParameterDescription *tmp = ACE_reinterpret_cast (IR_ParameterDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq::~_TAO_Unbounded_Sequence_IR_ParDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ParDescriptionSeq
// *************************************************************

IR_ParDescriptionSeq::IR_ParDescriptionSeq (void)
{}
IR_ParDescriptionSeq::IR_ParDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ParDescriptionSeq::IR_ParDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_ParameterDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ParDescriptionSeq::IR_ParDescriptionSeq (const IR_ParDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ParDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ParameterDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ParDescriptionSeq::~IR_ParDescriptionSeq (void) // dtor
{}
void IR_ParDescriptionSeq::_tao_any_destructor (void *x)
{
  IR_ParDescriptionSeq *tmp = ACE_static_cast (IR_ParDescriptionSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ParDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
  18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  404, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    388, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
      21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
      4, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      116, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
        14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
        3, // member count
        9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
        10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
        12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ParDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_ParDescriptionSeq), (char *) &_oc_IR_ParDescriptionSeq, 0, sizeof (IR_ParDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ParDescriptionSeq, &_tc_TAO_tc_IR_ParDescriptionSeq)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ContextIdentifier[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
  18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

};
static CORBA::TypeCode _tc_TAO_tc_IR_ContextIdentifier (CORBA::tk_alias, sizeof (_oc_IR_ContextIdentifier), (char *) &_oc_IR_ContextIdentifier, 0, sizeof (IR::ContextIdentifier));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdentifier, &_tc_TAO_tc_IR_ContextIdentifier)
TAO_NAMESPACE_END

// *************************************************************
// IR_ContextIdSeq
// *************************************************************

IR_ContextIdSeq::IR_ContextIdSeq (void)
{}
IR_ContextIdSeq::IR_ContextIdSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ContextIdSeq::IR_ContextIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ContextIdSeq::IR_ContextIdSeq (const IR_ContextIdSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ContextIdSeq::~IR_ContextIdSeq (void) // dtor
{}
void IR_ContextIdSeq::_tao_any_destructor (void *x)
{
  IR_ContextIdSeq *tmp = ACE_static_cast (IR_ContextIdSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ContextIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
  13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
  CORBA::tk_sequence, // typecode kind
  160, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    144, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
      18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ContextIdSeq (CORBA::tk_alias, sizeof (_oc_IR_ContextIdSeq), (char *) &_oc_IR_ContextIdSeq, 0, sizeof (IR_ContextIdSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ContextIdSeq, &_tc_TAO_tc_IR_ContextIdSeq)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_OperationDef_Proxy_Impl::_TAO_OperationDef_Proxy_Impl (void)
{}

_TAO_OperationDef_Remote_Proxy_Impl::_TAO_OperationDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_OperationDef_Remote_Proxy_Impl::result (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result",
      11,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_IDLType_ptr _TAO_OperationDef_Remote_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_result_def",
      15,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_OperationDef_Remote_Proxy_Impl::result_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_result_def",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        result_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << result_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_ParDescriptionSeq * _TAO_OperationDef_Remote_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ParDescriptionSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_ParDescriptionSeq, _tao_retval);
  IR_ParDescriptionSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_params",
      11,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ParDescriptionSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_OperationDef_Remote_Proxy_Impl::params (
    CORBA_Object *_collocated_tao_target_,
    const IR_ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_params",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set ri (
        &_tao_call,
        _collocated_tao_target_,
        params,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << params)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_OperationMode _TAO_OperationDef_Remote_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_OperationMode _tao_retval = (IR_OperationMode)0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_mode",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_OperationMode  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_OperationDef_Remote_Proxy_Impl::mode (
    CORBA_Object *_collocated_tao_target_,
    IR_OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_mode",
      9,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set ri (
        &_tao_call,
        _collocated_tao_target_,
        mode,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << mode)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_ContextIdSeq * _TAO_OperationDef_Remote_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ContextIdSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_ContextIdSeq, _tao_retval);
  IR_ContextIdSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_contexts",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ContextIdSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_OperationDef_Remote_Proxy_Impl::contexts (
    CORBA_Object *_collocated_tao_target_,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_contexts",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set ri (
        &_tao_call,
        _collocated_tao_target_,
        contexts,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << contexts)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_ExceptionDefSeq * _TAO_OperationDef_Remote_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ExceptionDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_ExceptionDefSeq, _tao_retval);
  IR_ExceptionDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_exceptions",
      15,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ExceptionDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_OperationDef_Remote_Proxy_Impl::exceptions (
    CORBA_Object *_collocated_tao_target_,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_exceptions",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set ri (
        &_tao_call,
        _collocated_tao_target_,
        exceptions,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << exceptions)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_OperationDef_Proxy_Broker::_TAO_OperationDef_Proxy_Broker (void)
{
}

_TAO_OperationDef_Proxy_Broker::~_TAO_OperationDef_Proxy_Broker (void)
{
}

_TAO_OperationDef_Proxy_Broker * (*_TAO_OperationDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_OperationDef_Remote_Proxy_Broker *
_TAO_OperationDef_Remote_Proxy_Broker::the_TAO_OperationDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_OperationDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_OperationDef_Remote_Proxy_Broker::_TAO_OperationDef_Remote_Proxy_Broker (void)
{
}

_TAO_OperationDef_Remote_Proxy_Broker::~_TAO_OperationDef_Remote_Proxy_Broker (void)
{
}

_TAO_OperationDef_Proxy_Impl&
_TAO_OperationDef_Remote_Proxy_Broker::select_proxy (
  ::IR_OperationDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_OperationDef::IR_OperationDef (int collocated)
{
  this->IR_OperationDef_setup_collocation (collocated);
}

// destructor
IR_OperationDef::~IR_OperationDef (void)
{}

void
IR_OperationDef::IR_OperationDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_OperationDef_Proxy_Broker_ =
      _TAO_OperationDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_OperationDef_Proxy_Broker_ =
      _TAO_OperationDef_Remote_Proxy_Broker::the_TAO_OperationDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
}

void IR_OperationDef::_tao_any_destructor (void *x)
{
  IR_OperationDef *tmp = ACE_static_cast (IR_OperationDef*,x);
  CORBA::release (tmp);
}

IR_OperationDef_ptr IR_OperationDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_OperationDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/OperationDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_OperationDef::_nil ());
      if (is_a == 0)
        return IR_OperationDef::_nil ();
    }
  return IR_OperationDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_OperationDef_ptr IR_OperationDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_OperationDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_OperationDef_ptr default_proxy = IR_OperationDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_OperationDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_OperationDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_OperationDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_OperationDef (stub, 0, obj->_servant ()), IR_OperationDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_OperationDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_OperationDef::_narrow
                    )
                )
          );
}

IR_OperationDef_ptr
IR_OperationDef::_duplicate (IR_OperationDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_OperationDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_OperationDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_OperationDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_OperationDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/OperationDef:1.0";
}

CORBA::TypeCode_ptr IR_OperationDef::result (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result (
      this,
      ACE_TRY_ENV
    );
}

IR_IDLType_ptr IR_OperationDef::result_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_OperationDef::result_def (
    IR_IDLType_ptr result_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).result_def (
      this,
      result_def,
      ACE_TRY_ENV
    );
}

IR_ParDescriptionSeq * IR_OperationDef::params (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).params (
      this,
      ACE_TRY_ENV
    );
}

void IR_OperationDef::params (
    const IR_ParDescriptionSeq & params,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).params (
      this,
      params,
      ACE_TRY_ENV
    );
}

IR_OperationMode IR_OperationDef::mode (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
      this,
      ACE_TRY_ENV
    );
}

void IR_OperationDef::mode (
    IR_OperationMode mode,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).mode (
      this,
      mode,
      ACE_TRY_ENV
    );
}

IR_ContextIdSeq * IR_OperationDef::contexts (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).contexts (
      this,
      ACE_TRY_ENV
    );
}

void IR_OperationDef::contexts (
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).contexts (
      this,
      contexts,
      ACE_TRY_ENV
    );
}

IR_ExceptionDefSeq * IR_OperationDef::exceptions (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).exceptions (
      this,
      ACE_TRY_ENV
    );
}

void IR_OperationDef::exceptions (
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_OperationDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).exceptions (
      this,
      exceptions,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::TAO_ClientRequestInfo_IR_OperationDef_result_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::TAO_ClientRequestInfo_IR_OperationDef_result_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set::TAO_ClientRequestInfo_IR_OperationDef_result_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr result_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    result_def_ (result_def)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_result_def = parameter_list->length ();
  parameter_list->length (length_result_def + 1);
  (*parameter_list)[length_result_def].argument <<=  this->result_def_;
  
  (*parameter_list)[length_result_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_result_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::TAO_ClientRequestInfo_IR_OperationDef_params_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_get::result (IR_ParDescriptionSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set::TAO_ClientRequestInfo_IR_OperationDef_params_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_ParDescriptionSeq & params,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    params_ (params)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_params_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::TAO_ClientRequestInfo_IR_OperationDef_mode_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_get::result (IR_OperationMode result)
{
  // update the result 
  this->_result = result;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set::TAO_ClientRequestInfo_IR_OperationDef_mode_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_OperationMode & mode,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    mode_ (mode)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;
  
  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_mode_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::TAO_ClientRequestInfo_IR_OperationDef_contexts_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_get::result (IR_ContextIdSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set::TAO_ClientRequestInfo_IR_OperationDef_contexts_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_contexts = parameter_list->length ();
  parameter_list->length (length_contexts + 1);
  (*parameter_list)[length_contexts].argument <<=  this->contexts_;
  
  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_contexts_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_get::result (IR_ExceptionDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_OperationDef::TAO_ClientRequestInfo_IR_OperationDef_exceptions_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_OperationDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDef:1.0
  13, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446566), ACE_NTOHL (0x0),  // name = IR_OperationDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_OperationDef (CORBA::tk_objref, sizeof (_oc_IR_OperationDef), (char *) &_oc_IR_OperationDef, 0, sizeof (IR_OperationDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDef, &_tc_TAO_tc_IR_OperationDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_OperationDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
  21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
  9, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
  CORBA::tk_TypeCode,

  5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
  CORBA::tk_enum, // typecode kind
  100, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
    14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
    2, // member count
    10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
    10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

  9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
  CORBA::tk_alias, // typecode kind for typedefs
  228, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
    13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
    CORBA::tk_sequence, // typecode kind
    160, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      144, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
        18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      0U,


  11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
  CORBA::tk_alias, // typecode kind for typedefs
  484, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
    18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    404, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      388, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
        21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
        4, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        48, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        116, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
          14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
          3, // member count
          9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
          10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
          12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


      0U,


  11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
  CORBA::tk_alias, // typecode kind for typedefs
  536, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
    18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    456, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      440, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
        21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
        5, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,


      0U,


};
static CORBA::TypeCode _tc_TAO_tc_IR_OperationDescription (CORBA::tk_struct, sizeof (_oc_IR_OperationDescription), (char *) &_oc_IR_OperationDescription, 0, sizeof (IR_OperationDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OperationDescription, &_tc_TAO_tc_IR_OperationDescription)
TAO_NAMESPACE_END

void IR_OperationDescription::_tao_any_destructor (void *x)
{
  IR_OperationDescription *tmp = ACE_static_cast (IR_OperationDescription*,x);
  delete tmp;
}

// *************************************************************
// IR_RepositoryIdSeq
// *************************************************************

IR_RepositoryIdSeq::IR_RepositoryIdSeq (void)
{}
IR_RepositoryIdSeq::IR_RepositoryIdSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_RepositoryIdSeq::IR_RepositoryIdSeq (CORBA::ULong max, CORBA::ULong length, char * *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_RepositoryIdSeq::IR_RepositoryIdSeq (const IR_RepositoryIdSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  TAO_Unbounded_String_Sequence
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_String_Sequence
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_RepositoryIdSeq::~IR_RepositoryIdSeq (void) // dtor
{}
void IR_RepositoryIdSeq::_tao_any_destructor (void *x)
{
  IR_RepositoryIdSeq *tmp = ACE_static_cast (IR_RepositoryIdSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_RepositoryIdSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
  16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
  CORBA::tk_sequence, // typecode kind
  84, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_alias, // typecode kind for typedefs
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
      13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
      CORBA::tk_string, 
      0U, // string length

    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_RepositoryIdSeq (CORBA::tk_alias, sizeof (_oc_IR_RepositoryIdSeq), (char *) &_oc_IR_RepositoryIdSeq, 0, sizeof (IR_RepositoryIdSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_RepositoryIdSeq, &_tc_TAO_tc_IR_RepositoryIdSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_OperationDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_OperationDescription *old = ACE_reinterpret_cast (IR_OperationDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_OperationDescription *tmp = ACE_reinterpret_cast (IR_OperationDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq::~_TAO_Unbounded_Sequence_IR_OpDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_OpDescriptionSeq
// *************************************************************

IR_OpDescriptionSeq::IR_OpDescriptionSeq (void)
{}
IR_OpDescriptionSeq::IR_OpDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_OpDescriptionSeq::IR_OpDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_OperationDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_OpDescriptionSeq::IR_OpDescriptionSeq (const IR_OpDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_OpDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_OperationDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_OpDescriptionSeq::~IR_OpDescriptionSeq (void) // dtor
{}
void IR_OpDescriptionSeq::_tao_any_destructor (void *x)
{
  IR_OpDescriptionSeq *tmp = ACE_static_cast (IR_OpDescriptionSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_OpDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
  17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  1896, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    1880, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
      21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
      9, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
      CORBA::tk_TypeCode,

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      100, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
        14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
        2, // member count
        10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
        10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

      9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
      CORBA::tk_alias, // typecode kind for typedefs
      228, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
        13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
        CORBA::tk_sequence, // typecode kind
        160, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_alias, // typecode kind for typedefs
          144, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
            18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length


          0U,


      11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
      CORBA::tk_alias, // typecode kind for typedefs
      484, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
        18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        404, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          388, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
            21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
            4, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,

            9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
            CORBA::tk_objref, // typecode kind
            48, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
              8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

            5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
            CORBA::tk_enum, // typecode kind
            116, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
              14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
              3, // member count
              9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
              10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
              12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


          0U,


      11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
      CORBA::tk_alias, // typecode kind for typedefs
      536, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        456, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          440, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            3, ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string, 
              0U, // string length

            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string, 
              0U, // string length

            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,


          0U,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_OpDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_OpDescriptionSeq), (char *) &_oc_IR_OpDescriptionSeq, 0, sizeof (IR_OpDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_OpDescriptionSeq, &_tc_TAO_tc_IR_OpDescriptionSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_AttributeDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_AttributeDescription *old = ACE_reinterpret_cast (IR_AttributeDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_AttributeDescription *tmp = ACE_reinterpret_cast (IR_AttributeDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq::~_TAO_Unbounded_Sequence_IR_AttrDescriptionSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_AttrDescriptionSeq
// *************************************************************

IR_AttrDescriptionSeq::IR_AttrDescriptionSeq (void)
{}
IR_AttrDescriptionSeq::IR_AttrDescriptionSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_AttrDescriptionSeq::IR_AttrDescriptionSeq (CORBA::ULong max, CORBA::ULong length, IR_AttributeDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_AttrDescriptionSeq::IR_AttrDescriptionSeq (const IR_AttrDescriptionSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_AttrDescriptionSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_AttributeDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_AttrDescriptionSeq::~IR_AttrDescriptionSeq (void) // dtor
{}
void IR_AttrDescriptionSeq::_tao_any_destructor (void *x)
{
  IR_AttrDescriptionSeq *tmp = ACE_static_cast (IR_AttrDescriptionSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_AttrDescriptionSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
  19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
  CORBA::tk_sequence, // typecode kind
  1708, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    1692, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
      21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
      8, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
      CORBA::tk_enum, // typecode kind
      104, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
        14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
        2, // member count
        12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
        14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

      15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
      CORBA::tk_alias, // typecode kind for typedefs
      536, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        456, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          440, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            3, ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string, 
              0U, // string length

            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string, 
              0U, // string length

            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,


          0U,


      15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
      CORBA::tk_alias, // typecode kind for typedefs
      536, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
        18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
        CORBA::tk_sequence, // typecode kind
        456, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          CORBA::tk_struct, // typecode kind
          440, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
            21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
            5, // member count
            5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
              11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
              CORBA::tk_string, 
              0U, // string length

            3, ACE_NTOHL (0x69640000),  // name = id
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string, 
              0U, // string length

            11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
            CORBA::tk_alias, // typecode kind for typedefs
            68, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
              13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
              CORBA::tk_string, 
              0U, // string length

            8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
            CORBA::tk_alias, // typecode kind for typedefs
            64, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
              12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
              CORBA::tk_string, 
              0U, // string length

            5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
            CORBA::tk_TypeCode,


          0U,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_AttrDescriptionSeq (CORBA::tk_alias, sizeof (_oc_IR_AttrDescriptionSeq), (char *) &_oc_IR_AttrDescriptionSeq, 0, sizeof (IR_AttrDescriptionSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_AttrDescriptionSeq, &_tc_TAO_tc_IR_AttrDescriptionSeq)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_InterfaceDef_Proxy_Impl::_TAO_InterfaceDef_Proxy_Impl (void)
{}

_TAO_InterfaceDef_Remote_Proxy_Impl::_TAO_InterfaceDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_InterfaceDefSeq * _TAO_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_InterfaceDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_InterfaceDefSeq, _tao_retval);
  IR_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_interfaces",
      20,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_InterfaceDef_Remote_Proxy_Impl::base_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_interfaces",
      20,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set ri (
        &_tao_call,
        _collocated_tao_target_,
        base_interfaces,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << base_interfaces)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Boolean _TAO_InterfaceDef_Remote_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_abstract",
      16,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_InterfaceDef_Remote_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_abstract",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set ri (
        &_tao_call,
        _collocated_tao_target_,
        is_abstract,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << CORBA::Any::from_boolean (is_abstract))
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Boolean _TAO_InterfaceDef_Remote_Proxy_Impl::is_local (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_local",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_InterfaceDef_Remote_Proxy_Impl::is_local (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_local",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set ri (
        &_tao_call,
        _collocated_tao_target_,
        is_local,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << CORBA::Any::from_boolean (is_local))
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Boolean _TAO_InterfaceDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        interface_id,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << interface_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

IR_AttributeDef_ptr _TAO_InterfaceDef_Remote_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_AttributeDef_ptr _tao_retval = IR_AttributeDef::_nil ();
  IR_AttributeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        type,
        mode,
        get_exceptions,
        put_exceptions,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << mode) &&
              (_tao_out << get_exceptions) &&
              (_tao_out << put_exceptions)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_AttributeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_OperationDef_ptr _TAO_InterfaceDef_Remote_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_OperationDef_ptr _tao_retval = IR_OperationDef::_nil ();
  IR_OperationDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << result) &&
              (_tao_out << mode) &&
              (_tao_out << params) &&
              (_tao_out << exceptions) &&
              (_tao_out << contexts)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_OperationDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_InterfaceDef_Proxy_Broker::_TAO_InterfaceDef_Proxy_Broker (void)
{
}

_TAO_InterfaceDef_Proxy_Broker::~_TAO_InterfaceDef_Proxy_Broker (void)
{
}

_TAO_InterfaceDef_Proxy_Broker * (*_TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_InterfaceDef_Remote_Proxy_Broker *
_TAO_InterfaceDef_Remote_Proxy_Broker::the_TAO_InterfaceDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_InterfaceDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_InterfaceDef_Remote_Proxy_Broker::_TAO_InterfaceDef_Remote_Proxy_Broker (void)
{
}

_TAO_InterfaceDef_Remote_Proxy_Broker::~_TAO_InterfaceDef_Remote_Proxy_Broker (void)
{
}

_TAO_InterfaceDef_Proxy_Impl&
_TAO_InterfaceDef_Remote_Proxy_Broker::select_proxy (
  ::IR_InterfaceDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_InterfaceDef::IR_InterfaceDef (int collocated)
{
  this->IR_InterfaceDef_setup_collocation (collocated);
}

// destructor
IR_InterfaceDef::~IR_InterfaceDef (void)
{}

void
IR_InterfaceDef::IR_InterfaceDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_InterfaceDef_Proxy_Broker_ =
      _TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_InterfaceDef_Proxy_Broker_ =
      _TAO_InterfaceDef_Remote_Proxy_Broker::the_TAO_InterfaceDef_Remote_Proxy_Broker ();
  
  this->IR_Container_setup_collocation (collocated);
  this->IR_Contained_setup_collocation (collocated);
  this->IR_IDLType_setup_collocation (collocated);
}

void IR_InterfaceDef::_tao_any_destructor (void *x)
{
  IR_InterfaceDef *tmp = ACE_static_cast (IR_InterfaceDef*,x);
  CORBA::release (tmp);
}

IR_InterfaceDef_ptr IR_InterfaceDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_InterfaceDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/InterfaceDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_InterfaceDef::_nil ());
      if (is_a == 0)
        return IR_InterfaceDef::_nil ();
    }
  return IR_InterfaceDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_InterfaceDef_ptr IR_InterfaceDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_InterfaceDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_InterfaceDef_ptr default_proxy = IR_InterfaceDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_InterfaceDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_InterfaceDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_InterfaceDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_InterfaceDef (stub, 0, obj->_servant ()), IR_InterfaceDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_InterfaceDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_InterfaceDef::_narrow
                    )
                )
          );
}

IR_InterfaceDef_ptr
IR_InterfaceDef::_duplicate (IR_InterfaceDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_InterfaceDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_InterfaceDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_InterfaceDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_InterfaceDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/InterfaceDef:1.0";
}

IR_InterfaceDefSeq * IR_InterfaceDef::base_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_interfaces (
      this,
      ACE_TRY_ENV
    );
}

void IR_InterfaceDef::base_interfaces (
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_interfaces (
      this,
      base_interfaces,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_InterfaceDef::is_abstract (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
      this,
      ACE_TRY_ENV
    );
}

void IR_InterfaceDef::is_abstract (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
      this,
      is_abstract,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_InterfaceDef::is_local (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_local (
      this,
      ACE_TRY_ENV
    );
}

void IR_InterfaceDef::is_local (
    CORBA::Boolean is_local,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_local (
      this,
      is_local,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_InterfaceDef::is_a (
    const char * interface_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
      this,
      interface_id,
      ACE_TRY_ENV
    );
}

IR_AttributeDef_ptr IR_InterfaceDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_attribute (
      this,
      id,
      name,
      version,
      type,
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );
}

IR_OperationDef_ptr IR_InterfaceDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_InterfaceDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_operation (
      this,
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_get::result (IR_InterfaceDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_InterfaceDefSeq & base_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    base_interfaces_ (base_interfaces)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_base_interfaces = parameter_list->length ();
  parameter_list->length (length_base_interfaces + 1);
  (*parameter_list)[length_base_interfaces].argument <<=  this->base_interfaces_;
  
  (*parameter_list)[length_base_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_base_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Boolean & is_abstract,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    is_abstract_ (is_abstract)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_abstract_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Boolean & is_local,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    is_local_ (is_local)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_is_local = parameter_list->length ();
  parameter_list->length (length_is_local + 1);
  (*parameter_list)[length_is_local].argument <<= CORBA::Any::from_boolean (this->is_local_);
  (*parameter_list)[length_is_local].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_local_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::TAO_ClientRequestInfo_IR_InterfaceDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * interface_id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    interface_id_ (interface_id)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_interface_id = parameter_list->length ();
  parameter_list->length (length_interface_id + 1);
  (*parameter_list)[length_interface_id].argument <<= interface_id_;
  (*parameter_list)[length_interface_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_is_a::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode & mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    mode_ (mode),
    get_exceptions_ (get_exceptions),
    put_exceptions_ (put_exceptions)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;
  
  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_get_exceptions = parameter_list->length ();
  parameter_list->length (length_get_exceptions + 1);
  (*parameter_list)[length_get_exceptions].argument <<=  this->get_exceptions_;
  
  (*parameter_list)[length_get_exceptions].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_put_exceptions = parameter_list->length ();
  parameter_list->length (length_put_exceptions + 1);
  (*parameter_list)[length_put_exceptions].argument <<=  this->put_exceptions_;
  
  (*parameter_list)[length_put_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_attribute::result (IR_AttributeDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode & mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    result_ (result),
    mode_ (mode),
    params_ (params),
    exceptions_ (exceptions),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_result = parameter_list->length ();
  parameter_list->length (length_result + 1);
  (*parameter_list)[length_result].argument <<=  this->result_;
  
  (*parameter_list)[length_result].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;
  
  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_contexts = parameter_list->length ();
  parameter_list->length (length_contexts + 1);
  (*parameter_list)[length_contexts].argument <<=  this->contexts_;
  
  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_InterfaceDef::TAO_ClientRequestInfo_IR_InterfaceDef_create_operation::result (IR_OperationDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_InterfaceDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
  13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDef (CORBA::tk_objref, sizeof (_oc_IR_InterfaceDef), (char *) &_oc_IR_InterfaceDef, 0, sizeof (IR_InterfaceDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDef, &_tc_TAO_tc_IR_InterfaceDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_InterfaceDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDescription:1.0
  21, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = InterfaceDescription
  10, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  1972, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1896, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1880, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        228, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          160, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            144, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        484, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          404, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            388, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              48, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  1788, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1708, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1692, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  16, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = base_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

  9, ACE_NTOHL (0x69735f6c), ACE_NTOHL (0x6f63616c), ACE_NTOHL (0x0),  // name = is_local
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_IR_InterfaceDescription (CORBA::tk_struct, sizeof (_oc_IR_InterfaceDescription), (char *) &_oc_IR_InterfaceDescription, 0, sizeof (IR_InterfaceDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_InterfaceDescription, &_tc_TAO_tc_IR_InterfaceDescription)
TAO_NAMESPACE_END

void IR_InterfaceDescription::_tao_any_destructor (void *x)
{
  IR_InterfaceDescription *tmp = ACE_static_cast (IR_InterfaceDescription*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ValueMember[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
  7, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

  9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
  CORBA::tk_objref, // typecode kind
  48, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
    8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

  7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
    11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
    CORBA::tk_short,


};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueMember (CORBA::tk_struct, sizeof (_oc_IR_ValueMember), (char *) &_oc_IR_ValueMember, 0, sizeof (IR_ValueMember));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMember, &_tc_TAO_tc_IR_ValueMember)
TAO_NAMESPACE_END

void IR_ValueMember::_tao_any_destructor (void *x)
{
  IR_ValueMember *tmp = ACE_static_cast (IR_ValueMember*,x);
  delete tmp;
}


#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ValueMember* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ValueMemberSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ValueMember *old = ACE_reinterpret_cast (IR_ValueMember *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_ValueMember *tmp = ACE_reinterpret_cast (IR_ValueMember *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ValueMemberSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq::~_TAO_Unbounded_Sequence_IR_ValueMemberSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ValueMemberSeq
// *************************************************************

IR_ValueMemberSeq::IR_ValueMemberSeq (void)
{}
IR_ValueMemberSeq::IR_ValueMemberSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ValueMemberSeq::IR_ValueMemberSeq (CORBA::ULong max, CORBA::ULong length, IR_ValueMember *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ValueMemberSeq::IR_ValueMemberSeq (const IR_ValueMemberSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ValueMemberSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ValueMember>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ValueMemberSeq::~IR_ValueMemberSeq (void) // dtor
{}
void IR_ValueMemberSeq::_tao_any_destructor (void *x)
{
  IR_ValueMemberSeq *tmp = ACE_static_cast (IR_ValueMemberSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ValueMemberSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberSeq:1.0
  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
  CORBA::tk_sequence, // typecode kind
  592, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    576, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
      12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
      7, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
      CORBA::tk_TypeCode,

      9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
        8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

      7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
        11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
        CORBA::tk_short,



    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueMemberSeq (CORBA::tk_alias, sizeof (_oc_IR_ValueMemberSeq), (char *) &_oc_IR_ValueMemberSeq, 0, sizeof (IR_ValueMemberSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberSeq, &_tc_TAO_tc_IR_ValueMemberSeq)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ValueMemberDef_Proxy_Impl::_TAO_ValueMemberDef_Proxy_Impl (void)
{}

_TAO_ValueMemberDef_Remote_Proxy_Impl::_TAO_ValueMemberDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::TypeCode_ptr _TAO_ValueMemberDef_Remote_Proxy_Impl::type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::TypeCode_ptr _tao_retval = CORBA::TypeCode::_nil ();
  CORBA::TypeCode_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type",
      9,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::TypeCode_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_IDLType_ptr _TAO_ValueMemberDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_type_def",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ValueMemberDef_Remote_Proxy_Impl::type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_type_def",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Visibility _TAO_ValueMemberDef_Remote_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Visibility _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_access",
      11,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_retval)
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Visibility  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_ValueMemberDef_Remote_Proxy_Impl::access (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_access",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set ri (
        &_tao_call,
        _collocated_tao_target_,
        access,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << access)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ValueMemberDef_Proxy_Broker::_TAO_ValueMemberDef_Proxy_Broker (void)
{
}

_TAO_ValueMemberDef_Proxy_Broker::~_TAO_ValueMemberDef_Proxy_Broker (void)
{
}

_TAO_ValueMemberDef_Proxy_Broker * (*_TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ValueMemberDef_Remote_Proxy_Broker *
_TAO_ValueMemberDef_Remote_Proxy_Broker::the_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ValueMemberDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ValueMemberDef_Remote_Proxy_Broker::_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
{
}

_TAO_ValueMemberDef_Remote_Proxy_Broker::~_TAO_ValueMemberDef_Remote_Proxy_Broker (void)
{
}

_TAO_ValueMemberDef_Proxy_Impl&
_TAO_ValueMemberDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ValueMemberDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ValueMemberDef::IR_ValueMemberDef (int collocated)
{
  this->IR_ValueMemberDef_setup_collocation (collocated);
}

// destructor
IR_ValueMemberDef::~IR_ValueMemberDef (void)
{}

void
IR_ValueMemberDef::IR_ValueMemberDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ValueMemberDef_Proxy_Broker_ =
      _TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ValueMemberDef_Proxy_Broker_ =
      _TAO_ValueMemberDef_Remote_Proxy_Broker::the_TAO_ValueMemberDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
}

void IR_ValueMemberDef::_tao_any_destructor (void *x)
{
  IR_ValueMemberDef *tmp = ACE_static_cast (IR_ValueMemberDef*,x);
  CORBA::release (tmp);
}

IR_ValueMemberDef_ptr IR_ValueMemberDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ValueMemberDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueMemberDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ValueMemberDef::_nil ());
      if (is_a == 0)
        return IR_ValueMemberDef::_nil ();
    }
  return IR_ValueMemberDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ValueMemberDef_ptr IR_ValueMemberDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ValueMemberDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ValueMemberDef_ptr default_proxy = IR_ValueMemberDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ValueMemberDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ValueMemberDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ValueMemberDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ValueMemberDef (stub, 0, obj->_servant ()), IR_ValueMemberDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ValueMemberDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ValueMemberDef::_narrow
                    )
                )
          );
}

IR_ValueMemberDef_ptr
IR_ValueMemberDef::_duplicate (IR_ValueMemberDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ValueMemberDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueMemberDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ValueMemberDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ValueMemberDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ValueMemberDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueMemberDef:1.0";
}

CORBA::TypeCode_ptr IR_ValueMemberDef::type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type (
      this,
      ACE_TRY_ENV
    );
}

IR_IDLType_ptr IR_ValueMemberDef::type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueMemberDef::type_def (
    IR_IDLType_ptr type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).type_def (
      this,
      type_def,
      ACE_TRY_ENV
    );
}

CORBA::Visibility IR_ValueMemberDef::access (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).access (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueMemberDef::access (
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueMemberDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).access (
      this,
      access,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_get::result (CORBA::TypeCode_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    type_def_ (type_def)
{}

Dynamic::ParameterList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_type_def = parameter_list->length ();
  parameter_list->length (length_type_def + 1);
  (*parameter_list)[length_type_def].argument <<=  this->type_def_;
  
  (*parameter_list)[length_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_get::result (CORBA::Visibility result)
{
  // update the result 
  this->_result = result;
}

IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Visibility & access,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    access_ (access)
{}

Dynamic::ParameterList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_access = parameter_list->length ();
  parameter_list->length (length_access + 1);
  (*parameter_list)[length_access].argument <<= access_;
  (*parameter_list)[length_access].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueMemberDef::TAO_ClientRequestInfo_IR_ValueMemberDef_access_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ValueMemberDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65724465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberDef:1.0
  15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657244), ACE_NTOHL (0x65660000),  // name = IR_ValueMemberDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueMemberDef (CORBA::tk_objref, sizeof (_oc_IR_ValueMemberDef), (char *) &_oc_IR_ValueMemberDef, 0, sizeof (IR_ValueMemberDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueMemberDef, &_tc_TAO_tc_IR_ValueMemberDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ValueDef_Proxy_Impl::_TAO_ValueDef_Proxy_Impl (void)
{}

_TAO_ValueDef_Remote_Proxy_Impl::_TAO_ValueDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_InterfaceDefSeq * _TAO_ValueDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_InterfaceDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_InterfaceDefSeq, _tao_retval);
  IR_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ValueDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set ri (
        &_tao_call,
        _collocated_tao_target_,
        supported_interfaces,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << supported_interfaces)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_InitializerSeq * _TAO_ValueDef_Remote_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_InitializerSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_InitializerSeq, _tao_retval);
  IR_InitializerSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_initializers",
      17,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_InitializerSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ValueDef_Remote_Proxy_Impl::initializers (
    CORBA_Object *_collocated_tao_target_,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_initializers",
      17,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set ri (
        &_tao_call,
        _collocated_tao_target_,
        initializers,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << initializers)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_ValueDef_ptr _TAO_ValueDef_Remote_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ValueDef_ptr _tao_retval = IR_ValueDef::_nil ();
  IR_ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_value",
      15,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ValueDef_Remote_Proxy_Impl::base_value (
    CORBA_Object *_collocated_tao_target_,
    IR_ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_base_value",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set ri (
        &_tao_call,
        _collocated_tao_target_,
        base_value,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << base_value)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_ValueDefSeq * _TAO_ValueDef_Remote_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ValueDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_ValueDefSeq, _tao_retval);
  IR_ValueDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_abstract_base_values",
      25,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ValueDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ValueDef_Remote_Proxy_Impl::abstract_base_values (
    CORBA_Object *_collocated_tao_target_,
    const IR_ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_abstract_base_values",
      25,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set ri (
        &_tao_call,
        _collocated_tao_target_,
        abstract_base_values,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << abstract_base_values)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Boolean _TAO_ValueDef_Remote_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_abstract",
      16,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_ValueDef_Remote_Proxy_Impl::is_abstract (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_abstract",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set ri (
        &_tao_call,
        _collocated_tao_target_,
        is_abstract,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << CORBA::Any::from_boolean (is_abstract))
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Boolean _TAO_ValueDef_Remote_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_custom",
      14,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_ValueDef_Remote_Proxy_Impl::is_custom (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_custom",
      14,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set ri (
        &_tao_call,
        _collocated_tao_target_,
        is_custom,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << CORBA::Any::from_boolean (is_custom))
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Boolean _TAO_ValueDef_Remote_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_truncatable",
      19,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

void _TAO_ValueDef_Remote_Proxy_Impl::is_truncatable (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_is_truncatable",
      19,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set ri (
        &_tao_call,
        _collocated_tao_target_,
        is_truncatable,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << CORBA::Any::from_boolean (is_truncatable))
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

CORBA::Boolean _TAO_ValueDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

IR_ValueMemberDef_ptr _TAO_ValueDef_Remote_Proxy_Impl::create_value_member (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ValueMemberDef_ptr _tao_retval = IR_ValueMemberDef::_nil ();
  IR_ValueMemberDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_value_member",
      19,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        type,
        access,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << access)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ValueMemberDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_AttributeDef_ptr _TAO_ValueDef_Remote_Proxy_Impl::create_attribute (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_AttributeDef_ptr _tao_retval = IR_AttributeDef::_nil ();
  IR_AttributeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_attribute",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        type,
        mode,
        get_exceptions,
        put_exceptions,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << type) &&
              (_tao_out << mode) &&
              (_tao_out << get_exceptions) &&
              (_tao_out << put_exceptions)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_AttributeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_OperationDef_ptr _TAO_ValueDef_Remote_Proxy_Impl::create_operation (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_OperationDef_ptr _tao_retval = IR_OperationDef::_nil ();
  IR_OperationDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_operation",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        result,
        mode,
        params,
        exceptions,
        contexts,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << result) &&
              (_tao_out << mode) &&
              (_tao_out << params) &&
              (_tao_out << exceptions) &&
              (_tao_out << contexts)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_OperationDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ValueDef_Proxy_Broker::_TAO_ValueDef_Proxy_Broker (void)
{
}

_TAO_ValueDef_Proxy_Broker::~_TAO_ValueDef_Proxy_Broker (void)
{
}

_TAO_ValueDef_Proxy_Broker * (*_TAO_ValueDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ValueDef_Remote_Proxy_Broker *
_TAO_ValueDef_Remote_Proxy_Broker::the_TAO_ValueDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ValueDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ValueDef_Remote_Proxy_Broker::_TAO_ValueDef_Remote_Proxy_Broker (void)
{
}

_TAO_ValueDef_Remote_Proxy_Broker::~_TAO_ValueDef_Remote_Proxy_Broker (void)
{
}

_TAO_ValueDef_Proxy_Impl&
_TAO_ValueDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ValueDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ValueDef::IR_ValueDef (int collocated)
{
  this->IR_ValueDef_setup_collocation (collocated);
}

// destructor
IR_ValueDef::~IR_ValueDef (void)
{}

void
IR_ValueDef::IR_ValueDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ValueDef_Proxy_Broker_ =
      _TAO_ValueDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ValueDef_Proxy_Broker_ =
      _TAO_ValueDef_Remote_Proxy_Broker::the_TAO_ValueDef_Remote_Proxy_Broker ();
  
  this->IR_Container_setup_collocation (collocated);
  this->IR_Contained_setup_collocation (collocated);
  this->IR_IDLType_setup_collocation (collocated);
}

void IR_ValueDef::_tao_any_destructor (void *x)
{
  IR_ValueDef *tmp = ACE_static_cast (IR_ValueDef*,x);
  CORBA::release (tmp);
}

IR_ValueDef_ptr IR_ValueDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ValueDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ValueDef::_nil ());
      if (is_a == 0)
        return IR_ValueDef::_nil ();
    }
  return IR_ValueDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ValueDef_ptr IR_ValueDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ValueDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ValueDef_ptr default_proxy = IR_ValueDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ValueDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ValueDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ValueDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ValueDef (stub, 0, obj->_servant ()), IR_ValueDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ValueDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ValueDef::_narrow
                    )
                )
          );
}

IR_ValueDef_ptr
IR_ValueDef::_duplicate (IR_ValueDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ValueDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ValueDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ValueDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ValueDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueDef:1.0";
}

IR_InterfaceDefSeq * IR_ValueDef::supported_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueDef::supported_interfaces (
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
      this,
      supported_interfaces,
      ACE_TRY_ENV
    );
}

IR_InitializerSeq * IR_ValueDef::initializers (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).initializers (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueDef::initializers (
    const IR_InitializerSeq & initializers,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).initializers (
      this,
      initializers,
      ACE_TRY_ENV
    );
}

IR_ValueDef_ptr IR_ValueDef::base_value (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_value (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueDef::base_value (
    IR_ValueDef_ptr base_value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_value (
      this,
      base_value,
      ACE_TRY_ENV
    );
}

IR_ValueDefSeq * IR_ValueDef::abstract_base_values (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).abstract_base_values (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueDef::abstract_base_values (
    const IR_ValueDefSeq & abstract_base_values,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).abstract_base_values (
      this,
      abstract_base_values,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_ValueDef::is_abstract (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueDef::is_abstract (
    CORBA::Boolean is_abstract,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_abstract (
      this,
      is_abstract,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_ValueDef::is_custom (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_custom (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueDef::is_custom (
    CORBA::Boolean is_custom,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_custom (
      this,
      is_custom,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_ValueDef::is_truncatable (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_truncatable (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueDef::is_truncatable (
    CORBA::Boolean is_truncatable,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_truncatable (
      this,
      is_truncatable,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_ValueDef::is_a (
    const char * id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
      this,
      id,
      ACE_TRY_ENV
    );
}

IR_ValueMemberDef_ptr IR_ValueDef::create_value_member (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    CORBA::Visibility access,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_value_member (
      this,
      id,
      name,
      version,
      type,
      access,
      ACE_TRY_ENV
    );
}

IR_AttributeDef_ptr IR_ValueDef::create_attribute (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_attribute (
      this,
      id,
      name,
      version,
      type,
      mode,
      get_exceptions,
      put_exceptions,
      ACE_TRY_ENV
    );
}

IR_OperationDef_ptr IR_ValueDef::create_operation (
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_operation (
      this,
      id,
      name,
      version,
      result,
      mode,
      params,
      exceptions,
      contexts,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_get::result (IR_InterfaceDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
  
  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::TAO_ClientRequestInfo_IR_ValueDef_initializers_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_get::result (IR_InitializerSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set::TAO_ClientRequestInfo_IR_ValueDef_initializers_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_InitializerSeq & initializers,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    initializers_ (initializers)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_initializers = parameter_list->length ();
  parameter_list->length (length_initializers + 1);
  (*parameter_list)[length_initializers].argument <<=  this->initializers_;
  
  (*parameter_list)[length_initializers].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_initializers_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::TAO_ClientRequestInfo_IR_ValueDef_base_value_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_get::result (IR_ValueDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set::TAO_ClientRequestInfo_IR_ValueDef_base_value_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_ValueDef_ptr base_value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    base_value_ (base_value)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_base_value = parameter_list->length ();
  parameter_list->length (length_base_value + 1);
  (*parameter_list)[length_base_value].argument <<=  this->base_value_;
  
  (*parameter_list)[length_base_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_base_value_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_get::result (IR_ValueDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_ValueDefSeq & abstract_base_values,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    abstract_base_values_ (abstract_base_values)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_abstract_base_values = parameter_list->length ();
  parameter_list->length (length_abstract_base_values + 1);
  (*parameter_list)[length_abstract_base_values].argument <<=  this->abstract_base_values_;
  
  (*parameter_list)[length_abstract_base_values].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_abstract_base_values_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Boolean & is_abstract,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    is_abstract_ (is_abstract)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_is_abstract = parameter_list->length ();
  parameter_list->length (length_is_abstract + 1);
  (*parameter_list)[length_is_abstract].argument <<= CORBA::Any::from_boolean (this->is_abstract_);
  (*parameter_list)[length_is_abstract].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_abstract_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Boolean & is_custom,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    is_custom_ (is_custom)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_is_custom = parameter_list->length ();
  parameter_list->length (length_is_custom + 1);
  (*parameter_list)[length_is_custom].argument <<= CORBA::Any::from_boolean (this->is_custom_);
  (*parameter_list)[length_is_custom].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_custom_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const CORBA::Boolean & is_truncatable,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    is_truncatable_ (is_truncatable)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_is_truncatable = parameter_list->length ();
  parameter_list->length (length_is_truncatable + 1);
  (*parameter_list)[length_is_truncatable].argument <<= CORBA::Any::from_boolean (this->is_truncatable_);
  (*parameter_list)[length_is_truncatable].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_truncatable_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::TAO_ClientRequestInfo_IR_ValueDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_is_a::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::TAO_ClientRequestInfo_IR_ValueDef_create_value_member (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    const CORBA::Visibility & access,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    access_ (access)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_access = parameter_list->length ();
  parameter_list->length (length_access + 1);
  (*parameter_list)[length_access].argument <<= access_;
  (*parameter_list)[length_access].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_value_member::result (IR_ValueMemberDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::TAO_ClientRequestInfo_IR_ValueDef_create_attribute (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr type,
    IR_AttributeMode & mode,
    const IR_ExceptionDefSeq & get_exceptions,
    const IR_ExceptionDefSeq & put_exceptions,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    type_ (type),
    mode_ (mode),
    get_exceptions_ (get_exceptions),
    put_exceptions_ (put_exceptions)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_type = parameter_list->length ();
  parameter_list->length (length_type + 1);
  (*parameter_list)[length_type].argument <<=  this->type_;
  
  (*parameter_list)[length_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;
  
  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_get_exceptions = parameter_list->length ();
  parameter_list->length (length_get_exceptions + 1);
  (*parameter_list)[length_get_exceptions].argument <<=  this->get_exceptions_;
  
  (*parameter_list)[length_get_exceptions].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_put_exceptions = parameter_list->length ();
  parameter_list->length (length_put_exceptions + 1);
  (*parameter_list)[length_put_exceptions].argument <<=  this->put_exceptions_;
  
  (*parameter_list)[length_put_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_attribute::result (IR_AttributeDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::TAO_ClientRequestInfo_IR_ValueDef_create_operation (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_IDLType_ptr result,
    IR_OperationMode & mode,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    const IR_ContextIdSeq & contexts,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    result_ (result),
    mode_ (mode),
    params_ (params),
    exceptions_ (exceptions),
    contexts_ (contexts)
{}

Dynamic::ParameterList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_result = parameter_list->length ();
  parameter_list->length (length_result + 1);
  (*parameter_list)[length_result].argument <<=  this->result_;
  
  (*parameter_list)[length_result].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_mode = parameter_list->length ();
  parameter_list->length (length_mode + 1);
  (*parameter_list)[length_mode].argument <<=  this->mode_;
  
  (*parameter_list)[length_mode].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_contexts = parameter_list->length ();
  parameter_list->length (length_contexts + 1);
  (*parameter_list)[length_contexts].argument <<=  this->contexts_;
  
  (*parameter_list)[length_contexts].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueDef::TAO_ClientRequestInfo_IR_ValueDef_create_operation::result (IR_OperationDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ValueDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
  9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_ValueDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueDef (CORBA::tk_objref, sizeof (_oc_IR_ValueDef), (char *) &_oc_IR_ValueDef, 0, sizeof (IR_ValueDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDef, &_tc_TAO_tc_IR_ValueDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ValueDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDescription:1.0
  17, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ValueDescription
  15, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  12, ACE_NTOHL (0x69735f61), ACE_NTOHL (0x62737472), ACE_NTOHL (0x61637400),  // name = is_abstract
  CORBA::tk_boolean,

  10, ACE_NTOHL (0x69735f63), ACE_NTOHL (0x7573746f), ACE_NTOHL (0x6d000000),  // name = is_custom
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  1972, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1896, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1880, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        228, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          160, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            144, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        484, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          404, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            388, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              48, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  1788, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1708, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1692, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
  CORBA::tk_alias, // typecode kind for typedefs
  664, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ValueMemberSeq:1.0
    15, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65710000),  // name = ValueMemberSeq
    CORBA::tk_sequence, // typecode kind
    592, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      576, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4d656d62), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueMember:1.0
        12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x654d656d), ACE_NTOHL (0x62657200),  // name = ValueMember
        7, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
        CORBA::tk_objref, // typecode kind
        48, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
          8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

        7, ACE_NTOHL (0x61636365), ACE_NTOHL (0x73730000),  // name = access
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x434f5242), ACE_NTOHL (0x412f5669), ACE_NTOHL (0x73696269), ACE_NTOHL (0x6c697479), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/CORBA/Visibility:1.0
          11, ACE_NTOHL (0x56697369), ACE_NTOHL (0x62696c69), ACE_NTOHL (0x74790000),  // name = Visibility
          CORBA::tk_short,



      0U,


  13, ACE_NTOHL (0x696e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657273), ACE_NTOHL (0x0),  // name = initializers
  CORBA::tk_alias, // typecode kind for typedefs
  576, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65725365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/InitializerSeq:1.0
    15, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657253), ACE_NTOHL (0x65710000),  // name = IR_InitializerSeq
    CORBA::tk_sequence, // typecode kind
    504, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      488, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e697469), ACE_NTOHL (0x616c697a), ACE_NTOHL (0x65723a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/Initializer:1.0
        12, ACE_NTOHL (0x496e6974), ACE_NTOHL (0x69616c69), ACE_NTOHL (0x7a657200),  // name = IR_Initializer
        2, // member count
        8, ACE_NTOHL (0x6d656d62), ACE_NTOHL (0x65727300),  // name = members
        CORBA::tk_alias, // typecode kind for typedefs
        324, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x62657253), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/StructMemberSeq:1.0
          16, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x53657100),  // name = IR_StructMemberSeq
          CORBA::tk_sequence, // typecode kind
          252, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            236, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f53), ACE_NTOHL (0x74727563), ACE_NTOHL (0x744d656d), ACE_NTOHL (0x6265723a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/StructMember:1.0
              13, ACE_NTOHL (0x53747275), ACE_NTOHL (0x63744d65), ACE_NTOHL (0x6d626572), ACE_NTOHL (0x0),  // name = IR_StructMember
              3, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              48, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType


            0U,


        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length


      0U,


  21, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727465), ACE_NTOHL (0x645f696e), ACE_NTOHL (0x74657266), ACE_NTOHL (0x61636573), ACE_NTOHL (0x0),  // name = supported_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  21, ACE_NTOHL (0x61627374), ACE_NTOHL (0x72616374), ACE_NTOHL (0x5f626173), ACE_NTOHL (0x655f7661), ACE_NTOHL (0x6c756573), ACE_NTOHL (0x0),  // name = abstract_base_values
  CORBA::tk_alias, // typecode kind for typedefs
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  15, ACE_NTOHL (0x69735f74), ACE_NTOHL (0x72756e63), ACE_NTOHL (0x61746162), ACE_NTOHL (0x6c650000),  // name = is_truncatable
  CORBA::tk_boolean,

  11, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f76616c), ACE_NTOHL (0x75650000),  // name = base_value
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
  CORBA::tk_TypeCode,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueDescription (CORBA::tk_struct, sizeof (_oc_IR_ValueDescription), (char *) &_oc_IR_ValueDescription, 0, sizeof (IR_ValueDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueDescription, &_tc_TAO_tc_IR_ValueDescription)
TAO_NAMESPACE_END

void IR_ValueDescription::_tao_any_destructor (void *x)
{
  IR_ValueDescription *tmp = ACE_static_cast (IR_ValueDescription*,x);
  delete tmp;
}


///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ValueBoxDef_Proxy_Impl::_TAO_ValueBoxDef_Proxy_Impl (void)
{}

_TAO_ValueBoxDef_Remote_Proxy_Impl::_TAO_ValueBoxDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_IDLType_ptr _TAO_ValueBoxDef_Remote_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_IDLType_ptr _tao_retval = IR_IDLType::_nil ();
  IR_IDLType_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_original_type_def",
      22,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_IDLType_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ValueBoxDef_Remote_Proxy_Impl::original_type_def (
    CORBA_Object *_collocated_tao_target_,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_original_type_def",
      22,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set ri (
        &_tao_call,
        _collocated_tao_target_,
        original_type_def,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << original_type_def)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ValueBoxDef_Proxy_Broker::_TAO_ValueBoxDef_Proxy_Broker (void)
{
}

_TAO_ValueBoxDef_Proxy_Broker::~_TAO_ValueBoxDef_Proxy_Broker (void)
{
}

_TAO_ValueBoxDef_Proxy_Broker * (*_TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ValueBoxDef_Remote_Proxy_Broker *
_TAO_ValueBoxDef_Remote_Proxy_Broker::the_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ValueBoxDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ValueBoxDef_Remote_Proxy_Broker::_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
{
}

_TAO_ValueBoxDef_Remote_Proxy_Broker::~_TAO_ValueBoxDef_Remote_Proxy_Broker (void)
{
}

_TAO_ValueBoxDef_Proxy_Impl&
_TAO_ValueBoxDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ValueBoxDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ValueBoxDef::IR_ValueBoxDef (int collocated)
{
  this->IR_ValueBoxDef_setup_collocation (collocated);
}

// destructor
IR_ValueBoxDef::~IR_ValueBoxDef (void)
{}

void
IR_ValueBoxDef::IR_ValueBoxDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ValueBoxDef_Proxy_Broker_ =
      _TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ValueBoxDef_Proxy_Broker_ =
      _TAO_ValueBoxDef_Remote_Proxy_Broker::the_TAO_ValueBoxDef_Remote_Proxy_Broker ();
  
  this->IR_TypedefDef_setup_collocation (collocated);
}

void IR_ValueBoxDef::_tao_any_destructor (void *x)
{
  IR_ValueBoxDef *tmp = ACE_static_cast (IR_ValueBoxDef*,x);
  CORBA::release (tmp);
}

IR_ValueBoxDef_ptr IR_ValueBoxDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ValueBoxDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ValueBoxDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ValueBoxDef::_nil ());
      if (is_a == 0)
        return IR_ValueBoxDef::_nil ();
    }
  return IR_ValueBoxDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ValueBoxDef_ptr IR_ValueBoxDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ValueBoxDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ValueBoxDef_ptr default_proxy = IR_ValueBoxDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ValueBoxDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ValueBoxDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ValueBoxDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ValueBoxDef (stub, 0, obj->_servant ()), IR_ValueBoxDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ValueBoxDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ValueBoxDef::_narrow
                    )
                )
          );
}

IR_ValueBoxDef_ptr
IR_ValueBoxDef::_duplicate (IR_ValueBoxDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ValueBoxDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ValueBoxDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/TypedefDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ValueBoxDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ValueBoxDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_TypedefDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_TypedefDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ValueBoxDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ValueBoxDef:1.0";
}

IR_IDLType_ptr IR_ValueBoxDef::original_type_def (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ValueBoxDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
      this,
      ACE_TRY_ENV
    );
}

void IR_ValueBoxDef::original_type_def (
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ValueBoxDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).original_type_def (
      this,
      original_type_def,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_get::result (IR_IDLType_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    IR_IDLType_ptr original_type_def,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    original_type_def_ (original_type_def)
{}

Dynamic::ParameterList *
IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_original_type_def = parameter_list->length ();
  parameter_list->length (length_original_type_def + 1);
  (*parameter_list)[length_original_type_def].argument <<=  this->original_type_def_;
  
  (*parameter_list)[length_original_type_def].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ValueBoxDef::TAO_ClientRequestInfo_IR_ValueBoxDef_original_type_def_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ValueBoxDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x426f7844), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ValueBoxDef:1.0
  12, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65426f78), ACE_NTOHL (0x44656600),  // name = IR_ValueBoxDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ValueBoxDef (CORBA::tk_objref, sizeof (_oc_IR_ValueBoxDef), (char *) &_oc_IR_ValueBoxDef, 0, sizeof (IR_ValueBoxDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ValueBoxDef, &_tc_TAO_tc_IR_ValueBoxDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ProvidesDef_Proxy_Impl::_TAO_ProvidesDef_Proxy_Impl (void)
{}

_TAO_ProvidesDef_Remote_Proxy_Impl::_TAO_ProvidesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_InterfaceDef_ptr _TAO_ProvidesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
     CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_InterfaceDef_ptr _tao_retval = IR_InterfaceDef::_nil ();
  IR_InterfaceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ProvidesDef_Proxy_Broker::_TAO_ProvidesDef_Proxy_Broker (void)
{
}

_TAO_ProvidesDef_Proxy_Broker::~_TAO_ProvidesDef_Proxy_Broker (void)
{
}

_TAO_ProvidesDef_Proxy_Broker * (*_TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ProvidesDef_Remote_Proxy_Broker *
_TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ProvidesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ProvidesDef_Remote_Proxy_Broker::_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
}

_TAO_ProvidesDef_Remote_Proxy_Broker::~_TAO_ProvidesDef_Remote_Proxy_Broker (void)
{
}

_TAO_ProvidesDef_Proxy_Impl&
_TAO_ProvidesDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ProvidesDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ProvidesDef::IR_ProvidesDef (int collocated)
{
  this->IR_ProvidesDef_setup_collocation (collocated);
}

// destructor
IR_ProvidesDef::~IR_ProvidesDef (void)
{}

void
IR_ProvidesDef::IR_ProvidesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ProvidesDef_Proxy_Broker_ =
      _TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ProvidesDef_Proxy_Broker_ =
      _TAO_ProvidesDef_Remote_Proxy_Broker::the_TAO_ProvidesDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
}

void IR_ProvidesDef::_tao_any_destructor (void *x)
{
  IR_ProvidesDef *tmp = ACE_static_cast (IR_ProvidesDef*,x);
  CORBA::release (tmp);
}

IR_ProvidesDef_ptr IR_ProvidesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ProvidesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ProvidesDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ProvidesDef::_nil ());
      if (is_a == 0)
        return IR_ProvidesDef::_nil ();
    }
  return IR_ProvidesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ProvidesDef_ptr IR_ProvidesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ProvidesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ProvidesDef_ptr default_proxy = IR_ProvidesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ProvidesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ProvidesDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ProvidesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ProvidesDef (stub, 0, obj->_servant ()), IR_ProvidesDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ProvidesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ProvidesDef::_narrow
                    )
                )
          );
}

IR_ProvidesDef_ptr
IR_ProvidesDef::_duplicate (IR_ProvidesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ProvidesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ProvidesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ProvidesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ProvidesDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ProvidesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ProvidesDef:1.0";
}

IR_InterfaceDef_ptr IR_ProvidesDef::interface_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ProvidesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).interface_type (
      this,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ProvidesDef::TAO_ClientRequestInfo_IR_ProvidesDef_interface_type_get::result (IR_InterfaceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ProvidesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
  12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = IR_ProvidesDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDef (CORBA::tk_objref, sizeof (_oc_IR_ProvidesDef), (char *) &_oc_IR_ProvidesDef, 0, sizeof (IR_ProvidesDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDef, &_tc_TAO_tc_IR_ProvidesDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ProvidesDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
  20, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
  CORBA::tk_objref, // typecode kind
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
    13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef

};
static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescription (CORBA::tk_struct, sizeof (_oc_IR_ProvidesDescription), (char *) &_oc_IR_ProvidesDescription, 0, sizeof (IR_ProvidesDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescription, &_tc_TAO_tc_IR_ProvidesDescription)
TAO_NAMESPACE_END

void IR_ProvidesDescription::_tao_any_destructor (void *x)
{
  IR_ProvidesDescription *tmp = ACE_static_cast (IR_ProvidesDescription*,x);
  delete tmp;
}


///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_UsesDef_Proxy_Impl::_TAO_UsesDef_Proxy_Impl (void)
{}

_TAO_UsesDef_Remote_Proxy_Impl::_TAO_UsesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_InterfaceDef_ptr _TAO_UsesDef_Remote_Proxy_Impl::interface_type (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_InterfaceDef_ptr _tao_retval = IR_InterfaceDef::_nil ();
  IR_InterfaceDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_interface_type",
      19,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_InterfaceDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::Boolean _TAO_UsesDef_Remote_Proxy_Impl::is_multiple (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_multiple",
      16,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_UsesDef_Proxy_Broker::_TAO_UsesDef_Proxy_Broker (void)
{
}

_TAO_UsesDef_Proxy_Broker::~_TAO_UsesDef_Proxy_Broker (void)
{
}


_TAO_UsesDef_Proxy_Broker * (*_TAO_UsesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_UsesDef_Remote_Proxy_Broker *
_TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_UsesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_UsesDef_Remote_Proxy_Broker::_TAO_UsesDef_Remote_Proxy_Broker (void)
{
}

_TAO_UsesDef_Remote_Proxy_Broker::~_TAO_UsesDef_Remote_Proxy_Broker (void)
{
}

_TAO_UsesDef_Proxy_Impl&
_TAO_UsesDef_Remote_Proxy_Broker::select_proxy (
  ::IR_UsesDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_UsesDef::IR_UsesDef (int collocated)
{
  this->IR_UsesDef_setup_collocation (collocated);
}

// destructor
IR_UsesDef::~IR_UsesDef (void)
{}

void
IR_UsesDef::IR_UsesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_UsesDef_Proxy_Broker_ =
      _TAO_UsesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_UsesDef_Proxy_Broker_ =
      _TAO_UsesDef_Remote_Proxy_Broker::the_TAO_UsesDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
}

void IR_UsesDef::_tao_any_destructor (void *x)
{
  IR_UsesDef *tmp = ACE_static_cast (IR_UsesDef*,x);
  CORBA::release (tmp);
}

IR_UsesDef_ptr IR_UsesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_UsesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/UsesDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_UsesDef::_nil ());
      if (is_a == 0)
        return IR_UsesDef::_nil ();
    }
  return IR_UsesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_UsesDef_ptr IR_UsesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_UsesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_UsesDef_ptr default_proxy = IR_UsesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_UsesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_UsesDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_UsesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_UsesDef (stub, 0, obj->_servant ()), IR_UsesDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_UsesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_UsesDef::_narrow
                    )
                )
          );
}

IR_UsesDef_ptr
IR_UsesDef::_duplicate (IR_UsesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_UsesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/UsesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_UsesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_UsesDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_UsesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/UsesDef:1.0";
}

IR_InterfaceDef_ptr IR_UsesDef::interface_type (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).interface_type (
      this,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_UsesDef::is_multiple (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_UsesDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_multiple (
      this,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_interface_type_get::result (IR_InterfaceDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_UsesDef::TAO_ClientRequestInfo_IR_UsesDef_is_multiple_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_UsesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
  8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = IR_UsesDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_UsesDef (CORBA::tk_objref, sizeof (_oc_IR_UsesDef), (char *) &_oc_IR_UsesDef, 0, sizeof (IR_UsesDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDef, &_tc_TAO_tc_IR_UsesDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_UsesDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
  16, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = UsesDescription
  6, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
  CORBA::tk_objref, // typecode kind
  60, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
    13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef

  12, ACE_NTOHL (0x69735f6d), ACE_NTOHL (0x756c7469), ACE_NTOHL (0x706c6500),  // name = is_multiple
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescription (CORBA::tk_struct, sizeof (_oc_IR_UsesDescription), (char *) &_oc_IR_UsesDescription, 0, sizeof (IR_UsesDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescription, &_tc_TAO_tc_IR_UsesDescription)
TAO_NAMESPACE_END

void IR_UsesDescription::_tao_any_destructor (void *x)
{
  IR_UsesDescription *tmp = ACE_static_cast (IR_UsesDescription*,x);
  delete tmp;
}

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_ProvidesDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_ProvidesDescription *old = ACE_reinterpret_cast (IR_ProvidesDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_ProvidesDescription *tmp = ACE_reinterpret_cast (IR_ProvidesDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq::~_TAO_Unbounded_Sequence_IR_ProvidesDescSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_ProvidesDescSeq
// *************************************************************

IR_ProvidesDescSeq::IR_ProvidesDescSeq (void)
{}
IR_ProvidesDescSeq::IR_ProvidesDescSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_ProvidesDescSeq::IR_ProvidesDescSeq (CORBA::ULong max, CORBA::ULong length, IR_ProvidesDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_ProvidesDescSeq::IR_ProvidesDescSeq (const IR_ProvidesDescSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_ProvidesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_ProvidesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_ProvidesDescSeq::~IR_ProvidesDescSeq (void) // dtor
{}
void IR_ProvidesDescSeq::_tao_any_destructor (void *x)
{
  IR_ProvidesDescSeq *tmp = ACE_static_cast (IR_ProvidesDescSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_ProvidesDescSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736353), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescSeq:1.0
  16, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x53657100),  // name = ProvidesDescSeq
  CORBA::tk_sequence, // typecode kind
  524, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    508, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      39, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDescription:1.0
      20, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = ProvidesDescription
      5, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
      CORBA::tk_objref, // typecode kind
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
        13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ProvidesDescSeq (CORBA::tk_alias, sizeof (_oc_IR_ProvidesDescSeq), (char *) &_oc_IR_ProvidesDescSeq, 0, sizeof (IR_ProvidesDescSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ProvidesDescSeq, &_tc_TAO_tc_IR_ProvidesDescSeq)
TAO_NAMESPACE_END

#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  
  void
  _TAO_Unbounded_Sequence_IR_UsesDescSeq::_allocate_buffer (CORBA::ULong length)
  {
    IR_UsesDescription* tmp = 0;
    tmp = _TAO_Unbounded_Sequence_IR_UsesDescSeq::allocbuf (length);
    
    if (this->buffer_ != 0)
    {
      IR_UsesDescription *old = ACE_reinterpret_cast (IR_UsesDescription *,this->buffer_);
      
      for (CORBA::ULong i = 0; i < this->length_; ++i)
        tmp[i] = old[i];
      
      if (this->release_)
        _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (old);
      
    }
    this->buffer_ = tmp;
  }
  
  void
  _TAO_Unbounded_Sequence_IR_UsesDescSeq::_deallocate_buffer (void)
  {
    if (this->buffer_ == 0 || this->release_ == 0)
      return;
    
    IR_UsesDescription *tmp = ACE_reinterpret_cast (IR_UsesDescription *,this->buffer_);
    
    _TAO_Unbounded_Sequence_IR_UsesDescSeq::freebuf (tmp);
    this->buffer_ = 0;
  } 
  
  _TAO_Unbounded_Sequence_IR_UsesDescSeq::~_TAO_Unbounded_Sequence_IR_UsesDescSeq (void) // Dtor.
  {
    this->_deallocate_buffer ();
  }
  
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 

// *************************************************************
// IR_UsesDescSeq
// *************************************************************

IR_UsesDescSeq::IR_UsesDescSeq (void)
{}
IR_UsesDescSeq::IR_UsesDescSeq (CORBA::ULong max) // uses max size
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max)
{}
IR_UsesDescSeq::IR_UsesDescSeq (CORBA::ULong max, CORBA::ULong length, IR_UsesDescription *buffer, CORBA::Boolean release)
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (max, length, buffer, release)
{}
IR_UsesDescSeq::IR_UsesDescSeq (const IR_UsesDescSeq &seq) // copy ctor
  : 
#if !defined (TAO_USE_SEQUENCE_TEMPLATES)
  _TAO_Unbounded_Sequence_IR_UsesDescSeq
#else /* TAO_USE_SEQUENCE_TEMPLATES */
  TAO_Unbounded_Sequence<IR_UsesDescription>
#endif /* !TAO_USE_SEQUENCE_TEMPLATES */ 
 (seq)
{}
IR_UsesDescSeq::~IR_UsesDescSeq (void) // dtor
{}
void IR_UsesDescSeq::_tao_any_destructor (void *x)
{
  IR_UsesDescSeq *tmp = ACE_static_cast (IR_UsesDescSeq*,x);
  delete tmp;
}

static const CORBA::Long _oc_IR_UsesDescSeq[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736353), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescSeq:1.0
  12, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x53657100),  // name = UsesDescSeq
  CORBA::tk_sequence, // typecode kind
  536, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    CORBA::tk_struct, // typecode kind
    520, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDescription:1.0
      16, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = UsesDescription
      6, // member count
      5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
        11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
        CORBA::tk_string, 
        0U, // string length

      3, ACE_NTOHL (0x69640000),  // name = id
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
      CORBA::tk_alias, // typecode kind for typedefs
      64, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
        12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
        CORBA::tk_string, 
        0U, // string length

      15, ACE_NTOHL (0x696e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x655f7479), ACE_NTOHL (0x70650000),  // name = interface_type
      CORBA::tk_objref, // typecode kind
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x6e746572), ACE_NTOHL (0x66616365), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/InterfaceDef:1.0
        13, ACE_NTOHL (0x496e7465), ACE_NTOHL (0x72666163), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_InterfaceDef

      12, ACE_NTOHL (0x69735f6d), ACE_NTOHL (0x756c7469), ACE_NTOHL (0x706c6500),  // name = is_multiple
      CORBA::tk_boolean,


    0U,

};
static CORBA::TypeCode _tc_TAO_tc_IR_UsesDescSeq (CORBA::tk_alias, sizeof (_oc_IR_UsesDescSeq), (char *) &_oc_IR_UsesDescSeq, 0, sizeof (IR_UsesDescSeq));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_UsesDescSeq, &_tc_TAO_tc_IR_UsesDescSeq)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_EventDef_Proxy_Impl::_TAO_EventDef_Proxy_Impl (void)
{}

_TAO_EventDef_Remote_Proxy_Impl::_TAO_EventDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::Boolean _TAO_EventDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        event_id,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << event_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

IR_ValueDef_ptr _TAO_EventDef_Remote_Proxy_Impl::event (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ValueDef_ptr _tao_retval = IR_ValueDef::_nil ();
  IR_ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_event",
      10,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_EventDef_Proxy_Broker::_TAO_EventDef_Proxy_Broker (void)
{
}

_TAO_EventDef_Proxy_Broker::~_TAO_EventDef_Proxy_Broker (void)
{
}

_TAO_EventDef_Proxy_Broker * (*_TAO_EventDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_EventDef_Remote_Proxy_Broker *
_TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_EventDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_EventDef_Remote_Proxy_Broker::_TAO_EventDef_Remote_Proxy_Broker (void)
{
}

_TAO_EventDef_Remote_Proxy_Broker::~_TAO_EventDef_Remote_Proxy_Broker (void)
{
}

_TAO_EventDef_Proxy_Impl&
_TAO_EventDef_Remote_Proxy_Broker::select_proxy (
  ::IR_EventDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_EventDef::IR_EventDef (int collocated)
{
  this->IR_EventDef_setup_collocation (collocated);
}

// destructor
IR_EventDef::~IR_EventDef (void)
{}

void
IR_EventDef::IR_EventDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EventDef_Proxy_Broker_ =
      _TAO_EventDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EventDef_Proxy_Broker_ =
      _TAO_EventDef_Remote_Proxy_Broker::the_TAO_EventDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
}

void IR_EventDef::_tao_any_destructor (void *x)
{
  IR_EventDef *tmp = ACE_static_cast (IR_EventDef*,x);
  CORBA::release (tmp);
}

IR_EventDef_ptr IR_EventDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_EventDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EventDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_EventDef::_nil ());
      if (is_a == 0)
        return IR_EventDef::_nil ();
    }
  return IR_EventDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_EventDef_ptr IR_EventDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_EventDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_EventDef_ptr default_proxy = IR_EventDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_EventDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_EventDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_EventDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_EventDef (stub, 0, obj->_servant ()), IR_EventDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_EventDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_EventDef::_narrow
                    )
                )
          );
}

IR_EventDef_ptr
IR_EventDef::_duplicate (IR_EventDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_EventDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_EventDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_EventDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_EventDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EventDef:1.0";
}

CORBA::Boolean IR_EventDef::is_a (
    const char * event_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
      this,
      event_id,
      ACE_TRY_ENV
    );
}

IR_ValueDef_ptr IR_EventDef::event (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_EventDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).event (
      this,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::TAO_ClientRequestInfo_IR_EventDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * event_id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    event_id_ (event_id)
{}

Dynamic::ParameterList *
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_event_id = parameter_list->length ();
  parameter_list->length (length_event_id + 1);
  (*parameter_list)[length_event_id].argument <<= event_id_;
  (*parameter_list)[length_event_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_is_a::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::TAO_ClientRequestInfo_IR_EventDef_event_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_EventDef::TAO_ClientRequestInfo_IR_EventDef_event_get::result (IR_ValueDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_EventDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x76656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDef:1.0
  9, ACE_NTOHL (0x4576656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = IR_EventDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_EventDef (CORBA::tk_objref, sizeof (_oc_IR_EventDef), (char *) &_oc_IR_EventDef, 0, sizeof (IR_EventDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDef, &_tc_TAO_tc_IR_EventDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_EventDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x76656e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EventDescription:1.0
  17, ACE_NTOHL (0x4576656e), ACE_NTOHL (0x74446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = EventDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  6, ACE_NTOHL (0x76616c75), ACE_NTOHL (0x65000000),  // name = value
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
    9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_ValueDef

};
static CORBA::TypeCode _tc_TAO_tc_IR_EventDescription (CORBA::tk_struct, sizeof (_oc_IR_EventDescription), (char *) &_oc_IR_EventDescription, 0, sizeof (IR_EventDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EventDescription, &_tc_TAO_tc_IR_EventDescription)
TAO_NAMESPACE_END

void IR_EventDescription::_tao_any_destructor (void *x)
{
  IR_EventDescription *tmp = ACE_static_cast (IR_EventDescription*,x);
  delete tmp;
}


///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_EmitsDef_Proxy_Impl::_TAO_EmitsDef_Proxy_Impl (void)
{}

_TAO_EmitsDef_Remote_Proxy_Impl::_TAO_EmitsDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_EmitsDef_Proxy_Broker::_TAO_EmitsDef_Proxy_Broker (void)
{
}

_TAO_EmitsDef_Proxy_Broker::~_TAO_EmitsDef_Proxy_Broker (void)
{
}

_TAO_EmitsDef_Proxy_Broker * (*_TAO_EmitsDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_EmitsDef_Remote_Proxy_Broker *
_TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_EmitsDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_EmitsDef_Remote_Proxy_Broker::_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
}

_TAO_EmitsDef_Remote_Proxy_Broker::~_TAO_EmitsDef_Remote_Proxy_Broker (void)
{
}

_TAO_EmitsDef_Proxy_Impl&
_TAO_EmitsDef_Remote_Proxy_Broker::select_proxy (
  ::IR_EmitsDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_EmitsDef::IR_EmitsDef (int collocated)
{
  this->IR_EmitsDef_setup_collocation (collocated);
}

// destructor
IR_EmitsDef::~IR_EmitsDef (void)
{}

void
IR_EmitsDef::IR_EmitsDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_EmitsDef_Proxy_Broker_ =
      _TAO_EmitsDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_EmitsDef_Proxy_Broker_ =
      _TAO_EmitsDef_Remote_Proxy_Broker::the_TAO_EmitsDef_Remote_Proxy_Broker ();
  
  this->IR_EventDef_setup_collocation (collocated);
}

void IR_EmitsDef::_tao_any_destructor (void *x)
{
  IR_EmitsDef *tmp = ACE_static_cast (IR_EmitsDef*,x);
  CORBA::release (tmp);
}

IR_EmitsDef_ptr IR_EmitsDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_EmitsDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/EmitsDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_EmitsDef::_nil ());
      if (is_a == 0)
        return IR_EmitsDef::_nil ();
    }
  return IR_EmitsDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_EmitsDef_ptr IR_EmitsDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_EmitsDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_EmitsDef_ptr default_proxy = IR_EmitsDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_EmitsDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_EmitsDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_EmitsDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_EmitsDef (stub, 0, obj->_servant ()), IR_EmitsDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_EmitsDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_EmitsDef::_narrow
                    )
                )
          );
}

IR_EmitsDef_ptr
IR_EmitsDef::_duplicate (IR_EmitsDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_EmitsDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EmitsDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_EmitsDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_EmitsDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_EventDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_EmitsDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/EmitsDef:1.0";
}

static const CORBA::Long _oc_IR_EmitsDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
  9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_EmitsDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_EmitsDef (CORBA::tk_objref, sizeof (_oc_IR_EmitsDef), (char *) &_oc_IR_EmitsDef, 0, sizeof (IR_EmitsDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_EmitsDef, &_tc_TAO_tc_IR_EmitsDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_PublishesDef_Proxy_Impl::_TAO_PublishesDef_Proxy_Impl (void)
{}

_TAO_PublishesDef_Remote_Proxy_Impl::_TAO_PublishesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_PublishesDef_Proxy_Broker::_TAO_PublishesDef_Proxy_Broker (void)
{
}

_TAO_PublishesDef_Proxy_Broker::~_TAO_PublishesDef_Proxy_Broker (void)
{
}

_TAO_PublishesDef_Proxy_Broker * (*_TAO_PublishesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_PublishesDef_Remote_Proxy_Broker *
_TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_PublishesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_PublishesDef_Remote_Proxy_Broker::_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
}

_TAO_PublishesDef_Remote_Proxy_Broker::~_TAO_PublishesDef_Remote_Proxy_Broker (void)
{
}

_TAO_PublishesDef_Proxy_Impl&
_TAO_PublishesDef_Remote_Proxy_Broker::select_proxy (
  ::IR_PublishesDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_PublishesDef::IR_PublishesDef (int collocated)
{
  this->IR_PublishesDef_setup_collocation (collocated);
}

// destructor
IR_PublishesDef::~IR_PublishesDef (void)
{}

void
IR_PublishesDef::IR_PublishesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PublishesDef_Proxy_Broker_ =
      _TAO_PublishesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PublishesDef_Proxy_Broker_ =
      _TAO_PublishesDef_Remote_Proxy_Broker::the_TAO_PublishesDef_Remote_Proxy_Broker ();
  
  this->IR_EventDef_setup_collocation (collocated);
}

void IR_PublishesDef::_tao_any_destructor (void *x)
{
  IR_PublishesDef *tmp = ACE_static_cast (IR_PublishesDef*,x);
  CORBA::release (tmp);
}

IR_PublishesDef_ptr IR_PublishesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_PublishesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PublishesDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_PublishesDef::_nil ());
      if (is_a == 0)
        return IR_PublishesDef::_nil ();
    }
  return IR_PublishesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_PublishesDef_ptr IR_PublishesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_PublishesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_PublishesDef_ptr default_proxy = IR_PublishesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_PublishesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_PublishesDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_PublishesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_PublishesDef (stub, 0, obj->_servant ()), IR_PublishesDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_PublishesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_PublishesDef::_narrow
                    )
                )
          );
}

IR_PublishesDef_ptr
IR_PublishesDef::_duplicate (IR_PublishesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_PublishesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PublishesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_PublishesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_PublishesDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_EventDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_PublishesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PublishesDef:1.0";
}

static const CORBA::Long _oc_IR_PublishesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
  13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_PublishesDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_PublishesDef (CORBA::tk_objref, sizeof (_oc_IR_PublishesDef), (char *) &_oc_IR_PublishesDef, 0, sizeof (IR_PublishesDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PublishesDef, &_tc_TAO_tc_IR_PublishesDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ConsumesDef_Proxy_Impl::_TAO_ConsumesDef_Proxy_Impl (void)
{}

_TAO_ConsumesDef_Remote_Proxy_Impl::_TAO_ConsumesDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ConsumesDef_Proxy_Broker::_TAO_ConsumesDef_Proxy_Broker (void)
{
}

_TAO_ConsumesDef_Proxy_Broker::~_TAO_ConsumesDef_Proxy_Broker (void)
{
}

_TAO_ConsumesDef_Proxy_Broker * (*_TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ConsumesDef_Remote_Proxy_Broker *
_TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ConsumesDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ConsumesDef_Remote_Proxy_Broker::_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
}

_TAO_ConsumesDef_Remote_Proxy_Broker::~_TAO_ConsumesDef_Remote_Proxy_Broker (void)
{
}

_TAO_ConsumesDef_Proxy_Impl&
_TAO_ConsumesDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ConsumesDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ConsumesDef::IR_ConsumesDef (int collocated)
{
  this->IR_ConsumesDef_setup_collocation (collocated);
}

// destructor
IR_ConsumesDef::~IR_ConsumesDef (void)
{}

void
IR_ConsumesDef::IR_ConsumesDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ConsumesDef_Proxy_Broker_ =
      _TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ConsumesDef_Proxy_Broker_ =
      _TAO_ConsumesDef_Remote_Proxy_Broker::the_TAO_ConsumesDef_Remote_Proxy_Broker ();
  
  this->IR_EventDef_setup_collocation (collocated);
}

void IR_ConsumesDef::_tao_any_destructor (void *x)
{
  IR_ConsumesDef *tmp = ACE_static_cast (IR_ConsumesDef*,x);
  CORBA::release (tmp);
}

IR_ConsumesDef_ptr IR_ConsumesDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ConsumesDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ConsumesDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ConsumesDef::_nil ());
      if (is_a == 0)
        return IR_ConsumesDef::_nil ();
    }
  return IR_ConsumesDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ConsumesDef_ptr IR_ConsumesDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ConsumesDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ConsumesDef_ptr default_proxy = IR_ConsumesDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ConsumesDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ConsumesDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ConsumesDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ConsumesDef (stub, 0, obj->_servant ()), IR_ConsumesDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ConsumesDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ConsumesDef::_narrow
                    )
                )
          );
}

IR_ConsumesDef_ptr
IR_ConsumesDef::_duplicate (IR_ConsumesDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ConsumesDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ConsumesDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/EventDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ConsumesDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ConsumesDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_EventDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_EventDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ConsumesDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ConsumesDef:1.0";
}

static const CORBA::Long _oc_IR_ConsumesDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
  12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = IR_ConsumesDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ConsumesDef (CORBA::tk_objref, sizeof (_oc_IR_ConsumesDef), (char *) &_oc_IR_ConsumesDef, 0, sizeof (IR_ConsumesDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ConsumesDef, &_tc_TAO_tc_IR_ConsumesDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_ComponentDef_Proxy_Impl::_TAO_ComponentDef_Proxy_Impl (void)
{}

_TAO_ComponentDef_Remote_Proxy_Impl::_TAO_ComponentDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_InterfaceDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_InterfaceDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_InterfaceDefSeq, _tao_retval);
  IR_InterfaceDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_supported_interfaces",
      25,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_InterfaceDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

void _TAO_ComponentDef_Remote_Proxy_Impl::supported_interfaces (
    CORBA_Object *_collocated_tao_target_,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW (CORBA::INTERNAL ());

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_set_supported_interfaces",
      25,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set ri (
        &_tao_call,
        _collocated_tao_target_,
        supported_interfaces,
        ACE_TRY_ENV
      );
      ACE_CHECK;
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK;
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK;
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << supported_interfaces)
            ))
            TAO_INTERCEPTOR_THROW (
              CORBA::MARSHAL ()
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK;
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES)
              );
              
            }
          
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK;
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK;
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  
}

IR_ComponentDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::base_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ComponentDef_ptr _tao_retval = IR_ComponentDef::_nil ();
  IR_ComponentDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_component",
      19,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ProvidesDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::provides_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ProvidesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_ProvidesDefSeq, _tao_retval);
  IR_ProvidesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_provides_interfaces",
      24,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ProvidesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_UsesDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::uses_interfaces (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_UsesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_UsesDefSeq, _tao_retval);
  IR_UsesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_uses_interfaces",
      20,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_UsesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_EmitsDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::emits_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_EmitsDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_EmitsDefSeq, _tao_retval);
  IR_EmitsDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_emits_events",
      17,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_EmitsDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_PublishesDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::publishes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_PublishesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_PublishesDefSeq, _tao_retval);
  IR_PublishesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_publishes_events",
      21,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_PublishesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ConsumesDefSeq * _TAO_ComponentDef_Remote_Proxy_Impl::consumes_events (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ConsumesDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_ConsumesDefSeq, _tao_retval);
  IR_ConsumesDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_consumes_events",
      20,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ConsumesDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::Boolean _TAO_ComponentDef_Remote_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_basic",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

IR_ProvidesDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_provides (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ProvidesDef_ptr _tao_retval = IR_ProvidesDef::_nil ();
  IR_ProvidesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_provides",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        interface_type,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ProvidesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_UsesDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_uses (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_UsesDef_ptr _tao_retval = IR_UsesDef::_nil ();
  IR_UsesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_uses",
      11,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        interface_type,
        is_multiple,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << interface_type) &&
              (_tao_out << CORBA::Any::from_boolean (is_multiple))
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_UsesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_EmitsDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_emits (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_EmitsDef_ptr _tao_retval = IR_EmitsDef::_nil ();
  IR_EmitsDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_emits",
      12,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_EmitsDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_PublishesDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_publishes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_PublishesDef_ptr _tao_retval = IR_PublishesDef::_nil ();
  IR_PublishesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_publishes",
      16,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_PublishesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ConsumesDef_ptr _TAO_ComponentDef_Remote_Proxy_Impl::create_consumes (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ConsumesDef_ptr _tao_retval = IR_ConsumesDef::_nil ();
  IR_ConsumesDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_consumes",
      15,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        value,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << value)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ConsumesDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_ComponentDef_Proxy_Broker::_TAO_ComponentDef_Proxy_Broker (void)
{
}

_TAO_ComponentDef_Proxy_Broker::~_TAO_ComponentDef_Proxy_Broker (void)
{
}

_TAO_ComponentDef_Proxy_Broker * (*_TAO_ComponentDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_ComponentDef_Remote_Proxy_Broker *
_TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_ComponentDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_ComponentDef_Remote_Proxy_Broker::_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
}

_TAO_ComponentDef_Remote_Proxy_Broker::~_TAO_ComponentDef_Remote_Proxy_Broker (void)
{
}

_TAO_ComponentDef_Proxy_Impl&
_TAO_ComponentDef_Remote_Proxy_Broker::select_proxy (
  ::IR_ComponentDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_ComponentDef::IR_ComponentDef (int collocated)
{
  this->IR_ComponentDef_setup_collocation (collocated);
}

// destructor
IR_ComponentDef::~IR_ComponentDef (void)
{}

void
IR_ComponentDef::IR_ComponentDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_ComponentDef_Proxy_Broker_ =
      _TAO_ComponentDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_ComponentDef_Proxy_Broker_ =
      _TAO_ComponentDef_Remote_Proxy_Broker::the_TAO_ComponentDef_Remote_Proxy_Broker ();
  
  this->IR_InterfaceDef_setup_collocation (collocated);
}

void IR_ComponentDef::_tao_any_destructor (void *x)
{
  IR_ComponentDef *tmp = ACE_static_cast (IR_ComponentDef*,x);
  CORBA::release (tmp);
}

IR_ComponentDef_ptr IR_ComponentDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_ComponentDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/ComponentDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_ComponentDef::_nil ());
      if (is_a == 0)
        return IR_ComponentDef::_nil ();
    }
  return IR_ComponentDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_ComponentDef_ptr IR_ComponentDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_ComponentDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_ComponentDef_ptr default_proxy = IR_ComponentDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_ComponentDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_ComponentDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_ComponentDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_ComponentDef (stub, 0, obj->_servant ()), IR_ComponentDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_ComponentDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_ComponentDef::_narrow
                    )
                )
          );
}

IR_ComponentDef_ptr
IR_ComponentDef::_duplicate (IR_ComponentDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_ComponentDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/ComponentDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_ComponentDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_ComponentDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_InterfaceDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_InterfaceDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_ComponentDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/ComponentDef:1.0";
}

IR_InterfaceDefSeq * IR_ComponentDef::supported_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
      this,
      ACE_TRY_ENV
    );
}

void IR_ComponentDef::supported_interfaces (
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).supported_interfaces (
      this,
      supported_interfaces,
      ACE_TRY_ENV
    );
}

IR_ComponentDef_ptr IR_ComponentDef::base_component (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_component (
      this,
      ACE_TRY_ENV
    );
}

IR_ProvidesDefSeq * IR_ComponentDef::provides_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).provides_interfaces (
      this,
      ACE_TRY_ENV
    );
}

IR_UsesDefSeq * IR_ComponentDef::uses_interfaces (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).uses_interfaces (
      this,
      ACE_TRY_ENV
    );
}

IR_EmitsDefSeq * IR_ComponentDef::emits_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).emits_events (
      this,
      ACE_TRY_ENV
    );
}

IR_PublishesDefSeq * IR_ComponentDef::publishes_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).publishes_events (
      this,
      ACE_TRY_ENV
    );
}

IR_ConsumesDefSeq * IR_ComponentDef::consumes_events (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).consumes_events (
      this,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_ComponentDef::is_basic (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_basic (
      this,
      ACE_TRY_ENV
    );
}

IR_ProvidesDef_ptr IR_ComponentDef::create_provides (
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_provides (
      this,
      id,
      name,
      version,
      interface_type,
      ACE_TRY_ENV
    );
}

IR_UsesDef_ptr IR_ComponentDef::create_uses (
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Boolean is_multiple,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_uses (
      this,
      id,
      name,
      version,
      interface_type,
      is_multiple,
      ACE_TRY_ENV
    );
}

IR_EmitsDef_ptr IR_ComponentDef::create_emits (
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_emits (
      this,
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );
}

IR_PublishesDef_ptr IR_ComponentDef::create_publishes (
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_publishes (
      this,
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );
}

IR_ConsumesDef_ptr IR_ComponentDef::create_consumes (
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_ComponentDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_consumes (
      this,
      id,
      name,
      version,
      value,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_get::result (IR_InterfaceDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const IR_InterfaceDefSeq & supported_interfaces,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    supported_interfaces_ (supported_interfaces)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_supported_interfaces = parameter_list->length ();
  parameter_list->length (length_supported_interfaces + 1);
  (*parameter_list)[length_supported_interfaces].argument <<=  this->supported_interfaces_;
  
  (*parameter_list)[length_supported_interfaces].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_supported_interfaces_set::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 1;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return result_any;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_base_component_get::result (IR_ComponentDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_provides_interfaces_get::result (IR_ProvidesDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_uses_interfaces_get::result (IR_UsesDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_emits_events_get::result (IR_EmitsDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_publishes_events_get::result (IR_PublishesDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_consumes_events_get::result (IR_ConsumesDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_is_basic_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::TAO_ClientRequestInfo_IR_ComponentDef_create_provides (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_interface_type = parameter_list->length ();
  parameter_list->length (length_interface_type + 1);
  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;
  
  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_provides::result (IR_ProvidesDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::TAO_ClientRequestInfo_IR_ComponentDef_create_uses (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_InterfaceDef_ptr interface_type,
    const CORBA::Boolean & is_multiple,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    interface_type_ (interface_type),
    is_multiple_ (is_multiple)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_interface_type = parameter_list->length ();
  parameter_list->length (length_interface_type + 1);
  (*parameter_list)[length_interface_type].argument <<=  this->interface_type_;
  
  (*parameter_list)[length_interface_type].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_is_multiple = parameter_list->length ();
  parameter_list->length (length_is_multiple + 1);
  (*parameter_list)[length_is_multiple].argument <<= CORBA::Any::from_boolean (this->is_multiple_);
  (*parameter_list)[length_is_multiple].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_uses::result (IR_UsesDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::TAO_ClientRequestInfo_IR_ComponentDef_create_emits (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_emits::result (IR_EmitsDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_publishes::result (IR_PublishesDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr value,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    value_ (value)
{}

Dynamic::ParameterList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_value = parameter_list->length ();
  parameter_list->length (length_value + 1);
  (*parameter_list)[length_value].argument <<=  this->value_;
  
  (*parameter_list)[length_value].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_ComponentDef::TAO_ClientRequestInfo_IR_ComponentDef_create_consumes::result (IR_ConsumesDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_ComponentDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDef:1.0
  13, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446566), ACE_NTOHL (0x0),  // name = IR_ComponentDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDef (CORBA::tk_objref, sizeof (_oc_IR_ComponentDef), (char *) &_oc_IR_ComponentDef, 0, sizeof (IR_ComponentDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDef, &_tc_TAO_tc_IR_ComponentDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_ComponentDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6d706f), ACE_NTOHL (0x6e656e74), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ComponentDescription:1.0
  21, ACE_NTOHL (0x436f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ComponentDescription
  13, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  15, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f636f6d), ACE_NTOHL (0x706f6e65), ACE_NTOHL (0x6e740000),  // name = base_component
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  20, ACE_NTOHL (0x73757070), ACE_NTOHL (0x6f727473), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = supports_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  156, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x79496453), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/RepositoryIdSeq:1.0
    16, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x53657100),  // name = RepositoryIdSeq
    CORBA::tk_sequence, // typecode kind
    84, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_alias, // typecode kind for typedefs
      68, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
        13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
        CORBA::tk_string, 
        0U, // string length

      0U,


  20, ACE_NTOHL (0x70726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = provides_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ProvidesDefSeq:1.0
    15, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_ProvidesDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x726f7669), ACE_NTOHL (0x64657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ProvidesDef:1.0
        12, ACE_NTOHL (0x50726f76), ACE_NTOHL (0x69646573), ACE_NTOHL (0x44656600),  // name = IR_ProvidesDef

      0U,


  16, ACE_NTOHL (0x75736573), ACE_NTOHL (0x5f696e74), ACE_NTOHL (0x65726661), ACE_NTOHL (0x63657300),  // name = uses_interfaces
  CORBA::tk_alias, // typecode kind for typedefs
  128, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/UsesDefSeq:1.0
    11, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_UsesDefSeq
    CORBA::tk_sequence, // typecode kind
    64, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      48, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f55), ACE_NTOHL (0x73657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/UsesDef:1.0
        8, ACE_NTOHL (0x55736573), ACE_NTOHL (0x44656600),  // name = IR_UsesDef

      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  1788, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1708, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1692, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  13, ACE_NTOHL (0x656d6974), ACE_NTOHL (0x735f6576), ACE_NTOHL (0x656e7473), ACE_NTOHL (0x0),  // name = emits_events
  CORBA::tk_alias, // typecode kind for typedefs
  132, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/EmitsDefSeq:1.0
    12, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = IR_EmitsDefSeq
    CORBA::tk_sequence, // typecode kind
    68, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      52, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x6d697473), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/EmitsDef:1.0
        9, ACE_NTOHL (0x456d6974), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_EmitsDef

      0U,


  17, ACE_NTOHL (0x7075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x735f6576), ACE_NTOHL (0x656e7473), ACE_NTOHL (0x0),  // name = publishes_events
  CORBA::tk_alias, // typecode kind for typedefs
  148, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65713a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/PublishesDefSeq:1.0
    16, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x53657100),  // name = IR_PublishesDefSeq
    CORBA::tk_sequence, // typecode kind
    76, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      60, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x75626c69), ACE_NTOHL (0x73686573), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/PublishesDef:1.0
        13, ACE_NTOHL (0x5075626c), ACE_NTOHL (0x69736865), ACE_NTOHL (0x73446566), ACE_NTOHL (0x0),  // name = IR_PublishesDef

      0U,


  16, ACE_NTOHL (0x636f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x5f657665), ACE_NTOHL (0x6e747300),  // name = consumes_events
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    34, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65665365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/ConsumesDefSeq:1.0
    15, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656653), ACE_NTOHL (0x65710000),  // name = IR_ConsumesDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7375), ACE_NTOHL (0x6d657344), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/ConsumesDef:1.0
        12, ACE_NTOHL (0x436f6e73), ACE_NTOHL (0x756d6573), ACE_NTOHL (0x44656600),  // name = IR_ConsumesDef

      0U,


  9, ACE_NTOHL (0x69735f62), ACE_NTOHL (0x61736963), ACE_NTOHL (0x0),  // name = is_basic
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_IR_ComponentDescription (CORBA::tk_struct, sizeof (_oc_IR_ComponentDescription), (char *) &_oc_IR_ComponentDescription, 0, sizeof (IR_ComponentDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_ComponentDescription, &_tc_TAO_tc_IR_ComponentDescription)
TAO_NAMESPACE_END

void IR_ComponentDescription::_tao_any_destructor (void *x)
{
  IR_ComponentDescription *tmp = ACE_static_cast (IR_ComponentDescription*,x);
  delete tmp;
}


///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_PrimaryKeyDef_Proxy_Impl::_TAO_PrimaryKeyDef_Proxy_Impl (void)
{}

_TAO_PrimaryKeyDef_Remote_Proxy_Impl::_TAO_PrimaryKeyDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

CORBA::Boolean _TAO_PrimaryKeyDef_Remote_Proxy_Impl::is_a (
    CORBA_Object *_collocated_tao_target_,
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "is_a",
      4,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a ri (
        &_tao_call,
        _collocated_tao_target_,
        primary_key_id,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << primary_key_id)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              _tao_retval
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

IR_ValueDef_ptr _TAO_PrimaryKeyDef_Remote_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ValueDef_ptr _tao_retval = IR_ValueDef::_nil ();
  IR_ValueDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ValueDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_PrimaryKeyDef_Proxy_Broker::_TAO_PrimaryKeyDef_Proxy_Broker (void)
{
}

_TAO_PrimaryKeyDef_Proxy_Broker::~_TAO_PrimaryKeyDef_Proxy_Broker (void)
{
}

_TAO_PrimaryKeyDef_Proxy_Broker * (*_TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_PrimaryKeyDef_Remote_Proxy_Broker *
_TAO_PrimaryKeyDef_Remote_Proxy_Broker::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_PrimaryKeyDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_PrimaryKeyDef_Remote_Proxy_Broker::_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
}

_TAO_PrimaryKeyDef_Remote_Proxy_Broker::~_TAO_PrimaryKeyDef_Remote_Proxy_Broker (void)
{
}

_TAO_PrimaryKeyDef_Proxy_Impl&
_TAO_PrimaryKeyDef_Remote_Proxy_Broker::select_proxy (
  ::IR_PrimaryKeyDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_PrimaryKeyDef::IR_PrimaryKeyDef (int collocated)
{
  this->IR_PrimaryKeyDef_setup_collocation (collocated);
}

// destructor
IR_PrimaryKeyDef::~IR_PrimaryKeyDef (void)
{}

void
IR_PrimaryKeyDef::IR_PrimaryKeyDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_ =
      _TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_PrimaryKeyDef_Proxy_Broker_ =
      _TAO_PrimaryKeyDef_Remote_Proxy_Broker::the_TAO_PrimaryKeyDef_Remote_Proxy_Broker ();
  
  this->IR_Contained_setup_collocation (collocated);
}

void IR_PrimaryKeyDef::_tao_any_destructor (void *x)
{
  IR_PrimaryKeyDef *tmp = ACE_static_cast (IR_PrimaryKeyDef*,x);
  CORBA::release (tmp);
}

IR_PrimaryKeyDef_ptr IR_PrimaryKeyDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_PrimaryKeyDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/PrimaryKeyDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_PrimaryKeyDef::_nil ());
      if (is_a == 0)
        return IR_PrimaryKeyDef::_nil ();
    }
  return IR_PrimaryKeyDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_PrimaryKeyDef_ptr IR_PrimaryKeyDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_PrimaryKeyDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_PrimaryKeyDef_ptr default_proxy = IR_PrimaryKeyDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_PrimaryKeyDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_PrimaryKeyDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_PrimaryKeyDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_PrimaryKeyDef (stub, 0, obj->_servant ()), IR_PrimaryKeyDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_PrimaryKeyDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_PrimaryKeyDef::_narrow
                    )
                )
          );
}

IR_PrimaryKeyDef_ptr
IR_PrimaryKeyDef::_duplicate (IR_PrimaryKeyDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_PrimaryKeyDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/PrimaryKeyDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_PrimaryKeyDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_PrimaryKeyDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_PrimaryKeyDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/PrimaryKeyDef:1.0";
}

CORBA::Boolean IR_PrimaryKeyDef::is_a (
    const char * primary_key_id,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_PrimaryKeyDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_a (
      this,
      primary_key_id,
      ACE_TRY_ENV
    );
}

IR_ValueDef_ptr IR_PrimaryKeyDef::primary_key (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_PrimaryKeyDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).primary_key (
      this,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * primary_key_id,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    primary_key_id_ (primary_key_id)
{}

Dynamic::ParameterList *
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_primary_key_id = parameter_list->length ();
  parameter_list->length (length_primary_key_id + 1);
  (*parameter_list)[length_primary_key_id].argument <<= primary_key_id_;
  (*parameter_list)[length_primary_key_id].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_is_a::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_PrimaryKeyDef::TAO_ClientRequestInfo_IR_PrimaryKeyDef_primary_key_get::result (IR_ValueDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_PrimaryKeyDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
  14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x66000000),  // name = IR_PrimaryKeyDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDef (CORBA::tk_objref, sizeof (_oc_IR_PrimaryKeyDef), (char *) &_oc_IR_PrimaryKeyDef, 0, sizeof (IR_PrimaryKeyDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDef, &_tc_TAO_tc_IR_PrimaryKeyDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_PrimaryKeyDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  41, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDescription:1.0
  22, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e000000),  // name = PrimaryKeyDescription
  5, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  12, ACE_NTOHL (0x7072696d), ACE_NTOHL (0x6172795f), ACE_NTOHL (0x6b657900),  // name = primary_key
  CORBA::tk_objref, // typecode kind
  52, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    28, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x616c7565), ACE_NTOHL (0x4465663a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ValueDef:1.0
    9, ACE_NTOHL (0x56616c75), ACE_NTOHL (0x65446566), ACE_NTOHL (0x0),  // name = IR_ValueDef

};
static CORBA::TypeCode _tc_TAO_tc_IR_PrimaryKeyDescription (CORBA::tk_struct, sizeof (_oc_IR_PrimaryKeyDescription), (char *) &_oc_IR_PrimaryKeyDescription, 0, sizeof (IR_PrimaryKeyDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_PrimaryKeyDescription, &_tc_TAO_tc_IR_PrimaryKeyDescription)
TAO_NAMESPACE_END

void IR_PrimaryKeyDescription::_tao_any_destructor (void *x)
{
  IR_PrimaryKeyDescription *tmp = ACE_static_cast (IR_PrimaryKeyDescription*,x);
  delete tmp;
}


///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_FactoryDef_Proxy_Impl::_TAO_FactoryDef_Proxy_Impl (void)
{}

_TAO_FactoryDef_Remote_Proxy_Impl::_TAO_FactoryDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_FactoryDef_Proxy_Broker::_TAO_FactoryDef_Proxy_Broker (void)
{
}

_TAO_FactoryDef_Proxy_Broker::~_TAO_FactoryDef_Proxy_Broker (void)
{
}

_TAO_FactoryDef_Proxy_Broker * (*_TAO_FactoryDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_FactoryDef_Remote_Proxy_Broker *
_TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_FactoryDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_FactoryDef_Remote_Proxy_Broker::_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
}

_TAO_FactoryDef_Remote_Proxy_Broker::~_TAO_FactoryDef_Remote_Proxy_Broker (void)
{
}

_TAO_FactoryDef_Proxy_Impl&
_TAO_FactoryDef_Remote_Proxy_Broker::select_proxy (
  ::IR_FactoryDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_FactoryDef::IR_FactoryDef (int collocated)
{
  this->IR_FactoryDef_setup_collocation (collocated);
}

// destructor
IR_FactoryDef::~IR_FactoryDef (void)
{}

void
IR_FactoryDef::IR_FactoryDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FactoryDef_Proxy_Broker_ =
      _TAO_FactoryDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FactoryDef_Proxy_Broker_ =
      _TAO_FactoryDef_Remote_Proxy_Broker::the_TAO_FactoryDef_Remote_Proxy_Broker ();
  
  this->IR_OperationDef_setup_collocation (collocated);
}

void IR_FactoryDef::_tao_any_destructor (void *x)
{
  IR_FactoryDef *tmp = ACE_static_cast (IR_FactoryDef*,x);
  CORBA::release (tmp);
}

IR_FactoryDef_ptr IR_FactoryDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_FactoryDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FactoryDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_FactoryDef::_nil ());
      if (is_a == 0)
        return IR_FactoryDef::_nil ();
    }
  return IR_FactoryDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_FactoryDef_ptr IR_FactoryDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_FactoryDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_FactoryDef_ptr default_proxy = IR_FactoryDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_FactoryDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_FactoryDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_FactoryDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_FactoryDef (stub, 0, obj->_servant ()), IR_FactoryDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_FactoryDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_FactoryDef::_narrow
                    )
                )
          );
}

IR_FactoryDef_ptr
IR_FactoryDef::_duplicate (IR_FactoryDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_FactoryDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FactoryDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_FactoryDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_FactoryDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_OperationDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_OperationDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_FactoryDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FactoryDef:1.0";
}

static const CORBA::Long _oc_IR_FactoryDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
  11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = IR_FactoryDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_FactoryDef (CORBA::tk_objref, sizeof (_oc_IR_FactoryDef), (char *) &_oc_IR_FactoryDef, 0, sizeof (IR_FactoryDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FactoryDef, &_tc_TAO_tc_IR_FactoryDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_FinderDef_Proxy_Impl::_TAO_FinderDef_Proxy_Impl (void)
{}

_TAO_FinderDef_Remote_Proxy_Impl::_TAO_FinderDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_FinderDef_Proxy_Broker::_TAO_FinderDef_Proxy_Broker (void)
{
}

_TAO_FinderDef_Proxy_Broker::~_TAO_FinderDef_Proxy_Broker (void)
{
}

_TAO_FinderDef_Proxy_Broker * (*_TAO_FinderDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_FinderDef_Remote_Proxy_Broker *
_TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_FinderDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_FinderDef_Remote_Proxy_Broker::_TAO_FinderDef_Remote_Proxy_Broker (void)
{
}

_TAO_FinderDef_Remote_Proxy_Broker::~_TAO_FinderDef_Remote_Proxy_Broker (void)
{
}

_TAO_FinderDef_Proxy_Impl&
_TAO_FinderDef_Remote_Proxy_Broker::select_proxy (
  ::IR_FinderDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_FinderDef::IR_FinderDef (int collocated)
{
  this->IR_FinderDef_setup_collocation (collocated);
}

// destructor
IR_FinderDef::~IR_FinderDef (void)
{}

void
IR_FinderDef::IR_FinderDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_FinderDef_Proxy_Broker_ =
      _TAO_FinderDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_FinderDef_Proxy_Broker_ =
      _TAO_FinderDef_Remote_Proxy_Broker::the_TAO_FinderDef_Remote_Proxy_Broker ();
  
  this->IR_OperationDef_setup_collocation (collocated);
}

void IR_FinderDef::_tao_any_destructor (void *x)
{
  IR_FinderDef *tmp = ACE_static_cast (IR_FinderDef*,x);
  CORBA::release (tmp);
}

IR_FinderDef_ptr IR_FinderDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_FinderDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/FinderDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_FinderDef::_nil ());
      if (is_a == 0)
        return IR_FinderDef::_nil ();
    }
  return IR_FinderDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_FinderDef_ptr IR_FinderDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_FinderDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_FinderDef_ptr default_proxy = IR_FinderDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_FinderDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_FinderDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_FinderDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_FinderDef (stub, 0, obj->_servant ()), IR_FinderDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_FinderDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_FinderDef::_narrow
                    )
                )
          );
}

IR_FinderDef_ptr
IR_FinderDef::_duplicate (IR_FinderDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_FinderDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/FinderDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/OperationDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_FinderDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_FinderDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_OperationDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_OperationDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_FinderDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/FinderDef:1.0";
}

static const CORBA::Long _oc_IR_FinderDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
  10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = IR_FinderDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_FinderDef (CORBA::tk_objref, sizeof (_oc_IR_FinderDef), (char *) &_oc_IR_FinderDef, 0, sizeof (IR_FinderDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_FinderDef, &_tc_TAO_tc_IR_FinderDef)
TAO_NAMESPACE_END

///////////////////////////////////////////////////////////////////////
//                Base & Remote Proxy  Implementation. 
//

_TAO_HomeDef_Proxy_Impl::_TAO_HomeDef_Proxy_Impl (void)
{}

_TAO_HomeDef_Remote_Proxy_Impl::_TAO_HomeDef_Remote_Proxy_Impl (void)
{}

// Remote Implementation of the IDL interface methods

IR_HomeDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::base_home (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_HomeDef_ptr _tao_retval = IR_HomeDef::_nil ();
  IR_HomeDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_base_home",
      14,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_HomeDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_ComponentDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::managed_component (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_ComponentDef_ptr _tao_retval = IR_ComponentDef::_nil ();
  IR_ComponentDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_managed_component",
      22,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_ComponentDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_PrimaryKeyDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::primary_key (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_PrimaryKeyDef_ptr _tao_retval = IR_PrimaryKeyDef::_nil ();
  IR_PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_primary_key",
      16,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_PrimaryKeyDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_FactoryDefSeq * _TAO_HomeDef_Remote_Proxy_Impl::factories (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_FactoryDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_FactoryDefSeq, _tao_retval);
  IR_FactoryDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_factories",
      14,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_FactoryDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_FinderDefSeq * _TAO_HomeDef_Remote_Proxy_Impl::finders (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_FinderDefSeq *_tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  ACE_NEW_RETURN (_tao_retval, IR_FinderDefSeq, _tao_retval);
  IR_FinderDefSeq_var _tao_safe_retval (_tao_retval);
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_finders",
      12,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_FinderDefSeq * _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

CORBA::Boolean _TAO_HomeDef_Remote_Proxy_Impl::is_basic (
    CORBA_Object *_collocated_tao_target_,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  CORBA::Boolean _tao_retval = 0;
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), _tao_retval);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "_get_is_basic",
      13,
      0,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get ri (
        &_tao_call,
        _collocated_tao_target_,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN  (_tao_retval);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> CORBA::Any::to_boolean (_tao_retval))
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                _tao_retval
              );
              
            }
          
          TAO_INTERCEPTOR (
              CORBA::Boolean  _tao_retval_info = _tao_retval;
               ri.result (_tao_retval_info);
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN  (_tao_retval);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN  (_tao_retval);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_retval;
}

IR_PrimaryKeyDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::create_primary_key (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_PrimaryKeyDef_ptr _tao_retval = IR_PrimaryKeyDef::_nil ();
  IR_PrimaryKeyDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_primary_key",
      18,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        primary_key,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << primary_key)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_PrimaryKeyDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_FactoryDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::create_factory (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_FactoryDef_ptr _tao_retval = IR_FactoryDef::_nil ();
  IR_FactoryDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_factory",
      14,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_FactoryDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}

IR_FinderDef_ptr _TAO_HomeDef_Remote_Proxy_Impl::create_finder (
    CORBA_Object *_collocated_tao_target_,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  IR_FinderDef_ptr _tao_retval = IR_FinderDef::_nil ();
  IR_FinderDef_var _tao_safe_retval (_tao_retval);
  
  
  TAO_Stub *istub = _collocated_tao_target_->_stubobj ();
  if (istub == 0)
    ACE_THROW_RETURN (CORBA::INTERNAL (), 0);

  
  TAO_GIOP_Twoway_Invocation _tao_call (
      istub,
      "create_finder",
      13,
      1,
      istub->orb_core ()
    );

#if (TAO_HAS_INTERCEPTORS == 1)
  TAO_ClientRequestInterceptor_Adapter _tao_vfr (
      istub->orb_core ()->client_request_interceptors ()
    );
  
#endif  /* TAO_HAS_INTERCEPTORS */
  
  for (;;)
    {
      int _invoke_status = TAO_INVOKE_EXCEPTION;
      
#if TAO_HAS_INTERCEPTORS == 1
      IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder ri (
        &_tao_call,
        _collocated_tao_target_,
        id,
        name,
        version,
        params,
        exceptions,
        ACE_TRY_ENV
      );
      ACE_CHECK_RETURN (0);
      
      ACE_TRY
        {
#endif /* TAO_HAS_INTERCEPTORS */
        
          _tao_call.start (ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          CORBA::Short _tao_response_flag = TAO_TWOWAY_RESPONSE_FLAG;
          TAO_INTERCEPTOR (ri.response_expected (1));
          
          TAO_INTERCEPTOR (
            _tao_vfr.send_request (
              &ri,
              ACE_TRY_ENV
            )
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          _tao_call.prepare_header (
              ACE_static_cast (CORBA::Octet, _tao_response_flag),
              ACE_TRY_ENV
            );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          TAO_OutputCDR &_tao_out = _tao_call.out_stream ();
          if (!(
                            (_tao_out << id) &&
              (_tao_out << name) &&
              (_tao_out << version) &&
              (_tao_out << params) &&
              (_tao_out << exceptions)
            ))
            TAO_INTERCEPTOR_THROW_RETURN (
              CORBA::MARSHAL (),
              0
            );
            
          _invoke_status =
            _tao_call.invoke (0, 0, ACE_TRY_ENV);
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
          if (_invoke_status == TAO_INVOKE_EXCEPTION)
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::UNKNOWN (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_InputCDR &_tao_in = _tao_call.inp_stream ();
          if (!(
                            (_tao_in >> _tao_safe_retval.inout ())
              ))
            {
              TAO_INTERCEPTOR_THROW_RETURN (
                CORBA::MARSHAL (TAO_DEFAULT_MINOR_CODE, CORBA::COMPLETED_YES),
                0
              );
              
            }
          
          TAO_INTERCEPTOR (
              IR_FinderDef_ptr _tao_retval_info = _tao_safe_retval._retn ();
              ri.result (_tao_retval_info);
              _tao_safe_retval = _tao_retval_info;
            );
          
          TAO_INTERCEPTOR (
            ri.reply_status (_invoke_status);
            if (_invoke_status == TAO_INVOKE_OK)
              {
                _tao_vfr.receive_reply (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            else
              {
                _tao_vfr.receive_other (
                  &ri,
                  ACE_TRY_ENV
                );
              }
            
          );
          TAO_INTERCEPTOR_CHECK_RETURN (0);
          
#if TAO_HAS_INTERCEPTORS == 1
        }
      ACE_CATCH (PortableInterceptor::ForwardRequest, exc)
        {
          _invoke_status =
            _tao_call.location_forward (exc.forward.in (), ACE_TRY_ENV);
          ACE_TRY_CHECK;
          
          ri.forward_reference (exc); 
          _tao_vfr.receive_other (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
        }
      ACE_CATCHANY
        {
          ri.exception (&ACE_ANY_EXCEPTION);
          _tao_vfr.receive_exception (
            &ri,
            ACE_TRY_ENV
          );
          ACE_TRY_CHECK;
          ACE_RE_THROW;
        }
      ACE_ENDTRY;
      ACE_CHECK_RETURN (0);
      
#endif /* TAO_HAS_INTERCEPTORS */

      if (_invoke_status == TAO_INVOKE_RESTART)
        {
          _tao_call.restart_flag (1);
          continue;
        }
      
      break;
    }
  return _tao_safe_retval._retn ();
}


//
//            End  Base & Remote  Proxy Implemeentation. 
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//           Remote & Base  Proxy Broker Implementation
//

_TAO_HomeDef_Proxy_Broker::_TAO_HomeDef_Proxy_Broker (void)
{
}

_TAO_HomeDef_Proxy_Broker::~_TAO_HomeDef_Proxy_Broker (void)
{
}

_TAO_HomeDef_Proxy_Broker * (*_TAO_HomeDef_Proxy_Broker_Factory_function_pointer) (
    CORBA::Object_ptr obj
  ) = 0;

// Factory Member function Implementation.
_TAO_HomeDef_Remote_Proxy_Broker *
_TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker (void)
{
  static ::_TAO_HomeDef_Remote_Proxy_Broker remote_proxy_broker;
  return &remote_proxy_broker;
}

_TAO_HomeDef_Remote_Proxy_Broker::_TAO_HomeDef_Remote_Proxy_Broker (void)
{
}

_TAO_HomeDef_Remote_Proxy_Broker::~_TAO_HomeDef_Remote_Proxy_Broker (void)
{
}

_TAO_HomeDef_Proxy_Impl&
_TAO_HomeDef_Remote_Proxy_Broker::select_proxy (
  ::IR_HomeDef *object,
  CORBA::Environment &ACE_TRY_ENV
)
{
  ACE_UNUSED_ARG (object);
  ACE_UNUSED_ARG (ACE_TRY_ENV);
  return remote_proxy_impl_;
}


//
//           End Remote & Base Proxy Broker Implementation
///////////////////////////////////////////////////////////////////////


// default constructor
IR_HomeDef::IR_HomeDef (int collocated)
{
  this->IR_HomeDef_setup_collocation (collocated);
}

// destructor
IR_HomeDef::~IR_HomeDef (void)
{}

void
IR_HomeDef::IR_HomeDef_setup_collocation (int collocated)
{
  if (collocated)
    this->the_TAO_HomeDef_Proxy_Broker_ =
      _TAO_HomeDef_Proxy_Broker_Factory_function_pointer (this);
  else
    this->the_TAO_HomeDef_Proxy_Broker_ =
      _TAO_HomeDef_Remote_Proxy_Broker::the_TAO_HomeDef_Remote_Proxy_Broker ();
  
  this->IR_InterfaceDef_setup_collocation (collocated);
}

void IR_HomeDef::_tao_any_destructor (void *x)
{
  IR_HomeDef *tmp = ACE_static_cast (IR_HomeDef*,x);
  CORBA::release (tmp);
}

IR_HomeDef_ptr IR_HomeDef::_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &ACE_TRY_ENV
  )
{
  if (CORBA::is_nil (obj))
    return IR_HomeDef::_nil ();
  if (! obj->_is_local ())
    {
      CORBA::Boolean is_a = obj->_is_a ("IDL:omg.org/IR/HomeDef:1.0", ACE_TRY_ENV);
      ACE_CHECK_RETURN (IR_HomeDef::_nil ());
      if (is_a == 0)
        return IR_HomeDef::_nil ();
    }
  return IR_HomeDef::_unchecked_narrow (obj, ACE_TRY_ENV);
}

IR_HomeDef_ptr IR_HomeDef::_unchecked_narrow (
    CORBA::Object_ptr obj,
    CORBA::Environment &
  )
{
  if (CORBA::is_nil (obj))
    return IR_HomeDef::_nil ();
  if (! obj->_is_local ())
    {
      TAO_Stub* stub = obj->_stubobj ();
      if (stub)
        stub->_incr_refcnt ();
      IR_HomeDef_ptr default_proxy = IR_HomeDef::_nil ();

      if (
          !CORBA::is_nil (stub->servant_orb_var ().ptr ()) &&
          stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects () &&
          obj->_is_collocated () &&_TAO_HomeDef_Proxy_Broker_Factory_function_pointer != 0
        )
      {
        ACE_NEW_RETURN (
          default_proxy,
          ::IR_HomeDef (
            stub,
            1,
            obj->_servant ()),
            
          IR_HomeDef::_nil ());
        }
      if (CORBA::is_nil (default_proxy))
        ACE_NEW_RETURN (default_proxy, ::IR_HomeDef (stub, 0, obj->_servant ()), IR_HomeDef::_nil ());
        return default_proxy;
      }
    else 
      return
        ACE_reinterpret_cast
          (
            IR_HomeDef_ptr,
              obj->_tao_QueryInterface
                (
                  ACE_reinterpret_cast
                    (
                      ptr_arith_t,
                      &IR_HomeDef::_narrow
                    )
                )
          );
}

IR_HomeDef_ptr
IR_HomeDef::_duplicate (IR_HomeDef_ptr obj)
{
  if (!CORBA::is_nil (obj))
    obj->_add_ref ();
  return obj;
}

CORBA::Boolean IR_HomeDef::_is_a (const CORBA::Char *value, CORBA::Environment &ACE_TRY_ENV)
{
  if (
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/HomeDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/InterfaceDef:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Container:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/Contained:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/IR/IDLType:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/IRObject:1.0")) ||
    (!ACE_OS::strcmp ((char *)value, "IDL:omg.org/CORBA/Object:1.0")))
  return 1; // success using local knowledge
  else
    return this->CORBA_Object::_is_a (value, ACE_TRY_ENV);
}

void *IR_HomeDef::_tao_QueryInterface (ptr_arith_t type)
{
  void *retv = 0;
  if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_HomeDef::_narrow))
    retv = ACE_reinterpret_cast (void*, this);
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_InterfaceDef::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_InterfaceDef_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Container::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Container_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_Contained::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_Contained_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &IR_IDLType::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            IR_IDLType_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast
    (ptr_arith_t,
      &CORBA_IRObject::_narrow))
    retv = ACE_reinterpret_cast
      (
        void *,
        ACE_static_cast
          (
            CORBA_IRObject_ptr,
            this
          )
      );
  else if (type == ACE_reinterpret_cast (ptr_arith_t, &CORBA::Object::_narrow))
    retv = ACE_reinterpret_cast (void *,
      ACE_static_cast (CORBA::Object_ptr, this));
    
  if (retv)
    this->_add_ref ();
  return retv;
}

const char* IR_HomeDef::_interface_repository_id (void) const
{
  return "IDL:omg.org/IR/HomeDef:1.0";
}

IR_HomeDef_ptr IR_HomeDef::base_home (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).base_home (
      this,
      ACE_TRY_ENV
    );
}

IR_ComponentDef_ptr IR_HomeDef::managed_component (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).managed_component (
      this,
      ACE_TRY_ENV
    );
}

IR_PrimaryKeyDef_ptr IR_HomeDef::primary_key (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).primary_key (
      this,
      ACE_TRY_ENV
    );
}

IR_FactoryDefSeq * IR_HomeDef::factories (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).factories (
      this,
      ACE_TRY_ENV
    );
}

IR_FinderDefSeq * IR_HomeDef::finders (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).finders (
      this,
      ACE_TRY_ENV
    );
}

CORBA::Boolean IR_HomeDef::is_basic (
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).is_basic (
      this,
      ACE_TRY_ENV
    );
}

IR_PrimaryKeyDef_ptr IR_HomeDef::create_primary_key (
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_primary_key (
      this,
      id,
      name,
      version,
      primary_key,
      ACE_TRY_ENV
    );
}

IR_FactoryDef_ptr IR_HomeDef::create_factory (
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_factory (
      this,
      id,
      name,
      version,
      params,
      exceptions,
      ACE_TRY_ENV
    );
}

IR_FinderDef_ptr IR_HomeDef::create_finder (
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &ACE_TRY_ENV
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  
  return this->the_TAO_HomeDef_Proxy_Broker_->select_proxy (this, ACE_TRY_ENV).create_finder (
      this,
      id,
      name,
      version,
      params,
      exceptions,
      ACE_TRY_ENV
    );
}

#if (TAO_HAS_INTERCEPTORS == 1)
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::TAO_ClientRequestInfo_IR_HomeDef_base_home_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_base_home_get::result (IR_HomeDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_managed_component_get::result (IR_ComponentDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_primary_key_get::result (IR_PrimaryKeyDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::TAO_ClientRequestInfo_IR_HomeDef_factories_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_factories_get::result (IR_FactoryDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::TAO_ClientRequestInfo_IR_HomeDef_finders_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_finders_get::result (IR_FinderDefSeq * result)
{
  // update the result 
  this->_result = result;
}

IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return parameter_list;
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= CORBA::Any::from_boolean (this->_result);
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_is_basic_get::result (CORBA::Boolean result)
{
  // update the result 
  this->_result = result;
}

IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    IR_ValueDef_ptr primary_key,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    primary_key_ (primary_key)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_primary_key = parameter_list->length ();
  parameter_list->length (length_primary_key + 1);
  (*parameter_list)[length_primary_key].argument <<=  this->primary_key_;
  
  (*parameter_list)[length_primary_key].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_primary_key::result (IR_PrimaryKeyDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::TAO_ClientRequestInfo_IR_HomeDef_create_factory (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_factory::result (IR_FactoryDef_ptr result)
{
  // update the result 
  this->_result = result;
}

IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::TAO_ClientRequestInfo_IR_HomeDef_create_finder (
    TAO_GIOP_Invocation *_tao_invocation,
    CORBA::Object_ptr _tao_target,
    const char * id,
    const char * name,
    const char * version,
    const IR_ParDescriptionSeq & params,
    const IR_ExceptionDefSeq & exceptions,
    CORBA::Environment &    
  )
  : TAO_ClientRequestInfo (_tao_invocation, _tao_target),
    id_ (id),
    name_ (name),
    version_ (version),
    params_ (params),
    exceptions_ (exceptions)
{}

Dynamic::ParameterList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::arguments (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the argument list on demand.
  Dynamic::ParameterList *parameter_list =
    TAO_RequestInfo_Util::make_parameter_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  Dynamic::ParameterList_var safe_parameter_list = parameter_list;
    
  CORBA::ULong length_id = parameter_list->length ();
  parameter_list->length (length_id + 1);
  (*parameter_list)[length_id].argument <<= id_;
  (*parameter_list)[length_id].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_name = parameter_list->length ();
  parameter_list->length (length_name + 1);
  (*parameter_list)[length_name].argument <<= name_;
  (*parameter_list)[length_name].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_version = parameter_list->length ();
  parameter_list->length (length_version + 1);
  (*parameter_list)[length_version].argument <<= version_;
  (*parameter_list)[length_version].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_params = parameter_list->length ();
  parameter_list->length (length_params + 1);
  (*parameter_list)[length_params].argument <<=  this->params_;
  
  (*parameter_list)[length_params].mode = Dynamic::PARAM_IN;
    
  CORBA::ULong length_exceptions = parameter_list->length ();
  parameter_list->length (length_exceptions + 1);
  (*parameter_list)[length_exceptions].argument <<=  this->exceptions_;
  
  (*parameter_list)[length_exceptions].mode = Dynamic::PARAM_IN;
  
  return safe_parameter_list._retn ();
}

Dynamic::ExceptionList *
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::exceptions (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the exception list on demand.
  Dynamic::ExceptionList *exception_list =
    TAO_RequestInfo_Util::make_exception_list (ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  return exception_list;
}


CORBA::Any * 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::result (CORBA::Environment &ACE_TRY_ENV)
  ACE_THROW_SPEC ((CORBA::SystemException))
{
  // Generate the result on demand.
  CORBA::Boolean tk_void_any = 0;
  CORBA::Any *result_any =
    TAO_RequestInfo_Util::make_any (tk_void_any, ACE_TRY_ENV);
  ACE_CHECK_RETURN (0);
  
  CORBA::Any_var safe_result_any = result_any;
  
  (*result_any) <<= this->_result;
  return safe_result_any._retn ();
}

void 
IR_HomeDef::TAO_ClientRequestInfo_IR_HomeDef_create_finder::result (IR_FinderDef_ptr result)
{
  // update the result 
  this->_result = result;
}

#endif /* TAO_HAS_INTERCEPTORS */

static const CORBA::Long _oc_IR_HomeDef[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65663a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDef:1.0
  8, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44656600),  // name = IR_HomeDef
};
static CORBA::TypeCode _tc_TAO_tc_IR_HomeDef (CORBA::tk_objref, sizeof (_oc_IR_HomeDef), (char *) &_oc_IR_HomeDef, 0, sizeof (IR_HomeDef));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDef, &_tc_TAO_tc_IR_HomeDef)
TAO_NAMESPACE_END

static const CORBA::Long _oc_IR_HomeDescription[] =
{
  TAO_ENCAP_BYTE_ORDER, // byte order
  35, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f48), ACE_NTOHL (0x6f6d6544), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e3a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/HomeDescription:1.0
  16, ACE_NTOHL (0x486f6d65), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e00),  // name = HomeDescription
  12, // member count
  5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
    11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
    CORBA::tk_string, 
    0U, // string length

  3, ACE_NTOHL (0x69640000),  // name = id
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
  CORBA::tk_alias, // typecode kind for typedefs
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
    12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
    CORBA::tk_string, 
    0U, // string length

  10, ACE_NTOHL (0x62617365), ACE_NTOHL (0x5f686f6d), ACE_NTOHL (0x65000000),  // name = base_home
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  18, ACE_NTOHL (0x6d616e61), ACE_NTOHL (0x6765645f), ACE_NTOHL (0x636f6d70), ACE_NTOHL (0x6f6e656e), ACE_NTOHL (0x74000000),  // name = managed_component
  CORBA::tk_alias, // typecode kind for typedefs
  68, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
    13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
    CORBA::tk_string, 
    0U, // string length

  16, ACE_NTOHL (0x7072696d), ACE_NTOHL (0x6172795f), ACE_NTOHL (0x6b65795f), ACE_NTOHL (0x64656600),  // name = primary_key_def
  CORBA::tk_objref, // typecode kind
  64, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x72696d61), ACE_NTOHL (0x72794b65), ACE_NTOHL (0x79446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/PrimaryKeyDef:1.0
    14, ACE_NTOHL (0x5072696d), ACE_NTOHL (0x6172794b), ACE_NTOHL (0x65794465), ACE_NTOHL (0x66000000),  // name = IR_PrimaryKeyDef

  10, ACE_NTOHL (0x66616374), ACE_NTOHL (0x6f726965), ACE_NTOHL (0x73000000),  // name = factories
  CORBA::tk_alias, // typecode kind for typedefs
  144, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FactoryDefSeq:1.0
    14, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65665365), ACE_NTOHL (0x71000000),  // name = IR_FactoryDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x6163746f), ACE_NTOHL (0x72794465), ACE_NTOHL (0x663a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/FactoryDef:1.0
        11, ACE_NTOHL (0x46616374), ACE_NTOHL (0x6f727944), ACE_NTOHL (0x65660000),  // name = IR_FactoryDef

      0U,


  8, ACE_NTOHL (0x66696e64), ACE_NTOHL (0x65727300),  // name = finders
  CORBA::tk_alias, // typecode kind for typedefs
  140, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/FinderDefSeq:1.0
    13, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66536571), ACE_NTOHL (0x0),  // name = IR_FinderDefSeq
    CORBA::tk_sequence, // typecode kind
    72, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_objref, // typecode kind
      56, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        29, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f46), ACE_NTOHL (0x696e6465), ACE_NTOHL (0x72446566), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/FinderDef:1.0
        10, ACE_NTOHL (0x46696e64), ACE_NTOHL (0x65724465), ACE_NTOHL (0x66000000),  // name = IR_FinderDef

      0U,


  11, ACE_NTOHL (0x6f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e730000),  // name = operations
  CORBA::tk_alias, // typecode kind for typedefs
  1972, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    36, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OpDescriptionSeq:1.0
    17, ACE_NTOHL (0x4f704465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x0),  // name = OpDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1896, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1880, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/OperationDescription:1.0
        21, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = OperationDescription
        9, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        7, ACE_NTOHL (0x72657375), ACE_NTOHL (0x6c740000),  // name = result
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        100, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f4f), ACE_NTOHL (0x70657261), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/OperationMode:1.0
          14, ACE_NTOHL (0x4f706572), ACE_NTOHL (0x6174696f), ACE_NTOHL (0x6e4d6f64), ACE_NTOHL (0x65000000),  // name = OperationMode
          2, // member count
          10, ACE_NTOHL (0x4f505f4e), ACE_NTOHL (0x4f524d41), ACE_NTOHL (0x4c000000),  // name = OP_NORMAL
          10, ACE_NTOHL (0x4f505f4f), ACE_NTOHL (0x4e455741), ACE_NTOHL (0x59000000),  // name = OP_ONEWAY

        9, ACE_NTOHL (0x636f6e74), ACE_NTOHL (0x65787473), ACE_NTOHL (0x0),  // name = contexts
        CORBA::tk_alias, // typecode kind for typedefs
        228, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x5365713a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ContextIdSeq:1.0
          13, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64536571), ACE_NTOHL (0x0),  // name = ContextIdSeq
          CORBA::tk_sequence, // typecode kind
          160, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_alias, // typecode kind for typedefs
            144, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f43), ACE_NTOHL (0x6f6e7465), ACE_NTOHL (0x78744964), ACE_NTOHL (0x656e7469), ACE_NTOHL (0x66696572), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ContextIdentifier:1.0
              18, ACE_NTOHL (0x436f6e74), ACE_NTOHL (0x65787449), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x72000000),  // name = ContextIdentifier
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length


            0U,


        11, ACE_NTOHL (0x70617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72730000),  // name = parameters
        CORBA::tk_alias, // typecode kind for typedefs
        484, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x61724465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParDescriptionSeq:1.0
          18, ACE_NTOHL (0x50617244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ParDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          404, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            388, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ParameterDescription:1.0
              21, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x72446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ParameterDescription
              4, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,

              9, ACE_NTOHL (0x74797065), ACE_NTOHL (0x5f646566), ACE_NTOHL (0x0),  // name = type_def
              CORBA::tk_objref, // typecode kind
              48, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                27, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x444c5479), ACE_NTOHL (0x70653a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/IDLType:1.0
                8, ACE_NTOHL (0x49444c54), ACE_NTOHL (0x79706500),  // name = IR_IDLType

              5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
              CORBA::tk_enum, // typecode kind
              116, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f50), ACE_NTOHL (0x6172616d), ACE_NTOHL (0x65746572), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ParameterMode:1.0
                14, ACE_NTOHL (0x50617261), ACE_NTOHL (0x6d657465), ACE_NTOHL (0x724d6f64), ACE_NTOHL (0x65000000),  // name = ParameterMode
                3, // member count
                9, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x0),  // name = PARAM_IN
                10, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f4f55), ACE_NTOHL (0x54000000),  // name = PARAM_OUT
                12, ACE_NTOHL (0x50415241), ACE_NTOHL (0x4d5f494e), ACE_NTOHL (0x4f555400),  // name = PARAM_INOUT


            0U,


        11, ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  11, ACE_NTOHL (0x61747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65730000),  // name = attributes
  CORBA::tk_alias, // typecode kind for typedefs
  1788, // encapsulation length
    TAO_ENCAP_BYTE_ORDER, // byte order
    38, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747244), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x713a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/AttrDescriptionSeq:1.0
    19, ACE_NTOHL (0x41747472), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x65710000),  // name = AttrDescriptionSeq
    CORBA::tk_sequence, // typecode kind
    1708, // encapsulation length
      TAO_ENCAP_BYTE_ORDER, // byte order
      CORBA::tk_struct, // typecode kind
      1692, // encapsulation length
        TAO_ENCAP_BYTE_ORDER, // byte order
        40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/AttributeDescription:1.0
        21, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x65446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = AttributeDescription
        8, // member count
        5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
          11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
          CORBA::tk_string, 
          0U, // string length

        3, ACE_NTOHL (0x69640000),  // name = id
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
        CORBA::tk_alias, // typecode kind for typedefs
        68, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
          13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
          CORBA::tk_string, 
          0U, // string length

        8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
        CORBA::tk_alias, // typecode kind for typedefs
        64, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
          12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
          CORBA::tk_string, 
          0U, // string length

        5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
        CORBA::tk_TypeCode,

        5, ACE_NTOHL (0x6d6f6465), ACE_NTOHL (0x0),  // name = mode
        CORBA::tk_enum, // typecode kind
        104, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          33, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f41), ACE_NTOHL (0x74747269), ACE_NTOHL (0x62757465), ACE_NTOHL (0x4d6f6465), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/AttributeMode:1.0
          14, ACE_NTOHL (0x41747472), ACE_NTOHL (0x69627574), ACE_NTOHL (0x654d6f64), ACE_NTOHL (0x65000000),  // name = AttributeMode
          2, // member count
          12, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f4e4f52), ACE_NTOHL (0x4d414c00),  // name = ATTR_NORMAL
          14, ACE_NTOHL (0x41545452), ACE_NTOHL (0x5f524541), ACE_NTOHL (0x444f4e4c), ACE_NTOHL (0x59000000),  // name = ATTR_READONLY

        15, ACE_NTOHL (0x6765745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = get_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,


        15, ACE_NTOHL (0x7075745f), ACE_NTOHL (0x65786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e730000),  // name = put_exceptions
        CORBA::tk_alias, // typecode kind for typedefs
        536, // encapsulation length
          TAO_ENCAP_BYTE_ORDER, // byte order
          37, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78634465), ACE_NTOHL (0x73637269), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e536571), ACE_NTOHL (0x3a312e30), ACE_NTOHL (0x0),  // repository ID = IDL:omg.org/IR/ExcDescriptionSeq:1.0
          18, ACE_NTOHL (0x45786344), ACE_NTOHL (0x65736372), ACE_NTOHL (0x69707469), ACE_NTOHL (0x6f6e5365), ACE_NTOHL (0x71000000),  // name = ExcDescriptionSeq
          CORBA::tk_sequence, // typecode kind
          456, // encapsulation length
            TAO_ENCAP_BYTE_ORDER, // byte order
            CORBA::tk_struct, // typecode kind
            440, // encapsulation length
              TAO_ENCAP_BYTE_ORDER, // byte order
              40, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f45), ACE_NTOHL (0x78636570), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x44657363), ACE_NTOHL (0x72697074), ACE_NTOHL (0x696f6e3a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/ExceptionDescription:1.0
              21, ACE_NTOHL (0x45786365), ACE_NTOHL (0x7074696f), ACE_NTOHL (0x6e446573), ACE_NTOHL (0x63726970), ACE_NTOHL (0x74696f6e), ACE_NTOHL (0x0),  // name = ExceptionDescription
              5, // member count
              5, ACE_NTOHL (0x6e616d65), ACE_NTOHL (0x0),  // name = name
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                30, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f49), ACE_NTOHL (0x64656e74), ACE_NTOHL (0x69666965), ACE_NTOHL (0x723a312e), ACE_NTOHL (0x30000000),  // repository ID = IDL:omg.org/IR/Identifier:1.0
                11, ACE_NTOHL (0x4964656e), ACE_NTOHL (0x74696669), ACE_NTOHL (0x65720000),  // name = Identifier
                CORBA::tk_string, 
                0U, // string length

              3, ACE_NTOHL (0x69640000),  // name = id
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              11, ACE_NTOHL (0x64656669), ACE_NTOHL (0x6e65645f), ACE_NTOHL (0x696e0000),  // name = defined_in
              CORBA::tk_alias, // typecode kind for typedefs
              68, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                32, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f52), ACE_NTOHL (0x65706f73), ACE_NTOHL (0x69746f72), ACE_NTOHL (0x7949643a), ACE_NTOHL (0x312e3000),  // repository ID = IDL:omg.org/IR/RepositoryId:1.0
                13, ACE_NTOHL (0x5265706f), ACE_NTOHL (0x7369746f), ACE_NTOHL (0x72794964), ACE_NTOHL (0x0),  // name = RepositoryId
                CORBA::tk_string, 
                0U, // string length

              8, ACE_NTOHL (0x76657273), ACE_NTOHL (0x696f6e00),  // name = version
              CORBA::tk_alias, // typecode kind for typedefs
              64, // encapsulation length
                TAO_ENCAP_BYTE_ORDER, // byte order
                31, ACE_NTOHL (0x49444c3a), ACE_NTOHL (0x6f6d672e), ACE_NTOHL (0x6f72672f), ACE_NTOHL (0x49522f56), ACE_NTOHL (0x65727369), ACE_NTOHL (0x6f6e5370), ACE_NTOHL (0x65633a31), ACE_NTOHL (0x2e300000),  // repository ID = IDL:omg.org/IR/VersionSpec:1.0
                12, ACE_NTOHL (0x56657273), ACE_NTOHL (0x696f6e53), ACE_NTOHL (0x70656300),  // name = VersionSpec
                CORBA::tk_string, 
                0U, // string length

              5, ACE_NTOHL (0x74797065), ACE_NTOHL (0x0),  // name = type
              CORBA::tk_TypeCode,


            0U,



      0U,


  9, ACE_NTOHL (0x69735f62), ACE_NTOHL (0x61736963), ACE_NTOHL (0x0),  // name = is_basic
  CORBA::tk_boolean,

};
static CORBA::TypeCode _tc_TAO_tc_IR_HomeDescription (CORBA::tk_struct, sizeof (_oc_IR_HomeDescription), (char *) &_oc_IR_HomeDescription, 0, sizeof (IR_HomeDescription));
TAO_NAMESPACE_TYPE (CORBA::TypeCode_ptr)
TAO_NAMESPACE_BEGIN (IR)
TAO_NAMESPACE_DEFINE (CORBA::TypeCode_ptr, _tc_HomeDescription, &_tc_TAO_tc_IR_HomeDescription)
TAO_NAMESPACE_END

void IR_HomeDescription::_tao_any_destructor (void *x)
{
  IR_HomeDescription *tmp = ACE_static_cast (IR_HomeDescription*,x);
  delete tmp;
}

void operator<<= (CORBA::Any &_tao_any, IR_DefinitionKind _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_DefinitionKind,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_DefinitionKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_DefinitionKind, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, CORBA_IRObject_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        CORBA::_tc_IRObject, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        CORBA_IRObject::_duplicate (_tao_elem),
        CORBA_IRObject::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, CORBA_IRObject_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = CORBA_IRObject::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (CORBA::_tc_IRObject, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          CORBA::_tc_IRObject,
          1,
          _tao_elem,
          CORBA_IRObject::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = CORBA_IRObject::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = CORBA_IRObject::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<CORBA_IRObject,CORBA_IRObject_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<CORBA_IRObject,CORBA_IRObject_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_Contained_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_Contained, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_Contained::_duplicate (_tao_elem),
        IR_Contained::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Contained_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_Contained::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_Contained, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_Contained,
          1,
          _tao_elem,
          IR_Contained::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_Contained::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_Contained::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_Contained,IR_Contained_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_Contained,IR_Contained_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_Contained::Description &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR_Contained::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_Contained::Description *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR_Contained::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_Contained::Description::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Contained::Description *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_Contained::Description*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_Contained::Description *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR_Contained::_tc_Description, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_Contained::Description*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_Contained::Description *tmp;
      ACE_NEW_RETURN (tmp, IR_Contained::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR_Contained::_tc_Description,
            1,
            ACE_static_cast (void *, tmp),
            IR_Contained::Description::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_InterfaceDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_InterfaceDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_InterfaceDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_InterfaceDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_InterfaceDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_InterfaceDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_InterfaceDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_InterfaceDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_InterfaceDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_InterfaceDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_InterfaceDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_InterfaceDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_InterfaceDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_InterfaceDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ValueDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ValueDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ValueDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ValueDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ValueDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ValueDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ValueDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ValueDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ValueDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ValueDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ComponentDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ComponentDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ComponentDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ComponentDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ComponentDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ComponentDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ComponentDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ComponentDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ComponentDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ComponentDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ComponentDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ComponentDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ProvidesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ProvidesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ProvidesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ProvidesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ProvidesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ProvidesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ProvidesDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ProvidesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ProvidesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ProvidesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ProvidesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_UsesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_UsesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_UsesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UsesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_UsesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UsesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UsesDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_UsesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_UsesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_UsesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_UsesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_HomeDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_HomeDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_HomeDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_HomeDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_HomeDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_HomeDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_HomeDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_HomeDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_HomeDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_HomeDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_HomeDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_HomeDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_HomeDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_EmitsDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EmitsDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_EmitsDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EmitsDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_EmitsDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EmitsDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_EmitsDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_EmitsDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EmitsDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_EmitsDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_EmitsDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_EmitsDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EmitsDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_EmitsDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_PublishesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PublishesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_PublishesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PublishesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_PublishesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PublishesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_PublishesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_PublishesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PublishesDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_PublishesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_PublishesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_PublishesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_PublishesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_PublishesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ConsumesDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConsumesDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ConsumesDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ConsumesDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ConsumesDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ConsumesDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ConsumesDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ConsumesDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ConsumesDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ConsumesDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ConsumesDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ConsumesDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ConsumesDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ConsumesDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_FactoryDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FactoryDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_FactoryDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_FactoryDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_FactoryDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FactoryDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_FactoryDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_FactoryDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FactoryDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_FactoryDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_FactoryDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_FactoryDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_FactoryDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_FactoryDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_FinderDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FinderDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_FinderDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_FinderDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_FinderDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FinderDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_FinderDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_FinderDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FinderDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_FinderDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_FinderDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_FinderDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_FinderDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_FinderDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ContainedSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ContainedSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ContainedSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ContainedSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ContainedSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ContainedSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ContainedSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ContainedSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ContainedSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ContainedSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ContainedSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ContainedSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ContainedSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ContainedSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR_StructMember &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_StructMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_StructMember *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_StructMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_StructMember::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_StructMember *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_StructMember*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_StructMember *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_StructMember, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_StructMember*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_StructMember *tmp;
      ACE_NEW_RETURN (tmp, IR_StructMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_StructMember,
            1,
            ACE_static_cast (void *, tmp),
            IR_StructMember::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_StructMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_StructMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_StructMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_StructMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_StructMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_StructMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_StructMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_StructMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_StructMemberSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_StructMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_StructMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_StructMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_StructMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_StructMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR_Initializer &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_Initializer,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_Initializer *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_Initializer,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_Initializer::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Initializer *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_Initializer*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_Initializer *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_Initializer, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_Initializer*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_Initializer *tmp;
      ACE_NEW_RETURN (tmp, IR_Initializer, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_Initializer,
            1,
            ACE_static_cast (void *, tmp),
            IR_Initializer::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_InitializerSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_InitializerSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_InitializerSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_InitializerSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_InitializerSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_InitializerSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_InitializerSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_InitializerSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_InitializerSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_InitializerSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_InitializerSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_InitializerSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_InitializerSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_InitializerSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR_UnionMember &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UnionMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_UnionMember *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UnionMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_UnionMember::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UnionMember *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_UnionMember*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UnionMember *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UnionMember, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_UnionMember*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_UnionMember *tmp;
      ACE_NEW_RETURN (tmp, IR_UnionMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UnionMember,
            1,
            ACE_static_cast (void *, tmp),
            IR_UnionMember::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_UnionMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UnionMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_UnionMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UnionMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_UnionMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UnionMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_UnionMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UnionMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UnionMemberSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_UnionMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_UnionMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_UnionMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UnionMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_UnionMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_EnumMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EnumMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_EnumMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EnumMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_EnumMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EnumMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_EnumMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_EnumMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EnumMemberSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_EnumMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_EnumMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_EnumMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EnumMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_EnumMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_Container_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_Container, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_Container::_duplicate (_tao_elem),
        IR_Container::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Container_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_Container::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_Container, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_Container,
          1,
          _tao_elem,
          IR_Container::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_Container::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_Container::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_Container,IR_Container_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_Container,IR_Container_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_Container::Description &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR_Container::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_Container::Description *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR_Container::_tc_Description,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_Container::Description::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Container::Description *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_Container::Description*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_Container::Description *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR_Container::_tc_Description, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_Container::Description*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_Container::Description *tmp;
      ACE_NEW_RETURN (tmp, IR_Container::Description, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR_Container::_tc_Description,
            1,
            ACE_static_cast (void *, tmp),
            IR_Container::Description::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_Container::DescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR_Container::_tc_DescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_Container::DescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR_Container::_tc_DescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_Container::DescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Container::DescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_Container::DescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_Container::DescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR_Container::_tc_DescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_Container::DescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_Container::DescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_Container::DescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR_Container::_tc_DescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_Container::DescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_IDLType_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_IDLType, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_IDLType::_duplicate (_tao_elem),
        IR_IDLType::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_IDLType_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_IDLType::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_IDLType, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_IDLType,
          1,
          _tao_elem,
          IR_IDLType::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_IDLType::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_IDLType::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_IDLType,IR_IDLType_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_IDLType,IR_IDLType_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_PrimitiveKind _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimitiveKind,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PrimitiveKind &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PrimitiveKind, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_Repository_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_Repository, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_Repository::_duplicate (_tao_elem),
        IR_Repository::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_Repository_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_Repository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_Repository, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_Repository,
          1,
          _tao_elem,
          IR_Repository::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_Repository::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_Repository::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_Repository,IR_Repository_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_Repository,IR_Repository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_ComponentRepository_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentRepository, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ComponentRepository::_duplicate (_tao_elem),
        IR_ComponentRepository::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ComponentRepository_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ComponentRepository::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ComponentRepository, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ComponentRepository,
          1,
          _tao_elem,
          IR_ComponentRepository::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ComponentRepository::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ComponentRepository::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ComponentRepository,IR_ComponentRepository_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ComponentRepository,IR_ComponentRepository_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_ModuleDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ModuleDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ModuleDef::_duplicate (_tao_elem),
        IR_ModuleDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ModuleDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ModuleDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ModuleDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ModuleDef,
          1,
          _tao_elem,
          IR_ModuleDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ModuleDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ModuleDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ModuleDef,IR_ModuleDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ModuleDef,IR_ModuleDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_ModuleDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ModuleDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_ModuleDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ModuleDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ModuleDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ModuleDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_ModuleDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ModuleDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ModuleDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ModuleDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ModuleDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_ModuleDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ModuleDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_ModuleDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_ConstantDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConstantDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ConstantDef::_duplicate (_tao_elem),
        IR_ConstantDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ConstantDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ConstantDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ConstantDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ConstantDef,
          1,
          _tao_elem,
          IR_ConstantDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ConstantDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ConstantDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ConstantDef,IR_ConstantDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ConstantDef,IR_ConstantDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_ConstantDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ConstantDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_ConstantDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ConstantDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ConstantDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ConstantDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_ConstantDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ConstantDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ConstantDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ConstantDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ConstantDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_ConstantDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ConstantDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_ConstantDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_TypedefDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_TypedefDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_TypedefDef::_duplicate (_tao_elem),
        IR_TypedefDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_TypedefDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_TypedefDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_TypedefDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_TypedefDef,
          1,
          _tao_elem,
          IR_TypedefDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_TypedefDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_TypedefDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_TypedefDef,IR_TypedefDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_TypedefDef,IR_TypedefDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_TypeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_TypeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_TypeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_TypeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_TypeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_TypeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_TypeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_TypeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_TypeDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_TypeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_TypeDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_TypeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_TypeDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_TypeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_StructDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_StructDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_StructDef::_duplicate (_tao_elem),
        IR_StructDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_StructDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_StructDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_StructDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_StructDef,
          1,
          _tao_elem,
          IR_StructDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_StructDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_StructDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_StructDef,IR_StructDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_StructDef,IR_StructDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_UnionDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UnionDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_UnionDef::_duplicate (_tao_elem),
        IR_UnionDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UnionDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_UnionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UnionDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_UnionDef,
          1,
          _tao_elem,
          IR_UnionDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_UnionDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_UnionDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_UnionDef,IR_UnionDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_UnionDef,IR_UnionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_EnumDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EnumDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_EnumDef::_duplicate (_tao_elem),
        IR_EnumDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EnumDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_EnumDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EnumDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EnumDef,
          1,
          _tao_elem,
          IR_EnumDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_EnumDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_EnumDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_EnumDef,IR_EnumDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_EnumDef,IR_EnumDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_AliasDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_AliasDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_AliasDef::_duplicate (_tao_elem),
        IR_AliasDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AliasDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_AliasDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AliasDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_AliasDef,
          1,
          _tao_elem,
          IR_AliasDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_AliasDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_AliasDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_AliasDef,IR_AliasDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_AliasDef,IR_AliasDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_NativeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_NativeDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_NativeDef::_duplicate (_tao_elem),
        IR_NativeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_NativeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_NativeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_NativeDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_NativeDef,
          1,
          _tao_elem,
          IR_NativeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_NativeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_NativeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_NativeDef,IR_NativeDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_NativeDef,IR_NativeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_PrimitiveDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PrimitiveDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_PrimitiveDef::_duplicate (_tao_elem),
        IR_PrimitiveDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PrimitiveDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_PrimitiveDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PrimitiveDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PrimitiveDef,
          1,
          _tao_elem,
          IR_PrimitiveDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_PrimitiveDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_PrimitiveDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_PrimitiveDef,IR_PrimitiveDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_PrimitiveDef,IR_PrimitiveDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_StringDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_StringDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_StringDef::_duplicate (_tao_elem),
        IR_StringDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_StringDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_StringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_StringDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_StringDef,
          1,
          _tao_elem,
          IR_StringDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_StringDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_StringDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_StringDef,IR_StringDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_StringDef,IR_StringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_WstringDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_WstringDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_WstringDef::_duplicate (_tao_elem),
        IR_WstringDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_WstringDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_WstringDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_WstringDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_WstringDef,
          1,
          _tao_elem,
          IR_WstringDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_WstringDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_WstringDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_WstringDef,IR_WstringDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_WstringDef,IR_WstringDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_FixedDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FixedDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_FixedDef::_duplicate (_tao_elem),
        IR_FixedDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FixedDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_FixedDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FixedDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FixedDef,
          1,
          _tao_elem,
          IR_FixedDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_FixedDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_FixedDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_FixedDef,IR_FixedDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_FixedDef,IR_FixedDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_SequenceDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_SequenceDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_SequenceDef::_duplicate (_tao_elem),
        IR_SequenceDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_SequenceDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_SequenceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_SequenceDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_SequenceDef,
          1,
          _tao_elem,
          IR_SequenceDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_SequenceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_SequenceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_SequenceDef,IR_SequenceDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_SequenceDef,IR_SequenceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_ArrayDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ArrayDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ArrayDef::_duplicate (_tao_elem),
        IR_ArrayDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ArrayDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ArrayDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ArrayDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ArrayDef,
          1,
          _tao_elem,
          IR_ArrayDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ArrayDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ArrayDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ArrayDef,IR_ArrayDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ArrayDef,IR_ArrayDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_ExceptionDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ExceptionDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ExceptionDef::_duplicate (_tao_elem),
        IR_ExceptionDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ExceptionDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ExceptionDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ExceptionDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ExceptionDef,
          1,
          _tao_elem,
          IR_ExceptionDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ExceptionDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ExceptionDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ExceptionDef,IR_ExceptionDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ExceptionDef,IR_ExceptionDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_ExceptionDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ExceptionDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_ExceptionDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ExceptionDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ExceptionDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ExceptionDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_ExceptionDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ExceptionDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ExceptionDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ExceptionDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ExceptionDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_ExceptionDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ExceptionDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_ExceptionDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ExceptionDefSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ExceptionDefSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ExceptionDefSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ExceptionDefSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ExceptionDefSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ExceptionDefSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ExceptionDefSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ExceptionDefSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ExceptionDefSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ExceptionDefSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ExceptionDefSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ExceptionDefSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ExceptionDefSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ExceptionDefSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ExcDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ExcDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ExcDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ExcDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ExcDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ExcDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ExcDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ExcDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ExcDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ExcDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ExcDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ExcDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ExcDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ExcDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_AttributeMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_AttributeMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AttributeMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AttributeMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_AttributeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_AttributeDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_AttributeDef::_duplicate (_tao_elem),
        IR_AttributeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AttributeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_AttributeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AttributeDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_AttributeDef,
          1,
          _tao_elem,
          IR_AttributeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_AttributeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_AttributeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_AttributeDef,IR_AttributeDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_AttributeDef,IR_AttributeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_AttributeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_AttributeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_AttributeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_AttributeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_AttributeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AttributeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_AttributeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_AttributeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AttributeDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_AttributeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_AttributeDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_AttributeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_AttributeDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_AttributeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_OperationMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_OperationMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_OperationMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_OperationMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_ParameterMode _tao_elem)
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ParameterMode,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ParameterMode &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ParameterMode, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      return 1;
    }
  }
  ACE_CATCHANY
  {
    return 0;
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR_ParameterDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ParameterDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_ParameterDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ParameterDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ParameterDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ParameterDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_ParameterDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ParameterDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ParameterDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ParameterDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ParameterDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_ParameterDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ParameterDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_ParameterDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ParDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ParDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ParDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ParDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ParDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ParDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ParDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ParDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ParDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ParDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ParDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ParDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ParDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ParDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ContextIdSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ContextIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ContextIdSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ContextIdSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ContextIdSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ContextIdSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ContextIdSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ContextIdSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ContextIdSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ContextIdSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ContextIdSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ContextIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ContextIdSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ContextIdSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_OperationDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_OperationDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_OperationDef::_duplicate (_tao_elem),
        IR_OperationDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_OperationDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_OperationDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_OperationDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_OperationDef,
          1,
          _tao_elem,
          IR_OperationDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_OperationDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_OperationDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_OperationDef,IR_OperationDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_OperationDef,IR_OperationDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_OperationDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_OperationDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_OperationDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_OperationDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_OperationDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_OperationDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_OperationDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_OperationDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_OperationDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_OperationDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_OperationDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_OperationDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_OperationDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_OperationDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_RepositoryIdSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_RepositoryIdSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_RepositoryIdSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_RepositoryIdSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_RepositoryIdSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_RepositoryIdSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_RepositoryIdSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_RepositoryIdSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_RepositoryIdSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_RepositoryIdSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_RepositoryIdSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_RepositoryIdSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_RepositoryIdSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_RepositoryIdSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_OpDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_OpDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_OpDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_OpDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_OpDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_OpDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_OpDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_OpDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_OpDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_OpDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_OpDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_OpDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_OpDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_OpDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_AttrDescriptionSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_AttrDescriptionSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_AttrDescriptionSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_AttrDescriptionSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_AttrDescriptionSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_AttrDescriptionSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_AttrDescriptionSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_AttrDescriptionSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_AttrDescriptionSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_AttrDescriptionSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_AttrDescriptionSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_AttrDescriptionSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_AttrDescriptionSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_AttrDescriptionSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_InterfaceDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_InterfaceDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_InterfaceDef::_duplicate (_tao_elem),
        IR_InterfaceDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_InterfaceDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_InterfaceDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_InterfaceDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_InterfaceDef,
          1,
          _tao_elem,
          IR_InterfaceDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_InterfaceDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_InterfaceDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_InterfaceDef,IR_InterfaceDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_InterfaceDef,IR_InterfaceDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_InterfaceDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_InterfaceDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_InterfaceDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_InterfaceDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_InterfaceDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_InterfaceDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_InterfaceDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_InterfaceDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_InterfaceDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_InterfaceDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_InterfaceDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_InterfaceDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_InterfaceDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_InterfaceDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, const IR_ValueMember &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_ValueMember *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueMember,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ValueMember::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueMember *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_ValueMember*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ValueMember *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueMember, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ValueMember*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ValueMember *tmp;
      ACE_NEW_RETURN (tmp, IR_ValueMember, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ValueMember,
            1,
            ACE_static_cast (void *, tmp),
            IR_ValueMember::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ValueMemberSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueMemberSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ValueMemberSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueMemberSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ValueMemberSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueMemberSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ValueMemberSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ValueMemberSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueMemberSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ValueMemberSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ValueMemberSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ValueMemberSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ValueMemberSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ValueMemberSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_ValueMemberDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueMemberDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ValueMemberDef::_duplicate (_tao_elem),
        IR_ValueMemberDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueMemberDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ValueMemberDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueMemberDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ValueMemberDef,
          1,
          _tao_elem,
          IR_ValueMemberDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ValueMemberDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ValueMemberDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ValueMemberDef,IR_ValueMemberDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ValueMemberDef,IR_ValueMemberDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_ValueDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ValueDef::_duplicate (_tao_elem),
        IR_ValueDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ValueDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ValueDef,
          1,
          _tao_elem,
          IR_ValueDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ValueDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ValueDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ValueDef,IR_ValueDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ValueDef,IR_ValueDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_ValueDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_ValueDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ValueDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ValueDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_ValueDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ValueDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ValueDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ValueDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_ValueDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ValueDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_ValueDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_ValueBoxDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ValueBoxDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ValueBoxDef::_duplicate (_tao_elem),
        IR_ValueBoxDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ValueBoxDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ValueBoxDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ValueBoxDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ValueBoxDef,
          1,
          _tao_elem,
          IR_ValueBoxDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ValueBoxDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ValueBoxDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ValueBoxDef,IR_ValueBoxDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ValueBoxDef,IR_ValueBoxDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_ProvidesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ProvidesDef::_duplicate (_tao_elem),
        IR_ProvidesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ProvidesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ProvidesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ProvidesDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ProvidesDef,
          1,
          _tao_elem,
          IR_ProvidesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ProvidesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ProvidesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ProvidesDef,IR_ProvidesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ProvidesDef,IR_ProvidesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_ProvidesDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_ProvidesDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ProvidesDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ProvidesDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_ProvidesDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ProvidesDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ProvidesDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ProvidesDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ProvidesDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_ProvidesDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_ProvidesDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_UsesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_UsesDef::_duplicate (_tao_elem),
        IR_UsesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UsesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_UsesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UsesDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_UsesDef,
          1,
          _tao_elem,
          IR_UsesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_UsesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_UsesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_UsesDef,IR_UsesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_UsesDef,IR_UsesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_UsesDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_UsesDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_UsesDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UsesDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_UsesDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UsesDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UsesDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_UsesDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_UsesDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_UsesDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_UsesDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_ProvidesDescSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ProvidesDescSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_ProvidesDescSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ProvidesDescSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ProvidesDescSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ProvidesDescSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_ProvidesDescSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ProvidesDescSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ProvidesDescSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ProvidesDescSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ProvidesDescSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_ProvidesDescSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ProvidesDescSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_ProvidesDescSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (
    CORBA::Any &_tao_any,
    const IR_UsesDescSeq &_tao_elem
  ) // copying
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_UsesDescSeq,
        TAO_ENCAP_BYTE_ORDER,
        stream.begin ()
      );
  }
}

void operator<<= (CORBA::Any &_tao_any, IR_UsesDescSeq *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_UsesDescSeq,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_UsesDescSeq::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_UsesDescSeq *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(
      const IR_UsesDescSeq*&,
      _tao_elem
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_UsesDescSeq *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_UsesDescSeq, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_UsesDescSeq*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_UsesDescSeq *tmp;
      ACE_NEW_RETURN (tmp, IR_UsesDescSeq, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_UsesDescSeq,
            1,
            ACE_static_cast (void *, tmp),
            IR_UsesDescSeq::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_EventDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EventDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_EventDef::_duplicate (_tao_elem),
        IR_EventDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EventDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_EventDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EventDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EventDef,
          1,
          _tao_elem,
          IR_EventDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_EventDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_EventDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_EventDef,IR_EventDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_EventDef,IR_EventDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_EventDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EventDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_EventDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_EventDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_EventDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EventDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_EventDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_EventDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EventDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_EventDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_EventDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_EventDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_EventDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_EventDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_EmitsDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_EmitsDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_EmitsDef::_duplicate (_tao_elem),
        IR_EmitsDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_EmitsDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_EmitsDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_EmitsDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_EmitsDef,
          1,
          _tao_elem,
          IR_EmitsDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_EmitsDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_EmitsDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_EmitsDef,IR_EmitsDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_EmitsDef,IR_EmitsDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_PublishesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PublishesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_PublishesDef::_duplicate (_tao_elem),
        IR_PublishesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PublishesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_PublishesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PublishesDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PublishesDef,
          1,
          _tao_elem,
          IR_PublishesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_PublishesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_PublishesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_PublishesDef,IR_PublishesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_PublishesDef,IR_PublishesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_ConsumesDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ConsumesDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ConsumesDef::_duplicate (_tao_elem),
        IR_ConsumesDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ConsumesDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ConsumesDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ConsumesDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ConsumesDef,
          1,
          _tao_elem,
          IR_ConsumesDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ConsumesDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ConsumesDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ConsumesDef,IR_ConsumesDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ConsumesDef,IR_ConsumesDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_ComponentDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_ComponentDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_ComponentDef::_duplicate (_tao_elem),
        IR_ComponentDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ComponentDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_ComponentDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ComponentDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_ComponentDef,
          1,
          _tao_elem,
          IR_ComponentDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_ComponentDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_ComponentDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_ComponentDef,IR_ComponentDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_ComponentDef,IR_ComponentDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_ComponentDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_ComponentDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_ComponentDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_ComponentDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_ComponentDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_ComponentDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_ComponentDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_ComponentDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_ComponentDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_ComponentDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_ComponentDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_ComponentDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_ComponentDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_PrimaryKeyDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_PrimaryKeyDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_PrimaryKeyDef::_duplicate (_tao_elem),
        IR_PrimaryKeyDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PrimaryKeyDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_PrimaryKeyDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PrimaryKeyDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_PrimaryKeyDef,
          1,
          _tao_elem,
          IR_PrimaryKeyDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_PrimaryKeyDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_PrimaryKeyDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_PrimaryKeyDef,IR_PrimaryKeyDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_PrimaryKeyDef,IR_PrimaryKeyDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_PrimaryKeyDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimaryKeyDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_PrimaryKeyDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_PrimaryKeyDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_PrimaryKeyDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_PrimaryKeyDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_PrimaryKeyDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_PrimaryKeyDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_PrimaryKeyDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_PrimaryKeyDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_PrimaryKeyDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_PrimaryKeyDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_PrimaryKeyDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_PrimaryKeyDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

void operator<<= (CORBA::Any &_tao_any, IR_FactoryDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FactoryDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_FactoryDef::_duplicate (_tao_elem),
        IR_FactoryDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FactoryDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_FactoryDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FactoryDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FactoryDef,
          1,
          _tao_elem,
          IR_FactoryDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_FactoryDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_FactoryDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_FactoryDef,IR_FactoryDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_FactoryDef,IR_FactoryDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_FinderDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_FinderDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_FinderDef::_duplicate (_tao_elem),
        IR_FinderDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_FinderDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_FinderDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_FinderDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_FinderDef,
          1,
          _tao_elem,
          IR_FinderDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_FinderDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_FinderDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_FinderDef,IR_FinderDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_FinderDef,IR_FinderDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, IR_HomeDef_ptr _tao_elem)
{
  TAO_OutputCDR stream;
  if (stream << _tao_elem)
  {
    _tao_any._tao_replace (
        IR::_tc_HomeDef, 
        TAO_ENCAP_BYTE_ORDER,
        stream.begin (),
        1,
        IR_HomeDef::_duplicate (_tao_elem),
        IR_HomeDef::_tao_any_destructor
      );
  }
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_HomeDef_ptr &_tao_elem)
{
  ACE_TRY_NEW_ENV
  {
    _tao_elem = IR_HomeDef::_nil ();
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_HomeDef, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    TAO_InputCDR stream (
        _tao_any._tao_get_cdr (),
        _tao_any._tao_byte_order ()
      );
    if (stream >> _tao_elem)
    {
      ((CORBA::Any *)&_tao_any)->_tao_replace (
          IR::_tc_HomeDef,
          1,
          _tao_elem,
          IR_HomeDef::_tao_any_destructor
        );
      return 1;
    }
  }
  ACE_CATCHANY
  {
    _tao_elem = IR_HomeDef::_nil ();
    return 0;
  }
  ACE_ENDTRY;
  _tao_elem = IR_HomeDef::_nil ();
  return 0;
}

#if defined (ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION)  || \
    defined (ACE_HAS_GNU_REPO)
    template class TAO_Object_Manager<IR_HomeDef,IR_HomeDef_var>;
  #elif defined (ACE_HAS_TEMPLATE_INSTANTIATION_PRAGMA)
  #  pragma instantiate TAO_Object_Manager<IR_HomeDef,IR_HomeDef_var>
#endif /* ACE_HAS_EXPLICIT_TEMPLATE_INSTANTIATION */

void operator<<= (CORBA::Any &_tao_any, const IR_HomeDescription &_tao_elem) // copying
{
  TAO_OutputCDR stream;
  stream << _tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin ()
    );
}

void operator<<= (CORBA::Any &_tao_any, IR_HomeDescription *_tao_elem) // non copying
{
  TAO_OutputCDR stream;
  stream << *_tao_elem;
  _tao_any._tao_replace (
      IR::_tc_HomeDescription,
      TAO_ENCAP_BYTE_ORDER,
      stream.begin (),
      1,
      _tao_elem,
      IR_HomeDescription::_tao_any_destructor
    );
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, IR_HomeDescription *&_tao_elem)
{
  return _tao_any >>= ACE_const_cast(const IR_HomeDescription*&,_tao_elem);
}

CORBA::Boolean operator>>= (const CORBA::Any &_tao_any, const IR_HomeDescription *&_tao_elem)
{
  _tao_elem = 0;
  ACE_TRY_NEW_ENV
  {
    CORBA::TypeCode_var type = _tao_any.type ();
    if (!type->equivalent (IR::_tc_HomeDescription, ACE_TRY_ENV)) // not equal
      {
        return 0;
      }
    ACE_TRY_CHECK;
    if (_tao_any.any_owns_data ())
    {
      _tao_elem = ACE_static_cast(
          const IR_HomeDescription*,
          _tao_any.value ()
        );
      return 1;
    }
    else
    {
      IR_HomeDescription *tmp;
      ACE_NEW_RETURN (tmp, IR_HomeDescription, 0);
      TAO_InputCDR stream (
          _tao_any._tao_get_cdr (),
          _tao_any._tao_byte_order ()
        );
      if (stream >> *tmp)
      {
        ((CORBA::Any *)&_tao_any)->_tao_replace (
            IR::_tc_HomeDescription,
            1,
            ACE_static_cast (void *, tmp),
            IR_HomeDescription::_tao_any_destructor
          );
        _tao_elem = tmp;
        return 1;
      }
      else
      {
        delete tmp;
      }
    }
  }
  ACE_CATCHANY
  {
  }
  ACE_ENDTRY;
  return 0;
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_InterfaceDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_InterfaceDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ValueDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ValueDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ComponentDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ComponentDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ProvidesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ProvidesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_UsesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_UsesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_HomeDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_HomeDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_EmitsDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_EmitsDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_PublishesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_PublishesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ConsumesDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ConsumesDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_FactoryDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_FactoryDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_FinderDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_FinderDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ContainedSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ContainedSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_StructMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_StructMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_InitializerSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_InitializerSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_UnionMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_UnionMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_EnumMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_EnumMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_Container::DescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_Container::DescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ExceptionDefSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ExceptionDefSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ExcDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ExcDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ParDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ParDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ContextIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ContextIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_RepositoryIdSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i].in ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_RepositoryIdSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i].out ());
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_OpDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_OpDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_AttrDescriptionSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_AttrDescriptionSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ValueMemberSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ValueMemberSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_ProvidesDescSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_ProvidesDescSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const IR_UsesDescSeq &_tao_sequence
  )
{
  if (strm << _tao_sequence.length ())
  {
    // encode all elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm << _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    IR_UsesDescSeq &_tao_sequence
  )
{
  CORBA::ULong _tao_seq_len;
  if (strm >> _tao_seq_len)
  {
    // set the length of the sequence
    _tao_sequence.length (_tao_seq_len);
    // If length is 0 we return true.
    if (0 >= _tao_seq_len) 
      return 1;
    // retrieve all the elements
    CORBA::Boolean _tao_marshal_flag = 1;
    for (CORBA::ULong i = 0; i < _tao_sequence.length () && _tao_marshal_flag; i++)
    {
      _tao_marshal_flag = (strm >> _tao_sequence[i]);
    }
    return _tao_marshal_flag;
  }
  return 0; // error
}

